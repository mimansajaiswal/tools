<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Components Demo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,500;9..144,700&family=Space+Grotesk:wght@400;500;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg: #f5f0e8;
            --ink: #201b16;
            --ink-soft: #6d6258;
            --line: #cfc2af;
            --surface: #fffaf3;
            --accent: #1f5d69;
            --accent-soft: #d9eef2;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background:
                radial-gradient(circle at 15% 10%, #efe5d8 0%, transparent 35%),
                radial-gradient(circle at 85% 95%, #e0efe9 0%, transparent 30%),
                var(--bg);
            color: var(--ink);
            font-family: "Space Grotesk", sans-serif;
            line-height: 1.45;
        }

        .shell {
            max-width: 1100px;
            margin: 0 auto;
            padding: 24px 18px 42px;
        }

        .hero {
            margin-bottom: 18px;
        }

        .hero h1 {
            margin: 0 0 6px;
            font: 700 36px/1.05 "Fraunces", serif;
        }

        .import-note {
            margin-top: 10px;
            font: 500 12px/1.4 "JetBrains Mono", monospace;
            color: var(--ink-soft);
            background: #fff;
            border: 1px solid var(--line);
            border-radius: 8px;
            padding: 8px 10px;
            display: inline-block;
        }

        .tab-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 16px 0 18px;
        }

        .tab-row--scroll {
            flex-wrap: wrap;
        }

        .example-tabs {
            display: grid;
            gap: 10px;
            margin-top: 16px;
        }

        .tab-select {
            position: relative;
            margin-bottom: 18px;
        }

        .tab-select-trigger {
            width: 100%;
            border: 1px solid var(--line);
            background: var(--surface);
            color: var(--ink);
            border-radius: 12px;
            padding: 10px 12px;
            cursor: pointer;
            font: 500 13px/1 "JetBrains Mono", monospace;
            letter-spacing: 0.01em;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .tab-select-trigger::after {
            content: "▾";
            color: var(--ink-soft);
            font-size: 12px;
        }

        .tab-select-menu {
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            right: 0;
            border: 1px solid var(--line);
            background: #fff;
            border-radius: 12px;
            padding: 6px;
            display: none;
            box-shadow: 0 16px 40px rgba(32, 27, 22, 0.12);
            z-index: 20;
            max-height: 280px;
            overflow-y: auto;
        }

        .tab-select.open .tab-select-menu {
            display: grid;
            gap: 4px;
        }

        .tab-select-option {
            border: 1px solid transparent;
            background: #fff;
            color: var(--ink);
            border-radius: 10px;
            padding: 8px 10px;
            cursor: pointer;
            text-align: left;
            font: 500 13px/1 "JetBrains Mono", monospace;
        }

        .tab-select-option.active {
            border-color: var(--accent);
            background: var(--accent-soft);
            color: var(--accent);
        }

        .tab-btn {
            border: 1px solid var(--line);
            background: var(--surface);
            color: var(--ink);
            border-radius: 999px;
            padding: 8px 12px;
            cursor: pointer;
            font: 500 13px/1 "JetBrains Mono", monospace;
            letter-spacing: 0.01em;
        }

        .tab-btn.active {
            border-color: var(--accent);
            background: var(--accent-soft);
            color: var(--accent);
        }

        .page {
            display: none;
            border: 1px solid var(--line);
            background: var(--surface);
            border-radius: 16px;
            padding: 14px;
            min-width: 0;
        }

        .page.active {
            display: block;
            animation: reveal .22s ease-out;
        }

        @keyframes reveal {
            from {
                opacity: 0;
                transform: translateY(5px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (min-width: 720px) {
            .tab-row--scroll {
                flex-wrap: nowrap;
                overflow-x: auto;
                padding-bottom: 4px;
                scroll-snap-type: x proximity;
            }

            .tab-row--scroll .tab-btn {
                flex: 0 0 auto;
                scroll-snap-align: start;
            }

            .tab-row--scroll::-webkit-scrollbar {
                height: 6px;
            }

            .tab-row--scroll::-webkit-scrollbar-thumb {
                background: #d7caba;
                border-radius: 999px;
            }

            .example-tabs .tab-select {
                display: none;
            }
        }

        @media (max-width: 719px) {

            #exampleTabs,
            #componentTabs {
                display: none;
            }
        }

        .example-wrap {
            margin-top: 10px;
            display: grid;
            gap: 12px;
        }

        .example-wrap>* {
            min-width: 0;
        }

        .example-head {
            display: grid;
            gap: 4px;
        }

        .example-head h2 {
            margin: 0;
            font: 700 22px/1.1 "Fraunces", serif;
        }

        .example-head p {
            margin: 0;
            color: var(--ink-soft);
        }

        .quickadd-intro p {
            margin: 0;
            color: var(--ink-soft);
            max-width: 75ch;
        }

        .meta {
            margin-top: 4px;
            color: var(--ink-soft);
            font: 500 12px/1.4 "JetBrains Mono", monospace;
        }

        .config-box {
            margin-top: 8px;
            border: 1px solid var(--line);
            background: #fff;
            border-radius: 10px;
            overflow: hidden;
            max-width: 100%;
        }

        .config-box>summary {
            cursor: pointer;
            list-style: none;
            padding: 8px 10px;
            font: 500 12px/1 "JetBrains Mono", monospace;
            color: var(--ink);
            background: #f8f3ea;
            border-bottom: 1px solid var(--line);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .config-box>summary::after {
            content: "▸";
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: var(--ink-soft);
            transform: rotate(0deg);
            transition: transform 140ms ease;
        }

        .config-box[open]>summary::after {
            transform: rotate(90deg);
        }

        .config-box>summary::-webkit-details-marker {
            display: none;
        }

        .config-tools {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            flex-wrap: wrap;
            margin: 0;
            padding: 8px 10px;
            border-bottom: 1px solid var(--line);
            background: #fffdf9;
        }

        .config-hint {
            color: var(--ink-soft);
            font: 500 11px/1.2 "JetBrains Mono", monospace;
        }

        .config-actions {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .ai-runtime {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 8px;
            margin: 0;
            padding: 8px 10px 10px;
            border-bottom: 1px solid var(--line);
            background: #fffcf7;
        }

        .ai-runtime [hidden] {
            display: none !important;
        }

        .ai-runtime.ai-runtime--compact {
            grid-template-columns: 1fr;
        }

        .ai-runtime-field {
            display: grid;
            gap: 4px;
            font: 500 11px/1.2 "JetBrains Mono", monospace;
            color: var(--ink-soft);
            min-width: 0;
        }

        .ai-runtime-input {
            width: 100%;
            min-width: 0;
            border: 1px solid var(--line);
            border-radius: 8px;
            padding: 6px 8px;
            background: #fff;
            color: var(--ink);
            font: 500 12px/1.2 "JetBrains Mono", monospace;
        }

        .ai-runtime-row {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .ai-runtime-check {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font: 500 11px/1.2 "JetBrains Mono", monospace;
            color: var(--ink-soft);
        }

        .config-btn {
            border: 1px solid var(--line);
            background: #fff;
            color: var(--ink);
            border-radius: 999px;
            padding: 4px 10px;
            font: 600 11px/1 "JetBrains Mono", monospace;
            cursor: pointer;
        }

        .config-btn:hover {
            border-color: var(--ink-soft);
        }

        .config-btn:disabled {
            opacity: 0.55;
            cursor: not-allowed;
        }

        .config-editor {
            margin: 0;
            padding: 10px;
            background: #fff;
            color: var(--ink);
            width: 100%;
            min-height: 240px;
            max-height: min(56vh, 620px);
            resize: vertical;
            border: 0;
            border-radius: 0;
            font: 500 11px/1.5 "JetBrains Mono", monospace;
            box-sizing: border-box;
            display: block;
            white-space: pre;
            overflow: auto;
        }

        .config-editor:focus {
            outline: 2px solid #c0b8ac;
            outline-offset: -2px;
        }

        .config-status {
            margin: 0;
            padding: 7px 10px;
            border-top: 1px solid var(--line);
            background: #fff;
            color: var(--ink-soft);
            min-height: 1.2em;
            font: 600 11px/1.2 "JetBrains Mono", monospace;
        }

        .config-status.ok {
            color: #0f766e;
        }

        .config-status.error {
            color: #b91c1c;
        }

        .config-errors {
            margin: 0;
            border-top: 1px solid var(--line);
            background: #fff8f8;
        }

        .config-errors[hidden] {
            display: none;
        }

        .config-errors summary {
            cursor: pointer;
            list-style: none;
            padding: 7px 10px;
            color: #8f1d1d;
            font: 700 11px/1.2 "JetBrains Mono", monospace;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .config-errors summary::after {
            content: "▾";
            color: #8f1d1d;
            transform: rotate(-90deg);
            transition: transform 120ms ease;
        }

        .config-errors[open] summary::after {
            transform: rotate(0deg);
        }

        .config-errors summary::-webkit-details-marker {
            display: none;
        }

        .config-errors-list {
            margin: 0;
            padding: 0 10px 10px 28px;
            color: #7f1d1d;
            font: 600 11px/1.35 "JetBrains Mono", monospace;
            max-height: min(34vh, 260px);
            overflow: auto;
        }

        .modal-demo-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .modal-demo-btn {
            border: 1px solid var(--line);
            background: #fff;
            color: var(--ink);
            border-radius: 8px;
            padding: 7px 12px;
            cursor: pointer;
            font: 600 12px/1 "JetBrains Mono", monospace;
        }

        .modal-demo-btn:hover {
            border-color: var(--ink-soft);
        }

        .modal-demo-note {
            color: var(--ink-soft);
            font: 500 11px/1.4 "JetBrains Mono", monospace;
        }

        .qa-modal-backdrop {
            position: fixed;
            inset: 0;
            z-index: 12000;
            background: rgba(20, 18, 16, 0.46);
            display: grid;
            place-items: center;
            padding: 14px;
        }

        .qa-modal-backdrop[hidden] {
            display: none !important;
        }

        .qa-modal {
            width: min(760px, 100%);
            max-height: min(82vh, 700px);
            border: 1px solid var(--line);
            border-radius: 10px;
            background: #fffaf3;
            color: var(--ink);
            box-shadow: 0 28px 80px rgba(0, 0, 0, 0.28);
            display: grid;
            grid-template-rows: auto minmax(0, 1fr);
            overflow: hidden;
        }

        .qa-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px 12px;
            border-bottom: 1px solid var(--line);
            background: #f8f3ea;
        }

        .qa-modal-title {
            margin: 0;
            font: 700 15px/1.2 "Fraunces", serif;
        }

        .qa-modal-body {
            min-height: 0;
            overflow: auto;
            padding: 12px;
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.65), rgba(255, 255, 255, 0.65)),
                repeating-linear-gradient(0deg, transparent 0, transparent 24px, rgba(207, 194, 175, 0.17) 24px, rgba(207, 194, 175, 0.17) 25px);
        }

        body.qa-modal-open {
            overflow: hidden;
        }

        @media (max-width: 640px) {
            .qa-modal-backdrop {
                padding: 8px;
            }

            .qa-modal {
                max-height: calc(100vh - 16px);
                border-radius: 8px;
            }

            .qa-modal-header {
                padding: 8px 9px;
            }

            .qa-modal-title {
                font-size: 14px;
            }

            .qa-modal-body {
                padding: 8px;
            }
        }

        /* Example 2 custom classNames */
        .petqa-root {
            --qa-bg: #eef8f3;
            --qa-fg: #1d2b25;
            --qa-muted: #5a6d63;
            --qa-border: #b8d5c7;
            --qa-accent: #1d7d5e;
            --qa-accent-soft: #d8efe5;
            --qa-danger: #8e3737;
            --qa-radius: 8px;
            --qa-font: "JetBrains Mono", monospace;
            box-shadow: 0 10px 30px rgba(29, 125, 94, 0.08);
        }

        .petqa-entry {
            background: linear-gradient(180deg, #ffffff 0%, #f7fcf9 100%);
        }

        .ai-config-details {
            margin-top: 8px;
            border: 1px solid var(--line);
            background: #fff;
            border-radius: 10px;
            overflow: visible;
            max-width: 100%;
        }

        .ai-config-details>summary {
            cursor: pointer;
            list-style: none;
            padding: 8px 10px;
            font: 500 12px/1 "JetBrains Mono", monospace;
            color: var(--ink);
            background: #f8f3ea;
            border-bottom: 1px solid var(--line);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .ai-config-details>summary::after {
            content: "▸";
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: var(--ink-soft);
            transform: rotate(0deg);
            transition: transform 140ms ease;
        }

        .ai-config-details[open]>summary::after {
            transform: rotate(90deg);
        }

        .ai-config-details>summary::-webkit-details-marker {
            display: none;
        }

        .custom-select {
            position: relative;
            min-width: 140px;
        }

        .custom-select-trigger {
            width: 100%;
            border: 1px solid var(--line);
            background: #fff;
            color: var(--ink);
            border-radius: 8px;
            padding: 6px 10px;
            cursor: pointer;
            font: 500 12px/1.2 "JetBrains Mono", monospace;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .custom-select-trigger::after {
            content: "▾";
            color: var(--ink-soft);
            font-size: 10px;
        }

        .custom-select-menu {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            border: 1px solid var(--line);
            background: #fff;
            border-radius: 8px;
            padding: 4px;
            display: none;
            box-shadow: 0 10px 24px rgba(32, 27, 22, 0.12);
            z-index: 20;
            max-height: 200px;
            overflow-y: auto;
        }

        .custom-select.open .custom-select-menu {
            display: grid;
            gap: 2px;
        }

        .custom-select-option {
            border: 0;
            background: #fff;
            color: var(--ink);
            border-radius: 6px;
            padding: 6px 8px;
            cursor: pointer;
            text-align: left;
            font: 500 12px/1 "JetBrains Mono", monospace;
        }

        .custom-select-option:hover,
        .custom-select-option.selected {
            background: var(--accent-soft);
            color: var(--accent);
        }
    </style>
</head>

<body>
    <main class="shell">
        <header class="hero">
            <h1>Components Demo</h1>
        </header>

        <div class="example-tabs" id="componentTabsWrap">
            <div class="tab-select" id="componentTabsSelect">
                <button class="tab-select-trigger" type="button" id="componentTabsTrigger">Quick Add</button>
                <div class="tab-select-menu" id="componentTabsMenu">
                    <button class="tab-select-option active" type="button" data-page="quickAddPage">Quick Add</button>
                </div>
            </div>
            <div class="tab-row tab-row--scroll" id="componentTabs">
                <button class="tab-btn active" data-page="quickAddPage">Quick Add</button>
            </div>
        </div>

        <section class="page active" id="quickAddPage">
            <div class="quickadd-intro">
                <p>Gallery scaffold for reusable UI components. Quick Add Parser is wired with live schema-driven
                    parsing
                    and six variant demos.</p>
                <div class="import-note">Single-file import:
                    <code>&lt;script src=\"./quick-add/quick-add-component.js\"&gt;&lt;/script&gt;</code>
                </div>
            </div>
            <div class="example-tabs" id="exampleTabsWrap">
                <div class="tab-select" id="exampleTabsSelect">
                    <button class="tab-select-trigger" type="button" id="exampleTabsTrigger">1: Task Planner
                        Variant</button>
                    <div class="tab-select-menu" id="exampleTabsMenu">
                        <button class="tab-select-option active" type="button" data-example="example1">1: Task Planner
                            Variant</button>
                        <button class="tab-select-option" type="button" data-example="example2">2: Pet Event
                            Variant</button>
                        <button class="tab-select-option" type="button" data-example="example3">3: Expense
                            Variant</button>
                        <button class="tab-select-option" type="button" data-example="example4">4: Modal Embed
                            Variant</button>
                        <button class="tab-select-option" type="button" data-example="example5">5: ✦ AI Parsing</button>
                        <button class="tab-select-option" type="button" data-example="example6">6: ✦ AI Parsing w/
                            Inline</button>
                    </div>
                </div>
                <div class="tab-row tab-row--scroll" id="exampleTabs">
                    <button class="tab-btn active" data-example="example1">1: Task Planner Variant</button>
                    <button class="tab-btn" data-example="example2">2: Pet Event Variant</button>
                    <button class="tab-btn" data-example="example3">3: Expense Variant</button>
                    <button class="tab-btn" data-example="example4">4: Modal Embed Variant</button>
                    <button class="tab-btn" data-example="example5">5: ✦ AI Parsing</button>
                    <button class="tab-btn" data-example="example6">6: ✦ AI Parsing w/ Inline</button>
                </div>
            </div>

            <article class="example-wrap active" data-example-panel="example1">
                <div class="example-head">
                    <h2>Task Planner Variant</h2>
                    <p>Double-newline bulk entries, terminator <code>;;</code> or next prefix commit, natural dates on
                        <code>due:</code>. Repeated single-value prefixes keep only the last one, parsed pills can be
                        dismissed with <code>x</code>, and entry cards allow multiple attachments.
                    </p>
                    <div class="meta" id="meta1"></div>
                    <details class="config-box">
                        <summary>Config + Options</summary>
                        <div class="config-tools">
                            <span class="config-hint">Playground JSON (editable)</span>
                            <div class="config-actions">
                                <button class="config-btn" type="button" id="applyConfig1">Apply</button>
                                <button class="config-btn" type="button" id="resetConfig1">Reset</button>
                            </div>
                        </div>
                        <textarea id="config1" class="config-editor" spellcheck="false"></textarea>
                        <div class="config-status" id="config1Status" aria-live="polite"></div>
                        <details class="config-errors" id="config1ErrorsBox" hidden>
                            <summary id="config1ErrorsSummary">Show all errors</summary>
                            <ul class="config-errors-list" id="config1Errors"></ul>
                        </details>
                    </details>
                </div>
                <div id="quickAddExample1"></div>
            </article>

            <article class="example-wrap" style="display:none" data-example-panel="example2">
                <div class="example-head">
                    <h2>Pet Event Variant</h2>
                    <p>Semicolon bulk separator, strict terminator <code>~~</code>, option auto-detect from free text,
                        dependency-aware event options by pet, inferred reduction, and <strong>auto-today</strong> date
                        defaulting. Includes self + conditional date constraints; blocked tokens are striped and
                        clickable for details.</p>
                    <div class="meta" id="meta2"></div>
                    <details class="config-box">
                        <summary>Config + Options</summary>
                        <div class="config-tools">
                            <span class="config-hint">Playground JSON (editable)</span>
                            <div class="config-actions">
                                <button class="config-btn" type="button" id="applyConfig2">Apply</button>
                                <button class="config-btn" type="button" id="resetConfig2">Reset</button>
                            </div>
                        </div>
                        <textarea id="config2" class="config-editor" spellcheck="false"></textarea>
                        <div class="config-status" id="config2Status" aria-live="polite"></div>
                        <details class="config-errors" id="config2ErrorsBox" hidden>
                            <summary id="config2ErrorsSummary">Show all errors</summary>
                            <ul class="config-errors-list" id="config2Errors"></ul>
                        </details>
                    </details>
                </div>
                <div id="quickAddExample2"></div>
            </article>

            <article class="example-wrap" style="display:none" data-example-panel="example3">
                <div class="example-head">
                    <h2>Expense Variant</h2>
                    <p>Commit mode <code>or-next-prefix</code> with terminator <code>::</code>, typed validation for
                        numbers/booleans/dates, dark theme token overrides.</p>
                    <div class="meta" id="meta3"></div>
                    <details class="config-box">
                        <summary>Config + Options</summary>
                        <div class="config-tools">
                            <span class="config-hint">Playground JSON (editable)</span>
                            <div class="config-actions">
                                <button class="config-btn" type="button" id="applyConfig3">Apply</button>
                                <button class="config-btn" type="button" id="resetConfig3">Reset</button>
                            </div>
                        </div>
                        <textarea id="config3" class="config-editor" spellcheck="false"></textarea>
                        <div class="config-status" id="config3Status" aria-live="polite"></div>
                        <details class="config-errors" id="config3ErrorsBox" hidden>
                            <summary id="config3ErrorsSummary">Show all errors</summary>
                            <ul class="config-errors-list" id="config3Errors"></ul>
                        </details>
                    </details>
                </div>
                <div id="quickAddExample3"></div>
            </article>

            <article class="example-wrap" style="display:none" data-example-panel="example4">
                <div class="example-head">
                    <h2>Modal Embed Variant</h2>
                    <p>Simulates usage inside a constrained modal container (scrolling body, clipped parent, fixed
                        overlay). Use this to validate floating menus/pickers in app-like dialogs.</p>
                    <div class="meta" id="meta4"></div>
                </div>
                <div class="modal-demo-controls">
                    <button class="modal-demo-btn" type="button" id="openQuickAddModal">Open Quick Add Modal</button>
                    <span class="modal-demo-note">The modal body is intentionally constrained to mimic embedded app
                        layouts.</span>
                </div>
                <div class="qa-modal-backdrop" id="quickAddModalBackdrop" hidden>
                    <section class="qa-modal" role="dialog" aria-modal="true" aria-labelledby="quickAddModalTitle">
                        <header class="qa-modal-header">
                            <h3 class="qa-modal-title" id="quickAddModalTitle">Quick Add In Modal</h3>
                            <button class="modal-demo-btn" type="button" id="closeQuickAddModal">Close</button>
                        </header>
                        <div class="qa-modal-body">
                            <div id="quickAddExample4"></div>
                        </div>
                    </section>
                </div>
            </article>

            <article class="example-wrap" style="display:none" data-example-panel="example5">
                <div class="example-head">
                    <h2>✦ AI Parsing</h2>
                    <p>Same <code>QuickAdd</code> component in <code>mode: "ai"</code>. Includes provider-compatible
                        API wiring, mock provider for synthetic testing, Parse/Queue/Process Queue controls, inline
                        edit,
                        remove/restore, optional separator-aware AI parsing, and offline queue persistence.</p>
                    <div class="meta" id="meta5"></div>
                    <details class="ai-config-details" id="aiRuntime5" open>
                        <summary>AI Provider Details</summary>
                        <div class="ai-runtime" id="aiRuntimeGrid5">
                            <label class="ai-runtime-field">Provider
                                <div class="custom-select" id="aiProviderSelect5">
                                    <button class="custom-select-trigger" type="button"
                                        id="aiProviderTrigger5">Demo</button>
                                    <div class="custom-select-menu">
                                        <button class="custom-select-option" type="button"
                                            data-value="demo">Demo</button>
                                        <button class="custom-select-option" type="button"
                                            data-value="openai">OpenAI</button>
                                        <button class="custom-select-option" type="button"
                                            data-value="anthropic">Anthropic</button>
                                        <button class="custom-select-option" type="button"
                                            data-value="google">Google</button>
                                        <button class="custom-select-option" type="button"
                                            data-value="custom">Custom</button>
                                    </div>
                                    <input type="hidden" id="aiProvider5" value="demo">
                                </div>
                            </label>
                            <label class="ai-runtime-field" id="aiEndpointField5" hidden>Custom Endpoint
                                <input class="ai-runtime-input" id="aiEndpoint5" type="text"
                                    placeholder="https://.../chat/completions" />
                            </label>
                            <label class="ai-runtime-field" id="aiModelField5">Model
                                <input class="ai-runtime-input" id="aiModel5" type="text" placeholder="gpt-4o-mini" />
                            </label>
                            <label class="ai-runtime-field" id="aiKeyField5">API Key
                                <input class="ai-runtime-input" id="aiApiKey5" type="password" placeholder="sk-..." />
                            </label>
                            <div class="ai-runtime-row">
                                <button class="config-btn" type="button" id="aiApply5" disabled>Apply</button>
                            </div>
                        </div>
                    </details>
                    <details class="config-box">
                        <summary>Config + Options</summary>
                        <div class="config-tools">
                            <span class="config-hint">Playground JSON (editable)</span>
                            <div class="config-actions">
                                <button class="config-btn" type="button" id="applyConfig5">Apply</button>
                                <button class="config-btn" type="button" id="resetConfig5">Reset</button>
                            </div>
                        </div>
                        <textarea id="config5" class="config-editor" spellcheck="false"></textarea>
                        <div class="config-status" id="config5Status" aria-live="polite"></div>
                        <details class="config-errors" id="config5ErrorsBox" hidden>
                            <summary id="config5ErrorsSummary">Show all errors</summary>
                            <ul class="config-errors-list" id="config5Errors"></ul>
                        </details>
                    </details>
                </div>
                <div id="quickAddExample5"></div>
            </article>

            <article class="example-wrap" style="display:none" data-example-panel="example6">
                <div class="example-head">
                    <h2>✦ AI Parsing w/ Inline</h2>
                    <p>AI mode with optional inline-pill overlays enabled. Uses dummy AI output with span offsets and
                        supports separator-aware parsing by newline, plus full provider/API-key runtime switching to
                        test
                        real calls.</p>
                    <div class="meta" id="meta6"></div>
                    <details class="ai-config-details" id="aiRuntime6" open>
                        <summary>AI Provider Details</summary>
                        <div class="ai-runtime" id="aiRuntimeGrid6">
                            <label class="ai-runtime-field">Provider
                                <div class="custom-select" id="aiProviderSelect6">
                                    <button class="custom-select-trigger" type="button"
                                        id="aiProviderTrigger6">Demo</button>
                                    <div class="custom-select-menu">
                                        <button class="custom-select-option" type="button"
                                            data-value="demo">Demo</button>
                                        <button class="custom-select-option" type="button"
                                            data-value="openai">OpenAI</button>
                                        <button class="custom-select-option" type="button"
                                            data-value="anthropic">Anthropic</button>
                                        <button class="custom-select-option" type="button"
                                            data-value="google">Google</button>
                                        <button class="custom-select-option" type="button"
                                            data-value="custom">Custom</button>
                                    </div>
                                    <input type="hidden" id="aiProvider6" value="demo">
                                </div>
                            </label>
                            <label class="ai-runtime-field" id="aiEndpointField6" hidden>Custom Endpoint
                                <input class="ai-runtime-input" id="aiEndpoint6" type="text"
                                    placeholder="https://.../chat/completions" />
                            </label>
                            <label class="ai-runtime-field" id="aiModelField6">Model
                                <input class="ai-runtime-input" id="aiModel6" type="text" placeholder="gpt-4o-mini" />
                            </label>
                            <label class="ai-runtime-field" id="aiKeyField6">API Key
                                <input class="ai-runtime-input" id="aiApiKey6" type="password" placeholder="sk-..." />
                            </label>
                            <div class="ai-runtime-row">
                                <button class="config-btn" type="button" id="aiApply6" disabled>Apply</button>
                            </div>
                        </div>
                    </details>
                    <details class="config-box">
                        <summary>Config + Options</summary>
                        <div class="config-tools">
                            <span class="config-hint">Playground JSON (editable)</span>
                            <div class="config-actions">
                                <button class="config-btn" type="button" id="applyConfig6">Apply</button>
                                <button class="config-btn" type="button" id="resetConfig6">Reset</button>
                            </div>
                        </div>
                        <textarea id="config6" class="config-editor" spellcheck="false"></textarea>
                        <div class="config-status" id="config6Status" aria-live="polite"></div>
                        <details class="config-errors" id="config6ErrorsBox" hidden>
                            <summary id="config6ErrorsSummary">Show all errors</summary>
                            <ul class="config-errors-list" id="config6Errors"></ul>
                        </details>
                    </details>
                </div>
                <div id="quickAddExample6"></div>
            </article>
        </section>

    </main>

    <script src="https://unpkg.com/chrono-node@2.7.7/dist/chrono.min.js"></script>
    <script src="./quick-add/quick-add-component.js"></script>
    <script>
        function connectTabs(tabContainerId, attrName, panelSelector, opts = {}) {
            const container = document.getElementById(tabContainerId);
            if (!container) return;
            container.addEventListener('click', (event) => {
                const btn = event.target.closest(`[${attrName}]`);
                if (!btn) return;
                const value = btn.getAttribute(attrName);
                container.querySelectorAll(`[${attrName}]`).forEach((item) => {
                    item.classList.toggle('active', item === btn);
                });
                document.querySelectorAll(panelSelector).forEach((panel) => {
                    const panelId = panel.id || panel.getAttribute('data-example-panel');
                    const active = panelId === value;
                    panel.classList.toggle('active', active);
                    panel.style.display = active ? '' : 'none';
                });
                if (typeof opts.onChange === 'function') {
                    opts.onChange(value, btn);
                }
            });
        }

        connectTabs('componentTabs', 'data-page', '.page', {
            onChange: (value, btn) => {
                const selectEl = document.getElementById('componentTabsSelect');
                if (!selectEl) return;
                selectEl.querySelectorAll('[data-page]').forEach((option) => {
                    option.classList.toggle('active', option.getAttribute('data-page') === value);
                });
                const trigger = document.getElementById('componentTabsTrigger');
                if (trigger) {
                    trigger.textContent = btn.textContent.trim();
                }
            }
        });
        connectTabs('exampleTabs', 'data-example', '[data-example-panel]', {
            onChange: (value, btn) => {
                const selectEl = document.getElementById('exampleTabsSelect');
                if (!selectEl) return;
                selectEl.querySelectorAll('[data-example]').forEach((option) => {
                    option.classList.toggle('active', option.getAttribute('data-example') === value);
                });
                const trigger = document.getElementById('exampleTabsTrigger');
                if (trigger) {
                    trigger.textContent = btn.textContent.trim();
                }
            }
        });

        function cloneJson(value) {
            return JSON.parse(JSON.stringify(value));
        }

        function toEditableConfig(baseConfig) {
            const editable = cloneJson(baseConfig);
            delete editable.mount;
            delete editable.onParse;
            return editable;
        }

        function setConfigStatus(statusEl, text, type) {
            if (!statusEl) return;
            statusEl.textContent = text || '';
            statusEl.classList.remove('ok', 'error');
            if (type) {
                statusEl.classList.add(type);
            }
        }

        const ALLOWED_TOP_LEVEL_KEYS = new Set([
            'mode',
            'debounceMs',
            'allowMultipleEntries',
            'entrySeparator',
            'fieldTerminator',
            'fieldTerminatorMode',
            'escapeChar',
            'fallbackField',
            'showJsonOutput',
            'showInlinePills',
            'showEntryCards',
            'showEntryHeader',
            'showEntryPills',
            'inputHeightMode',
            'inputMaxHeight',
            'allowEntryAttachments',
            'allowMultipleAttachments',
            'allowedAttachmentTypes',
            'attachmentSources',
            'autoDetectOptionsWithoutPrefix',
            'reduceInferredOptions',
            'inferredMatchMode',
            'inferredMatchThreshold',
            'placeholder',
            'hintText',
            'schema',
            'ai',
            'classNames',
            'tokens'
        ]);
        const ALLOWED_AI_KEYS = new Set([
            'enabled',
            'autoParse',
            'debounceMs',
            'minInputLength',
            'preserveEditedEntries',
            'separatorAware',
            'inlinePills',
            'forceJson',
            'provider',
            'apiKey',
            'model',
            'endpoint',
            'temperature',
            'systemPrompt',
            'mockResponse',
            'mockLatencyMs',
            'controls',
            'queueStorageKey',
            'experimental'
        ]);
        const ALLOWED_AI_EXPERIMENTAL_KEYS = new Set(['inlinePills']);
        const ALLOWED_SCHEMA_KEYS = new Set(['fields']);
        const ALLOWED_FIELD_KEYS = new Set([
            'key',
            'label',
            'prefixes',
            'type',
            'enum',
            'options',
            'required',
            'multiple',
            'naturalDate',
            'allowDateOnly',
            'defaultTime',
            'timeFormat',
            'color',
            'autoDetectWithoutPrefix',
            'reduceInferredOptions',
            'autoToday',
            'allowCustom',
            'exhaustive',
            'dependsOn',
            'dependencies',
            'constraints',
            'constraint'
        ]);
        const ALLOWED_OPTION_KEYS = new Set([
            'value',
            'label',
            'color',
            'dependsOn',
            'dependencies',
            'constraints',
            'constraint'
        ]);
        const ALLOWED_CONDITION_KEYS = new Set(['field', 'op', 'value', 'values', 'and', 'or', 'not', 'when', 'message']);
        const VALID_FIELD_TYPES = new Set(['string', 'number', 'options', 'date', 'datetime', 'boolean']);
        const VALID_FIELD_TERMINATOR_MODES = new Set(['strict', 'or-next-prefix', 'or-end']);
        const VALID_QA_MODES = new Set(['deterministic', 'ai']);
        const VALID_AI_PROVIDERS = new Set(['openai', 'anthropic', 'google', 'custom']);
        const VALID_CONDITION_OPERATORS = new Set([
            'eq',
            'neq',
            'in',
            'notin',
            'gt',
            'gte',
            'lt',
            'lte',
            'includes',
            'exists',
            'notexists'
        ]);

        function isPlainObject(value) {
            return !!value && typeof value === 'object' && !Array.isArray(value);
        }

        function pushValidationError(errors, path, message) {
            errors.push(path ? `${path}: ${message}` : message);
        }

        function validateAllowedKeys(obj, allowedKeys, path, errors) {
            Object.keys(obj || {}).forEach((key) => {
                if (!allowedKeys.has(key)) {
                    pushValidationError(errors, `${path}.${key}`, 'key is not allowed');
                }
            });
        }

        function validateConstraintNode(node, path, errors) {
            if (!isPlainObject(node)) {
                pushValidationError(errors, path, 'must be an object');
                return;
            }
            validateAllowedKeys(node, ALLOWED_CONDITION_KEYS, path, errors);

            if (node.field !== undefined && typeof node.field !== 'string') {
                pushValidationError(errors, `${path}.field`, 'must be a string');
            }
            if (node.message !== undefined && typeof node.message !== 'string') {
                pushValidationError(errors, `${path}.message`, 'must be a string');
            }
            if (node.op !== undefined) {
                if (typeof node.op !== 'string') {
                    pushValidationError(errors, `${path}.op`, 'must be a string');
                } else if (!VALID_CONDITION_OPERATORS.has(node.op)) {
                    pushValidationError(
                        errors,
                        `${path}.op`,
                        `must be one of: ${Array.from(VALID_CONDITION_OPERATORS).join(', ')}`
                    );
                }
            }
            if (node.values !== undefined && !Array.isArray(node.values)) {
                pushValidationError(errors, `${path}.values`, 'must be an array');
            }
            if (node.and !== undefined) {
                if (!Array.isArray(node.and)) {
                    pushValidationError(errors, `${path}.and`, 'must be an array');
                } else {
                    node.and.forEach((item, index) => validateConstraintNode(item, `${path}.and[${index}]`, errors));
                }
            }
            if (node.or !== undefined) {
                if (!Array.isArray(node.or)) {
                    pushValidationError(errors, `${path}.or`, 'must be an array');
                } else {
                    node.or.forEach((item, index) => validateConstraintNode(item, `${path}.or[${index}]`, errors));
                }
            }
            if (node.not !== undefined) {
                validateConstraintNode(node.not, `${path}.not`, errors);
            }
            if (node.when !== undefined) {
                validateConstraintNode(node.when, `${path}.when`, errors);
            }
        }

        function validateConstraintSet(value, path, errors) {
            if (value === undefined) {
                return;
            }
            if (Array.isArray(value)) {
                value.forEach((item, index) => validateConstraintNode(item, `${path}[${index}]`, errors));
                return;
            }
            validateConstraintNode(value, path, errors);
        }

        function validateOption(option, path, errors) {
            if (!isPlainObject(option)) {
                if (typeof option !== 'string' && typeof option !== 'number' && typeof option !== 'boolean') {
                    pushValidationError(errors, path, 'option must be string/number/boolean or object');
                }
                return;
            }

            validateAllowedKeys(option, ALLOWED_OPTION_KEYS, path, errors);
            if (option.value === undefined) {
                pushValidationError(errors, `${path}.value`, 'is required for object options');
            }
            if (option.label !== undefined && typeof option.label !== 'string') {
                pushValidationError(errors, `${path}.label`, 'must be a string');
            }
            if (option.color !== undefined && typeof option.color !== 'string') {
                pushValidationError(errors, `${path}.color`, 'must be a string');
            }
            validateConstraintSet(option.dependsOn !== undefined ? option.dependsOn : option.dependencies, `${path}.dependsOn`, errors);
            validateConstraintSet(option.constraints !== undefined ? option.constraints : option.constraint, `${path}.constraints`, errors);
        }

        function validateField(field, path, errors) {
            if (!isPlainObject(field)) {
                pushValidationError(errors, path, 'field must be an object');
                return;
            }

            validateAllowedKeys(field, ALLOWED_FIELD_KEYS, path, errors);
            if (!field.key || typeof field.key !== 'string') {
                pushValidationError(errors, `${path}.key`, 'is required and must be a string');
            }
            if (field.type !== undefined) {
                if (typeof field.type !== 'string' || !VALID_FIELD_TYPES.has(field.type)) {
                    pushValidationError(errors, `${path}.type`, `must be one of: ${Array.from(VALID_FIELD_TYPES).join(', ')}`);
                }
            }
            if (field.label !== undefined && typeof field.label !== 'string') {
                pushValidationError(errors, `${path}.label`, 'must be a string');
            }
            if (field.prefixes !== undefined) {
                if (!Array.isArray(field.prefixes)) {
                    pushValidationError(errors, `${path}.prefixes`, 'must be an array of strings');
                } else if (field.prefixes.some((item) => typeof item !== 'string')) {
                    pushValidationError(errors, `${path}.prefixes`, 'must contain only strings');
                }
            }
            if (field.enum !== undefined) {
                if (!Array.isArray(field.enum)) {
                    pushValidationError(errors, `${path}.enum`, 'must be an array');
                }
            }
            if (field.options !== undefined) {
                if (!Array.isArray(field.options)) {
                    pushValidationError(errors, `${path}.options`, 'must be an array');
                } else {
                    field.options.forEach((option, index) => validateOption(option, `${path}.options[${index}]`, errors));
                }
            }
            ['required', 'multiple', 'naturalDate', 'allowDateOnly', 'autoDetectWithoutPrefix', 'reduceInferredOptions', 'allowCustom', 'exhaustive']
                .forEach((key) => {
                    if (field[key] !== undefined && typeof field[key] !== 'boolean') {
                        pushValidationError(errors, `${path}.${key}`, 'must be a boolean');
                    }
                });
            if (field.defaultTime !== undefined && typeof field.defaultTime !== 'string') {
                pushValidationError(errors, `${path}.defaultTime`, 'must be a string in HH:mm format');
            }
            if (field.timeFormat !== undefined) {
                const format = String(field.timeFormat).toLowerCase();
                if (format !== '24h' && format !== 'ampm') {
                    pushValidationError(errors, `${path}.timeFormat`, 'must be "24h" or "ampm"');
                }
            }
            if (field.color !== undefined && typeof field.color !== 'string') {
                pushValidationError(errors, `${path}.color`, 'must be a string');
            }
            validateConstraintSet(field.dependsOn !== undefined ? field.dependsOn : field.dependencies, `${path}.dependsOn`, errors);
            validateConstraintSet(field.constraints !== undefined ? field.constraints : field.constraint, `${path}.constraints`, errors);
        }

        function validateEditableConfig(config) {
            const errors = [];

            if (!isPlainObject(config)) {
                return ['Config must be a JSON object.'];
            }

            validateAllowedKeys(config, ALLOWED_TOP_LEVEL_KEYS, 'config', errors);

            if (config.debounceMs !== undefined && typeof config.debounceMs !== 'number') {
                pushValidationError(errors, 'config.debounceMs', 'must be a number');
            }
            if (config.entrySeparator !== undefined && typeof config.entrySeparator !== 'string') {
                pushValidationError(errors, 'config.entrySeparator', 'must be a string');
            }
            if (config.fieldTerminator !== undefined && typeof config.fieldTerminator !== 'string') {
                pushValidationError(errors, 'config.fieldTerminator', 'must be a string');
            }
            if (config.fieldTerminatorMode !== undefined) {
                if (typeof config.fieldTerminatorMode !== 'string' || !VALID_FIELD_TERMINATOR_MODES.has(config.fieldTerminatorMode)) {
                    pushValidationError(
                        errors,
                        'config.fieldTerminatorMode',
                        `must be one of: ${Array.from(VALID_FIELD_TERMINATOR_MODES).join(', ')}`
                    );
                }
            }
            if (config.escapeChar !== undefined && typeof config.escapeChar !== 'string') {
                pushValidationError(errors, 'config.escapeChar', 'must be a string');
            }
            if (config.fallbackField !== undefined && typeof config.fallbackField !== 'string') {
                pushValidationError(errors, 'config.fallbackField', 'must be a string');
            }
            if (config.placeholder !== undefined && typeof config.placeholder !== 'string') {
                pushValidationError(errors, 'config.placeholder', 'must be a string');
            }
            if (config.hintText !== undefined && typeof config.hintText !== 'string') {
                pushValidationError(errors, 'config.hintText', 'must be a string');
            }
            if (config.mode !== undefined) {
                if (typeof config.mode !== 'string' || !VALID_QA_MODES.has(config.mode)) {
                    pushValidationError(errors, 'config.mode', `must be one of: ${Array.from(VALID_QA_MODES).join(', ')}`);
                }
            }

            [
                'allowMultipleEntries',
                'showJsonOutput',
                'showInlinePills',
                'showEntryCards',
                'showEntryHeader',
                'showEntryPills',
                'allowEntryAttachments',
                'allowMultipleAttachments',
                'autoDetectOptionsWithoutPrefix',
                'reduceInferredOptions'
            ].forEach((key) => {
                if (config[key] !== undefined && typeof config[key] !== 'boolean') {
                    pushValidationError(errors, `config.${key}`, 'must be a boolean');
                }
            });

            if (config.attachmentSources !== undefined) {
                if (!Array.isArray(config.attachmentSources)) {
                    pushValidationError(errors, 'config.attachmentSources', 'must be an array of strings');
                } else if (config.attachmentSources.some((item) => typeof item !== 'string')) {
                    pushValidationError(errors, 'config.attachmentSources', 'must contain only strings');
                }
            }

            if (config.allowedAttachmentTypes !== undefined) {
                if (!Array.isArray(config.allowedAttachmentTypes)) {
                    pushValidationError(errors, 'config.allowedAttachmentTypes', 'must be an array of strings');
                } else if (config.allowedAttachmentTypes.some((item) => typeof item !== 'string')) {
                    pushValidationError(errors, 'config.allowedAttachmentTypes', 'must contain only strings');
                }
            }

            if (config.classNames !== undefined) {
                if (!isPlainObject(config.classNames)) {
                    pushValidationError(errors, 'config.classNames', 'must be an object');
                } else {
                    Object.keys(config.classNames).forEach((key) => {
                        if (typeof config.classNames[key] !== 'string') {
                            pushValidationError(errors, `config.classNames.${key}`, 'must be a string');
                        }
                    });
                }
            }

            if (config.tokens !== undefined) {
                if (!isPlainObject(config.tokens)) {
                    pushValidationError(errors, 'config.tokens', 'must be an object');
                } else {
                    Object.keys(config.tokens).forEach((key) => {
                        const tokenValue = config.tokens[key];
                        if (typeof tokenValue !== 'string' && typeof tokenValue !== 'number') {
                            pushValidationError(errors, `config.tokens.${key}`, 'must be a string or number');
                        }
                    });
                }
            }

            if (config.ai !== undefined) {
                if (!isPlainObject(config.ai)) {
                    pushValidationError(errors, 'config.ai', 'must be an object');
                } else {
                    validateAllowedKeys(config.ai, ALLOWED_AI_KEYS, 'config.ai', errors);
                    ['enabled', 'autoParse', 'preserveEditedEntries', 'separatorAware', 'inlinePills', 'forceJson']
                        .forEach((key) => {
                            if (config.ai[key] !== undefined && typeof config.ai[key] !== 'boolean') {
                                pushValidationError(errors, `config.ai.${key}`, 'must be a boolean');
                            }
                        });
                    ['debounceMs', 'minInputLength', 'temperature', 'mockLatencyMs']
                        .forEach((key) => {
                            if (config.ai[key] !== undefined && typeof config.ai[key] !== 'number') {
                                pushValidationError(errors, `config.ai.${key}`, 'must be a number');
                            }
                        });
                    ['provider', 'apiKey', 'model', 'endpoint', 'systemPrompt', 'queueStorageKey']
                        .forEach((key) => {
                            if (config.ai[key] !== undefined && typeof config.ai[key] !== 'string') {
                                pushValidationError(errors, `config.ai.${key}`, 'must be a string');
                            }
                        });
                    if (config.ai.mockResponse !== undefined) {
                        const value = config.ai.mockResponse;
                        const isString = typeof value === 'string';
                        const isObject = isPlainObject(value);
                        const isNull = value === null;
                        if (!isString && !isObject && !isNull) {
                            pushValidationError(errors, 'config.ai.mockResponse', 'must be a JSON object, JSON string, or null');
                        }
                    }
                    if (config.ai.provider !== undefined && !VALID_AI_PROVIDERS.has(String(config.ai.provider || '').toLowerCase())) {
                        pushValidationError(errors, 'config.ai.provider', `must be one of: ${Array.from(VALID_AI_PROVIDERS).join(', ')}`);
                    }
                    if (config.ai.experimental !== undefined) {
                        if (!isPlainObject(config.ai.experimental)) {
                            pushValidationError(errors, 'config.ai.experimental', 'must be an object');
                        } else {
                            validateAllowedKeys(config.ai.experimental, ALLOWED_AI_EXPERIMENTAL_KEYS, 'config.ai.experimental', errors);
                            if (config.ai.experimental.inlinePills !== undefined && typeof config.ai.experimental.inlinePills !== 'boolean') {
                                pushValidationError(errors, 'config.ai.experimental.inlinePills', 'must be a boolean');
                            }
                        }
                    }
                }
            }

            if (!isPlainObject(config.schema)) {
                pushValidationError(errors, 'config.schema', 'is required and must be an object');
            } else {
                validateAllowedKeys(config.schema, ALLOWED_SCHEMA_KEYS, 'config.schema', errors);
                if (!Array.isArray(config.schema.fields)) {
                    pushValidationError(errors, 'config.schema.fields', 'is required and must be an array');
                } else {
                    config.schema.fields.forEach((field, index) => validateField(field, `config.schema.fields[${index}]`, errors));
                }
            }

            return errors;
        }

        function setupConfigPlayground(options) {
            const {
                editorId,
                applyButtonId,
                resetButtonId,
                statusId,
                errorsBoxId,
                errorsSummaryId,
                errorsListId,
                component,
                baseConfig,
                defaultInput
            } = options;

            const editorEl = document.getElementById(editorId);
            const applyBtn = document.getElementById(applyButtonId);
            const resetBtn = document.getElementById(resetButtonId);
            const statusEl = document.getElementById(statusId);
            const errorsBoxEl = document.getElementById(errorsBoxId);
            const errorsSummaryEl = document.getElementById(errorsSummaryId);
            const errorsListEl = document.getElementById(errorsListId);
            if (!editorEl || !applyBtn || !resetBtn || !component) {
                return;
            }

            const defaultEditable = toEditableConfig(baseConfig);
            editorEl.value = JSON.stringify(defaultEditable, null, 2);
            const validationDebounceMs = 260;
            let validationTimer = null;

            function parseAndValidateEditor() {
                let parsed;
                try {
                    parsed = JSON.parse(editorEl.value);
                } catch (error) {
                    return {
                        ok: false,
                        parsed: null,
                        errors: [`Invalid JSON: ${error.message}`]
                    };
                }

                const errors = validateEditableConfig(parsed);
                return {
                    ok: errors.length === 0,
                    parsed,
                    errors
                };
            }

            function renderValidationErrors(errors) {
                if (!errorsBoxEl || !errorsListEl || !errorsSummaryEl) {
                    return;
                }
                const list = Array.isArray(errors) ? errors : [];
                errorsListEl.innerHTML = '';
                if (!list.length) {
                    errorsBoxEl.hidden = true;
                    errorsBoxEl.open = false;
                    errorsSummaryEl.textContent = 'Show all errors';
                    return;
                }

                errorsBoxEl.hidden = false;
                errorsSummaryEl.textContent = `Show all errors (${list.length})`;
                list.forEach((message) => {
                    const item = document.createElement('li');
                    item.textContent = message;
                    errorsListEl.appendChild(item);
                });
            }

            function refreshValidationUI() {
                const result = parseAndValidateEditor();
                applyBtn.disabled = !result.ok;
                if (result.ok) {
                    setConfigStatus(statusEl, 'Valid config. Click Apply to update parser.', 'ok');
                    renderValidationErrors([]);
                } else {
                    const firstError = result.errors[0] || 'Not valid.';
                    const extraCount = Math.max(0, result.errors.length - 1);
                    const suffix = extraCount ? ` (+${extraCount} more)` : '';
                    setConfigStatus(statusEl, `Not valid: ${firstError}${suffix}`, 'error');
                    renderValidationErrors(result.errors);
                }
                return result;
            }

            function scheduleValidation() {
                if (validationTimer) {
                    clearTimeout(validationTimer);
                }
                validationTimer = setTimeout(() => {
                    validationTimer = null;
                    refreshValidationUI();
                }, validationDebounceMs);
            }

            function applyFromEditor() {
                if (validationTimer) {
                    clearTimeout(validationTimer);
                    validationTimer = null;
                }
                const validation = parseAndValidateEditor();
                if (!validation.ok) {
                    refreshValidationUI();
                    return;
                }
                const parsed = validation.parsed;

                if (component && typeof component.resetAiVerification === 'function') {
                    component.resetAiVerification('Config updated.');
                }

                const currentInput = component.getResult()?.input || defaultInput || '';
                const nextConfig = Object.assign({}, baseConfig, parsed, {
                    ai: Object.assign({}, baseConfig.ai || {}, parsed.ai || {}, {
                        experimental: Object.assign(
                            {},
                            (baseConfig.ai && baseConfig.ai.experimental) || {},
                            (parsed.ai && parsed.ai.experimental) || {}
                        )
                    }),
                    mount: baseConfig.mount,
                    onParse: baseConfig.onParse
                });

                try {
                    component.updateConfig(nextConfig);
                    component.setInput(currentInput);
                } catch (error) {
                    const message = `Config error: ${error.message}`;
                    setConfigStatus(statusEl, message, 'error');
                    renderValidationErrors([message]);
                    return;
                }
                setConfigStatus(statusEl, 'Applied.', 'ok');
                renderValidationErrors([]);
                return true;
            }

            applyBtn.addEventListener('click', applyFromEditor);
            resetBtn.addEventListener('click', () => {
                editorEl.value = JSON.stringify(defaultEditable, null, 2);
                applyFromEditor();
                setConfigStatus(statusEl, 'Reset to default and applied.', 'ok');
            });
            editorEl.addEventListener('input', () => {
                applyBtn.disabled = true;
                setConfigStatus(statusEl, 'Checking...', '');
                scheduleValidation();
            });
            refreshValidationUI();

            return {
                editorEl,
                applyBtn,
                resetBtn,
                applyFromEditor,
                parseAndValidateEditor,
                refreshValidationUI,
                setConfigStatus: (text, type) => setConfigStatus(statusEl, text, type)
            };
        }

        function setupAiRuntimeControls(options) {
            const {
                playground,
                providerSelectId,
                providerTriggerId,
                providerInputId,
                apiKeyId,
                modelId,
                endpointId,
                applyId,
                endpointFieldId,
                modelFieldId,
                keyFieldId
            } = options || {};
            if (!playground) {
                return;
            }
            const providerSelectEl = document.getElementById(providerSelectId);
            const providerTriggerEl = document.getElementById(providerTriggerId);
            const providerInputEl = document.getElementById(providerInputId);
            const apiKeyEl = document.getElementById(apiKeyId);
            const modelEl = document.getElementById(modelId);
            const endpointEl = document.getElementById(endpointId);
            const applyEl = document.getElementById(applyId);
            const applyRowEl = applyEl ? applyEl.closest('.ai-runtime-row') : null;
            const endpointFieldEl = document.getElementById(endpointFieldId);
            const modelFieldEl = document.getElementById(modelFieldId);
            const keyFieldEl = document.getElementById(keyFieldId);
            let lastProvider = '';

            if (!providerInputEl || !apiKeyEl || !modelEl || !endpointEl || !applyEl) {
                return;
            }

            function getDefaultModel(provider) {
                const normalized = String(provider || '').toLowerCase();
                if (normalized === 'anthropic') return 'claude-3-haiku-20240307';
                if (normalized === 'google') return 'gemini-1.5-flash';
                return 'gpt-4o-mini';
            }

            function syncModelDefaults(provider) {
                const normalized = String(provider || '').toLowerCase();
                const defaultModel = getDefaultModel(normalized);
                modelEl.placeholder = defaultModel;
                if (!modelEl.value) {
                    modelEl.value = defaultModel;
                } else {
                    const previousDefault = lastProvider ? getDefaultModel(lastProvider) : '';
                    if (modelEl.value === previousDefault) {
                        modelEl.value = defaultModel;
                    }
                }
                lastProvider = normalized;
            }

            // Custom Select Logic
            if (providerSelectEl && providerTriggerEl) {
                providerTriggerEl.addEventListener('click', () => {
                    providerSelectEl.classList.toggle('open');
                });
                providerSelectEl.addEventListener('click', (event) => {
                    const option = event.target.closest('.custom-select-option');
                    if (!option) return;
                    const value = option.getAttribute('data-value');
                    const text = option.textContent;
                    providerInputEl.value = value;
                    providerTriggerEl.textContent = text;
                    providerSelectEl.classList.remove('open');
                    syncFieldVisibility(value);
                    syncModelDefaults(value);
                    syncApplyState();
                });
                document.addEventListener('click', (event) => {
                    if (!providerSelectEl.contains(event.target)) {
                        providerSelectEl.classList.remove('open');
                    }
                });
            }

            function syncFieldVisibility(value) {
                const provider = String(value || providerInputEl.value || '').toLowerCase();
                const isDemo = provider === 'demo';
                const isCustom = provider === 'custom';

                if (endpointFieldEl) {
                    endpointFieldEl.hidden = !isCustom;
                }
                if (modelFieldEl) {
                    modelFieldEl.hidden = isDemo;
                }
                if (keyFieldEl) {
                    keyFieldEl.hidden = isDemo;
                }
                if (applyEl) {
                    applyEl.hidden = isDemo;
                }
                if (applyRowEl) {
                    applyRowEl.hidden = isDemo;
                }

                const runtimeGrid = providerSelectEl ? providerSelectEl.closest('.ai-runtime') : null;
                if (runtimeGrid) {
                    runtimeGrid.classList.toggle('ai-runtime--compact', isDemo);
                }
            }

            function syncApplyState() {
                const provider = String(providerInputEl.value || '').toLowerCase();
                const isDemo = provider === 'demo';
                const isCustom = provider === 'custom';
                if (isDemo) {
                    applyEl.disabled = true;
                    return;
                }
                const hasApiKey = String(apiKeyEl.value || '').trim().length > 0;
                const hasModel = String(modelEl.value || '').trim().length > 0;
                const hasEndpoint = !isCustom || String(endpointEl.value || '').trim().length > 0;
                applyEl.disabled = !(hasApiKey && hasModel && hasEndpoint);
            }

            function readEditorConfig() {
                try {
                    return JSON.parse(playground.editorEl.value || '{}');
                } catch (error) {
                    return null;
                }
            }

            function syncControlsFromEditor() {
                const parsed = readEditorConfig();
                const ai = (parsed && parsed.ai && typeof parsed.ai === 'object') ? parsed.ai : {};
                let activeProvider = String(ai.provider || 'openai');

                // If mockResponse is NOT explicitly null, it implies demo mode (since base config has it)
                // In JSON editor, function is missing (undefined). null means disabled.
                if (ai.mockResponse !== null) {
                    activeProvider = 'demo';
                }

                providerInputEl.value = activeProvider;
                if (providerTriggerEl && providerSelectEl) {
                    const option = providerSelectEl.querySelector(`[data-value="${activeProvider}"]`);
                    providerTriggerEl.textContent = option ? option.textContent : activeProvider;
                }

                apiKeyEl.value = String(ai.apiKey || '');
                modelEl.value = String(ai.model || '');
                endpointEl.value = String(ai.endpoint || '');

                syncFieldVisibility(activeProvider);
                syncModelDefaults(activeProvider);
                syncApplyState();
            }

            function applyRuntimeToEditor() {
                const parsed = readEditorConfig();
                if (!parsed || typeof parsed !== 'object') {
                    playground.setConfigStatus('Invalid JSON: cannot apply runtime controls.', 'error');
                    return;
                }
                parsed.ai = (parsed.ai && typeof parsed.ai === 'object') ? parsed.ai : {};
                const chosenProvider = providerInputEl.value;

                if (chosenProvider === 'demo') {
                    // Remove mockResponse from JSON so base config's function applies
                    delete parsed.ai.mockResponse;
                } else {
                    parsed.ai.provider = chosenProvider;
                    parsed.ai.mockResponse = null; // Disable mock
                }

                parsed.ai.apiKey = String(apiKeyEl.value || '');
                parsed.ai.model = String(modelEl.value || '');
                parsed.ai.endpoint = String(endpointEl.value || '');
                parsed.ai.forceJson = true;

                playground.editorEl.value = JSON.stringify(parsed, null, 2);
                const applied = playground.applyFromEditor();
                if (applied) {
                    playground.setConfigStatus(`Applied AI details (${chosenProvider}).`, 'ok');
                    syncControlsFromEditor();
                }
            }
            [apiKeyEl, modelEl, endpointEl].forEach((el) => {
                el.addEventListener('input', syncApplyState);
            });
            providerInputEl.addEventListener('change', syncApplyState);
            applyEl.addEventListener('click', applyRuntimeToEditor);
            playground.applyBtn.addEventListener('click', () => {
                window.requestAnimationFrame(syncControlsFromEditor);
            });
            playground.resetBtn.addEventListener('click', () => {
                window.requestAnimationFrame(syncControlsFromEditor);
            });
            syncControlsFromEditor();
        }

        const taskConfig = {
            mount: '#quickAddExample1',
            debounceMs: 280,
            entrySeparator: '\n\n',
            fieldTerminator: ';;',
            fieldTerminatorMode: 'or-next-prefix',
            allowEntryAttachments: true,
            allowMultipleAttachments: true,
            allowedAttachmentTypes: ['.pdf', '.png', '.jpg', 'image/*'],
            attachmentSources: ['camera', 'gallery', 'files'],
            fallbackField: 'title',
            placeholder: 'Example: ... !p2;; !p1;; and #work;; #health ... (last value wins)',
            inputHeightMode: 'scroll',
            inputMaxHeight: 160,
            schema: {
                fields: [
                    { key: 'title', type: 'string', required: true },
                    {
                        key: 'priority',
                        type: 'options',
                        prefixes: ['!'],
                        exhaustive: true,
                        options: [
                            { value: 'p1', color: '#dc2626' },
                            { value: 'p2', color: '#d97706' },
                            { value: 'p3', color: '#0284c7' }
                        ]
                    },
                    {
                        key: 'project',
                        type: 'options',
                        prefixes: ['#'],
                        exhaustive: true,
                        options: [
                            { value: 'health', color: '#0d9488' },
                            { value: 'work', color: '#7c3aed' },
                            { value: 'home', color: '#16a34a' },
                            { value: 'errands', color: '#475569' }
                        ]
                    },
                    { key: 'due', type: 'datetime', naturalDate: true, allowDateOnly: true, defaultTime: '08:00', prefixes: ['due:'] },
                    { key: 'owner', type: 'string', prefixes: ['@'] }
                ]
            },
            tokens: {
                '--qa-bg': '#fff8ef',
                '--qa-border': '#e5d7c4',
                '--qa-accent': '#8b4a2f',
                '--qa-accent-soft': '#f4e7df'
            },
            onParse: (result) => {
                document.getElementById('meta1').textContent = `entries=${result.entryCount}, valid=${result.validCount}, invalid=${result.invalidCount}`;
            }
        };
        const taskDefaultInput =
            'Book vet appointment then call clinic !p3;; shift to urgent !p1;; prep records #health;; and confirm slot due:23 feb 26 at 3pm;; with @Mimansa;; before breakfast\n\n' +
            'Pick up supplements !p2;; #errands;; due:next week at 9:15am;; @Mimansa;;';
        const taskAdd = QuickAdd.create(taskConfig);
        taskAdd.setInput(taskDefaultInput);
        setupConfigPlayground({
            editorId: 'config1',
            applyButtonId: 'applyConfig1',
            resetButtonId: 'resetConfig1',
            statusId: 'config1Status',
            errorsBoxId: 'config1ErrorsBox',
            errorsSummaryId: 'config1ErrorsSummary',
            errorsListId: 'config1Errors',
            component: taskAdd,
            baseConfig: taskConfig,
            defaultInput: taskDefaultInput
        });

        const petConfig = {
            mount: '#quickAddExample2',
            debounceMs: 320,
            entrySeparator: ';',
            fieldTerminator: '~~',
            fieldTerminatorMode: 'strict',
            showEntryHeader: false,
            autoDetectOptionsWithoutPrefix: true,
            reduceInferredOptions: false,
            inferredMatchMode: 'fuzzy',
            inferredMatchThreshold: 0.8,
            fallbackField: 'note',
            placeholder: 'Use ; for new entry. Example: pet:Luna~~ event:walk~~ due:2025-02-01~~ at:yesterday~~ (at: defaults to today if omitted)',
            inputHeightMode: 'scroll',
            inputMaxHeight: 150,
            classNames: {
                root: 'qa-root petqa-root',
                entry: 'qa-entry petqa-entry'
            },
            schema: {
                fields: [
                    { key: 'note', type: 'string' },
                    {
                        key: 'pet',
                        type: 'options',
                        prefixes: ['pet:'],
                        required: true,
                        exhaustive: true,
                        options: [
                            { value: 'Luna', color: '#22c55e' },
                            { value: 'Mochi', color: '#f97316' },
                            { value: 'Pico', color: '#3b82f6' }
                        ]
                    },
                    {
                        key: 'event',
                        type: 'options',
                        prefixes: ['event:', 'ev:'],
                        required: true,
                        exhaustive: true,
                        options: [
                            { value: 'walk', color: '#22c55e', dependsOn: { field: 'pet', op: 'in', value: ['Luna', 'Mochi'] } },
                            { value: 'fetch', color: '#16a34a', dependsOn: { field: 'pet', op: 'eq', value: 'Luna' } },
                            { value: 'litter', color: '#2563eb', dependsOn: { field: 'pet', op: 'eq', value: 'Pico' } },
                            { value: 'groom', color: '#f97316', dependsOn: { field: 'pet', op: 'eq', value: 'Mochi' } },
                            { value: 'vet', color: '#7c3aed' }
                        ]
                    },
                    {
                        key: 'due',
                        type: 'date',
                        naturalDate: false,
                        prefixes: ['due:'],
                        constraints: [
                            {
                                op: 'gte',
                                value: '2025-02-15',
                                message: 'Due date must be on or after 2025-02-15'
                            },
                            {
                                when: { field: 'pet', op: 'eq', value: 'Pico' },
                                op: 'gte',
                                value: '2026-01-01',
                                message: 'For pet Pico, due date must be on or after 2026-01-01'
                            }
                        ]
                    },
                    {
                        key: 'symptom',
                        type: 'options',
                        prefixes: ['symptom:', 'sym:'],
                        allowCustom: true,
                        autoDetectWithoutPrefix: true,
                        reduceInferredOptions: true,
                        options: [
                            { value: 'cough', color: '#dc2626' },
                            { value: 'vomit', color: '#ea580c' },
                            { value: 'itching', color: '#d97706' },
                            { value: 'low energy', color: '#7c3aed' }
                        ]
                    },
                    { key: 'severity', type: 'number', prefixes: ['sev:'] },
                    { key: 'at', type: 'date', naturalDate: true, prefixes: ['at:'], required: true, autoToday: true }
                ]
            },
            onParse: (result) => {
                document.getElementById('meta2').textContent = `entries=${result.entryCount}, valid=${result.validCount}, invalid=${result.invalidCount}`;
            }
        };
        const petDefaultInput =
            'pet:Luna~~ event:litter~~ due:2025-02-01~~ sev:2~~ at:yesterday~~ cogh and appetite normal;' +
            ' pet:Mochi~~ event:groom~~ due:2026-03-01~~ sev:3~~ at:today~~ low enery and slept longer than usyal;' +
            ' pet:Pico~~ event:vet~~ due:2026-04-01~~ checkup (auto-dated)';
        const petAdd = QuickAdd.create(petConfig);
        petAdd.setInput(petDefaultInput);
        setupConfigPlayground({
            editorId: 'config2',
            applyButtonId: 'applyConfig2',
            resetButtonId: 'resetConfig2',
            statusId: 'config2Status',
            errorsBoxId: 'config2ErrorsBox',
            errorsSummaryId: 'config2ErrorsSummary',
            errorsListId: 'config2Errors',
            component: petAdd,
            baseConfig: petConfig,
            defaultInput: petDefaultInput
        });

        const expenseConfig = {
            mount: '#quickAddExample3',
            debounceMs: 250,
            entrySeparator: '\n',
            fieldTerminator: '::',
            fieldTerminatorMode: 'or-next-prefix',
            showEntryPills: false,
            fallbackField: 'memo',
            placeholder: 'Example: Team lunch $23.4:: cat:Food:: pay:Card:: on:2026-02-06:: rb:no::',
            inputHeightMode: 'scroll',
            inputMaxHeight: 140,
            schema: {
                fields: [
                    { key: 'memo', type: 'string', required: true },
                    { key: 'amount', type: 'number', prefixes: ['$'], required: true },
                    {
                        key: 'category',
                        type: 'options',
                        prefixes: ['cat:'],
                        required: true,
                        exhaustive: true,
                        options: [
                            { value: 'Food', color: '#f59e0b' },
                            { value: 'Travel', color: '#0ea5e9' },
                            { value: 'Supplies', color: '#22c55e' },
                            { value: 'Software', color: '#a855f7' }
                        ]
                    },
                    {
                        key: 'payment',
                        type: 'options',
                        prefixes: ['pay:'],
                        allowCustom: false,
                        options: [
                            { value: 'Card', color: '#06b6d4' },
                            { value: 'Cash', color: '#84cc16' },
                            { value: 'UPI', color: '#f97316' },
                            { value: 'Bank', color: '#8b5cf6' }
                        ]
                    },
                    { key: 'on', type: 'date', naturalDate: false, prefixes: ['on:'], required: true },
                    { key: 'reimbursable', type: 'boolean', prefixes: ['rb:'] }
                ]
            },
            tokens: {
                '--qa-bg': '#1d2328',
                '--qa-fg': '#edf2f8',
                '--qa-muted': '#a6b3c0',
                '--qa-border': '#33404a',
                '--qa-accent': '#66d9ef',
                '--qa-accent-soft': '#27414c',
                '--qa-danger': '#f28b82',
                '--qa-card-bg': '#111a20',
                '--qa-card-fg': '#edf2f8',
                '--qa-input-bg': '#0f171d',
                '--qa-input-fg': '#edf2f8',
                '--qa-output-bg': '#0f171d',
                '--qa-output-fg': '#dbe7f3',
                '--qa-pill-bg': '#13232d',
                '--qa-pill-border': '#3f5f74',
                '--qa-pill-fg': '#dceaf8'
            },
            onParse: (result) => {
                document.getElementById('meta3').textContent = `entries=${result.entryCount}, valid=${result.validCount}, invalid=${result.invalidCount}`;
            }
        };
        const expenseDefaultInput =
            'Team lunch $23.4:: cat:Food:: pay:Card:: on:2026-02-06:: rb:no::\n' +
            'Airport cab $48 cat:Travel pay:Cash on:2026-02-05 rb:yes';
        const expenseAdd = QuickAdd.create(expenseConfig);
        expenseAdd.setInput(expenseDefaultInput);
        setupConfigPlayground({
            editorId: 'config3',
            applyButtonId: 'applyConfig3',
            resetButtonId: 'resetConfig3',
            statusId: 'config3Status',
            errorsBoxId: 'config3ErrorsBox',
            errorsSummaryId: 'config3ErrorsSummary',
            errorsListId: 'config3Errors',
            component: expenseAdd,
            baseConfig: expenseConfig,
            defaultInput: expenseDefaultInput
        });

        const modalConfig = {
            mount: '#quickAddExample4',
            debounceMs: 260,
            entrySeparator: '\n\n',
            fieldTerminator: ';;',
            fieldTerminatorMode: 'or-next-prefix',
            fallbackField: 'title',
            placeholder: 'Try: prep update !p2;; due:next week at 9:15am;; @Mimansa;;',
            schema: {
                fields: [
                    { key: 'title', type: 'string', required: true },
                    {
                        key: 'priority',
                        type: 'options',
                        prefixes: ['!'],
                        exhaustive: true,
                        options: [
                            { value: 'p1', color: '#dc2626' },
                            { value: 'p2', color: '#d97706' },
                            { value: 'p3', color: '#0284c7' }
                        ]
                    },
                    {
                        key: 'status',
                        type: 'options',
                        prefixes: ['st:'],
                        exhaustive: true,
                        options: [
                            { value: 'todo', color: '#475569' },
                            { value: 'doing', color: '#0ea5e9' },
                            { value: 'done', color: '#16a34a' }
                        ]
                    },
                    { key: 'due', type: 'datetime', naturalDate: true, allowDateOnly: true, defaultTime: '08:00', prefixes: ['due:'] },
                    { key: 'owner', type: 'string', prefixes: ['@'] }
                ]
            },
            tokens: {
                '--qa-bg': '#fff9f1',
                '--qa-border': '#d9ccb8',
                '--qa-accent': '#7c4a2a',
                '--qa-accent-soft': '#efe2d5',
                '--qa-max-width': '100%'
            },
            onParse: (result) => {
                document.getElementById('meta4').textContent = `entries=${result.entryCount}, valid=${result.validCount}, invalid=${result.invalidCount}`;
            }
        };
        const modalDefaultInput =
            'Finalize investor update !p2;; st:doing;; due:23 feb 26 at 3pm;; @Mimansa;;\n\n' +
            'Book dentist !p1;; st:todo;; due:next week at 9:15am;; @Mimansa;;';
        const modalAdd = QuickAdd.create(modalConfig);
        modalAdd.setInput(modalDefaultInput);

        function buildDemoTaskAiEntriesForSegment(text) {
            const source = String(text || '').trim();
            const lower = source.toLowerCase();
            const attachments = Array.from(new Set(
                (source.match(/\b(?:photo|file)\s*(\d+)\b/gi) || [])
                    .map((item) => item.replace(/\D+/g, '').trim())
                    .filter(Boolean)
                    .map((num) => `attachment-${num}`)
            ));
            const priority = lower.includes('urgent') || lower.includes('p1') ? 'p1' : (lower.includes('p3') ? 'p3' : 'p2');
            const project = lower.includes('health')
                ? 'health'
                : (lower.includes('home') ? 'home' : (lower.includes('errand') ? 'errands' : 'work'));
            const ownerMatch = source.match(/@([\w-]+)/);
            const owner = ownerMatch ? ownerMatch[1] : 'Mimansa';
            const due = lower.includes('tomorrow') ? '2026-02-15T09:00' : '2026-02-14T15:30';

            return [{
                title: source || 'Synthetic AI task',
                priority,
                project,
                due,
                owner,
                attachments
            }];
        }

        function buildDemoTaskAiStructuredResponse(input) {
            const text = String(input || '').trim();
            return {
                entries: buildDemoTaskAiEntriesForSegment(text),
                missing: [],
                warnings: ['Synthetic response enabled in demo (config.ai.mockResponse).']
            };
        }

        function buildDemoPetAiEntriesForSegment(text) {
            const source = String(text || '').trim();
            const lower = source.toLowerCase();
            const pet = lower.includes('luna') ? 'Luna' : (lower.includes('mochi') ? 'Mochi' : (lower.includes('pico') ? 'Pico' : 'Luna'));
            const event = lower.includes('groom')
                ? 'groom'
                : (lower.includes('vet') ? 'vet' : (lower.includes('fetch') ? 'fetch' : 'walk'));
            const symptom = lower.includes('cough')
                ? 'cough'
                : (lower.includes('vomit') ? 'vomit' : (lower.includes('itch') ? 'itching' : 'low energy'));
            const severityMatch = source.match(/\b(\d+)\b/);
            const severity = severityMatch ? Number(severityMatch[1]) : 2;
            const due = lower.includes('next week') ? '2026-02-20' : '2026-02-18';
            const at = lower.includes('yesterday') ? '2026-02-13' : '2026-02-14';

            return [{
                note: source || 'Synthetic AI pet note',
                pet,
                event,
                due,
                symptom,
                severity,
                at
            }];
        }

        function buildDemoPetAiInlineResponse(input) {
            const text = String(input || '').trim();
            const lower = text.toLowerCase();
            const entries = buildDemoPetAiEntriesForSegment(text).map((entry) => {
                const spans = [];
                const addSpan = (field, phrase) => {
                    if (!phrase) return;
                    const start = lower.indexOf(String(phrase).toLowerCase());
                    if (start < 0) return;
                    spans.push({
                        field,
                        value: text.slice(start, start + String(phrase).length),
                        start,
                        end: start + String(phrase).length
                    });
                };
                addSpan('pet', entry.pet);
                addSpan('event', entry.event);
                addSpan('symptom', entry.symptom);
                addSpan('due', entry.due);
                addSpan('at', entry.at);
                return Object.assign({}, entry, { spans });
            });
            return {
                entries,
                missing: [],
                warnings: ['Synthetic response enabled in demo (config.ai.mockResponse).']
            };
        }

        const aiConfig5 = {
            mount: '#quickAddExample5',
            mode: 'ai',
            debounceMs: 280,
            entrySeparator: '\n\n',
            fieldTerminator: ';;',
            fieldTerminatorMode: 'or-next-prefix',
            allowEntryAttachments: true,
            allowMultipleAttachments: true,
            allowedAttachmentTypes: ['.pdf', '.png', '.jpg', 'image/*'],
            attachmentSources: ['camera', 'gallery', 'files'],
            fallbackField: 'title',
            placeholder: 'Example: ... !p2;; !p1;; and #work;; #health ... (last value wins)',
            inputHeightMode: 'scroll',
            inputMaxHeight: 160,
            schema: {
                fields: [
                    { key: 'title', type: 'string', required: true },
                    {
                        key: 'priority',
                        type: 'options',
                        prefixes: ['!'],
                        exhaustive: true,
                        options: [
                            { value: 'p1', color: '#dc2626' },
                            { value: 'p2', color: '#d97706' },
                            { value: 'p3', color: '#0284c7' }
                        ]
                    },
                    {
                        key: 'project',
                        type: 'options',
                        prefixes: ['#'],
                        exhaustive: true,
                        options: [
                            { value: 'health', color: '#0d9488' },
                            { value: 'work', color: '#7c3aed' },
                            { value: 'home', color: '#16a34a' },
                            { value: 'errands', color: '#475569' }
                        ]
                    },
                    { key: 'due', type: 'datetime', naturalDate: true, allowDateOnly: true, defaultTime: '08:00', prefixes: ['due:'] },
                    { key: 'owner', type: 'string', prefixes: ['@'] }
                ]
            },
            ai: {
                enabled: true,
                autoParse: true,
                debounceMs: 900,
                minInputLength: 8,
                separatorAware: true,
                inlinePills: false,
                provider: 'openai',
                apiKey: 'demo-key',
                model: 'gpt-4o-mini',
                mockLatencyMs: 420,
                mockResponse: (input) => buildDemoTaskAiStructuredResponse(input),
                controls: { parse: true, queue: true, process: true, clear: true }
            },
            tokens: {
                '--qa-bg': '#fff8ef',
                '--qa-border': '#e5d7c4',
                '--qa-accent': '#8b4a2f',
                '--qa-accent-soft': '#f4e7df'
            },
            onParse: (result) => {
                document.getElementById('meta5').textContent =
                    `mode=${result.mode || 'deterministic'}, entries=${result.entryCount}, valid=${result.validCount}, queued=${result.queueCount || 0}`;
            }
        };
        const aiDefaultInput5 =
            taskDefaultInput;
        const aiAdd5 = QuickAdd.create(aiConfig5);
        aiAdd5.setInput(aiDefaultInput5);
        const aiPlayground5 = setupConfigPlayground({
            editorId: 'config5',
            applyButtonId: 'applyConfig5',
            resetButtonId: 'resetConfig5',
            statusId: 'config5Status',
            errorsBoxId: 'config5ErrorsBox',
            errorsSummaryId: 'config5ErrorsSummary',
            errorsListId: 'config5Errors',
            component: aiAdd5,
            baseConfig: aiConfig5,
            defaultInput: aiDefaultInput5
        });
        setupAiRuntimeControls({
            playground: aiPlayground5,
            providerSelectId: 'aiProviderSelect5',
            providerTriggerId: 'aiProviderTrigger5',
            providerInputId: 'aiProvider5',
            apiKeyId: 'aiApiKey5',
            modelId: 'aiModel5',
            endpointId: 'aiEndpoint5',
            applyId: 'aiApply5',
            endpointFieldId: 'aiEndpointField5',
            modelFieldId: 'aiModelField5',
            keyFieldId: 'aiKeyField5'
        });

        const aiConfig6 = {
            mount: '#quickAddExample6',
            mode: 'ai',
            debounceMs: 320,
            entrySeparator: ';',
            fieldTerminator: '~~',
            fieldTerminatorMode: 'strict',
            showEntryHeader: false,
            autoDetectOptionsWithoutPrefix: true,
            reduceInferredOptions: false,
            inferredMatchMode: 'fuzzy',
            inferredMatchThreshold: 0.8,
            fallbackField: 'note',
            placeholder: 'Use ; for new entry. Example: pet:Luna~~ event:walk~~ due:2025-02-01~~ at:yesterday~~ (at: defaults to today if omitted)',
            inputHeightMode: 'scroll',
            inputMaxHeight: 150,
            showInlinePills: true,
            classNames: {
                root: 'qa-root petqa-root',
                entry: 'qa-entry petqa-entry'
            },
            schema: {
                fields: [
                    { key: 'note', type: 'string' },
                    {
                        key: 'pet',
                        type: 'options',
                        prefixes: ['pet:'],
                        required: true,
                        exhaustive: true,
                        options: [
                            { value: 'Luna', color: '#22c55e' },
                            { value: 'Mochi', color: '#f97316' },
                            { value: 'Pico', color: '#3b82f6' }
                        ]
                    },
                    {
                        key: 'event',
                        type: 'options',
                        prefixes: ['event:', 'ev:'],
                        required: true,
                        exhaustive: true,
                        options: [
                            { value: 'walk', color: '#22c55e', dependsOn: { field: 'pet', op: 'in', value: ['Luna', 'Mochi'] } },
                            { value: 'fetch', color: '#16a34a', dependsOn: { field: 'pet', op: 'eq', value: 'Luna' } },
                            { value: 'litter', color: '#2563eb', dependsOn: { field: 'pet', op: 'eq', value: 'Pico' } },
                            { value: 'groom', color: '#f97316', dependsOn: { field: 'pet', op: 'eq', value: 'Mochi' } },
                            { value: 'vet', color: '#7c3aed' }
                        ]
                    },
                    {
                        key: 'due',
                        type: 'date',
                        naturalDate: false,
                        prefixes: ['due:'],
                        constraints: [
                            {
                                op: 'gte',
                                value: '2025-02-15',
                                message: 'Due date must be on or after 2025-02-15'
                            },
                            {
                                when: { field: 'pet', op: 'eq', value: 'Pico' },
                                op: 'gte',
                                value: '2026-01-01',
                                message: 'For pet Pico, due date must be on or after 2026-01-01'
                            }
                        ]
                    },
                    {
                        key: 'symptom',
                        type: 'options',
                        prefixes: ['symptom:', 'sym:'],
                        allowCustom: true,
                        autoDetectWithoutPrefix: true,
                        reduceInferredOptions: true,
                        options: [
                            { value: 'cough', color: '#dc2626' },
                            { value: 'vomit', color: '#ea580c' },
                            { value: 'itching', color: '#d97706' },
                            { value: 'low energy', color: '#7c3aed' }
                        ]
                    },
                    { key: 'severity', type: 'number', prefixes: ['sev:'] },
                    { key: 'at', type: 'date', naturalDate: true, prefixes: ['at:'], required: true, autoToday: true }
                ]
            },
            ai: {
                enabled: true,
                autoParse: true,
                debounceMs: 900,
                minInputLength: 8,
                separatorAware: true,
                inlinePills: true,
                provider: 'openai',
                apiKey: 'demo-key',
                model: 'gpt-4o-mini',
                mockLatencyMs: 420,
                mockResponse: (input) => buildDemoPetAiInlineResponse(input),
                inlinePillHarness: ({ input, entries }) => {
                    const rawInput = String(input || '');
                    const marks = [];
                    const pushMark = (mark) => {
                        if (!mark) return;
                        const start = Number(mark.start);
                        const end = Number(mark.end);
                        if (!Number.isFinite(start) || !Number.isFinite(end) || end <= start) {
                            return;
                        }
                        if (start < 0 || end > rawInput.length) {
                            return;
                        }
                        marks.push({
                            start,
                            end,
                            label: String(mark.label || rawInput.slice(start, end)),
                            inferred: true,
                            fieldKey: mark.fieldKey || mark.field || '',
                            value: mark.value
                        });
                    };
                    (entries || []).forEach((entry) => {
                        const segmentStart = Number.isFinite(Number(entry && entry._sourceStart))
                            ? Number(entry._sourceStart)
                            : 0;
                        const segmentEnd = Number.isFinite(Number(entry && entry._sourceEnd))
                            ? Number(entry._sourceEnd)
                            : rawInput.length;
                        const segmentSafeStart = Math.max(0, Math.min(segmentStart, rawInput.length));
                        const segmentSafeEnd = Math.max(segmentSafeStart, Math.min(segmentEnd, rawInput.length));
                        const segmentLength = Math.max(0, segmentSafeEnd - segmentSafeStart);
                        const segmentSlice = rawInput.slice(segmentSafeStart, segmentSafeEnd);

                        (entry.spans || []).forEach((span) => {
                            const rawStart = Number(span && span.start);
                            const rawEnd = Number(span && span.end);
                            const spanValue = String((span && span.value) || '').trim();
                            const hasNumeric = Number.isFinite(rawStart) && Number.isFinite(rawEnd) && rawEnd > rawStart;
                            let start = NaN;
                            let end = NaN;

                            if (hasNumeric) {
                                const appearsGlobal = rawStart >= segmentSafeStart && rawEnd <= segmentSafeEnd;
                                const appearsRelative = rawStart >= 0 && rawEnd <= segmentLength;
                                if (appearsGlobal) {
                                    start = rawStart;
                                    end = rawEnd;
                                } else if (appearsRelative) {
                                    start = segmentSafeStart + rawStart;
                                    end = segmentSafeStart + rawEnd;
                                } else {
                                    start = rawStart;
                                    end = rawEnd;
                                }
                            }

                            const isValidRange = Number.isFinite(start) && Number.isFinite(end) && end > start;
                            const inBounds = isValidRange && start >= 0 && end <= rawInput.length;
                            const snippet = inBounds ? rawInput.slice(start, end) : '';
                            const valueMatches = !spanValue
                                || snippet.toLowerCase().includes(spanValue.toLowerCase());

                            if (!inBounds || !valueMatches) {
                                if (!spanValue || !segmentSlice) {
                                    return;
                                }
                                const rel = segmentSlice.toLowerCase().indexOf(spanValue.toLowerCase());
                                if (rel < 0) {
                                    return;
                                }
                                start = segmentSafeStart + rel;
                                end = start + spanValue.length;
                            }

                            if (!Number.isFinite(start) || !Number.isFinite(end) || end <= start) {
                                return;
                            }

                            pushMark({
                                start,
                                end,
                                label: `${span.field || 'field'}: ${span.value || ''}`,
                                inferred: true,
                                fieldKey: span.field || '',
                                value: span.value
                            });
                        });
                    });
                    return marks;
                }
            },
            onParse: (result) => {
                document.getElementById('meta6').textContent =
                    `mode=${result.mode || 'deterministic'}, entries=${result.entryCount}, valid=${result.validCount}, queued=${result.queueCount || 0}`;
            }
        };
        const aiDefaultInput6 =
            petDefaultInput;
        const aiAdd6 = QuickAdd.create(aiConfig6);
        aiAdd6.setInput(aiDefaultInput6);
        const aiPlayground6 = setupConfigPlayground({
            editorId: 'config6',
            applyButtonId: 'applyConfig6',
            resetButtonId: 'resetConfig6',
            statusId: 'config6Status',
            errorsBoxId: 'config6ErrorsBox',
            errorsSummaryId: 'config6ErrorsSummary',
            errorsListId: 'config6Errors',
            component: aiAdd6,
            baseConfig: aiConfig6,
            defaultInput: aiDefaultInput6
        });
        setupAiRuntimeControls({
            playground: aiPlayground6,
            providerSelectId: 'aiProviderSelect6',
            providerTriggerId: 'aiProviderTrigger6',
            providerInputId: 'aiProvider6',
            apiKeyId: 'aiApiKey6',
            modelId: 'aiModel6',
            endpointId: 'aiEndpoint6',
            applyId: 'aiApply6',
            endpointFieldId: 'aiEndpointField6',
            modelFieldId: 'aiModelField6',
            keyFieldId: 'aiKeyField6'
        });

        const modalBackdropEl = document.getElementById('quickAddModalBackdrop');
        const openModalBtn = document.getElementById('openQuickAddModal');
        const closeModalBtn = document.getElementById('closeQuickAddModal');
        const exampleTabsEl = document.getElementById('exampleTabs');
        const exampleTabsSelectEl = document.getElementById('exampleTabsSelect');
        const exampleTabsTriggerEl = document.getElementById('exampleTabsTrigger');
        const openModal = () => {
            if (!modalBackdropEl) return;
            modalBackdropEl.hidden = false;
            document.body.classList.add('qa-modal-open');
            window.requestAnimationFrame(() => {
                const input = modalBackdropEl.querySelector('[data-role="input"]');
                if (input && typeof input.focus === 'function') {
                    input.focus();
                }
            });
        };
        const closeModal = () => {
            if (!modalBackdropEl) return;
            modalBackdropEl.hidden = true;
            document.body.classList.remove('qa-modal-open');
        };
        if (openModalBtn) {
            openModalBtn.addEventListener('click', openModal);
        }
        if (closeModalBtn) {
            closeModalBtn.addEventListener('click', closeModal);
        }
        if (modalBackdropEl) {
            modalBackdropEl.addEventListener('click', (event) => {
                if (event.target === modalBackdropEl) {
                    closeModal();
                }
            });
        }
        if (exampleTabsEl) {
            exampleTabsEl.addEventListener('click', (event) => {
                const tab = event.target.closest('[data-example]');
                if (tab && tab.getAttribute('data-example') !== 'example4') {
                    closeModal();
                }
            });
        }
        if (exampleTabsSelectEl && exampleTabsTriggerEl) {
            exampleTabsTriggerEl.addEventListener('click', () => {
                exampleTabsSelectEl.classList.toggle('open');
            });
            exampleTabsSelectEl.addEventListener('click', (event) => {
                const option = event.target.closest('[data-example]');
                if (!option) return;
                const value = option.getAttribute('data-example');
                const match = exampleTabsEl?.querySelector(`[data-example="${value}"]`);
                if (match) {
                    match.click();
                }
                exampleTabsSelectEl.classList.remove('open');
            });
            document.addEventListener('click', (event) => {
                if (!exampleTabsSelectEl.contains(event.target)) {
                    exampleTabsSelectEl.classList.remove('open');
                }
            });
        }

        const componentTabsEl = document.getElementById('componentTabs');
        const componentTabsSelectEl = document.getElementById('componentTabsSelect');
        const componentTabsTriggerEl = document.getElementById('componentTabsTrigger');

        if (componentTabsSelectEl && componentTabsTriggerEl) {
            componentTabsTriggerEl.addEventListener('click', () => {
                componentTabsSelectEl.classList.toggle('open');
            });
            componentTabsSelectEl.addEventListener('click', (event) => {
                const option = event.target.closest('[data-page]');
                if (!option) return;
                const value = option.getAttribute('data-page');
                const match = componentTabsEl?.querySelector(`[data-page="${value}"]`);
                if (match) {
                    match.click();
                }
                componentTabsSelectEl.classList.remove('open');
            });
            document.addEventListener('click', (event) => {
                if (!componentTabsSelectEl.contains(event.target)) {
                    componentTabsSelectEl.classList.remove('open');
                }
            });
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && modalBackdropEl && !modalBackdropEl.hidden) {
                const hasOpenQuickAddPopup = !!modalBackdropEl.querySelector(
                    '[data-role="datePicker"]:not([hidden]), [data-role="dropdown"]:not([hidden]), [data-role="blockedInfo"]:not([hidden])'
                );
                if (hasOpenQuickAddPopup) {
                    return;
                }
                closeModal();
            }
        }, true);
    </script>
</body>

</html>