<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Stack Designer</title>

    <!-- Tailwind CSS for UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif']
                    },
                    colors: {
                        linen: {
                            50: '#fdfaf7',
                            100: '#f5eee3',
                            200: '#ebdcc5',
                            300: '#d7c4a6'
                        },
                        oatmeal: {
                            100: '#f2e6d5',
                            200: '#e3d1b8',
                            300: '#d2b793',
                            400: '#bc9e78'
                        },
                        earth: {
                            50: '#fafaf9',
                            100: '#f5f5f4',
                            200: '#e7e5e4',
                            300: '#d6d3d1',
                            400: '#a8a29e',
                            500: '#78716c',
                            600: '#57534e',
                            700: '#44403c',
                            800: '#292524',
                            900: '#1c1917'
                        },
                        charcoal: {
                            400: '#70675f',
                            500: '#564f48',
                            600: '#3c3631',
                            700: '#2d2a27',
                            800: '#1f1a17'
                        },
                        amethyst: {
                            300: '#cbbbdc',
                            400: '#b8aac7',
                            500: '#9f86c0',
                            600: '#6a5a7d'
                        }
                    }
                }
            }
        };
    </script>

    <!-- PDF.js for parsing PDF files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5eee3;
            color: #292524;
        }

        .btn-accent {
            background-color: #866fa3;
            color: #fdfaf7;
        }

        .btn-accent:hover {
            background-color: #6f598d;
        }

        .btn-charcoal {
            background-color: #3c3631;
            color: #fdfaf7;
        }

        .btn-charcoal:hover {
            background-color: #2d2a27;
        }

        /* Custom Scrollbar for the settings panel */
        .custom-scroll::-webkit-scrollbar {
            width: 6px;
        }

        .custom-scroll::-webkit-scrollbar-track {
            background: #f5eee3;
        }

        .custom-scroll::-webkit-scrollbar-thumb {
            background: #d7c4a6;
            border-radius: 3px;
        }

        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: #9f86c0;
        }

        /* Checkerboard pattern for transparent background */
        .checkerboard {
            background-image:
                linear-gradient(45deg, #eadcc5 25%, transparent 25%),
                linear-gradient(-45deg, #eadcc5 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, rgba(149, 134, 114, 0.2) 75%),
                linear-gradient(-45deg, transparent 75%, rgba(149, 134, 114, 0.2) 75%);
            background-size: 24px 24px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        input[type="range"],
        input[type="checkbox"] {
            accent-color: #9f86c0;
        }
    </style>

    <script>
        // Configure PDF.js Worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
</head>

<body class="bg-linen-100 h-screen flex flex-col overflow-hidden text-earth-800">

    <!-- Header -->
    <header class="bg-linen-50 border-b border-earth-200 px-6 py-3 flex items-center justify-between shadow-sm z-10">
        <div class="flex items-center gap-2">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-amethyst-500" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
            <h1 class="text-lg font-semibold tracking-tight">PDF Stack Designer</h1>
        </div>
        <div class="flex gap-3">
            <label for="pdf-upload"
                class="cursor-pointer btn-accent px-4 py-2 rounded-md text-sm font-medium transition shadow-sm flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                </svg>
                Upload PDF
            </label>
            <input type="file" id="pdf-upload" accept="application/pdf" class="hidden" />

            <button id="download-btn"
                class="btn-charcoal px-4 py-2 rounded-md text-sm font-medium transition shadow-sm flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                disabled>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                </svg>
                Download PNG
            </button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">

        <!-- Settings Sidebar -->
        <aside class="w-80 bg-linen-50 border-r border-earth-200 overflow-y-auto custom-scroll flex flex-col">
            <div class="p-5 space-y-6">

                <!-- Status -->
                <div id="status-area"
                    class="text-xs font-mono p-3 bg-linen-50 rounded border border-earth-200 text-earth-500">
                    Waiting for file...
                </div>

                <div class="space-y-4">
                    <h3 class="text-xs font-bold uppercase text-earth-400 tracking-wider">Layout</h3>

                    <!-- Direction -->
                    <div>
                        <label class="block text-sm font-medium text-earth-700 mb-1">Stack Direction</label>
                        <select id="direction"
                            class="w-full bg-linen-50 border border-earth-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-amethyst-300">
                            <option value="ltr">Left to Right</option>
                            <option value="rtl">Right to Left</option>
                            <option value="ttb">Top to Bottom</option>
                            <option value="btt">Bottom to Top</option>
                        </select>
                    </div>

                    <!-- Page Count -->
                    <div>
                        <label class="block text-sm font-medium text-earth-700 mb-1">Page Limit <span id="limit-val"
                                class="text-earth-400 text-xs ml-1">(5)</span></label>
                        <input type="range" id="page-limit" min="1" max="20" value="5"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>

                    <!-- Spacing (Overlap) -->
                    <div>
                        <label class="block text-sm font-medium text-earth-700 mb-1">Spread Amount</label>
                        <input type="range" id="spacing" min="0" max="300" value="100"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>

                    <!-- Vertical Offset -->
                    <div>
                        <label class="block text-sm font-medium text-earth-700 mb-1">Vertical Step</label>
                        <input type="range" id="v-step" min="-50" max="50" value="10"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>
                </div>

                <hr class="border-linen-200">

                <div class="space-y-4">
                    <h3 class="text-xs font-bold uppercase text-earth-400 tracking-wider">Style</h3>

                    <!-- Rotation -->
                    <div>
                        <label class="block text-sm font-medium text-earth-700 mb-1">Tilt / Rotation</label>
                        <input type="range" id="rotation" min="-45" max="45" value="-5"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>

                    <!-- Randomness -->
                    <div>
                        <label class="block text-sm font-medium text-earth-700 mb-1">Messiness (Random Jitter)</label>
                        <input type="range" id="jitter" min="0" max="20" value="2"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>

                    <!-- Margin Crop -->
                    <div>
                        <div class="flex items-center justify-between">
                            <label class="block text-sm font-medium text-earth-700">Margin Crop (After First)</label>
                            <span id="margin-crop-value" class="text-xs text-earth-400 font-semibold">0%</span>
                        </div>
                        <input type="range" id="margin-crop" min="0" max="30" value="0"
                            class="mt-1 w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                        <p class="text-[11px] text-earth-500 mt-1">Trims the leading edge (based on stack direction) so
                            inner pages reveal more content.</p>
                    </div>

                    <!-- Shadow -->
                    <div>
                        <div class="flex items-center justify-between">
                            <label class="block text-sm font-medium text-earth-700">Drop Shadow</label>
                            <div class="flex items-center gap-2">
                                <span id="shadow-toggle-value" class="text-xs text-earth-400 font-semibold">On</span>
                                <label class="inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="shadow-toggle" class="sr-only peer" checked>
                                    <span
                                        class="w-10 h-5 bg-earth-200 peer-checked:bg-amethyst-500 rounded-full transition-colors relative">
                                        <span
                                            class="absolute top-0.5 left-0.5 w-4 h-4 bg-white rounded-full transition-transform peer-checked:translate-x-5"></span>
                                    </span>
                                </label>
                            </div>
                        </div>
                        <p class="text-[11px] text-earth-500 mt-1">Toggle drop shadows for more minimal stacks.</p>
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-earth-700 mb-1">Shadow Intensity</label>
                        <input type="range" id="shadow-blur" min="0" max="100" value="40"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>

                    <!-- Background -->
                    <div>
                        <div class="flex items-center justify-between">
                            <label class="block text-sm font-medium text-earth-700">Canvas Background</label>
                            <div class="flex items-center gap-2">
                                <span id="bg-toggle-value"
                                    class="text-xs text-earth-400 font-semibold">Transparent</span>
                                <label class="inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="transparent-bg" class="sr-only peer" checked>
                                    <span
                                        class="w-10 h-5 bg-earth-200 peer-checked:bg-amethyst-500 rounded-full transition-colors relative">
                                        <span
                                            class="absolute top-0.5 left-0.5 w-4 h-4 bg-white rounded-full transition-transform peer-checked:translate-x-5"></span>
                                    </span>
                                </label>
                            </div>
                        </div>
                        <div id="bg-color-wrapper" class="mt-3 hidden">
                            <label class="text-xs uppercase tracking-wide text-earth-500 font-semibold mb-1 block">Fill
                                Color</label>
                            <input type="color" id="bg-color" value="#ffffff"
                                class="w-full h-9 cursor-pointer rounded-md border border-earth-300">
                        </div>
                    </div>
                </div>

            </div>
        </aside>

        <!-- Main Preview Area -->
        <main class="flex-1 bg-linen-200 flex items-center justify-center overflow-auto p-8 relative"
            id="canvas-container">
            <div class="text-center text-earth-500" id="placeholder-text">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto mb-4 text-earth-400" fill="none"
                    viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"
                        d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 2H7a2 2 0 00-2 2v15a2 2 0 002 2z" />
                </svg>
                <p class="text-lg font-medium">Upload a PDF to start designing</p>
                <p class="text-sm mt-1">Files are processed locally in your browser.</p>
            </div>
            <canvas id="main-canvas" class="shadow-2xl hidden max-w-full max-h-full"></canvas>
        </main>
    </div>

    <script>
        // --- State Management ---
        const state = {
            pdfDoc: null,
            pageImages: [], // Array of { canvas, width, height }
            config: {
                direction: 'ltr',
                pageLimit: 5,
                spacing: 100,
                vStep: 10,
                rotation: -5,
                jitter: 2,
                marginCrop: 0,
                shadowEnabled: true,
                shadowBlur: 40,
                transparentBg: true,
                bgColor: '#ffffff'
            },
            renderToken: 0,
            limitDebounce: null
        };

        // --- DOM Elements ---
        const els = {
            fileInput: document.getElementById('pdf-upload'),
            canvas: document.getElementById('main-canvas'),
            downloadBtn: document.getElementById('download-btn'),
            status: document.getElementById('status-area'),
            placeholder: document.getElementById('placeholder-text'),
            container: document.getElementById('canvas-container'),

            // Inputs
            inputs: {
                direction: document.getElementById('direction'),
                pageLimit: document.getElementById('page-limit'),
                spacing: document.getElementById('spacing'),
                vStep: document.getElementById('v-step'),
                rotation: document.getElementById('rotation'),
                jitter: document.getElementById('jitter'),
                marginCrop: document.getElementById('margin-crop'),
                shadowEnabled: document.getElementById('shadow-toggle'),
                shadowBlur: document.getElementById('shadow-blur'),
                transparentBg: document.getElementById('transparent-bg'),
                bgColor: document.getElementById('bg-color')
            }
        };

        // --- Initialization ---
        function init() {
            // Attach listeners to all inputs
            Object.entries(els.inputs).forEach(([key, el]) => {
                el.addEventListener('input', (e) => {
                    // Update state
                    if (el.type === 'checkbox') state.config[key] = el.checked;
                    else if (key === 'direction' || key === 'bgColor') state.config[key] = el.value;
                    else state.config[key] = parseInt(el.value);

                    // UI Updates
                    if (key === 'pageLimit') document.getElementById('limit-val').innerText = `(${el.value})`;
                    if (key === 'transparentBg') {
                        document.getElementById('bg-color-wrapper').style.display = el.checked ? 'none' : 'block';
                        document.getElementById('bg-toggle-value').innerText = el.checked ? 'Transparent' : 'Solid';
                    }
                    if (key === 'marginCrop') {
                        document.getElementById('margin-crop-value').innerText = `${el.value}%`;
                    }
                    if (key === 'shadowEnabled') {
                        document.getElementById('shadow-toggle-value').innerText = el.checked ? 'On' : 'Off';
                    }

                    // Redraw if we have images
                    if (state.pageImages.length > 0) {
                        if (key === 'pageLimit') {
                            if (state.limitDebounce) clearTimeout(state.limitDebounce);
                            state.limitDebounce = setTimeout(() => {
                                loadPagesFromDoc();
                            }, 200);
                        } else {
                            drawStack();
                        }
                    }
                });
            });

            document.getElementById('margin-crop-value').innerText = `${state.config.marginCrop}%`;
            document.getElementById('shadow-toggle-value').innerText = state.config.shadowEnabled ? 'On' : 'Off';
            els.inputs.shadowEnabled.checked = state.config.shadowEnabled;
            document.getElementById('bg-toggle-value').innerText = state.config.transparentBg ? 'Transparent' : 'Solid';
            els.inputs.transparentBg.checked = state.config.transparentBg;
            document.getElementById('bg-color-wrapper').style.display = state.config.transparentBg ? 'none' : 'block';

            els.fileInput.addEventListener('change', handleFileUpload);
            els.downloadBtn.addEventListener('click', downloadImage);

            // Window resize listener to adjust canvas display (not content)
            window.addEventListener('resize', () => {
                if (state.pageImages.length > 0) drawStack();
            });
        }

        // --- File Handling ---
        async function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            if (file.type !== 'application/pdf') {
                alert('Please upload a valid PDF file.');
                return;
            }

            els.status.textContent = "Loading PDF...";
            els.placeholder.style.display = 'none';

            try {
                const arrayBuffer = await file.arrayBuffer();
                state.pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                els.status.textContent = `PDF Loaded (${state.pdfDoc.numPages} pages). Rendering...`;
                await loadPagesFromDoc();

                els.downloadBtn.disabled = false;
                els.canvas.classList.remove('hidden');
            } catch (err) {
                console.error(err);
                els.status.textContent = "Error: " + err.message;
                alert("Error loading PDF. Ensure it is not password protected.");
            }
        }

        // --- PDF Rendering (To Offscreen Canvas) ---
        async function loadPagesFromDoc() {
            if (!state.pdfDoc) return;
            const currentToken = ++state.renderToken;

            state.pageImages = [];
            const count = Math.min(state.pdfDoc.numPages, state.config.pageLimit);
            const scale = 1.5; // High quality for output

            els.status.textContent = `Rendering ${count} pages...`;

            for (let i = 1; i <= count; i++) {
                const page = await state.pdfDoc.getPage(i);
                const viewport = page.getViewport({ scale: scale });

                // Create offscreen canvas
                const offCanvas = document.createElement('canvas');
                offCanvas.width = viewport.width;
                offCanvas.height = viewport.height;
                const ctx = offCanvas.getContext('2d');

                const renderContext = {
                    canvasContext: ctx,
                    viewport: viewport
                };

                await page.render(renderContext).promise;
                if (currentToken !== state.renderToken) return; // Abort if a new render started

                state.pageImages.push({
                    canvas: offCanvas,
                    width: viewport.width,
                    height: viewport.height,
                    // Pre-calculate random jitter for this page so it stays consistent
                    jitterX: (Math.random() - 0.5) * 2,
                    jitterY: (Math.random() - 0.5) * 2,
                    jitterRot: (Math.random() - 0.5) * 2
                });
            }

            if (currentToken !== state.renderToken) return;
            els.status.textContent = "Rendering complete.";
            drawStack();
        }

        function sampleEdgeColor(canvas, sx, sy, sw, sh) {
            const ctx = canvas.getContext('2d');
            if (!ctx) return 'rgba(255,255,255,1)';
            const sampleW = Math.max(1, Math.min(20, Math.floor(sw)));
            const sampleH = Math.max(1, Math.min(20, Math.floor(sh)));
            const startX = Math.max(0, Math.min(canvas.width - sampleW, Math.round(sx + (sw - sampleW) / 2)));
            const startY = Math.max(0, Math.min(canvas.height - sampleH, Math.round(sy + (sh - sampleH) / 2)));
            try {
                const data = ctx.getImageData(startX, startY, sampleW, sampleH).data;
                let r = 0, g = 0, b = 0, a = 0;
                const pixels = sampleW * sampleH;
                for (let i = 0; i < data.length; i += 4) {
                    r += data[i];
                    g += data[i + 1];
                    b += data[i + 2];
                    a += data[i + 3];
                }
                r = Math.round(r / pixels);
                g = Math.round(g / pixels);
                b = Math.round(b / pixels);
                const alpha = (a / pixels) / 255;
                return `rgba(${r}, ${g}, ${b}, ${alpha || 1})`;
            } catch (err) {
                return 'rgba(255,255,255,1)';
            }
        }

        function getCropMetrics(img, index, config) {
            const direction = config.direction;
            const w = img.width;
            const h = img.height;
            const percent = index === 0 ? 0 : config.marginCrop;
            const fraction = Math.max(0, Math.min(100, percent)) / 100;
            const isVertical = direction === 'ttb' || direction === 'btt';
            const baseAxis = isVertical ? h : w;
            const cropPixelsRaw = baseAxis * fraction;
            const cropPixels = Math.min(baseAxis, Math.round(cropPixelsRaw));
            const hasCrop = cropPixels > 0;

            const metrics = {
                width: w,
                height: h,
                main: {
                    sx: 0,
                    sy: 0,
                    sw: w,
                    sh: h,
                    dx: 0,
                    dy: 0,
                    dw: w,
                    dh: h
                },
                filler: null
            };

            if (!hasCrop) return metrics;

            if (!isVertical) {
                if (direction === 'ltr') {
                    const sw = Math.max(1, w - cropPixels);
                    metrics.main.sw = sw;
                    metrics.main.dw = sw;
                    metrics.main.dx = cropPixels;
                    metrics.filler = {
                        dx: 0,
                        dy: 0,
                        dw: cropPixels,
                        dh: h,
                        orientation: 'horizontal',
                        startColor: sampleEdgeColor(img.canvas, 0, 0, Math.min(4, w - cropPixels), h),
                        endColor: sampleEdgeColor(img.canvas, w - cropPixels, 0, cropPixels, h)
                    };
                } else if (direction === 'rtl') {
                    const sw = Math.max(1, w - cropPixels);
                    metrics.main.sx = cropPixels;
                    metrics.main.sw = sw;
                    metrics.main.dw = sw;
                    metrics.main.dx = 0;
                    metrics.filler = {
                        dx: w - cropPixels,
                        dy: 0,
                        dw: cropPixels,
                        dh: h,
                        orientation: 'horizontal',
                        startColor: sampleEdgeColor(img.canvas, w - Math.min(4, w - cropPixels), 0, Math.min(4, w - cropPixels), h),
                        endColor: sampleEdgeColor(img.canvas, 0, 0, cropPixels, h)
                    };
                }
            } else {
                if (direction === 'ttb') {
                    const sh = Math.max(1, h - cropPixels);
                    metrics.main.sh = sh;
                    metrics.main.dh = sh;
                    metrics.main.dy = cropPixels;
                    metrics.filler = {
                        dx: 0,
                        dy: 0,
                        dw: w,
                        dh: cropPixels,
                        orientation: 'vertical',
                        startColor: sampleEdgeColor(img.canvas, 0, 0, w, Math.min(4, h - cropPixels)),
                        endColor: sampleEdgeColor(img.canvas, 0, h - cropPixels, w, cropPixels)
                    };
                } else if (direction === 'btt') {
                    const sh = Math.max(1, h - cropPixels);
                    metrics.main.sy = cropPixels;
                    metrics.main.sh = sh;
                    metrics.main.dh = sh;
                    metrics.main.dy = 0;
                    metrics.filler = {
                        dx: 0,
                        dy: h - cropPixels,
                        dw: w,
                        dh: cropPixels,
                        orientation: 'vertical',
                        startColor: sampleEdgeColor(img.canvas, 0, h - Math.min(4, h - cropPixels), w, Math.min(4, h - cropPixels)),
                        endColor: sampleEdgeColor(img.canvas, 0, 0, w, cropPixels)
                    };
                }
            }

            return metrics;
        }

        function composePageImage(img, metrics) {
            if (!metrics.filler) return img.canvas;

            const canvas = document.createElement('canvas');
            canvas.width = metrics.width;
            canvas.height = metrics.height;
            const ctx = canvas.getContext('2d');

            // Fill the reconstructed margin with a gradient between existing edge and cropped region
            if (metrics.filler.orientation === 'horizontal') {
                const grad = ctx.createLinearGradient(
                    metrics.filler.dx,
                    metrics.filler.dy,
                    metrics.filler.dx + metrics.filler.dw,
                    metrics.filler.dy
                );
                grad.addColorStop(0, metrics.filler.startColor || 'rgba(255,255,255,1)');
                grad.addColorStop(1, metrics.filler.endColor || 'rgba(255,255,255,1)');
                ctx.fillStyle = grad;
            } else {
                const grad = ctx.createLinearGradient(
                    metrics.filler.dx,
                    metrics.filler.dy,
                    metrics.filler.dx,
                    metrics.filler.dy + metrics.filler.dh
                );
                grad.addColorStop(0, metrics.filler.startColor || 'rgba(255,255,255,1)');
                grad.addColorStop(1, metrics.filler.endColor || 'rgba(255,255,255,1)');
                ctx.fillStyle = grad;
            }
            ctx.fillRect(metrics.filler.dx, metrics.filler.dy, metrics.filler.dw, metrics.filler.dh);

            // Draw main portion
            ctx.drawImage(
                img.canvas,
                metrics.main.sx,
                metrics.main.sy,
                metrics.main.sw,
                metrics.main.sh,
                metrics.main.dx,
                metrics.main.dy,
                metrics.main.dw,
                metrics.main.dh
            );

            return canvas;
        }

        // --- Core Stack Algorithm ---
        function drawStack() {
            if (state.pageImages.length === 0) return;

            const ctx = els.canvas.getContext('2d');
            const config = state.config;
            const images = state.pageImages;
            const direction = config.direction;

            // 1. Calculate Canvas Bounds
            // We need to simulate the draw first to find the total width/height needed.
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            const shadowActive = !!config.shadowEnabled;

            // Loop to determine bounding box
            images.forEach((img, index) => {
                const metrics = getCropMetrics(img, index, config);
                const w = metrics.width;
                const h = metrics.height;

                // Position Logic
                let x = 0, y = 0;
                const offset = index * config.spacing;
                const vOffset = index * config.vStep;

                if (direction === 'ltr') x = offset;
                else if (direction === 'rtl') x = -offset;
                else if (direction === 'ttb') { y = offset; x = 0; }
                else if (direction === 'btt') { y = -offset; x = 0; }

                // Add jitter
                x += img.jitterX * config.jitter;
                y += img.jitterY * config.jitter;
                y += vOffset; // add configured vertical step

                // Rotation impacts bounding box. Approximate with a safety margin or use trig
                const pad = (shadowActive ? config.shadowBlur : 0) + 50; // Padding for shadow and rotation

                minX = Math.min(minX, x - pad);
                maxX = Math.max(maxX, x + w + pad);
                minY = Math.min(minY, y - pad);
                maxY = Math.max(maxY, y + h + pad);
            });

            // 2. Resize Canvas
            els.canvas.width = maxX - minX;
            els.canvas.height = maxY - minY;

            // 3. Background
            if (!config.transparentBg) {
                ctx.fillStyle = config.bgColor;
                ctx.fillRect(0, 0, els.canvas.width, els.canvas.height);
            } else {
                ctx.clearRect(0, 0, els.canvas.width, els.canvas.height);
            }

            // 4. Draw Images
            const drawOrder = images.map((img, i) => ({ ...img, originalIndex: i })).reverse();

            drawOrder.forEach((img) => {
                const index = img.originalIndex;
                const metrics = getCropMetrics(img, index, config);
                const pageCanvas = metrics.filler ? composePageImage(img, metrics) : img.canvas;

                ctx.save();

                // Translation
                let x = 0, y = 0;
                const offset = index * config.spacing;
                const vOffset = index * config.vStep;

                if (direction === 'ltr') x = offset;
                else if (direction === 'rtl') x = -offset;
                else if (direction === 'ttb') { y = offset; x = 0; }
                else if (direction === 'btt') { y = -offset; x = 0; }

                // Adjust coordinate system to center the stack in the canvas
                const drawX = x - minX + (img.jitterX * config.jitter);
                const drawY = y - minY + vOffset + (img.jitterY * config.jitter);

                // Move to center of where the page should be to rotate
                const centerX = drawX + metrics.width / 2;
                const centerY = drawY + metrics.height / 2;

                ctx.translate(centerX, centerY);

                // Rotate
                const baseRot = config.rotation * (Math.PI / 180);
                const jitRot = (img.jitterRot * config.jitter) * (Math.PI / 180);
                ctx.rotate(baseRot + jitRot);

                // Shadow
                if (shadowActive) {
                    ctx.shadowColor = "rgba(0, 0, 0, 0.3)";
                    ctx.shadowBlur = config.shadowBlur;
                    ctx.shadowOffsetX = 10;
                    ctx.shadowOffsetY = 10;
                } else {
                    ctx.shadowColor = "transparent";
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }

                // Draw composite page
                ctx.drawImage(
                    pageCanvas,
                    0,
                    0,
                    metrics.width,
                    metrics.height,
                    -metrics.width / 2,
                    -metrics.height / 2,
                    metrics.width,
                    metrics.height
                );

                // Optional border
                ctx.shadowColor = "transparent";
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                ctx.lineWidth = 1;
                ctx.strokeRect(-metrics.width / 2, -metrics.height / 2, metrics.width, metrics.height);

                ctx.restore();
            });
        }

        // --- Download ---
        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'pdf-stack.png';
            link.href = els.canvas.toDataURL('image/png');
            link.click();
        }

        // Start
        init();

    </script>
</body>

</html>