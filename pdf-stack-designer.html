<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Stack Designer</title>

    <!-- Tailwind CSS for UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif']
                    },
                    colors: {
                        linen: {
                            50: '#fdfaf7',
                            100: '#f5eee3',
                            200: '#ebdcc5',
                            300: '#d7c4a6'
                        },
                        oatmeal: {
                            100: '#f2e6d5',
                            200: '#e3d1b8',
                            300: '#d2b793',
                            400: '#bc9e78'
                        },
                        earth: {
                            50: '#fafaf9',
                            100: '#f5f5f4',
                            200: '#e7e5e4',
                            300: '#d6d3d1',
                            400: '#a8a29e',
                            500: '#78716c',
                            600: '#57534e',
                            700: '#44403c',
                            800: '#292524',
                            900: '#1c1917'
                        },
                        charcoal: {
                            400: '#70675f',
                            500: '#564f48',
                            600: '#3c3631',
                            700: '#2d2a27',
                            800: '#1f1a17'
                        },
                        amethyst: {
                            300: '#cbbbdc',
                            400: '#b8aac7',
                            500: '#9f86c0',
                            600: '#6a5a7d'
                        }
                    }
                }
            }
        };

    </script>

    <!-- PDF.js for parsing PDF files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5eee3;
            color: #292524;
        }

        .btn-accent {
            background-color: #866fa3;
            color: #fdfaf7;
        }

        .btn-accent:hover {
            background-color: #6f598d;
        }

        .btn-charcoal {
            background-color: #3c3631;
            color: #fdfaf7;
        }

        .btn-charcoal:hover {
            background-color: #2d2a27;
        }

        /* Custom Scrollbar for the settings panel */
        .custom-scroll::-webkit-scrollbar {
            width: 6px;
        }

        .custom-scroll::-webkit-scrollbar-track {
            background: #f5eee3;
        }

        .custom-scroll::-webkit-scrollbar-thumb {
            background: #d7c4a6;
            border-radius: 3px;
        }

        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: #9f86c0;
        }

        /* Outline to hint transparent canvas bounds */
        .canvas-outline {
            border: 2px dashed rgba(87, 83, 78, 0.4);
            border-radius: 10px;
            background-color: transparent;
        }

        .status-panel {
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
            outline: none;
        }

        .status-panel.status-info {
            background-color: #f5eee3;
            border-color: #d7c4a6;
            color: #57534e;
        }

        .status-panel.status-success {
            background-color: #e6f4ea;
            border-color: #8bc48a;
            color: #2f5d37;
        }

        .status-panel.status-error {
            background-color: #fde8e4;
            border-color: #f19c8b;
            color: #8c2f22;
        }

        #main-canvas {
            background-color: transparent;
            transition: background 0.2s ease;
        }

        input[type="range"],
        input[type="checkbox"] {
            accent-color: #9f86c0;
        }
    </style>

    <script>
        // Configure PDF.js Worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
</head>

<body class="bg-linen-100 h-screen flex flex-col overflow-hidden text-earth-800">

    <!-- Header -->
    <header class="bg-linen-50 border-b border-earth-200 px-6 py-3 flex items-center justify-between shadow-sm z-10">
        <div class="flex items-center gap-2">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-amethyst-500" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
            <h1 class="text-lg font-semibold tracking-tight">PDF Stack Designer</h1>
        </div>
        <div class="flex gap-3 flex-wrap items-center justify-end">
            <label for="pdf-upload"
                class="cursor-pointer btn-accent px-4 py-2 rounded-md text-sm font-medium transition shadow-sm flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                </svg>
                Upload PDF
            </label>
            <input type="file" id="pdf-upload" accept="application/pdf" class="hidden" />
            <div class="flex gap-2 items-center">
                <input id="pdf-url-input" type="url" placeholder="https://example.com/file.pdf"
                    class="w-60 lg:w-72 px-3 py-2 rounded-md border border-earth-300 bg-white text-sm focus:outline-none focus:ring-2 focus:ring-amethyst-300"
                    aria-label="PDF URL">
                <button id="load-url-btn"
                    class="btn-accent px-3 py-2 rounded-md text-sm font-medium transition shadow-sm disabled:opacity-50 disabled:cursor-not-allowed">
                    Load URL
                </button>
            </div>

            <button id="download-btn"
                class="btn-charcoal px-4 py-2 rounded-md text-sm font-medium transition shadow-sm flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                disabled>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                </svg>
                Download PNG
            </button>
            <button id="share-config-btn"
                class="btn-charcoal px-4 py-2 rounded-md text-sm font-medium transition shadow-sm flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="18" cy="5" r="3" />
                    <circle cx="6" cy="12" r="3" />
                    <circle cx="18" cy="19" r="3" />
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49" />
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49" />
                </svg>
                Share Config
            </button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">

        <!-- Settings Sidebar -->
        <aside class="w-80 bg-linen-50 border-r border-earth-200 overflow-y-auto custom-scroll flex flex-col">
            <div class="p-5 space-y-6">

                <!-- Status -->
                <div id="status-area"
                    class="status-panel status-info text-xs font-mono p-3 bg-linen-50 rounded border border-earth-200 text-earth-500"
                    role="status" aria-live="polite" aria-atomic="true" tabindex="-1">
                    Waiting for file...
                </div>

                <div class="space-y-4">
                    <h3 class="text-xs font-bold uppercase text-earth-400 tracking-wider">Layout</h3>

                    <!-- Direction -->
                    <div>
                        <label class="block text-sm font-medium text-earth-700 mb-1">Stack Direction</label>
                        <select id="direction"
                            class="w-full bg-linen-50 border border-earth-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-amethyst-300">
                            <option value="ltr">Left to Right</option>
                            <option value="rtl">Right to Left</option>
                            <option value="ttb">Top to Bottom</option>
                            <option value="btt">Bottom to Top</option>
                        </select>
                    </div>

                    <!-- Page Count -->
                    <div>
                        <div class="flex items-center justify-between mb-1">
                            <label for="page-limit" class="block text-sm font-medium text-earth-700">Page Limit</label>
                            <span id="limit-val" class="text-xs text-earth-400 font-semibold">5</span>
                        </div>
                        <input type="range" id="page-limit" min="1" max="20" value="5"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>

                    <!-- Spacing (Overlap) -->
                    <div>
                        <div class="flex items-center justify-between mb-1">
                            <label class="block text-sm font-medium text-earth-700">Spread Amount</label>
                            <span id="spacing-value" class="text-xs text-earth-400 font-semibold">100px</span>
                        </div>
                        <input type="range" id="spacing" min="0" max="300" value="100"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>

                    <!-- Vertical Offset -->
                    <div>
                        <div class="flex items-center justify-between mb-1">
                            <label class="block text-sm font-medium text-earth-700">Vertical Step</label>
                            <span id="v-step-value" class="text-xs text-earth-400 font-semibold">10px</span>
                        </div>
                        <input type="range" id="v-step" min="-50" max="50" value="10"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>

                    <!-- Image Quality -->
                    <div>
                        <div class="flex items-center justify-between mb-1">
                            <label class="block text-sm font-medium text-earth-700">Image Quality</label>
                            <span id="scale-value" class="text-xs text-earth-400 font-semibold">1.5x</span>
                        </div>
                        <input type="range" id="render-scale" min="0.5" max="3" step="0.1" value="1.5"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>
                </div>

                <hr class="border-linen-200">

                <div class="space-y-4">
                    <h3 class="text-xs font-bold uppercase text-earth-400 tracking-wider">Style</h3>

                    <!-- Rotation -->
                    <div>
                        <div class="flex items-center justify-between mb-1">
                            <label class="block text-sm font-medium text-earth-700">Tilt / Rotation</label>
                            <span id="rotation-value" class="text-xs text-earth-400 font-semibold">-5°</span>
                        </div>
                        <input type="range" id="rotation" min="-45" max="45" value="-5"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>

                    <!-- Randomness -->
                    <div>
                        <div class="flex items-center justify-between mb-1">
                            <label class="block text-sm font-medium text-earth-700">Messiness (Random Jitter)</label>
                            <span id="jitter-value" class="text-xs text-earth-400 font-semibold">2</span>
                        </div>
                        <input type="range" id="jitter" min="0" max="20" value="2"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>

                    <!-- Margin Crop -->
                    <div>
                        <div class="flex items-center justify-between">
                            <label class="block text-sm font-medium text-earth-700">Margin Crop (After First)</label>
                            <span id="margin-crop-value" class="text-xs text-earth-400 font-semibold">0%</span>
                        </div>
                        <input type="range" id="margin-crop" min="0" max="30" value="0"
                            class="mt-1 w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                        <p class="text-[11px] text-earth-500 mt-1">Trims the leading edge (based on stack direction) so
                            inner pages reveal more content.</p>
                    </div>

                    <!-- Shadow -->
                    <div>
                        <div class="flex items-center justify-between">
                            <label class="block text-sm font-medium text-earth-700">Drop Shadow</label>
                            <div class="flex items-center gap-2">
                                <span id="shadow-toggle-value" class="text-xs text-earth-400 font-semibold">On</span>
                                <label class="inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="shadow-toggle" class="sr-only peer" checked>
                                    <span
                                        class="w-10 h-5 bg-earth-200 peer-checked:bg-amethyst-500 rounded-full transition-colors relative">
                                        <span
                                            class="absolute top-0.5 left-0.5 w-4 h-4 bg-white rounded-full transition-transform peer-checked:translate-x-5"></span>
                                    </span>
                                </label>
                            </div>
                        </div>
                        <p class="text-[11px] text-earth-500 mt-1">Toggle drop shadows for more minimal stacks.</p>
                    </div>

                    <div>
                        <div class="flex items-center justify-between mb-1">
                            <label class="block text-sm font-medium text-earth-700">Shadow Intensity</label>
                            <span id="shadow-blur-value" class="text-xs text-earth-400 font-semibold">40px</span>
                        </div>
                        <input type="range" id="shadow-blur" min="0" max="100" value="40"
                            class="w-full h-2 bg-linen-200 rounded-lg appearance-none cursor-pointer accent-amethyst-500">
                    </div>

                    <!-- Background -->
                    <div>
                        <div class="flex items-center justify-between">
                            <label class="block text-sm font-medium text-earth-700">Canvas Background</label>
                            <div class="flex items-center gap-2">
                                <span id="bg-toggle-value"
                                    class="text-xs text-earth-400 font-semibold">Transparent</span>
                                <label class="inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="transparent-bg" class="sr-only peer" checked>
                                    <span
                                        class="w-10 h-5 bg-earth-200 peer-checked:bg-amethyst-500 rounded-full transition-colors relative">
                                        <span
                                            class="absolute top-0.5 left-0.5 w-4 h-4 bg-white rounded-full transition-transform peer-checked:translate-x-5"></span>
                                    </span>
                                </label>
                            </div>
                        </div>
                        <div id="bg-color-wrapper" class="mt-3 hidden">
                            <label class="text-xs uppercase tracking-wide text-earth-500 font-semibold mb-1 block">Fill
                                Color</label>
                            <input type="color" id="bg-color" value="#ffffff"
                                class="w-full h-9 cursor-pointer rounded-md border border-earth-300">
                        </div>
                    </div>
                </div>

            </div>
        </aside>

        <!-- Main Preview Area -->
        <main class="flex-1 bg-linen-200 flex items-center justify-center overflow-auto p-8 relative"
            id="canvas-container">
            <div class="text-center text-earth-500" id="placeholder-text">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto mb-4 text-earth-400" fill="none"
                    viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"
                        d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 2H7a2 2 0 00-2 2v15a2 2 0 002 2z" />
                </svg>
                <p class="text-lg font-medium">Upload a PDF to start designing</p>
                <p class="text-sm mt-1">Files are processed locally in your browser.</p>
            </div>
            <canvas id="main-canvas" class="shadow-2xl hidden max-w-full max-h-full"></canvas>
        </main>
    </div>

    <script>
        const DEFAULT_CONFIG = {
            direction: 'ltr',
            pageLimit: 5,
            spacing: 100,
            vStep: 10,
            renderScale: 1.5,
            rotation: -5,
            jitter: 2,
            marginCrop: 0,
            shadowEnabled: true,
            shadowBlur: 40,
            transparentBg: true,
            bgColor: '#ffffff'
        };

        const CONFIG_SCHEMA = {
            direction: { type: 'enum', options: ['ltr', 'rtl', 'ttb', 'btt'] },
            pageLimit: { type: 'int', min: 1, max: 20 },
            spacing: { type: 'int', min: 0, max: 300 },
            vStep: { type: 'int', min: -50, max: 50 },
            renderScale: { type: 'float', min: 0.5, max: 3 },
            rotation: { type: 'int', min: -45, max: 45 },
            jitter: { type: 'int', min: 0, max: 20 },
            marginCrop: { type: 'int', min: 0, max: 30 },
            shadowEnabled: { type: 'bool' },
            shadowBlur: { type: 'int', min: 0, max: 100 },
            transparentBg: { type: 'bool' },
            bgColor: { type: 'color' }
        };

        const STORAGE_KEY = 'pdfStackDesignerConfig';
        let storageErrorLogged = false;
        let historyErrorLogged = false;

        // --- State Management ---
        const state = {
            pdfDoc: null,
            pageImages: [], // Array of { canvas, width, height }
            config: { ...DEFAULT_CONFIG },
            renderToken: 0,
            limitDebounce: null
        };

        // --- DOM Elements ---
        const els = {
            fileInput: document.getElementById('pdf-upload'),
            pdfUrlInput: document.getElementById('pdf-url-input'),
            loadUrlBtn: document.getElementById('load-url-btn'),
            shareBtn: document.getElementById('share-config-btn'),
            canvas: document.getElementById('main-canvas'),
            downloadBtn: document.getElementById('download-btn'),
            status: document.getElementById('status-area'),
            placeholder: document.getElementById('placeholder-text'),
            container: document.getElementById('canvas-container'),

            // Inputs
            inputs: {
                direction: document.getElementById('direction'),
                pageLimit: document.getElementById('page-limit'),
                spacing: document.getElementById('spacing'),
                vStep: document.getElementById('v-step'),
                renderScale: document.getElementById('render-scale'),
                rotation: document.getElementById('rotation'),
                jitter: document.getElementById('jitter'),
                marginCrop: document.getElementById('margin-crop'),
                shadowEnabled: document.getElementById('shadow-toggle'),
                shadowBlur: document.getElementById('shadow-blur'),
                transparentBg: document.getElementById('transparent-bg'),
                bgColor: document.getElementById('bg-color')
            }
        };

        const STATUS_CLASS_MAP = {
            info: 'status-info',
            success: 'status-success',
            error: 'status-error'
        };

        function setStatus(message, tone = 'info', options = {}) {
            if (!els.status) return;
            Object.values(STATUS_CLASS_MAP).forEach((cls) => els.status.classList.remove(cls));
            const className = STATUS_CLASS_MAP[tone] || STATUS_CLASS_MAP.info;
            els.status.classList.add(className);
            els.status.textContent = message;
            if (tone === 'error' && !options.suppressFocus) {
                els.status.focus();
            }
        }

        function updateCanvasBackdrop() {
            if (!els.canvas) return;
            if (state.config.transparentBg) {
                els.canvas.classList.add('canvas-outline');
                els.canvas.style.backgroundColor = 'transparent';
            } else {
                els.canvas.classList.remove('canvas-outline');
                els.canvas.style.backgroundColor = state.config.bgColor || '#ffffff';
            }
        }

        // --- Config Helpers ---
        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        function sanitizeConfigValue(key, value) {
            const schema = CONFIG_SCHEMA[key];
            if (!schema) return null;
            switch (schema.type) {
                case 'enum':
                    return schema.options.includes(value) ? value : null;
                case 'int': {
                    const num = parseInt(value, 10);
                    if (Number.isNaN(num)) return null;
                    return clamp(num, schema.min, schema.max);
                }
                case 'float': {
                    const num = parseFloat(value);
                    if (Number.isNaN(num)) return null;
                    return clamp(num, schema.min, schema.max);
                }
                case 'bool':
                    if (typeof value === 'boolean') return value;
                    if (typeof value === 'number') return value !== 0;
                    if (typeof value === 'string') {
                        const normalized = value.toLowerCase();
                        if (normalized === 'true' || normalized === '1') return true;
                        if (normalized === 'false' || normalized === '0') return false;
                    }
                    return null;
                case 'color':
                    if (typeof value === 'string' && /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(value.trim())) {
                        return value.trim();
                    }
                    return null;
                default:
                    if (typeof value === 'string') return value;
                    return null;
            }
        }

        function applySourceToConfig(target, source) {
            if (!source) return target;
            Object.keys(CONFIG_SCHEMA).forEach((key) => {
                if (source[key] === undefined) return;
                const parsed = sanitizeConfigValue(key, source[key]);
                if (parsed !== null && parsed !== undefined) {
                    target[key] = parsed;
                }
            });
            return target;
        }

        function readStoredConfig() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (raw) {
                    return JSON.parse(raw);
                }
            } catch (err) {
                if (!storageErrorLogged) {
                    console.warn('Unable to read stored config', err);
                    storageErrorLogged = true;
                }
            }
            return null;
        }

        function loadConfigFromPersistence() {
            let config = { ...DEFAULT_CONFIG };
            config = applySourceToConfig(config, readStoredConfig());
            const params = new URLSearchParams(window.location.search);
            const queryValues = {};
            params.forEach((value, key) => {
                if (CONFIG_SCHEMA[key]) {
                    queryValues[key] = value;
                }
            });
            config = applySourceToConfig(config, queryValues);
            return config;
        }

        function persistConfig(skipHistoryUpdate = false) {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state.config));
            } catch (err) {
                if (!storageErrorLogged) {
                    console.warn('Unable to persist config', err);
                    storageErrorLogged = true;
                }
            }
            if (!skipHistoryUpdate) {
                updateUrlQuery();
            }
        }

        function updateUrlQuery() {
            const params = new URLSearchParams();
            Object.keys(CONFIG_SCHEMA).forEach((key) => {
                params.set(key, state.config[key]);
            });
            const hash = window.location.hash || '';
            const newUrl = `${window.location.pathname}?${params.toString()}${hash}`;
            try {
                window.history.replaceState({}, '', newUrl);
            } catch (err) {
                if (!historyErrorLogged) {
                    console.warn('Unable to update URL', err);
                    historyErrorLogged = true;
                }
            }
        }

        function applyConfigToInputs() {
            Object.entries(els.inputs).forEach(([key, input]) => {
                const value = state.config[key];
                if (!input) return;
                if (input.type === 'checkbox') input.checked = Boolean(value);
                else input.value = value;
            });
            document.getElementById('limit-val').innerText = `${state.config.pageLimit}`;
            document.getElementById('margin-crop-value').innerText = `${state.config.marginCrop}%`;
            document.getElementById('shadow-toggle-value').innerText = state.config.shadowEnabled ? 'On' : 'Off';
            document.getElementById('bg-toggle-value').innerText = state.config.transparentBg ? 'Transparent' : 'Solid';
            document.getElementById('bg-color-wrapper').style.display = state.config.transparentBg ? 'none' : 'block';
            const spacingLabel = document.getElementById('spacing-value');
            if (spacingLabel) spacingLabel.innerText = `${state.config.spacing}px`;
            const vStepLabel = document.getElementById('v-step-value');
            if (vStepLabel) vStepLabel.innerText = `${state.config.vStep}px`;
            const scaleLabel = document.getElementById('scale-value');
            if (scaleLabel) scaleLabel.innerText = `${state.config.renderScale.toFixed(1)}x`;
            const rotationLabel = document.getElementById('rotation-value');
            if (rotationLabel) rotationLabel.innerText = `${state.config.rotation}°`;
            const jitterLabel = document.getElementById('jitter-value');
            if (jitterLabel) jitterLabel.innerText = `${state.config.jitter}`;
            const shadowBlurLabel = document.getElementById('shadow-blur-value');
            if (shadowBlurLabel) shadowBlurLabel.innerText = `${state.config.shadowBlur}px`;
            updateCanvasBackdrop();
        }

        async function shareCurrentConfig() {
            updateUrlQuery();
            const shareUrl = window.location.href;
            const successMessage = 'Share link copied to clipboard.';
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                    setStatus(successMessage, 'success');
                    return;
                }
                throw new Error('Clipboard API unavailable');
            } catch (err) {
                console.warn('Clipboard copy failed, using fallback', err);
                const copied = window.prompt('Copy this configuration URL:', shareUrl);
                if (copied !== null) {
                    setStatus(successMessage, 'success');
                } else {
                    setStatus('Copy the URL shown to share this configuration.', 'info');
                }
            }
        }

        // --- Initialization ---
        function init() {
            state.config = loadConfigFromPersistence();
            applyConfigToInputs();
            persistConfig();
            setStatus('Waiting for file...');

            // Attach listeners to all inputs
            Object.entries(els.inputs).forEach(([key, el]) => {
                el.addEventListener('input', (e) => {
                    let newValue;
                    // Update state
                    if (el.type === 'checkbox') newValue = el.checked;
                    else if (key === 'direction' || key === 'bgColor') newValue = el.value;
                    else if (key === 'renderScale') newValue = parseFloat(el.value);
                    else newValue = parseInt(el.value);
                    state.config[key] = newValue;

                    // UI Updates
                    if (key === 'pageLimit') {
                        document.getElementById('limit-val').innerText = `${newValue}`;
                    }
                    if (key === 'transparentBg') {
                        document.getElementById('bg-color-wrapper').style.display = newValue ? 'none' : 'block';
                        document.getElementById('bg-toggle-value').innerText = newValue ? 'Transparent' : 'Solid';
                    }
                    if (key === 'marginCrop') {
                        document.getElementById('margin-crop-value').innerText = `${newValue}%`;
                    }
                    if (key === 'shadowEnabled') {
                        document.getElementById('shadow-toggle-value').innerText = newValue ? 'On' : 'Off';
                    }
                    if (key === 'spacing') {
                        const spacingLabel = document.getElementById('spacing-value');
                        if (spacingLabel) spacingLabel.innerText = `${newValue}px`;
                    }
                    if (key === 'vStep') {
                        const vStepLabel = document.getElementById('v-step-value');
                        if (vStepLabel) vStepLabel.innerText = `${newValue}px`;
                    }
                    if (key === 'renderScale') {
                        const scaleLabel = document.getElementById('scale-value');
                        if (scaleLabel && typeof newValue === 'number') {
                            scaleLabel.innerText = `${newValue.toFixed(1)}x`;
                        }
                    }
                    if (key === 'rotation') {
                        const rotationLabel = document.getElementById('rotation-value');
                        if (rotationLabel) rotationLabel.innerText = `${newValue}°`;
                    }
                    if (key === 'jitter') {
                        const jitterLabel = document.getElementById('jitter-value');
                        if (jitterLabel) jitterLabel.innerText = `${newValue}`;
                    }
                    if (key === 'shadowBlur') {
                        const shadowBlurLabel = document.getElementById('shadow-blur-value');
                        if (shadowBlurLabel) shadowBlurLabel.innerText = `${newValue}px`;
                    }

                    if (key === 'transparentBg' || key === 'bgColor') {
                        updateCanvasBackdrop();
                    }

                    persistConfig();

                    // Redraw if we have images
                    if (state.pageImages.length > 0) {
                        if (key === 'pageLimit') {
                            if (state.limitDebounce) clearTimeout(state.limitDebounce);
                            state.limitDebounce = setTimeout(() => {
                                loadPagesFromDoc();
                            }, 200);
                        } else {
                            drawStack();
                        }
                    }
                });
            });

            els.fileInput.addEventListener('change', handleFileUpload);
            if (els.loadUrlBtn) {
                els.loadUrlBtn.addEventListener('click', (event) => {
                    event.preventDefault();
                    handleUrlLoad();
                });
            }
            if (els.pdfUrlInput) {
                els.pdfUrlInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        handleUrlLoad();
                    }
                });
            }
            els.downloadBtn.addEventListener('click', downloadImage);
            if (els.shareBtn) {
                els.shareBtn.addEventListener('click', (event) => {
                    event.preventDefault();
                    shareCurrentConfig();
                });
            }

            // Window resize listener to adjust canvas display (not content)
            window.addEventListener('resize', () => {
                if (state.pageImages.length > 0) drawStack();
            });
        }

        // --- File Handling ---
        async function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            if (file.type !== 'application/pdf') {
                setStatus('Please upload a valid PDF file.', 'error');
                e.target.value = '';
                return;
            }

            setStatus('Loading PDF...');
            els.placeholder.style.display = 'none';

            try {
                const arrayBuffer = await file.arrayBuffer();
                state.pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                setStatus(`PDF Loaded (${state.pdfDoc.numPages} pages). Rendering...`);
                await loadPagesFromDoc();

                els.downloadBtn.disabled = false;
                els.canvas.classList.remove('hidden');
            } catch (err) {
                console.error(err);
                setStatus(`Error loading PDF: ${err.message}`, 'error');
            }
        }

        async function handleUrlLoad() {
            if (!els.pdfUrlInput) return;
            const rawUrl = els.pdfUrlInput.value.trim();
            if (!rawUrl) {
                setStatus('Please enter a PDF URL to load.', 'error', { suppressFocus: true });
                els.pdfUrlInput.focus();
                return;
            }

            let parsedUrl;
            try {
                parsedUrl = new URL(rawUrl, window.location.href);
            } catch (err) {
                setStatus('Please enter a valid URL.', 'error', { suppressFocus: true });
                els.pdfUrlInput.focus();
                return;
            }

            if (!['http:', 'https:'].includes(parsedUrl.protocol)) {
                setStatus('Only HTTP(S) links are supported.', 'error', { suppressFocus: true });
                els.pdfUrlInput.focus();
                return;
            }

            setStatus('Loading PDF from URL...');
            els.placeholder.style.display = 'none';
            if (els.loadUrlBtn) els.loadUrlBtn.disabled = true;

            try {
                state.pdfDoc = await pdfjsLib.getDocument({ url: parsedUrl.toString(), withCredentials: false }).promise;

                setStatus(`PDF Loaded (${state.pdfDoc.numPages} pages). Rendering...`);
                await loadPagesFromDoc();

                els.downloadBtn.disabled = false;
                els.canvas.classList.remove('hidden');
            } catch (err) {
                console.error(err);
                setStatus(`Error loading PDF from URL: ${err.message}`, 'error');
            } finally {
                if (els.loadUrlBtn) els.loadUrlBtn.disabled = false;
            }
        }

        // --- PDF Rendering (To Offscreen Canvas) ---
        async function loadPagesFromDoc() {
            if (!state.pdfDoc) return;
            const currentToken = ++state.renderToken;

            state.pageImages = [];
            const count = Math.min(state.pdfDoc.numPages, state.config.pageLimit);
            const scale = state.config.renderScale || DEFAULT_CONFIG.renderScale;

            setStatus(`Rendering ${count} page${count === 1 ? '' : 's'}...`);

            for (let i = 1; i <= count; i++) {
                if (currentToken !== state.renderToken) return;
                setStatus(`Rendering page ${i} of ${count}...`);
                const page = await state.pdfDoc.getPage(i);
                const viewport = page.getViewport({ scale: scale });

                // Create offscreen canvas
                const offCanvas = document.createElement('canvas');
                offCanvas.width = viewport.width;
                offCanvas.height = viewport.height;
                const ctx = offCanvas.getContext('2d');

                const renderContext = {
                    canvasContext: ctx,
                    viewport: viewport
                };

                await page.render(renderContext).promise;
                if (currentToken !== state.renderToken) return; // Abort if a new render started

                state.pageImages.push({
                    canvas: offCanvas,
                    width: viewport.width,
                    height: viewport.height,
                    // Pre-calculate random jitter for this page so it stays consistent
                    jitterX: (Math.random() - 0.5) * 2,
                    jitterY: (Math.random() - 0.5) * 2,
                    jitterRot: (Math.random() - 0.5) * 2
                });
            }

            if (currentToken !== state.renderToken) return;
            setStatus('Rendering complete.', 'success');
            drawStack();
        }

        function sampleEdgeColor(canvas, sx, sy, sw, sh) {
            const ctx = canvas.getContext('2d');
            if (!ctx) return 'rgba(255,255,255,1)';
            const sampleW = Math.max(1, Math.min(20, Math.floor(sw)));
            const sampleH = Math.max(1, Math.min(20, Math.floor(sh)));
            const startX = Math.max(0, Math.min(canvas.width - sampleW, Math.round(sx + (sw - sampleW) / 2)));
            const startY = Math.max(0, Math.min(canvas.height - sampleH, Math.round(sy + (sh - sampleH) / 2)));
            try {
                const data = ctx.getImageData(startX, startY, sampleW, sampleH).data;
                let r = 0, g = 0, b = 0, a = 0;
                const pixels = sampleW * sampleH;
                for (let i = 0; i < data.length; i += 4) {
                    r += data[i];
                    g += data[i + 1];
                    b += data[i + 2];
                    a += data[i + 3];
                }
                r = Math.round(r / pixels);
                g = Math.round(g / pixels);
                b = Math.round(b / pixels);
                const alpha = (a / pixels) / 255;
                return `rgba(${r}, ${g}, ${b}, ${alpha || 1})`;
            } catch (err) {
                return 'rgba(255,255,255,1)';
            }
        }

        function getCropMetrics(img, index, config) {
            const direction = config.direction;
            const w = img.width;
            const h = img.height;
            const percent = index === 0 ? 0 : config.marginCrop;
            const fraction = Math.max(0, Math.min(100, percent)) / 100;
            const isVertical = direction === 'ttb' || direction === 'btt';
            const baseAxis = isVertical ? h : w;
            const cropPixelsRaw = baseAxis * fraction;
            const cropPixels = Math.min(baseAxis, Math.round(cropPixelsRaw));
            const hasCrop = cropPixels > 0;

            const metrics = {
                width: w,
                height: h,
                main: {
                    sx: 0,
                    sy: 0,
                    sw: w,
                    sh: h,
                    dx: 0,
                    dy: 0,
                    dw: w,
                    dh: h
                },
                filler: null
            };

            if (!hasCrop) return metrics;

            if (!isVertical) {
                if (direction === 'ltr') {
                    const sw = Math.max(1, w - cropPixels);
                    metrics.main.sw = sw;
                    metrics.main.dw = sw;
                    metrics.main.dx = cropPixels;
                    metrics.filler = {
                        dx: 0,
                        dy: 0,
                        dw: cropPixels,
                        dh: h,
                        orientation: 'horizontal',
                        startColor: sampleEdgeColor(img.canvas, 0, 0, Math.min(4, w - cropPixels), h),
                        endColor: sampleEdgeColor(img.canvas, w - cropPixels, 0, cropPixels, h)
                    };
                } else if (direction === 'rtl') {
                    const sw = Math.max(1, w - cropPixels);
                    metrics.main.sx = cropPixels;
                    metrics.main.sw = sw;
                    metrics.main.dw = sw;
                    metrics.main.dx = 0;
                    metrics.filler = {
                        dx: w - cropPixels,
                        dy: 0,
                        dw: cropPixels,
                        dh: h,
                        orientation: 'horizontal',
                        startColor: sampleEdgeColor(img.canvas, w - Math.min(4, w - cropPixels), 0, Math.min(4, w - cropPixels), h),
                        endColor: sampleEdgeColor(img.canvas, 0, 0, cropPixels, h)
                    };
                }
            } else {
                if (direction === 'ttb') {
                    const sh = Math.max(1, h - cropPixels);
                    metrics.main.sh = sh;
                    metrics.main.dh = sh;
                    metrics.main.dy = cropPixels;
                    metrics.filler = {
                        dx: 0,
                        dy: 0,
                        dw: w,
                        dh: cropPixels,
                        orientation: 'vertical',
                        startColor: sampleEdgeColor(img.canvas, 0, 0, w, Math.min(4, h - cropPixels)),
                        endColor: sampleEdgeColor(img.canvas, 0, h - cropPixels, w, cropPixels)
                    };
                } else if (direction === 'btt') {
                    const sh = Math.max(1, h - cropPixels);
                    metrics.main.sy = cropPixels;
                    metrics.main.sh = sh;
                    metrics.main.dh = sh;
                    metrics.main.dy = 0;
                    metrics.filler = {
                        dx: 0,
                        dy: h - cropPixels,
                        dw: w,
                        dh: cropPixels,
                        orientation: 'vertical',
                        startColor: sampleEdgeColor(img.canvas, 0, h - Math.min(4, h - cropPixels), w, Math.min(4, h - cropPixels)),
                        endColor: sampleEdgeColor(img.canvas, 0, 0, w, cropPixels)
                    };
                }
            }

            return metrics;
        }

        function composePageImage(img, metrics) {
            if (!metrics.filler) return img.canvas;

            const canvas = document.createElement('canvas');
            canvas.width = metrics.width;
            canvas.height = metrics.height;
            const ctx = canvas.getContext('2d');

            // Fill the reconstructed margin with a gradient between existing edge and cropped region
            if (metrics.filler.orientation === 'horizontal') {
                const grad = ctx.createLinearGradient(
                    metrics.filler.dx,
                    metrics.filler.dy,
                    metrics.filler.dx + metrics.filler.dw,
                    metrics.filler.dy
                );
                grad.addColorStop(0, metrics.filler.startColor || 'rgba(255,255,255,1)');
                grad.addColorStop(1, metrics.filler.endColor || 'rgba(255,255,255,1)');
                ctx.fillStyle = grad;
            } else {
                const grad = ctx.createLinearGradient(
                    metrics.filler.dx,
                    metrics.filler.dy,
                    metrics.filler.dx,
                    metrics.filler.dy + metrics.filler.dh
                );
                grad.addColorStop(0, metrics.filler.startColor || 'rgba(255,255,255,1)');
                grad.addColorStop(1, metrics.filler.endColor || 'rgba(255,255,255,1)');
                ctx.fillStyle = grad;
            }
            ctx.fillRect(metrics.filler.dx, metrics.filler.dy, metrics.filler.dw, metrics.filler.dh);

            // Draw main portion
            ctx.drawImage(
                img.canvas,
                metrics.main.sx,
                metrics.main.sy,
                metrics.main.sw,
                metrics.main.sh,
                metrics.main.dx,
                metrics.main.dy,
                metrics.main.dw,
                metrics.main.dh
            );

            return canvas;
        }

        // --- Core Stack Algorithm ---
        function drawStack() {
            if (state.pageImages.length === 0) return;
            updateCanvasBackdrop();

            const ctx = els.canvas.getContext('2d');
            const config = state.config;
            const images = state.pageImages;
            const direction = config.direction;

            // 1. Calculate Canvas Bounds
            // We need to simulate the draw first to find the total width/height needed.
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            const shadowActive = !!config.shadowEnabled;

            // Loop to determine bounding box
            images.forEach((img, index) => {
                const metrics = getCropMetrics(img, index, config);
                const w = metrics.width;
                const h = metrics.height;

                // Position Logic
                let x = 0, y = 0;
                const offset = index * config.spacing;
                const vOffset = index * config.vStep;

                if (direction === 'ltr') x = offset;
                else if (direction === 'rtl') x = -offset;
                else if (direction === 'ttb') { y = offset; x = 0; }
                else if (direction === 'btt') { y = -offset; x = 0; }

                // Add jitter
                x += img.jitterX * config.jitter;
                y += img.jitterY * config.jitter;
                y += vOffset; // add configured vertical step

                // Rotation impacts bounding box. Approximate with a safety margin or use trig
                const pad = (shadowActive ? config.shadowBlur : 0) + 50; // Padding for shadow and rotation

                minX = Math.min(minX, x - pad);
                maxX = Math.max(maxX, x + w + pad);
                minY = Math.min(minY, y - pad);
                maxY = Math.max(maxY, y + h + pad);
            });

            // 2. Resize Canvas
            els.canvas.width = maxX - minX;
            els.canvas.height = maxY - minY;

            // 3. Background
            if (!config.transparentBg) {
                ctx.fillStyle = config.bgColor;
                ctx.fillRect(0, 0, els.canvas.width, els.canvas.height);
            } else {
                ctx.clearRect(0, 0, els.canvas.width, els.canvas.height);
            }

            // 4. Draw Images
            const drawOrder = images.map((img, i) => ({ ...img, originalIndex: i })).reverse();

            drawOrder.forEach((img) => {
                const index = img.originalIndex;
                const metrics = getCropMetrics(img, index, config);
                const pageCanvas = metrics.filler ? composePageImage(img, metrics) : img.canvas;

                ctx.save();

                // Translation
                let x = 0, y = 0;
                const offset = index * config.spacing;
                const vOffset = index * config.vStep;

                if (direction === 'ltr') x = offset;
                else if (direction === 'rtl') x = -offset;
                else if (direction === 'ttb') { y = offset; x = 0; }
                else if (direction === 'btt') { y = -offset; x = 0; }

                // Adjust coordinate system to center the stack in the canvas
                const drawX = x - minX + (img.jitterX * config.jitter);
                const drawY = y - minY + vOffset + (img.jitterY * config.jitter);

                // Move to center of where the page should be to rotate
                const centerX = drawX + metrics.width / 2;
                const centerY = drawY + metrics.height / 2;

                ctx.translate(centerX, centerY);

                // Rotate
                const baseRot = config.rotation * (Math.PI / 180);
                const jitRot = (img.jitterRot * config.jitter) * (Math.PI / 180);
                ctx.rotate(baseRot + jitRot);

                // Shadow
                if (shadowActive) {
                    ctx.shadowColor = "rgba(0, 0, 0, 0.3)";
                    ctx.shadowBlur = config.shadowBlur;
                    ctx.shadowOffsetX = 10;
                    ctx.shadowOffsetY = 10;
                } else {
                    ctx.shadowColor = "transparent";
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }

                // Draw composite page
                ctx.drawImage(
                    pageCanvas,
                    0,
                    0,
                    metrics.width,
                    metrics.height,
                    -metrics.width / 2,
                    -metrics.height / 2,
                    metrics.width,
                    metrics.height
                );

                // Optional border
                ctx.shadowColor = "transparent";
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                ctx.lineWidth = 1;
                ctx.strokeRect(-metrics.width / 2, -metrics.height / 2, metrics.width, metrics.height);

                ctx.restore();
            });
        }

        // --- Download ---
        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'pdf-stack.png';
            link.href = els.canvas.toDataURL('image/png');
            link.click();
        }

        // Start
        init();

    </script>
</body>

</html>