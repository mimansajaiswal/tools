<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Chronicles</title>
    <meta name="theme-color" content="#917FB3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Photo Chronicles">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="./manifest.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="./icons/icon-180.png">

    <!-- Tailwind CSS (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Font: DM Serif Display (Headers) & Inter (Body) -->
    <link
        href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&family=DM+Serif+Display&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">

    <!-- Tailwind Config for Custom Palette -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        oatmeal: '#F3F0E6',
                        'oatmeal-dark': '#E6E2D6',
                        'earth-metal': '#4A4A4A',
                        charcoal: '#2D2D2D',
                        'white-linen': '#FAF9F6',
                        'dull-purple': '#917FB3',
                        'dull-purple-hover': '#7A6A9A',
                        'muted-pink': '#D8A7B1',
                        'muted-pink-dim': '#C696A0'
                    },
                    fontFamily: {
                        serif: ['"DM Serif Display"', 'serif'],
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #F3F0E6;
        }

        ::-webkit-scrollbar-thumb {
            background: #D8A7B1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #917FB3;
        }

        /* Utility */
        .glass-panel {
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        /* Camera Overlay Transition */
        .overlay-ghost {
            transition: opacity 0.3s ease, clip-path 0.3s ease;
            pointer-events: none;
        }

        /* Loader */
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #917FB3;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Toast Animation */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast-enter {
            animation: slideIn 0.3s ease-out forwards;
        }

        .toast-exit {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Grid Lines */
        .grid-line {
            position: absolute;
            pointer-events: none;
        }

        /* First-visit blurb */
        .welcome-blurb {
            font-family: 'Caveat', 'Inter', sans-serif;
            font-style: italic;
            color: #917FB3;
            font-size: 1.15rem;
            line-height: 1.45;
        }
    </style>
</head>

<body
    class="bg-oatmeal text-earth-metal font-sans h-[100dvh] flex flex-col md:flex-row overflow-hidden selection:bg-dull-purple selection:text-white">

    <!-- Toast Container -->
    <div id="toastContainer"
        class="fixed top-4 right-4 z-[100] flex flex-col gap-2 w-full max-w-sm pointer-events-none"></div>

    <!-- Hidden Canvas for Processing (Global) -->
    <canvas id="photoCanvas" class="hidden"></canvas>

    <!-- Sidebar (Desktop) / Bottom Nav (Mobile) -->
    <aside
        class="order-2 md:order-1 w-full md:w-64 h-16 md:h-full flex-shrink-0 flex flex-row md:flex-col border-t md:border-t-0 md:border-r border-oatmeal-dark bg-oatmeal/50 transition-all duration-300 justify-between z-20">

        <!-- Logo Area -->
        <div class="hidden md:flex h-16 px-6 border-b border-oatmeal-dark items-center gap-3 flex-shrink-0">
            <div class="w-8 h-8 rounded-full bg-dull-purple flex items-center justify-center text-white-linen">
                <i data-lucide="history" class="w-5 h-5"></i>
            </div>
            <div class="flex flex-col">
                <h1 class="font-serif text-lg text-charcoal tracking-wide leading-none">Photo Chronicles</h1>
                <span class="text-[9px] uppercase tracking-widest text-earth-metal/60">with Notion</span>
            </div>
        </div>

        <!-- Diary List -->
        <div class="hidden md:flex flex-col flex-1 overflow-hidden">
            <div class="flex-1 overflow-y-auto p-3 space-y-2" id="diaryListContainer">
                <!-- Diaries injected here -->
            </div>
            <!-- Data Safety Notice (Sidebar) -->
            <div
                class="p-4 text-[10px] text-earth-metal/50 leading-tight border-t border-oatmeal-dark/50 bg-oatmeal/30">
                <i data-lucide="info" class="w-3 h-3 inline mb-0.5 mr-1"></i>
                This app stores the last 25 images locally for fast loading. Data is safely synced to Notion.
                <br><br>
                <strong>Note:</strong> Images shown here are compressed thumbnails. For full quality, please check your
                Notion database.
            </div>
        </div>

        <!-- Mobile Nav Items (Only visible on small screens) -->
        <div class="md:hidden flex w-full justify-around items-center px-4">
            <button onclick="App.openModal('settingsModal')" class="p-2 text-earth-metal hover:text-dull-purple">
                <i data-lucide="settings" class="w-6 h-6"></i>
            </button>
            <button onclick="App.initNewEntry()"
                class="p-3 -mt-6 bg-dull-purple text-white rounded-full shadow-lg border-4 border-oatmeal">
                <i data-lucide="plus" class="w-6 h-6"></i>
            </button>
            <button onclick="App.attemptNewDiary()" class="p-2 text-earth-metal hover:text-dull-purple">
                <i data-lucide="book-plus" class="w-6 h-6"></i>
            </button>
        </div>

        <!-- Sidebar Footer (Desktop) -->
        <div class="hidden md:block p-4 border-t border-oatmeal-dark space-y-2 flex-shrink-0">
            <button onclick="App.attemptNewDiary()"
                class="w-full flex items-center justify-start gap-3 p-2 rounded-lg hover:bg-white-linen text-dull-purple transition-colors">
                <i data-lucide="plus-circle" class="w-5 h-5"></i>
                <span class="font-medium">New Diary</span>
            </button>
            <button onclick="App.openModal('settingsModal')"
                class="w-full flex items-center justify-start gap-3 p-2 rounded-lg hover:bg-white-linen text-earth-metal transition-colors">
                <i data-lucide="settings" class="w-5 h-5"></i>
                <span class="font-medium">Settings</span>
            </button>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="order-1 md:order-2 flex-1 flex flex-col min-h-0 relative" id="mainView">

        <!-- Header -->
        <header
            class="h-16 border-b border-oatmeal-dark flex items-center justify-between px-4 md:px-6 bg-oatmeal/80 backdrop-blur-sm z-10 flex-shrink-0">
            <div class="flex items-center gap-3 overflow-hidden">
                <!-- Mobile Diary Switcher Trigger -->
                <button id="mobileDiaryToggleBtn" onclick="App.toggleMobileDiaryMenu(event)"
                    class="md:hidden p-1 rounded hover:bg-white/50 -ml-1 text-earth-metal">
                    <i data-lucide="library" class="w-5 h-5"></i>
                </button>

                <h2 id="activeDiaryTitle" class="font-serif text-xl md:text-2xl text-charcoal truncate">Select a Diary
                </h2>
                <span id="syncStatus"
                    class="hidden flex-shrink-0 text-[10px] px-2 py-1 rounded-full bg-white border border-oatmeal-dark text-earth-metal items-center gap-1">
                    <span class="w-2 h-2 rounded-full bg-gray-400"></span>
                    <span>Init</span>
                </span>
            </div>

            <div class="flex items-center gap-2">
                <button onclick="SyncManager.syncCurrentDiary()" title="Refresh Sync"
                    class="p-2 hover:bg-white-linen rounded-full text-earth-metal transition-colors">
                    <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                </button>
                <!-- Desktop Add Button -->
                <button id="addEntryBtn" onclick="App.initNewEntry()"
                    class="hidden md:flex bg-dull-purple hover:bg-dull-purple-hover text-white-linen px-4 py-2 rounded-lg shadow-sm transition-all items-center gap-2">
                    <i data-lucide="pen-tool" class="w-4 h-4"></i>
                    <span>Add Entry</span>
                </button>
            </div>
        </header>

        <!-- Mobile Diary Menu (Dropdown/Sheet) -->
        <div id="mobileDiaryMenu"
            class="md:hidden hidden absolute top-16 left-0 w-full bg-white-linen shadow-xl border-b border-oatmeal-dark z-20 max-h-[60vh] overflow-y-auto">
            <div class="p-2" id="mobileDiaryList">
                <!-- Diaries injected here -->
            </div>
        </div>

        <!-- Entry Gallery -->
        <div id="entryGallery" class="flex-1 overflow-y-auto p-4 md:p-8 pb-24 md:pb-8">
            <!-- Content injected via JS -->
        </div>

    </main>

    <!-- MODALS -->

    <!-- 1. Settings Modal -->
    <div id="settingsModal"
        class="fixed inset-0 bg-charcoal/20 backdrop-blur-sm hidden items-center justify-center z-50 p-4"
        onclick="if(event.target===this) App.closeModal('settingsModal')">
        <div
            class="bg-white-linen w-full max-w-md p-6 rounded-xl shadow-xl border border-oatmeal-dark relative max-h-full overflow-y-auto">
            <button onclick="App.closeModal('settingsModal')"
                class="absolute top-4 right-4 text-earth-metal/50 hover:text-earth-metal">
                <i data-lucide="x" class="w-5 h-5"></i>
            </button>
            <h3 class="font-serif text-xl mb-4 text-charcoal">Settings</h3>

            <!-- Connection Status Indicator -->
            <div id="connectionStatus" class="mb-6"></div>

            <div class="space-y-6">

                <!-- Database Instructions (Before Proxy) -->
                <div
                    class="bg-dull-purple/5 border border-dull-purple/20 p-3 rounded text-xs text-earth-metal leading-relaxed">
                    <p class="font-bold mb-1">Required Notion Database Format:</p>
                    <p class="text-[11px] mb-2 opacity-80">Columns: Name (title), Tags (multi-select), Date (date),
                        Files (media), Notes (text).</p>
                    <p>
                        Need a template? <a
                            href="https://mimansajaiswal-embedded-dbs.notion.site/photo-chronicles-template?v=2b423941af7b8019977c000c05dd66cf"
                            target="_blank"
                            class="text-dull-purple underline hover:text-dull-purple-hover font-bold">Duplicate this
                            one</a> and add your own tags to start.
                    </p>
                </div>

                <!-- 1. Proxy Settings (Step 1) -->
                <div class="space-y-3 bg-oatmeal/30 p-3 rounded border border-oatmeal-dark/50 relative">
                    <span
                        class="absolute -top-2.5 left-2 bg-white-linen text-[10px] font-bold px-1 text-dull-purple">STEP
                        1: PROXY</span>

                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal">API Proxy
                                Worker URL</label>
                            <button onclick="App.openModal('workerHelpModal')"
                                class="text-dull-purple hover:text-charcoal" title="How to set up Worker">
                                <i data-lucide="info" class="w-4 h-4"></i>
                            </button>
                        </div>
                        <input type="text" id="settingWorkerUrl" placeholder="https://..."
                            oninput="App.onSettingInput()"
                            class="w-full bg-oatmeal border border-oatmeal-dark rounded p-2 text-sm mb-2">
                    </div>
                    <div>
                        <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal mb-1">Proxy
                            Secret (Optional)</label>
                        <input type="password" id="settingProxyToken" placeholder="ALL_CORS_PROXY_MATCH_TOKEN"
                            oninput="App.onSettingInput()"
                            class="w-full bg-oatmeal border border-oatmeal-dark rounded p-2 text-sm mb-2">
                    </div>
                    <button onclick="App.verifyWorker()" id="verifyWorkerBtn"
                        class="w-full bg-dull-purple/10 hover:bg-dull-purple/20 text-dull-purple border border-dull-purple/20 py-2 rounded text-xs font-bold uppercase tracking-wider transition-colors flex items-center justify-center gap-2">
                        Verify Proxy
                    </button>
                </div>

                <!-- 2. Authentication (Step 2) -->
                <div id="authSection"
                    class="bg-oatmeal/50 p-4 rounded-lg border border-oatmeal-dark relative opacity-50 pointer-events-none transition-opacity">
                    <span
                        class="absolute -top-2.5 left-2 bg-white-linen text-[10px] font-bold px-1 text-earth-metal">STEP
                        2: AUTH</span>

                    <div class="flex justify-between items-center mb-2 mt-1">
                        <label
                            class="block text-xs font-bold uppercase tracking-wider text-earth-metal">Authentication</label>
                        <a href="https://developers.notion.com/docs/create-a-notion-integration#create-your-integration-in-notion"
                            target="_blank" class="text-dull-purple hover:text-charcoal" title="How to get a token">
                            <i data-lucide="info" class="w-4 h-4"></i>
                        </a>
                    </div>
                    <div class="flex gap-2 mb-2">
                        <button onclick="App.saveBeforeOAuth()"
                            class="flex-1 bg-charcoal text-white-linen py-2 rounded flex items-center justify-center gap-2 hover:bg-black transition-colors shadow-sm group">
                            <i data-lucide="zap"
                                class="w-4 h-4 text-yellow-400 group-hover:text-yellow-300 transition-colors"></i>
                            <span class="text-sm font-medium">Connect via OAuth</span>
                        </button>
                    </div>
                    <div class="relative flex py-2 items-center">
                        <div class="flex-grow border-t border-oatmeal-dark/50"></div>
                        <span
                            class="flex-shrink-0 mx-2 text-[10px] text-earth-metal/40 font-bold uppercase tracking-widest">OR
                            MANUAL KEY</span>
                        <div class="flex-grow border-t border-oatmeal-dark/50"></div>
                    </div>

                    <!-- Updated Manual Key Input with Verify Button -->
                    <div class="flex gap-2">
                        <input type="password" id="settingAuthToken" placeholder="Paste 'secret_...' token here"
                            oninput="App.onSettingInput()"
                            class="flex-1 bg-white-linen border border-oatmeal-dark rounded p-2 text-xs outline-none text-earth-metal placeholder-earth-metal/30">
                        <button onclick="App.testManualConnection(this)"
                            class="bg-dull-purple/10 text-dull-purple hover:bg-dull-purple hover:text-white text-xs font-medium px-3 rounded transition-colors border border-dull-purple/20">
                            Verify Key
                        </button>
                    </div>
                </div>
            </div>

            <details class="group mt-8 border-t border-oatmeal-dark pt-4">
                <summary
                    class="text-xs font-bold uppercase tracking-wider text-red-800 mb-2 cursor-pointer list-none flex items-center gap-2 outline-none">
                    <span class="flex-1">Danger Zone</span>
                    <i data-lucide="chevron-down"
                        class="w-4 h-4 text-red-800 group-open:rotate-180 transition-transform"></i>
                </summary>
                <div class="pt-2">
                    <button onclick="App.resetApp()"
                        class="w-full border border-red-200 bg-red-50 text-red-600 hover:bg-red-100 py-2 rounded text-xs font-medium flex items-center justify-center gap-2 transition-colors">
                        <i data-lucide="trash" class="w-3 h-3"></i> Reset App & Clear Cache
                    </button>
                </div>
            </details>

            <div class="mt-6 flex justify-end items-center gap-3">
                <button onclick="App.saveSettings()" id="saveSettingsBtn" disabled
                    class="px-4 py-2 rounded bg-dull-purple text-white-linen hover:bg-dull-purple-hover font-medium disabled:opacity-50 disabled:cursor-not-allowed transition-opacity">Save
                    Settings</button>
            </div>
        </div>
    </div>

    <!-- 2. Worker Help Modal -->
    <div id="workerHelpModal"
        class="fixed inset-0 bg-charcoal/20 backdrop-blur-sm hidden items-center justify-center z-[60] p-4"
        onclick="if(event.target===this) App.closeModal('workerHelpModal')">
        <div
            class="bg-white-linen w-full max-w-2xl h-[80vh] p-6 rounded-xl shadow-2xl border border-oatmeal-dark flex flex-col">
            <div class="flex justify-between items-center mb-4 border-b border-oatmeal-dark pb-2">
                <h3 class="font-serif text-xl text-charcoal">Setup Cloudflare Worker</h3>
                <button onclick="App.closeModal('workerHelpModal')" class="text-earth-metal/50 hover:text-earth-metal">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto space-y-4 text-sm text-earth-metal pr-2">
                <p>To bypass Notion's CORS restrictions, you need a small proxy. We use Cloudflare Workers (Free).</p>
                <ol class="list-decimal pl-5 space-y-2">
                    <li>Go to <a href="https://workers.cloudflare.com/" target="_blank"
                            class="text-dull-purple underline">Cloudflare Workers</a> and create a new Worker.</li>
                    <li>Copy the code below and paste it into the Worker editor (replace default code).</li>
                    <li>Save and Deploy.</li>
                    <li>(Optional) In Worker Settings > Variables, add <code>ALL_CORS_PROXY_MATCH_TOKEN</code> with a
                        secret password.</li>
                    <li>Copy your Worker's URL (e.g., <code>https://my-proxy.user.workers.dev</code>) and paste it into
                        the app settings.</li>
                </ol>
                <div class="relative">
                    <button onclick="App.copyWorkerCode(this)"
                        class="absolute top-2 right-2 bg-white/80 hover:bg-white px-2 py-1 rounded text-xs shadow text-charcoal font-bold">Copy
                        Code</button>
                    <pre id="workerCodeBlock"
                        class="bg-charcoal text-white-linen p-4 rounded text-xs font-mono overflow-x-auto">
const NOTION_API_END_POINT = "https://api.notion.com/v1";

export default {
  async fetch(request, env) {
    return await handleRequest(request, env);
  }
};

function getCorsHeaders(request) {
  return {
    "Access-Control-Allow-Origin": request.headers.get("Origin") || "*",
    "Access-Control-Allow-Methods": "GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization, Notion-Version",
  };
}

function handleOptions(request) {
  return new Response(null, {
    headers: getCorsHeaders(request),
  });
}

async function handleRequest(request, env) {
  if (request.method === "OPTIONS") {
    return handleOptions(request);
  }

  const url = new URL(request.url);
  const requiredToken = (env.ALL_CORS_PROXY_MATCH_TOKEN || "").trim();

  if (requiredToken !== "") {
    const providedToken = url.searchParams.get("token");
    if (providedToken !== requiredToken) {
      return new Response("Unauthorized", { status: 403 });
    }
    url.searchParams.delete("token");
  }

  const isGeneral = url.searchParams.has("url");
  let targetUrl;
  let secretKey = null;

  if (isGeneral) {
    targetUrl = url.searchParams.get("url");
    url.searchParams.delete("url");
    try {
      targetUrl = new URL(targetUrl).toString();
    } catch (err) {
      return new Response("Invalid target URL", { status: 400 });
    }
  } else {
    secretKey = url.searchParams.get("secret");
    if (!secretKey) {
      return new Response("Missing secret key parameter", { status: 400 });
    }
    url.searchParams.delete("secret");

    let normalizedPath = url.pathname.replace(/\/{2,}/g, '/');
    const base = NOTION_API_END_POINT.replace(/\/$/, "");
    const path = normalizedPath.startsWith("/") ? normalizedPath : "/" + normalizedPath;
    targetUrl = base + path + url.search;
  }

  const modifiedRequest = new Request(targetUrl, request);
  modifiedRequest.headers.set("Origin", new URL(targetUrl).origin);

  if (!isGeneral && secretKey) {
    modifiedRequest.headers.set("Authorization", `Bearer ${secretKey}`);
    modifiedRequest.headers.set("Notion-Version", "2022-06-28");
  }

  const response = await fetch(modifiedRequest);
  const newResponse = new Response(response.body, response);
  newResponse.headers.set("Access-Control-Allow-Origin", request.headers.get("Origin") || "*");
  newResponse.headers.append("Vary", "Origin");

  return newResponse;
}
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- 3. New Diary Modal (Revamped) -->
    <div id="newDiaryModal"
        class="fixed inset-0 bg-charcoal/20 backdrop-blur-sm hidden items-center justify-center z-50 p-4"
        onclick="if(event.target===this) App.closeModal('newDiaryModal')">
        <div
            class="bg-white-linen w-full max-w-md p-6 rounded-xl shadow-xl border border-oatmeal-dark overflow-visible flex flex-col h-[500px]">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="font-serif text-xl text-charcoal">New Diary</h3>
                <button onclick="App.scanForDatabases()"
                    class="text-xs text-dull-purple hover:underline flex items-center gap-1" id="refreshDbBtn">
                    <i data-lucide="refresh-cw" class="w-3 h-3"></i> Refresh
                </button>
            </div>

            <div class="space-y-4 flex-1 overflow-y-auto pr-1">

                <!-- Searchable Dropdown -->
                <div class="relative">
                    <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal mb-1">Select Notion
                        Database</label>

                    <!-- Info Text Moved Here -->
                    <div class="text-[10px] text-earth-metal/60 mb-3 leading-tight">
                        Only showing datasources with required columns: Name (title), Date (date), Tags (multi-select),
                        Notes (text), Files (media).
                    </div>

                    <div class="relative">
                        <input type="text" id="dbSearchInput" placeholder="Search Databases..."
                            onfocus="App.toggleDbDropdown(true)" onkeyup="App.filterDbList(event)"
                            class="w-full bg-oatmeal border border-oatmeal-dark rounded p-2 text-sm focus:ring-2 focus:ring-dull-purple/50 outline-none"
                            autocomplete="off">
                        <i data-lucide="chevron-down"
                            class="absolute right-3 top-3 w-4 h-4 text-earth-metal/50 pointer-events-none"></i>
                    </div>

                    <!-- Dropdown List -->
                    <div id="dbDropdownList"
                        class="hidden absolute top-full left-0 w-full mt-1 bg-white shadow-xl rounded-lg border border-oatmeal-dark max-h-60 overflow-y-auto z-50">
                        <!-- Items injected here -->
                        <div class="p-4 text-center text-xs text-earth-metal/50">Type to search...</div>
                    </div>
                </div>

                <!-- Selected DB Info -->
                <div id="selectedDbInfo" class="hidden bg-dull-purple/5 p-3 rounded border border-dull-purple/20 mt-4">
                    <div class="text-xs font-bold text-dull-purple uppercase tracking-wider mb-1">Selected</div>
                    <div class="font-serif text-lg text-charcoal" id="previewDbTitle"></div>
                    <div class="text-xs text-earth-metal/70 mt-1 line-clamp-2" id="previewDbDesc"></div>
                </div>
            </div>

            <div class="mt-6 flex justify-end gap-3 flex-shrink-0 pt-4 border-t border-oatmeal-dark">
                <button onclick="App.closeModal('newDiaryModal')"
                    class="px-4 py-2 rounded text-earth-metal hover:bg-oatmeal">Cancel</button>
                <button onclick="App.createDiary()"
                    class="px-4 py-2 rounded bg-dull-purple text-white-linen hover:bg-dull-purple-hover">Create
                    Diary</button>
            </div>
        </div>
    </div>

    <!-- 4. Delete Confirmation Modal -->
    <div id="deleteModal"
        class="fixed inset-0 bg-charcoal/20 backdrop-blur-sm hidden items-center justify-center z-[70] p-4"
        onclick="if(event.target===this) App.closeModal('deleteModal')">
        <div class="bg-white-linen w-full max-w-sm p-6 rounded-xl shadow-xl border border-oatmeal-dark">
            <h3 class="font-serif text-lg text-charcoal mb-2">Delete Entry?</h3>
            <p class="text-sm text-earth-metal/80 mb-6">This will remove the entry from your <b>local storage</b> AND
                <b>Notion</b>. This action cannot be undone.
            </p>
            <div class="flex justify-end gap-3">
                <button onclick="App.closeModal('deleteModal')"
                    class="px-4 py-2 rounded text-earth-metal hover:bg-oatmeal text-sm">Cancel</button>
                <button onclick="App.executeDelete()"
                    class="px-4 py-2 rounded bg-red-500 text-white hover:bg-red-600 text-sm font-medium">Delete
                    Everywhere</button>
            </div>
        </div>
    </div>

    <!-- 6. Reset Confirmation Modal (New) -->
    <div id="resetConfirmationModal"
        class="fixed inset-0 bg-charcoal/20 backdrop-blur-sm hidden items-center justify-center z-[80] p-4"
        onclick="if(event.target===this) App.closeModal('resetConfirmationModal')">
        <div class="bg-white-linen w-full max-w-sm p-6 rounded-xl shadow-xl border border-red-200">
            <div class="flex items-center gap-3 mb-2 text-red-700">
                <i data-lucide="alert-triangle" class="w-6 h-6"></i>
                <h3 class="font-serif text-lg">Reset App?</h3>
            </div>
            <p class="text-sm text-earth-metal/80 mb-6 leading-relaxed">
                This will <b>disconnect Notion</b> and <b>delete all local settings & cache</b>.
                <br><br>
                Your data stored in Notion will stay safe, but you will need to reconnect to see it again.
            </p>
            <div class="flex justify-end gap-3">
                <button onclick="App.closeModal('resetConfirmationModal')"
                    class="px-4 py-2 rounded text-earth-metal hover:bg-oatmeal text-sm">Cancel</button>
                <button onclick="App.executeReset()"
                    class="px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700 text-sm font-medium shadow-md hover:shadow-lg transition-all">Yes,
                    Reset Everything</button>
            </div>
        </div>
    </div>

    <!-- 5. Entry Modal (Live Composite Layout) -->
    <div id="entryModal" class="fixed inset-0 bg-white-linen z-50 hidden flex-col overflow-hidden">

        <!-- Close Button -->
        <button onclick="App.closeModal('entryModal')"
            class="absolute top-4 left-4 z-50 bg-black/50 text-white p-2 rounded-full backdrop-blur-sm hover:bg-black/70 transition">
            <i data-lucide="x" class="w-6 h-6"></i>
        </button>

        <!-- Top Section: Camera Viewfinder (Canvas-based) -->
        <div id="cameraSection"
            class="relative w-full h-[40%] md:h-[50%] max-h-[600px] bg-zinc-100 flex-shrink-0 flex items-center justify-center overflow-hidden group">

            <!-- Hidden Video Source -->
            <video id="videoSource" autoplay playsinline class="hidden"></video>

            <!-- The Viewfinder Canvas (Live Composite) -->
            <canvas id="viewfinder" class="w-full h-full object-contain z-10"></canvas>

            <!-- Ghost Overlay (Restored as img) -->
            <img id="ghostOverlay"
                class="absolute inset-0 w-full h-full object-contain z-30 pointer-events-none transition-opacity duration-200 opacity-0">

            <!-- Camera Controls -->
            <div id="camControls"
                class="absolute bottom-4 left-0 right-0 z-40 flex flex-col items-center gap-3 transition-opacity duration-200">

                <!-- Segment Indicator (If collage mode > 1) -->
                <div id="segmentIndicator"
                    class="text-charcoal/70 bg-white/80 px-2 py-1 rounded text-[10px] font-mono uppercase tracking-widest hidden shadow-sm">
                    Segment <span id="segCurrent">1</span>/<span id="segTotal">1</span>
                </div>

                <!-- Main Controls Row -->
                <div class="flex items-center justify-center gap-4 md:gap-6">

                    <!-- 1. Mirror Toggle (If user facing) -->
                    <button id="mirrorToggleBtn" onclick="App.toggleMirror()"
                        class="hidden bg-black/40 backdrop-blur-md p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="flip-horizontal" class="w-6 h-6"></i>
                    </button>

                    <!-- 2. Flip Camera Button -->
                    <button onclick="App.flipCamera()"
                        class="bg-black/40 backdrop-blur-md p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="refresh-ccw" class="w-6 h-6"></i>
                    </button>

                    <!-- 3. Insert Image (File Input) -->
                    <label
                        class="cursor-pointer bg-black/40 backdrop-blur-md p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="image" class="w-6 h-6"></i>
                        <input type="file" id="fileInput" accept="image/*" class="hidden"
                            onchange="App.handleFileUpload(event)">
                    </label>

                    <!-- 4. Capture Button (Center) -->
                    <button onclick="App.captureSegment()" id="captureBtn"
                        class="w-16 h-16 rounded-full border-4 border-white/80 bg-charcoal/60 shadow-[0_0_12px_rgba(0,0,0,0.5)] flex items-center justify-center hover:bg-black/70 transition active:scale-95 backdrop-blur-sm">
                        <div class="w-12 h-12 bg-white rounded-full shadow-inner"></div>
                    </button>

                    <!-- 5. Layout Button (Grid Mode) -->
                    <div class="relative group">
                        <button onclick="App.toggleCollageMenu()" id="gridBtn"
                            class="bg-black/40 backdrop-blur-md p-3 rounded-full hover:bg-black/60 text-white transition font-bold text-xs flex items-center justify-center w-12 h-12">
                            1x
                        </button>

                        <!-- Vertical Popup for Grid Selection -->
                        <div id="collageMenu"
                            class="hidden absolute bottom-full left-1/2 -translate-x-1/2 mb-2 bg-black/80 backdrop-blur-md rounded-xl flex-col p-2 gap-2 transition-all shadow-lg w-auto items-center z-50">

                            <!-- 1x -->
                            <button onclick="App.setCollageMode(1)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">1x</button>

                            <!-- 2x Row -->
                            <div class="flex gap-2">
                                <button onclick="App.setCollageMode(2)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">2x
                                    &rarr;</button>
                                <button onclick="App.setCollageMode(5)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">2x
                                    &darr;</button>
                            </div>

                            <!-- 3x Row -->
                            <div class="flex gap-2">
                                <button onclick="App.setCollageMode(3)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">3x
                                    &rarr;</button>
                                <button onclick="App.setCollageMode(6)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">3x
                                    &darr;</button>
                                <button onclick="App.setCollageMode(7)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">3x
                                    1/2</button>
                            </div>

                            <!-- 4x -->
                            <button onclick="App.setCollageMode(4)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">4x</button>
                        </div>
                    </div>

                    <!-- 6. Portrait/Landscape Toggle -->
                    <button onclick="App.toggleOrientation()" id="orientationBtn"
                        class="bg-black/40 backdrop-blur-md p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="rectangle-horizontal" class="w-6 h-6"></i>
                    </button>

                    <!-- 7. Ghost Button -->
                    <div class="relative flex items-center">
                        <button onclick="App.toggleGhost()" id="ghostToggleBtn"
                            class="bg-black/40 backdrop-blur-md p-3 rounded-full hover:bg-black/60 text-white transition opacity-50 peer">
                            <i data-lucide="ghost" class="w-6 h-6"></i>
                        </button>
                        <!-- Slider ABOVE - Fixed width & Position -->
                        <div id="ghostSliderContainer"
                            class="hidden absolute bottom-full mb-4 -right-1 bg-black/60 p-2 rounded flex-col items-center">
                            <input type="range" min="0" max="1" step="0.1" value="0.3"
                                class="w-16 h-1 bg-white/50 rounded-lg appearance-none cursor-pointer"
                                oninput="App.setGhostOpacity(this.value)">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Section: Form (Scrollable) -->
        <div id="formSection" class="flex-1 bg-white-linen p-6 md:p-8 overflow-y-auto w-full md:max-w-2xl md:mx-auto">
            <div class="space-y-5 pb-20">

                <!-- Taken Photo Preview & Retake UI (Hidden by default) -->
                <div id="takenPhotoUI" class="hidden flex-col gap-3 mb-4">
                    <div class="w-full h-64 bg-oatmeal rounded-lg overflow-hidden relative shadow-sm group cursor-pointer"
                        onclick="App.handleCollageClick(event)">
                        <img id="smallPreview" class="w-full h-full object-contain">
                        <!-- Hint overlay -->
                        <div
                            class="absolute inset-0 bg-black/20 opacity-0 group-hover:opacity-100 transition flex items-center justify-center text-white text-xs font-bold pointer-events-none">
                            Click segment to retake
                        </div>
                    </div>
                    <div class="flex justify-center gap-2">
                        <button onclick="App.retakeAll()"
                            class="text-xs bg-charcoal text-white px-4 py-2 rounded-full hover:bg-black flex items-center gap-2 transition">
                            <i data-lucide="refresh-cw" class="w-3 h-3"></i> Retake All
                        </button>
                    </div>
                </div>

                <!-- Title -->
                <div>
                    <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal mb-1">Title</label>
                    <input type="text" id="entryTitle"
                        class="w-full bg-oatmeal border-none rounded-lg p-3 focus:ring-2 focus:ring-dull-purple/50 outline-none text-lg font-serif"
                        placeholder="Untitled Entry">
                </div>

                <!-- Date -->
                <div>
                    <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal mb-1">Date</label>
                    <input type="datetime-local" id="entryDate"
                        class="w-full bg-oatmeal border-none rounded-lg p-3 focus:ring-2 focus:ring-dull-purple/50 outline-none text-sm text-charcoal">
                </div>

                <!-- Notes -->
                <div>
                    <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal mb-1">Notes</label>
                    <textarea id="entryNotes"
                        class="w-full bg-oatmeal border-none rounded-lg p-4 h-32 focus:ring-2 focus:ring-dull-purple/50 outline-none resize-none placeholder-earth-metal/30 leading-relaxed"
                        placeholder="What did you see today?"></textarea>
                </div>

                <!-- Tags -->
                <div>
                    <div class="flex justify-between items-center mb-1">
                        <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal">Tags</label>
                        <button onclick="SyncManager.fetchTags(false)"
                            class="text-[10px] text-dull-purple hover:underline flex items-center gap-1">
                            <i data-lucide="refresh-ccw" class="w-3 h-3"></i> Refresh
                        </button>
                    </div>
                    <div class="flex flex-wrap gap-2 mb-2" id="activeTags"></div>
                    <div class="relative">
                        <input type="text" id="tagInput" placeholder="Add a tag..."
                            class="w-full bg-oatmeal border-none rounded-lg p-3 focus:ring-2 focus:ring-dull-purple/50 outline-none"
                            onkeyup="App.handleTagInput(event)" onfocus="App.handleTagInput(event)">
                        <div id="tagSuggestions"
                            class="absolute top-full left-0 w-full bg-white shadow-lg rounded mt-1 z-10 hidden max-h-32 overflow-y-auto border border-oatmeal-dark">
                        </div>
                    </div>
                </div>

                <!-- Save Button -->
                <div class="pt-4 flex justify-end">
                    <button onclick="App.saveEntry()" id="saveEntryBtn" disabled
                        class="bg-charcoal hover:bg-black disabled:opacity-50 disabled:cursor-not-allowed text-white-linen px-8 py-3 rounded-xl transition-all shadow-md flex items-center justify-center gap-2 text-base font-medium">
                        <span>Save Entry</span>
                        <i data-lucide="arrow-right" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- JAVASCRIPT LOGIC -->
    <script>
        const PWA_CACHE_PREFIX = 'photo-chronicles-cache';

        const registerServiceWorker = () => {
            if (!('serviceWorker' in navigator)) return;
            navigator.serviceWorker.register('./service-worker.js')
                .then((registration) => {
                    console.log('Service worker registered with scope:', registration.scope);
                })
                .catch((err) => console.error('Service worker registration failed:', err));
        };

        const clearPwaData = async () => {
            try {
                if ('caches' in window) {
                    const keys = await caches.keys();
                    await Promise.all(keys.filter((key) => key.startsWith(PWA_CACHE_PREFIX)).map((key) => caches.delete(key)));
                }
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    await Promise.all(registrations.map((reg) => reg.unregister()));
                }
            } catch (err) {
                console.warn('PWA cleanup skipped:', err);
            }
        };

        const UTILS = {
            id: () => Math.random().toString(36).substr(2, 9),
            now: () => new Date().toISOString(),
            localToUTC: (localDateTimeString) => {
                if (!localDateTimeString) return new Date().toISOString();
                const d = new Date(localDateTimeString);
                return d.toISOString();
            },
            toLocalISO: (date) => {
                const offset = date.getTimezoneOffset() * 60000;
                return new Date(date.getTime() - offset).toISOString().slice(0, 16);
            },
            formatDate: (iso) => new Date(iso).toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }),
            toBase64: (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            }),
            dataURLtoBlob: (dataurl) => {
                var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
                    bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
                while (n--) { u8arr[n] = bstr.charCodeAt(n); }
                return new Blob([u8arr], { type: mime });
            },
            // Create a local thumbnail version (350px, 0.6 quality, webp)
            processImage: (imageSource, width = 350, quality = 0.6) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous"; // Try to handle CORS
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const scale = width / img.width;
                        canvas.width = width;
                        canvas.height = img.height * scale;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        try {
                            const dataUrl = canvas.toDataURL('image/webp', quality);
                            resolve(dataUrl);
                        } catch (e) {
                            reject(e);
                        }
                    };
                    img.onerror = (e) => reject(e);
                    img.src = imageSource;
                });
            },
            // High Quality Compression < 5MB
            compressToLimit: async (dataUrl, maxBytes = 5 * 1024 * 1024) => {
                let quality = 0.95;
                let result = dataUrl;

                // Helper size check
                const getSize = (url) => (url.length * 3 / 4) - (url.indexOf(',') > -1 ? url.indexOf(',') : 0); // rough approx

                if (getSize(result) < maxBytes) return result;

                // If too big, try creating blob/canvas loop
                // Simplified: Just return a reasonable high quality webp immediately as webp is usually efficient
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        // Try 0.8 webp immediately if original passed was too big or raw
                        const newUrl = canvas.toDataURL('image/webp', 0.85);
                        resolve(newUrl);
                    };
                    img.src = dataUrl;
                });
            }
        };

        const Storage = {
            getSettings: () => JSON.parse(localStorage.getItem('mirror_settings') || '{"workerUrl":"","authToken":"","proxyToken":"","orientation":"landscape","collageMode":1,"ghostOpacity":0.3}'),
            setSettings: (s) => localStorage.setItem('mirror_settings', JSON.stringify(s)),
            getData: () => JSON.parse(localStorage.getItem('mirror_data') || '[]'),
            setData: (d) => localStorage.setItem('mirror_data', JSON.stringify(d)),

            // New: Cache for valid Notion Databases
            getCachedDatabases: () => JSON.parse(localStorage.getItem('notion_db_cache') || '[]'),
            setCachedDatabases: (dbs) => localStorage.setItem('notion_db_cache', JSON.stringify(dbs)),

            saveDiary: (diary) => {
                const data = Storage.getData();
                data.push(diary);
                Storage.setData(data);
            },
            deleteEntry: (diaryId, entryId) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.entries = diary.entries.filter(e => e.id !== entryId);
                    Storage.setData(data);
                }
            },
            saveEntry: (diaryId, entry) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.entries.unshift(entry);
                    const unique = [];
                    const map = new Map();
                    for (const item of diary.entries) {
                        if (!map.has(item.id)) {
                            map.set(item.id, true);
                            unique.push(item);
                        }
                    }
                    // Limit to 25 entries to save local storage space
                    diary.entries = unique.slice(0, 25);
                    entry.tags.forEach(t => {
                        if (!diary.tags.includes(t)) diary.tags.push(t);
                    });
                    Storage.setData(data);
                }
            },
            updateEntrySyncStatus: (diaryId, entryId, status, notionId = null) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                const entry = diary?.entries.find(e => e.id === entryId);
                if (entry) {
                    entry.synced = status;
                    if (notionId) entry.notionId = notionId;
                    Storage.setData(data);
                }
            },
            updateDiaryTags: (diaryId, newTags) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    const merged = [...new Set([...diary.tags, ...newTags])];
                    diary.tags = merged;
                    Storage.setData(data);
                }
            },
            setLastFetch: (diaryId, timeStr) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.lastFetch = timeStr;
                    Storage.setData(data);
                }
            }
        };

        const API = {
            request: async (method, notionEndpoint, body = null, overrideSettings = null) => {
                const { workerUrl, authToken, proxyToken } = overrideSettings || Storage.getSettings();
                if (!workerUrl || !authToken) throw new Error("Missing Settings");

                const cleanWorkerUrl = workerUrl.trim().replace(/\/$/, '');
                const cleanToken = proxyToken ? proxyToken.trim() : null;
                const cleanAuth = authToken.trim();
                const target = `https://api.notion.com/v1${notionEndpoint}`;

                const fetchUrl = new URL(cleanWorkerUrl);
                fetchUrl.searchParams.append('url', target);
                if (cleanToken) fetchUrl.searchParams.append('token', cleanToken);

                const headers = { 'Authorization': `Bearer ${cleanAuth}`, 'Notion-Version': '2022-06-28' };
                if (!(body instanceof FormData)) {
                    headers['Content-Type'] = 'application/json';
                    body = body ? JSON.stringify(body) : null;
                }

                try {
                    const res = await fetch(fetchUrl.toString(), { method, headers, body });
                    if (!res.ok) {
                        const txt = await res.text();
                        let errorMsg = `API Error ${res.status}`;
                        try {
                            const json = JSON.parse(txt);
                            if (json.message) errorMsg = json.message;
                            else if (json.error && json.error.message) errorMsg = json.error.message;
                        } catch (e) {
                            if (txt && txt.length < 100) errorMsg += `: ${txt}`;
                        }
                        throw new Error(errorMsg);
                    }
                    return await res.json();
                } catch (e) {
                    if (e.name === 'TypeError' && e.message.includes('Failed to fetch')) {
                        throw new Error("CORS Error: Please check your Worker allowed headers.");
                    }
                    throw e;
                }
            },
            uploadFileContent: async (uploadUrl, fileBlob) => {
                const { workerUrl, authToken, proxyToken } = Storage.getSettings();
                const cleanWorkerUrl = workerUrl.trim().replace(/\/$/, '');
                const fetchUrl = new URL(cleanWorkerUrl);
                fetchUrl.searchParams.append('url', uploadUrl);
                if (proxyToken) fetchUrl.searchParams.append('token', proxyToken);

                const formData = new FormData();
                formData.append("file", fileBlob, "photo.jpg");
                const headers = { 'Authorization': `Bearer ${authToken}`, 'Notion-Version': '2025-09-03' };

                const res = await fetch(fetchUrl.toString(), { method: 'POST', headers, body: formData });
                if (!res.ok) throw new Error(`Upload Failed`);
                return await res.json();
            },
            fetchDatabases: async (settings = null) => {
                let results = [];
                let hasMore = true;
                let nextCursor = undefined;
                while (hasMore) {
                    const payload = {
                        filter: { value: 'database', property: 'object' },
                        page_size: 100,
                        start_cursor: nextCursor
                    };
                    const res = await API.request('POST', '/search', payload, settings);
                    results = [...results, ...res.results];
                    hasMore = res.has_more;
                    nextCursor = res.next_cursor;
                    if (results.length > 300) hasMore = false;
                }
                return results;
            }
        };

        const SyncManager = {
            statusEl: null,
            init: () => {
                SyncManager.statusEl = document.getElementById('syncStatus');
                window.addEventListener('online', SyncManager.syncCurrentDiary);
                if (App.state.activeDiaryId) SyncManager.syncCurrentDiary();
            },
            updateUI: (status) => {
                if (!SyncManager.statusEl) return;
                SyncManager.statusEl.classList.remove('hidden', 'flex');
                const textSpan = SyncManager.statusEl.querySelector('span:last-child');
                const dot = SyncManager.statusEl.querySelector('span:first-child');

                if (status === 'syncing') {
                    dot.className = "loader w-2 h-2 border-earth-metal";
                    textSpan.innerText = "Syncing...";
                } else if (status === 'offline') {
                    dot.className = "w-2 h-2 rounded-full bg-red-400";
                    textSpan.innerText = "Offline";
                } else if (status === 'synced') {
                    dot.className = "w-2 h-2 rounded-full bg-green-400";
                    textSpan.innerText = "Synced";
                    setTimeout(() => SyncManager.statusEl.classList.add('hidden'), 3000);
                } else {
                    dot.className = "w-2 h-2 rounded-full bg-red-600";
                    textSpan.innerText = "Error";
                }
            },

            fetchTags: async (silent = false) => {
                const diaryId = App.state.activeDiaryId;
                if (!diaryId) return;
                const diary = Storage.getData().find(d => d.id === diaryId);

                try {
                    if (!silent) App.showToast("Fetching tags...", "info");
                    const res = await API.request('GET', `/databases/${diary.originalDbId || diary.notionDataSourceId}`);
                    const properties = res.properties || {};

                    if (properties["Tags"] && properties["Tags"].multi_select) {
                        const options = properties["Tags"].multi_select.options.map(o => o.name);
                        Storage.updateDiaryTags(diaryId, options);
                        App.state.diaries = Storage.getData();
                        if (!silent) App.showToast(`Updated ${options.length} tags.`, "success");
                    }
                } catch (e) {
                    console.error("Tag fetch failed", e);
                    if (!silent) App.showToast("Could not fetch tags schema.", "error");
                }
            },

            syncCurrentDiary: async () => {
                if (!navigator.onLine) { SyncManager.updateUI('offline'); return; }
                const diaryId = App.state.activeDiaryId;
                if (!diaryId) return;

                let diary = Storage.getData().find(d => d.id === diaryId);
                if (!diary || !diary.originalDbId) return;

                SyncManager.updateUI('syncing');
                App.state.isLoading = true;
                App.renderDiaryView();

                try {
                    // 1. PUSH
                    const unsynced = diary.entries.filter(e => !e.synced);
                    for (const entry of unsynced) {
                        try {
                            // Ensure we push the high res if we have it, or the current local one
                            // Note: In saveEntry we now save LOW res to disk, but we should attempt to keep High Res in memory if possible?
                            // Actually, simplistic approach: if unsynced, just push what we have. 
                            // If user refreshed page, high res is gone, but local low res is better than nothing.
                            // Ideally app stays open.
                            const notionId = await SyncManager.pushEntryToNotion(diary.originalDbId, entry);
                            Storage.updateEntrySyncStatus(diaryId, entry.id, true, notionId);
                            App.state.diaries = Storage.getData();
                        } catch (err) {
                            console.error("Failed to push entry", entry, err);
                            App.showToast(`Sync failed for entry "${entry.title}".`, "error");
                        }
                    }

                    // 2. PULL (Updated to Limit 25 & Process Images)
                    const fetchLimit = 25; // Reduced as requested
                    let payload = {
                        page_size: fetchLimit,
                        sorts: [{ property: 'Date', direction: 'descending' }]
                    };

                    const response = await API.request('POST', `/databases/${diary.originalDbId}/query`, payload);

                    const currentData = Storage.getData();
                    const activeDiary = currentData.find(d => d.id === diaryId);

                    // We need to iterate and potentially fetch images
                    // Using for...of loop to handle async image processing sequentially/parallel-ish

                    for (const page of response.results) {
                        const localIndex = activeDiary.entries.findIndex(e => e.notionId === page.id);

                        const props = page.properties;
                        const getDate = (p) => p?.date?.start || UTILS.now();
                        const getTags = (p) => p?.multi_select?.map(x => x.name) || [];
                        const notesContent = props.Notes?.rich_text?.[0]?.plain_text || "";
                        const titleContent = props.Name?.title?.[0]?.plain_text || "(No Title)";

                        let notionPhotoUrl = null;
                        if (props.Files?.files?.length > 0) {
                            const f = props.Files.files[0];
                            notionPhotoUrl = f.file?.url || f.external?.url;
                        }

                        // Check if we need to download the image
                        let localPhotoData = null;
                        const existingEntry = localIndex > -1 ? activeDiary.entries[localIndex] : null;

                        // If we have a local entry with a dataURL, keep it unless forced update (logic simplified here: keep local if exists)
                        if (existingEntry && existingEntry.photoDataURL && existingEntry.photoDataURL.startsWith('data:')) {
                            localPhotoData = existingEntry.photoDataURL;
                        }

                        // If no local photo but notion has one, fetch and compress it
                        if (!localPhotoData && notionPhotoUrl) {
                            try {
                                // Using the worker proxy to fetch image if needed to avoid strict CORS on signed URLs, 
                                // but usually signed S3 URLs are okay if origin is handled. 
                                // We'll try direct first, if that fails, we can't easily use the proxy for binary without encoding tweaks.
                                // Let's try UTILS.processImage directly on the URL.
                                localPhotoData = await UTILS.processImage(notionPhotoUrl, 350, 0.6);
                            } catch (err) {
                                console.warn("Failed to download/process image from Notion", err);
                                // Fallback: store the URL (will expire, but better than null)
                                localPhotoData = notionPhotoUrl;
                            }
                        }

                        const syncedEntry = {
                            id: existingEntry ? existingEntry.id : UTILS.id(),
                            notionId: page.id,
                            date: getDate(props.Date),
                            title: titleContent,
                            notes: notesContent,
                            tags: getTags(props.Tags),
                            photoDataURL: localPhotoData, // Now utilizing the local WebP blob
                            synced: true
                        };

                        if (localIndex > -1) {
                            activeDiary.entries[localIndex] = syncedEntry;
                        } else {
                            activeDiary.entries.push(syncedEntry);
                        }
                    }

                    // Sort and Limit
                    activeDiary.entries.sort((a, b) => new Date(b.date) - new Date(a.date));
                    if (activeDiary.entries.length > 25) {
                        activeDiary.entries = activeDiary.entries.slice(0, 25);
                    }

                    Storage.setData(currentData);
                    App.state.diaries = currentData;

                    SyncManager.updateUI('synced');
                    SyncManager.fetchTags(true);

                } catch (e) {
                    console.error("Sync Error", e);
                    SyncManager.updateUI('error');
                    if (e.message.includes("CORS")) App.showToast(e.message, 'error');
                } finally {
                    App.state.isLoading = false;
                    App.renderDiaryView();
                    App.renderSidebar();
                }
            },

            pushEntryToNotion: async (dbId, entry) => {
                let uploadedFileId = null;

                // Note: entry.photoDataURL might be the low-res version if refreshed.
                // If it's the session where we just took it, we might want to use the high-res one if available.
                // But to simplify, we push what we have. Ideally, in App.saveEntry we trigger sync immediately 
                // while App.state.capturedImageHighRes (if we implemented it) is available.
                // For now, we assume entry.photoDataURL is what we upload.
                // If it's data URI:
                if (entry.photoDataURL && entry.photoDataURL.startsWith('data:')) {
                    try {
                        const initRes = await API.request('POST', '/file_uploads', {
                            "object": "file_upload", "filename": "photo.webp", "content_type": "image/webp"
                        });
                        const blob = UTILS.dataURLtoBlob(entry.photoDataURL);
                        await API.uploadFileContent(initRes.upload_url, blob);
                        uploadedFileId = initRes.id;
                    } catch (err) {
                        App.showToast("Image upload failed, saving text.", "error");
                    }
                }

                const titleToSend = entry.title || "Untitled Entry";

                const properties = {
                    "Name": { "title": [{ "text": { "content": titleToSend } }] },
                    "Date": { "date": { "start": entry.date } },
                    "Notes": { "rich_text": [{ "text": { "content": entry.notes } }] },
                    "Tags": { "multi_select": entry.tags.map(t => ({ "name": t })) }
                };

                if (uploadedFileId) {
                    properties["Files"] = { "files": [{ "type": "file_upload", "file_upload": { "id": uploadedFileId } }] };
                }

                const res = await API.request('POST', '/pages', {
                    parent: { type: "database_id", database_id: dbId },
                    properties
                });
                return res.id;
            }
        };

        const App = {
            state: {
                diaries: [],
                activeDiaryId: null,
                stream: null,
                facingMode: 'environment',
                capturedImage: null, // Low res for UI
                capturedImageHighRes: null, // New: High res for upload
                currentTags: [],
                ghostMode: false,
                ghostImageObj: null,
                ghostOpacity: 0.3,
                orientation: 'landscape',
                collageMode: 1,
                activeSegment: 0,
                segments: [],
                mirrorVideo: false,
                selectedDb: null,
                cachedDbs: [],
                isLoading: false
            },

            collageConfigs: {
                1: [{ x: 0, y: 0, w: 1, h: 1 }],
                2: [{ x: 0, y: 0, w: 0.5, h: 1 }, { x: 0.5, y: 0, w: 0.5, h: 1 }],
                3: [{ x: 0, y: 0, w: 0.3333, h: 1 }, { x: 0.3333, y: 0, w: 0.3333, h: 1 }, { x: 0.6666, y: 0, w: 0.3334, h: 1 }],
                4: [{ x: 0, y: 0, w: 0.5, h: 0.5 }, { x: 0.5, y: 0, w: 0.5, h: 0.5 }, { x: 0, y: 0.5, w: 0.5, h: 0.5 }, { x: 0.5, y: 0.5, w: 0.5, h: 0.5 }],
                5: [{ x: 0, y: 0, w: 1, h: 0.5 }, { x: 0, y: 0.5, w: 1, h: 0.5 }],
                6: [{ x: 0, y: 0, w: 1, h: 0.3333 }, { x: 0, y: 0.3333, w: 1, h: 0.3333 }, { x: 0, y: 0.6666, w: 1, h: 0.3334 }],
                7: [{ x: 0.25, y: 0, w: 0.5, h: 0.5 }, { x: 0, y: 0.5, w: 0.5, h: 0.5 }, { x: 0.5, y: 0.5, w: 0.5, h: 0.5 }]
            },

            init: () => {
                lucide.createIcons();
                App.state.diaries = Storage.getData();
                App.renderSidebar();

                const s = Storage.getSettings();
                App.state.orientation = s.orientation || 'landscape';
                App.state.collageMode = s.collageMode || 1;
                App.state.ghostOpacity = s.ghostOpacity || 0.3;

                const oBtn = document.getElementById('orientationBtn');
                if (oBtn) {
                    const iconName = App.state.orientation === 'landscape' ? 'rectangle-horizontal' : 'rectangle-vertical';
                    oBtn.innerHTML = `<i data-lucide="${iconName}" class="w-6 h-6"></i>`;
                    lucide.createIcons();
                }

                const urlParams = new URLSearchParams(window.location.search);
                const newAuth = urlParams.get('accessToken');

                if (newAuth) {
                    const settings = Storage.getSettings();
                    const newSettings = { ...settings, authToken: newAuth };
                    Storage.setSettings(newSettings);
                    window.history.replaceState({}, document.title, window.location.pathname);
                    App.showToast(`Connected! Scanning databases...`, 'success');
                    if (newSettings.workerUrl) App.scanForDatabases(newSettings);
                }

                if (window.innerWidth < 768 && App.state.diaries.length > 0) {
                    App.selectDiary(App.state.diaries[0].id);
                } else {
                    App.renderWelcomeState();
                }

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        const modals = ['settingsModal', 'newDiaryModal', 'workerHelpModal', 'deleteModal', 'entryModal'];
                        modals.forEach(id => {
                            const el = document.getElementById(id);
                            if (el && !el.classList.contains('hidden')) App.closeModal(id);
                        });
                        document.getElementById('mobileDiaryMenu').classList.add('hidden');
                    }
                });

                document.addEventListener('click', (e) => {
                    const dropdown = document.getElementById('dbDropdownList');
                    const input = document.getElementById('dbSearchInput');
                    if (dropdown && !dropdown.classList.contains('hidden') && !dropdown.contains(e.target) && e.target !== input) {
                        dropdown.classList.add('hidden');
                    }
                    const mobMenu = document.getElementById('mobileDiaryMenu');
                    const isBtn = e.target.closest('#mobileDiaryToggleBtn');
                    const isMenu = e.target.closest('#mobileDiaryMenu');
                    if (mobMenu && !mobMenu.classList.contains('hidden') && !isMenu && !isBtn) {
                        mobMenu.classList.add('hidden');
                    }
                });

                SyncManager.init();
                requestAnimationFrame(App.drawLoop);
            },

            isValidChronicleDb: (props) => {
                if (!props['Name'] || props['Name'].type !== 'title') return false;
                if (!props['Tags'] || props['Tags'].type !== 'multi_select') return false;
                if (!props['Date'] || props['Date'].type !== 'date') return false;
                if (!props['Notes'] || props['Notes'].type !== 'rich_text') return false;
                if (!props['Files'] || props['Files'].type !== 'files') return false;
                return true;
            },

            scanForDatabases: async (settings = null) => {
                const btn = document.getElementById('refreshDbBtn');
                if (btn) {
                    const icon = btn.querySelector('svg');
                    if (icon) icon.classList.add('animate-spin');
                }
                App.state.cachedDbs = [];
                try {
                    const allDbs = await API.fetchDatabases(settings);
                    const validDbs = allDbs.filter(db => App.isValidChronicleDb(db.properties)).map(db => ({
                        id: db.id,
                        title: db.title?.[0]?.plain_text || "Untitled Database",
                        description: db.description?.[0]?.plain_text || ""
                    }));
                    Storage.setCachedDatabases(validDbs);
                    App.state.cachedDbs = validDbs;
                    if (document.getElementById('newDiaryModal').classList.contains('flex')) {
                        App.renderDbDropdownItems(validDbs);
                    }
                    if (!settings) App.showToast(`Found ${validDbs.length} compatible databases.`, "success");
                } catch (e) {
                    console.error(e);
                    App.showToast("Failed to fetch databases", "error");
                } finally {
                    if (btn) {
                        const icon = btn.querySelector('svg');
                        if (icon) icon.classList.remove('animate-spin');
                    }
                }
            },

            toggleDbDropdown: (forceShow = null) => {
                const list = document.getElementById('dbDropdownList');
                if (forceShow === true) list.classList.remove('hidden');
                else if (forceShow === false) list.classList.add('hidden');
                else list.classList.toggle('hidden');
                if (!list.classList.contains('hidden') && document.getElementById('dbSearchInput').value === '') {
                    App.renderDbDropdownItems(App.state.cachedDbs);
                }
            },

            filterDbList: (e) => {
                const term = e.target.value.toLowerCase();
                const filtered = App.state.cachedDbs.filter(db => db.title.toLowerCase().includes(term));
                App.renderDbDropdownItems(filtered);
                App.toggleDbDropdown(true);
            },

            renderDbDropdownItems: (dbs) => {
                const list = document.getElementById('dbDropdownList');
                list.innerHTML = '';
                const usedIds = App.state.diaries.map(d => d.originalDbId);
                const availableDbs = dbs.filter(db => !usedIds.includes(db.id));
                if (availableDbs.length === 0) {
                    list.innerHTML = `<div class="p-4 text-center text-xs text-earth-metal/50">No databases found.</div>`;
                    return;
                }
                availableDbs.forEach(db => {
                    const el = document.createElement('div');
                    el.className = "p-3 border-b border-oatmeal-dark last:border-0 hover:bg-white-linen cursor-pointer transition-colors flex flex-col gap-1";
                    el.onclick = () => App.selectDatabase(db);
                    el.innerHTML = `
                        <div class="flex items-center justify-between">
                            <span class="font-bold text-sm text-charcoal">${db.title}</span>
                        </div>
                        ${db.description ? `<div class="text-[10px] text-earth-metal/60 truncate">${db.description}</div>` : ''}
                    `;
                    list.appendChild(el);
                });
            },

            selectDatabase: (db) => {
                App.state.selectedDb = db;
                const input = document.getElementById('dbSearchInput');
                input.value = db.title;
                const infoBox = document.getElementById('selectedDbInfo');
                document.getElementById('previewDbTitle').innerText = db.title;
                document.getElementById('previewDbDesc').innerText = db.description || "No description";
                infoBox.classList.remove('hidden');
                App.toggleDbDropdown(false);
            },

            attemptNewDiary: () => {
                App.state.selectedDb = null;
                document.getElementById('dbSearchInput').value = '';
                document.getElementById('selectedDbInfo').classList.add('hidden');
                const s = Storage.getSettings();
                if (!s.workerUrl || !s.authToken) {
                    App.showToast("Please connect to Notion first.", "error");
                    App.openModal('settingsModal');
                } else {
                    App.openModal('newDiaryModal');
                    const cached = Storage.getCachedDatabases();
                    App.state.cachedDbs = cached;
                    if (cached.length > 0) {
                        App.renderDbDropdownItems(cached);
                    } else {
                        App.scanForDatabases();
                    }
                }
            },

            createDiary: async () => {
                if (!App.state.selectedDb) return App.showToast("Please select a database.", "error");
                const db = App.state.selectedDb;
                const newDiary = {
                    id: UTILS.id(),
                    title: db.title,
                    originalDbId: db.id,
                    description: db.description,
                    tags: [],
                    entries: []
                };
                Storage.saveDiary(newDiary);
                App.state.diaries = Storage.getData();
                App.closeModal('newDiaryModal');
                App.selectDiary(newDiary.id);
                App.showToast("Diary Created!", "success");
            },

            resetApp: () => {
                App.openModal('resetConfirmationModal');
            },

            executeReset: async () => {
                try {
                    localStorage.clear();
                    await clearPwaData();
                    window.location.href = window.location.pathname;
                } catch (e) {
                    console.error(e);
                    App.showToast("Failed to clear storage automatically. Please clear browser cache.", "error");
                }
            },

            toggleMobileDiaryMenu: (e) => {
                if (e) e.stopPropagation();
                const menu = document.getElementById('mobileDiaryMenu');
                const list = document.getElementById('mobileDiaryList');
                if (menu.classList.contains('hidden')) {
                    menu.classList.remove('hidden');
                    list.innerHTML = '';
                    if (App.state.diaries.length === 0) {
                        list.innerHTML = `<div class="p-4 text-center text-xs text-earth-metal/50">No diaries yet.</div>`;
                    } else {
                        App.state.diaries.forEach(diary => {
                            const isActive = diary.id === App.state.activeDiaryId;
                            const div = document.createElement('div');
                            div.className = `p-3 rounded-lg cursor-pointer flex items-center justify-between mb-1 ${isActive ? 'bg-oatmeal-dark/30 font-bold text-dull-purple' : 'hover:bg-white'}`;
                            div.onclick = () => {
                                App.selectDiary(diary.id);
                                menu.classList.add('hidden');
                            };
                            div.innerHTML = `<span>${diary.title}</span> ${isActive ? '<i data-lucide="check" class="w-4 h-4"></i>' : ''}`;
                            list.appendChild(div);
                        });
                        lucide.createIcons();
                    }
                } else {
                    menu.classList.add('hidden');
                }
            },

            showToast: (message, type = 'info') => {
                const container = document.getElementById('toastContainer');
                const el = document.createElement('div');
                let bg = type === 'success' ? 'bg-oatmeal border-green-500' : (type === 'error' ? 'bg-white border-red-500' : 'bg-white-linen border-dull-purple');
                let icon = type === 'success' ? 'check-circle' : (type === 'error' ? 'alert-circle' : 'info');
                el.className = `toast-enter pointer-events-auto p-4 rounded shadow-md flex gap-3 text-sm ${bg} border-l-4 transition-all`;
                el.innerHTML = `<i data-lucide="${icon}" class="w-5 h-5 mt-0.5"></i><div class="flex-1">${message}</div>`;
                container.appendChild(el);
                lucide.createIcons();
                let timeout = type === 'error' ? 3000 : 1500;
                setTimeout(() => { el.classList.add('toast-exit'); setTimeout(() => el.remove(), 300); }, timeout);
            },

            renderSidebar: () => {
                const container = document.getElementById('diaryListContainer');
                container.innerHTML = '';
                if (App.state.diaries.length === 0) {
                    container.innerHTML = `<div class="text-xs text-center text-earth-metal/50 mt-4">No diaries yet.</div>`;
                    return;
                }
                App.state.diaries.forEach(diary => {
                    const isActive = diary.id === App.state.activeDiaryId;
                    const div = document.createElement('div');
                    const count = diary.entries.length;
                    const countDisplay = count > 50 ? "50+" : count;
                    div.className = `p-3 rounded-lg cursor-pointer flex flex-col gap-1 transition-colors ${isActive ? 'bg-white-linen shadow-sm border border-oatmeal-dark' : 'hover:bg-oatmeal-dark/50'}`;
                    div.onclick = () => App.selectDiary(diary.id);
                    div.innerHTML = `
                        <div class="font-medium text-charcoal truncate">${diary.title}</div>
                        <div class="text-[10px] text-earth-metal/60">${countDisplay} entries</div>
                    `;
                    container.appendChild(div);
                });
            },

            renderWelcomeState: () => {
                const gallery = document.getElementById('entryGallery');
                const s = Storage.getSettings();
                const isConnected = s.workerUrl && s.authToken;
                const hasDiaries = App.state.diaries.length > 0;
                if (!isConnected) {
                    gallery.innerHTML = `
                        <div class="h-full flex flex-col items-center justify-center text-center gap-4">
                            <div class="bg-dull-purple/10 p-4 rounded-full"><i data-lucide="plug" class="w-10 h-10 text-dull-purple"></i></div>
                            <div>
                                <h3 class="font-serif text-2xl text-charcoal mb-2">Welcome to Photo Chronicles</h3>
                                <p class="welcome-blurb max-w-md mx-auto mb-3">Photo Chronicles is your cozy, camera-first diary that turns daily snaps into a living timelineauto-sorted, timestamped, and synced privately to Notion so memories stay safe and easy to revisit.</p>
                                <p class="text-earth-metal/60 max-w-xs mx-auto mb-6">Connect your Notion workspace to start tracking.</p>
                                <button onclick="App.openModal('settingsModal')" class="bg-charcoal text-white px-6 py-3 rounded-lg font-medium hover:bg-black transition">Connect to Notion</button>
                            </div>
                        </div>`;
                } else if (!hasDiaries) {
                    gallery.innerHTML = `
                        <div class="h-full flex flex-col items-center justify-center text-center gap-4">
                            <div class="bg-oatmeal-dark p-4 rounded-full"><i data-lucide="book-plus" class="w-10 h-10 text-earth-metal"></i></div>
                            <div>
                                <h3 class="font-serif text-2xl text-charcoal mb-2">You're Connected!</h3>
                                <p class="text-earth-metal/60 max-w-xs mx-auto mb-6">Create your first diary to link a Notion Database.</p>
                                <button onclick="App.attemptNewDiary()" class="bg-dull-purple text-white px-6 py-3 rounded-lg font-medium hover:bg-dull-purple-hover transition">Create First Diary</button>
                            </div>
                        </div>`;
                } else {
                    gallery.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-center text-earth-metal/60"><i data-lucide="book-open" class="w-12 h-12 mb-4 opacity-50"></i><p>Select a diary.</p></div>`;
                }
                lucide.createIcons();
            },

            renderDiaryView: () => {
                const diary = App.state.diaries.find(d => d.id === App.state.activeDiaryId);
                const gallery = document.getElementById('entryGallery');
                const title = document.getElementById('activeDiaryTitle');

                if (!diary) return;
                title.innerText = diary.title;
                gallery.innerHTML = '';

                if (App.state.isLoading && diary.entries.length === 0) {
                    gallery.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-center text-earth-metal/60">
                        <div class="loader w-8 h-8 border-4 border-dull-purple border-t-transparent rounded-full mb-4"></div>
                        <p>Loading entries...</p>
                    </div>`;
                    return;
                }

                if (diary.entries.length === 0) {
                    gallery.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-center text-earth-metal/60"><i data-lucide="camera" class="w-12 h-12 mb-4 opacity-50"></i><p>Empty.</p></div>`;
                    lucide.createIcons();
                    return;
                }

                // Updated Denser Grid
                const grid = document.createElement('div');
                grid.className = "grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3";

                // Limit to 25 entries display if more exist (safety)
                const displayEntries = diary.entries.slice(0, 25);

                displayEntries.forEach(entry => {
                    const card = document.createElement('div');
                    card.className = "relative group bg-white-linen rounded-lg overflow-hidden shadow-sm border border-oatmeal-dark hover:shadow-md transition-shadow flex flex-col";

                    const imgHtml = entry.photoDataURL
                        ? `<img src="${entry.photoDataURL}" class="w-full aspect-square object-cover bg-oatmeal" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNjY2MiIHN0cm9rZS13aWR0aD0iMiI+PHJlY3QgeD0iMyIgeT0iMyIgd2lkdGg9IjE4IiBoZWlnaHQ9IjE4IiByeD0iMiIgcnk9IjIiPjwvcmVjdD48Y2lyY2xlIGN4PSI4LjUiIGN5PSI4LjUiIHI9IjEuNSI+PC9jaXJjbGU+PHBvbHlsaW5lIHBvaW50cz0iMjEgMTUgMTYgMTAgNSAyMSI+PC9wb2x5bGluZT48L3N2Zz4n">`
                        : `<div class="w-full aspect-square bg-oatmeal flex items-center justify-center text-earth-metal/30"><i data-lucide="image-off"></i></div>`;

                    const dispTitle = entry.title || "Untitled";

                    const deleteBtn = `
                        <div class="absolute top-1 right-1 opacity-0 group-hover:opacity-100 transition-opacity z-10">
                            <button onclick="event.stopPropagation(); App.confirmDelete('${diary.id}', '${entry.id}')" class="bg-white/80 hover:bg-white text-red-500 p-1.5 rounded-full shadow-sm backdrop-blur-sm transition">
                                <i data-lucide="trash-2" class="w-3 h-3"></i>
                            </button>
                        </div>
                    `;

                    card.innerHTML = `
                        ${deleteBtn}
                        ${imgHtml}
                        <div class="p-2 flex flex-col gap-1">
                            <div class="flex justify-between items-center">
                                <span class="text-[10px] font-mono text-earth-metal/60 truncate">${UTILS.formatDate(entry.date)}</span>
                                <div class="w-1.5 h-1.5 rounded-full ${entry.synced ? 'bg-green-400' : 'bg-amber-400'}" title="${entry.synced ? 'Synced' : 'Local'}"></div>
                            </div>
                            <h4 class="font-bold text-xs text-charcoal truncate leading-tight">${dispTitle}</h4>
                        </div>
                    `;
                    grid.appendChild(card);
                });
                gallery.appendChild(grid);

                const footerMsg = diary.entries.length >= 25
                    ? "Showing last 25 entries. (Thumbnails only - check Notion for full quality)"
                    : "End of entries. (Thumbnails only - check Notion for full quality)";
                let footer = document.createElement('div');
                footer.id = 'galleryFooter';
                footer.className = "text-center text-xs text-earth-metal/40 py-8";
                footer.innerText = footerMsg;
                gallery.appendChild(footer);

                lucide.createIcons();
            },

            selectDiary: (id) => {
                App.state.activeDiaryId = id;
                App.renderSidebar();
                App.renderDiaryView();
                if (window.innerWidth < 768) {
                    const sidebar = document.getElementById('sidebar');
                    if (sidebar) sidebar.classList.add('-translate-x-full');
                    const overlay = document.getElementById('mobileSidebarOverlay');
                    if (overlay) overlay.classList.add('hidden');
                }
                SyncManager.syncCurrentDiary();
            },

            toggleMobileSidebar: () => {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('mobileSidebarOverlay');
                if (sidebar.classList.contains('-translate-x-full')) {
                    sidebar.classList.remove('-translate-x-full');
                    overlay.classList.remove('hidden');
                } else {
                    sidebar.classList.add('-translate-x-full');
                    overlay.classList.add('hidden');
                }
            },

            initNewEntry: async () => {
                App.state.currentTags = [];
                App.state.capturedImage = null;
                App.state.capturedImageHighRes = null; // Reset High Res
                App.state.activeSegment = 0;
                App.state.segments = [];
                App.state.mirrorVideo = false;
                App.state.ghostImageObj = null;

                App.setCollageMode(App.state.collageMode);

                document.getElementById('entryNotes').value = '';
                document.getElementById('entryTitle').value = '';
                document.getElementById('entryDate').value = UTILS.toLocalISO(new Date());
                document.getElementById('activeTags').innerHTML = '';
                document.getElementById('tagInput').value = '';
                document.getElementById('saveEntryBtn').disabled = true;
                document.getElementById('mirrorToggleBtn').classList.add('hidden');

                document.getElementById('takenPhotoUI').classList.remove('flex');
                document.getElementById('takenPhotoUI').classList.add('hidden');
                document.getElementById('cameraSection').classList.remove('hidden');

                const diary = App.state.diaries.find(d => d.id === App.state.activeDiaryId);
                if (!diary) return App.showToast("Create a diary first.", "error");

                const toggleBtn = document.getElementById('ghostToggleBtn');
                const lastEntryWithPhoto = diary.entries.find(e => e.photoDataURL);
                const ghostImg = document.getElementById('ghostOverlay');

                if (lastEntryWithPhoto) {
                    ghostImg.src = lastEntryWithPhoto.photoDataURL;
                    toggleBtn.classList.remove('hidden');
                    toggleBtn.classList.remove('opacity-50');
                    App.state.ghostMode = true;
                    const savedOpacity = App.state.ghostOpacity;
                    ghostImg.classList.remove('opacity-0');
                    ghostImg.style.opacity = savedOpacity;
                    const sliderInput = document.querySelector('#ghostSliderContainer input');
                    if (sliderInput) sliderInput.value = savedOpacity;
                    document.getElementById('ghostSliderContainer').classList.add('hidden');
                    const img = new Image();
                    img.onload = () => { App.state.ghostImageObj = img; };
                    img.src = lastEntryWithPhoto.photoDataURL;
                } else {
                    toggleBtn.classList.add('hidden');
                    App.state.ghostMode = false;
                    ghostImg.classList.add('opacity-0');
                    document.getElementById('ghostSliderContainer').classList.add('hidden');
                }

                App.openModal('entryModal');
                App.initCamera();
                SyncManager.fetchTags(true);
            },

            setCollageMode: (mode) => {
                App.state.collageMode = mode;
                App.state.activeSegment = 0;
                App.state.segments = [];
                const s = Storage.getSettings();
                s.collageMode = mode;
                Storage.setSettings(s);
                document.querySelectorAll('.collage-btn').forEach(btn => {
                    btn.classList.add('bg-white/20', 'hover:bg-white/10');
                    btn.classList.remove('bg-white', 'text-black');
                });
                const modeToIdx = { 1: 0, 2: 1, 5: 2, 3: 3, 6: 4, 7: 5, 4: 6 };
                const btns = document.querySelectorAll('.collage-btn');
                const targetBtn = btns[modeToIdx[mode]];
                if (targetBtn) {
                    targetBtn.classList.remove('bg-white/20', 'hover:bg-white/10');
                    targetBtn.classList.add('bg-white', 'text-black');
                }
                App.updateGridOverlay();
                const segInd = document.getElementById('segmentIndicator');
                if (mode > 1) {
                    segInd.classList.remove('hidden');
                    document.getElementById('segTotal').innerText = App.collageConfigs[mode].length;
                    document.getElementById('segCurrent').innerText = 1;
                } else {
                    segInd.classList.add('hidden');
                }
                document.getElementById('collageMenu').classList.add('hidden');
                document.getElementById('collageMenu').classList.remove('flex');
                let label = "1x";
                if (mode === 2) label = "2x ";
                if (mode === 3) label = "3x ";
                if (mode === 4) label = "4x";
                if (mode === 5) label = "2x ";
                if (mode === 6) label = "3x ";
                if (mode === 7) label = "3x 1/2";
                document.getElementById('gridBtn').innerText = label;
            },

            toggleCollageMenu: () => {
                const menu = document.getElementById('collageMenu');
                if (menu.classList.contains('hidden')) {
                    menu.classList.remove('hidden');
                    menu.classList.add('flex');
                } else {
                    menu.classList.add('hidden');
                    menu.classList.remove('flex');
                }
            },

            toggleOrientation: () => {
                const current = App.state.orientation;
                const next = current === 'landscape' ? 'portrait' : 'landscape';
                App.state.orientation = next;
                const s = Storage.getSettings();
                s.orientation = next;
                Storage.setSettings(s);
                const btn = document.getElementById('orientationBtn');
                if (btn) {
                    const iconName = next === 'landscape' ? 'rectangle-horizontal' : 'rectangle-vertical';
                    btn.innerHTML = `<i data-lucide="${iconName}" class="w-6 h-6"></i>`;
                    lucide.createIcons();
                }
            },

            updateGridOverlay: () => {
            },

            initCamera: async () => {
                const video = document.getElementById('videoSource');
                try {
                    if (App.state.stream) {
                        App.state.stream.getTracks().forEach(t => t.stop());
                    }
                    App.state.stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: App.state.facingMode },
                        audio: false
                    });
                    video.srcObject = App.state.stream;
                    const mirrorBtn = document.getElementById('mirrorToggleBtn');
                    if (App.state.facingMode === 'user') {
                        mirrorBtn.classList.remove('hidden');
                    } else {
                        mirrorBtn.classList.add('hidden');
                        App.state.mirrorVideo = false;
                        const btn = document.getElementById('mirrorToggleBtn');
                        btn.classList.remove('bg-white/40');
                        btn.classList.add('bg-black/40');
                    }
                } catch (e) {
                }
            },

            drawLoop: () => {
                const video = document.getElementById('videoSource');
                const cvs = document.getElementById('viewfinder');
                const ctx = cvs.getContext('2d');
                const isPortrait = App.state.orientation === 'portrait';
                const mode = App.state.collageMode;
                const BaseW = isPortrait ? 960 : 1280;
                const BaseH = isPortrait ? 1280 : 960;
                let multW = 1;
                let multH = 1;
                if (mode === 2) multW = 2;
                else if (mode === 3) multW = 3;
                else if (mode === 4) { multW = 2; multH = 2; }
                else if (mode === 5) { multH = 2; }
                else if (mode === 6) { multH = 3; }
                else if (mode === 7) { multW = 2; multH = 2; }
                const W = BaseW * multW;
                const H = BaseH * multH;
                if (cvs.width !== W || cvs.height !== H) {
                    cvs.width = W;
                    cvs.height = H;
                }
                ctx.clearRect(0, 0, W, H);
                const layout = App.collageConfigs[App.state.collageMode];
                if (App.state.ghostMode && App.state.ghostImageObj) {
                    ctx.save();
                    ctx.globalAlpha = App.state.ghostOpacity;
                    const img = App.state.ghostImageObj;
                    const imgW = img.width;
                    const imgH = img.height;
                    const srcRatio = imgW / imgH;
                    const dstRatio = W / H;
                    let gsx, gsy, gsw, gsh;
                    if (srcRatio > dstRatio) {
                        gsh = imgH; gsw = gsh * dstRatio; gsy = 0; gsx = (imgW - gsw) / 2;
                    } else {
                        gsw = imgW; gsh = gsw / dstRatio; gsx = 0; gsy = (imgH - gsh) / 2;
                    }
                    ctx.drawImage(img, gsx, gsy, gsw, gsh, 0, 0, W, H);
                    ctx.restore();
                }
                layout.forEach((slot, idx) => {
                    const dx = slot.x * W;
                    const dy = slot.y * H;
                    const dw = slot.w * W;
                    const dh = slot.h * H;
                    if (idx === App.state.activeSegment) {
                        if (video.readyState === 4) {
                            ctx.save();
                            const vidW = video.videoWidth;
                            const vidH = video.videoHeight;
                            const srcRatio = vidW / vidH;
                            const dstRatio = dw / dh;
                            let sx, sy, sw, sh;
                            if (srcRatio > dstRatio) {
                                sh = vidH; sw = sh * dstRatio; sy = 0; sx = (vidW - sw) / 2;
                            } else {
                                sw = vidW; sh = sw / dstRatio; sx = 0; sy = (vidH - sh) / 2;
                            }
                            if (App.state.mirrorVideo && App.state.facingMode === 'user') {
                                ctx.translate(dx + dw, dy);
                                ctx.scale(-1, 1);
                                ctx.drawImage(video, sx, sy, sw, sh, 0, 0, dw, dh);
                            } else {
                                ctx.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh);
                            }
                            ctx.restore();
                        }
                    } else if (App.state.segments[idx]) {
                        ctx.drawImage(App.state.segments[idx], 0, 0, App.state.segments[idx].width, App.state.segments[idx].height, dx, dy, dw, dh);
                    } else {
                        ctx.fillStyle = "#111";
                        ctx.fillRect(dx, dy, dw, dh);
                    }
                    ctx.strokeStyle = "rgba(255,255,255,0.1)";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(dx, dy, dw, dh);
                });
                requestAnimationFrame(App.drawLoop);
            },

            flipCamera: () => {
                App.state.facingMode = App.state.facingMode === 'user' ? 'environment' : 'user';
                App.initCamera();
            },

            toggleMirror: () => {
                App.state.mirrorVideo = !App.state.mirrorVideo;
                const btn = document.getElementById('mirrorToggleBtn');
                if (App.state.mirrorVideo) {
                    btn.classList.add('bg-white/40');
                    btn.classList.remove('bg-black/40');
                } else {
                    btn.classList.remove('bg-white/40');
                    btn.classList.add('bg-black/40');
                }
            },

            toggleGhost: () => {
                const ghost = document.getElementById('ghostOverlay');
                const btn = document.getElementById('ghostToggleBtn');
                const slider = document.getElementById('ghostSliderContainer');
                if (App.state.ghostMode) {
                    if (slider.classList.contains('hidden')) {
                        slider.classList.remove('hidden');
                    } else {
                        App.state.ghostMode = false;
                        ghost.classList.add('opacity-0');
                        btn.classList.add('opacity-50');
                        slider.classList.add('hidden');
                    }
                } else {
                    App.state.ghostMode = true;
                    ghost.classList.remove('opacity-0');
                    ghost.style.opacity = App.state.ghostOpacity;
                    btn.classList.remove('opacity-50');
                    slider.classList.remove('hidden');
                }
            },

            setGhostOpacity: (val) => {
                const newVal = parseFloat(val);
                App.state.ghostOpacity = newVal;
                const ghost = document.getElementById('ghostOverlay');
                if (App.state.ghostMode) ghost.style.opacity = newVal;
                const s = Storage.getSettings();
                s.ghostOpacity = newVal;
                Storage.setSettings(s);
            },

            handleTagInput: (e) => {
                const val = e.target.value.trim().toLowerCase();
                const suggestions = document.getElementById('tagSuggestions');
                const diary = App.state.diaries.find(d => d.id === App.state.activeDiaryId);
                const allTags = diary ? diary.tags : [];
                const matches = val
                    ? allTags.filter(t => t.toLowerCase().includes(val) && !App.state.currentTags.includes(t))
                    : allTags.filter(t => !App.state.currentTags.includes(t));
                if (matches.length > 0) {
                    suggestions.classList.remove('hidden');
                    suggestions.innerHTML = matches.map(t =>
                        `<div class="p-2 hover:bg-oatmeal cursor-pointer text-sm" onclick="App.addTag('${t}')">${t}</div>`
                    ).join('');
                } else {
                    suggestions.classList.add('hidden');
                }
                if (e.key === 'Enter' && val) {
                    App.addTag(e.target.value.trim());
                }
            },

            addTag: (t) => {
                if (!App.state.currentTags.includes(t)) {
                    App.state.currentTags.push(t);
                    App.renderTags();
                    document.getElementById('tagInput').value = '';
                    document.getElementById('tagSuggestions').classList.add('hidden');
                }
            },

            renderTags: () => {
                const container = document.getElementById('activeTags');
                container.innerHTML = App.state.currentTags.map(t => `
                    <span class="bg-oatmeal border border-oatmeal-dark text-dull-purple px-2 py-1 rounded text-xs flex items-center gap-1">
                        ${t}
                        <button onclick="App.removeTag('${t}')" class="hover:text-red-500"><i data-lucide="x" class="w-3 h-3"></i></button>
                    </span>
                `).join('');
                lucide.createIcons();
            },

            removeTag: (t) => {
                App.state.currentTags = App.state.currentTags.filter(x => x !== t);
                App.renderTags();
            },

            confirmDelete: (diaryId, entryId) => {
                App.state.pendingDelete = { diaryId, entryId };
                App.openModal('deleteModal');
            },

            executeDelete: async () => {
                const { diaryId, entryId } = App.state.pendingDelete;
                if (!diaryId || !entryId) return;
                App.closeModal('deleteModal');
                const diary = Storage.getData().find(d => d.id === diaryId);
                const entry = diary?.entries.find(e => e.id === entryId);
                const notionId = entry?.notionId;
                Storage.deleteEntry(diaryId, entryId);
                App.state.diaries = Storage.getData();
                App.renderDiaryView();
                App.renderSidebar();
                App.showToast("Deleted locally", "success");
                if (notionId) {
                    try {
                        await API.request('PATCH', `/pages/${notionId}`, { archived: true });
                        App.showToast("Deleted from Notion", "success");
                    } catch (e) {
                        console.error("Notion delete failed", e);
                        App.showToast("Failed to delete from Notion", "error");
                    }
                }
            },

            saveEntry: async () => {
                const notes = document.getElementById('entryNotes').value;
                const titleInput = document.getElementById('entryTitle').value;
                const dateVal = document.getElementById('entryDate').value;
                const date = UTILS.localToUTC(dateVal);
                const title = titleInput.trim() || new Date(dateVal).toLocaleString(undefined, {
                    weekday: 'short', year: 'numeric', month: 'short', day: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });

                if (!App.state.capturedImage) return App.showToast('An image is required.', 'error');

                // Generate both versions if not already done (though finalizeCollage creates UI version)
                // We should ensure we save the Low Res version to local storage to save space
                let photoToSave = App.state.capturedImage;
                let photoToUpload = App.state.capturedImageHighRes || App.state.capturedImage;

                const newEntry = {
                    id: UTILS.id(),
                    date: date,
                    title: title,
                    notes: notes,
                    tags: App.state.currentTags,
                    photoDataURL: photoToSave, // Local storage gets low res
                    synced: false,
                    notionId: null
                };

                Storage.saveEntry(App.state.activeDiaryId, newEntry);
                App.state.diaries = Storage.getData();

                App.closeModal('entryModal');
                App.renderDiaryView();
                App.showToast("Saved locally", 'success');

                // For sync, we temporarily attach the High Res image to the entry object in memory 
                // so the push function uses it, but we don't save it to localStorage
                // Or we can just pass it directly if we restructure sync. 
                // Simplest hack: Modify the entry object in memory before calling sync
                const entryForSync = { ...newEntry, photoDataURL: photoToUpload };

                // We need to manually trigger push for this specific entry with high res data
                // Because SyncManager reads from Storage (which has low res)
                // So we bypass standard sync loop for this new entry
                try {
                    SyncManager.updateUI('syncing');
                    const diary = Storage.getData().find(d => d.id === App.state.activeDiaryId);
                    const notionId = await SyncManager.pushEntryToNotion(diary.originalDbId, entryForSync);
                    Storage.updateEntrySyncStatus(App.state.activeDiaryId, newEntry.id, true, notionId);
                    SyncManager.updateUI('synced');
                    App.state.diaries = Storage.getData();
                    App.renderDiaryView();
                } catch (e) {
                    console.error("Immediate sync failed", e);
                    SyncManager.updateUI('error');
                    // It will retry later with low res version from storage, which is acceptable fallback
                }
            },

            copyWorkerCode: (btn) => {
                const code = document.getElementById('workerCodeBlock').innerText;
                const textArea = document.createElement('textarea');
                textArea.value = code;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    const originalText = btn.innerText;
                    btn.innerText = "Copied!";
                    setTimeout(() => btn.innerText = originalText, 2000);
                } catch (err) {
                    console.error('Fallback copy failed', err);
                }
                document.body.removeChild(textArea);
            },

            captureSegment: () => {
                const video = document.getElementById('videoSource');
                const canvas = document.createElement('canvas');
                const isPortrait = App.state.orientation === 'portrait';
                const BaseW = isPortrait ? 960 : 1280;
                const BaseH = isPortrait ? 1280 : 960;
                canvas.width = BaseW;
                canvas.height = BaseH;
                const ctx = canvas.getContext('2d');
                const vidW = video.videoWidth;
                const vidH = video.videoHeight;
                const srcRatio = vidW / vidH;
                const dstRatio = BaseW / BaseH;
                let sx, sy, sw, sh;
                if (srcRatio > dstRatio) { sh = vidH; sw = sh * dstRatio; sy = 0; sx = (vidW - sw) / 2; }
                else { sw = vidW; sh = sw / dstRatio; sx = 0; sy = (vidH - sh) / 2; }
                if (App.state.mirrorVideo && App.state.facingMode === 'user') {
                    ctx.save();
                    ctx.translate(BaseW, 0);
                    ctx.scale(-1, 1);
                    ctx.drawImage(video, sx, sy, sw, sh, 0, 0, BaseW, BaseH);
                    ctx.restore();
                } else {
                    ctx.drawImage(video, sx, sy, sw, sh, 0, 0, BaseW, BaseH);
                }
                App.state.segments[App.state.activeSegment] = canvas;
                const layout = App.collageConfigs[App.state.collageMode];
                const total = layout.length;
                let allFilled = true;
                let nextEmpty = -1;
                for (let i = 0; i < total; i++) {
                    if (!App.state.segments[i]) {
                        allFilled = false;
                        if (nextEmpty === -1) nextEmpty = i;
                    }
                }
                if (allFilled) {
                    App.finalizeCollage();
                } else {
                    App.state.activeSegment = nextEmpty;
                    document.getElementById('segCurrent').innerText = App.state.activeSegment + 1;
                    App.updateGridOverlay();
                }
            },

            finalizeCollage: async () => {
                const layout = App.collageConfigs[App.state.collageMode];
                const finalCanvas = document.getElementById('photoCanvas');
                if (!finalCanvas) return;
                const isPortrait = App.state.orientation === 'portrait';
                const mode = App.state.collageMode;
                const BaseW = isPortrait ? 960 : 1280;
                const BaseH = isPortrait ? 1280 : 960;
                let multW = 1;
                let multH = 1;
                if (mode === 2) multW = 2;
                else if (mode === 3) multW = 3;
                else if (mode === 4) { multW = 2; multH = 2; }
                else if (mode === 5) { multH = 2; }
                else if (mode === 6) { multH = 3; }
                else if (mode === 7) { multW = 2; multH = 2; }
                const W = BaseW * multW;
                const H = BaseH * multH;
                finalCanvas.width = W; finalCanvas.height = H;
                const ctx = finalCanvas.getContext('2d');
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, W, H);
                layout.forEach((slot, idx) => {
                    const seg = App.state.segments[idx];
                    if (seg) {
                        const dx = slot.x * W;
                        const dy = slot.y * H;
                        const dw = slot.w * W;
                        const dh = slot.h * H;
                        ctx.drawImage(seg, 0, 0, seg.width, seg.height, dx, dy, dw, dh);
                    }
                });

                // 1. Generate High Res Version for Upload (WebP Max Quality)
                // We must ensure it's under 5MB
                const highResBase = finalCanvas.toDataURL('image/webp', 0.95);
                App.state.capturedImageHighRes = await UTILS.compressToLimit(highResBase, 4.5 * 1024 * 1024);

                // 2. Generate Low Res Version for Local Storage (WebP 350px 0.6)
                App.state.capturedImage = await UTILS.processImage(highResBase, 350, 0.6);

                document.getElementById('cameraSection').classList.add('hidden');
                document.getElementById('smallPreview').src = App.state.capturedImage; // Show low res preview
                document.getElementById('takenPhotoUI').classList.remove('hidden');
                document.getElementById('takenPhotoUI').classList.add('flex');
                document.getElementById('saveEntryBtn').disabled = false;

                if (App.state.stream) App.state.stream.getTracks().forEach(t => t.stop());
            },

            handleCollageClick: (e) => {
                if (App.state.collageMode === 1) return;
                const img = e.target;
                const rect = img.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;
                const layout = App.collageConfigs[App.state.collageMode];
                const clickedIdx = layout.findIndex(slot => x >= slot.x && x <= slot.x + slot.w && y >= slot.y && y <= slot.y + slot.h);
                if (clickedIdx !== -1) {
                    App.state.activeSegment = clickedIdx;
                    App.retakePartial();
                }
            },

            retakePartial: () => {
                document.getElementById('takenPhotoUI').classList.add('hidden');
                document.getElementById('takenPhotoUI').classList.remove('flex');
                document.getElementById('cameraSection').classList.remove('hidden');
                App.initCamera();
                App.updateGridOverlay();
                document.getElementById('segCurrent').innerText = App.state.activeSegment + 1;
            },

            retakeAll: () => {
                App.state.activeSegment = 0;
                App.state.segments = [];
                document.getElementById('takenPhotoUI').classList.add('hidden');
                document.getElementById('takenPhotoUI').classList.remove('flex');
                document.getElementById('cameraSection').classList.remove('hidden');
                document.getElementById('saveEntryBtn').disabled = true;
                App.initCamera();
                App.setCollageMode(App.state.collageMode);
            },

            retakePhoto: () => { App.retakeAll(); },

            handleFileUpload: async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const base64 = await UTILS.toBase64(file);
                    const img = new Image();
                    img.src = base64;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const isPortrait = App.state.orientation === 'portrait';
                        const BaseW = isPortrait ? 960 : 1280;
                        const BaseH = isPortrait ? 1280 : 960;
                        canvas.width = BaseW;
                        canvas.height = BaseH;
                        const ctx = canvas.getContext('2d');
                        const srcRatio = img.width / img.height;
                        const dstRatio = BaseW / BaseH;
                        let sx, sy, sw, sh;
                        if (srcRatio > dstRatio) { sh = img.height; sw = sh * dstRatio; sy = 0; sx = (img.width - sw) / 2; }
                        else { sw = img.width; sh = sw / dstRatio; sx = 0; sy = (img.height - sh) / 2; }
                        ctx.drawImage(img, sx, sy, sw, sh, 0, 0, BaseW, BaseH);
                        App.state.segments[App.state.activeSegment] = canvas;
                        const layout = App.collageConfigs[App.state.collageMode];
                        const total = layout.length;
                        const filledCount = App.state.segments.filter(s => s).length;
                        if (filledCount === total) {
                            App.finalizeCollage();
                        } else {
                            App.state.activeSegment++;
                            document.getElementById('segCurrent').innerText = App.state.activeSegment + 1;
                            App.updateGridOverlay();
                        }
                    }
                }
            },
            renderSettingsStatus: (settings) => {
                const statusEl = document.getElementById('connectionStatus');
                const s = settings || Storage.getSettings();
                if (!s.authToken) {
                    statusEl.innerHTML = `
                        <div class="flex items-start gap-3 text-amber-700 bg-amber-50 p-3 rounded-lg border border-amber-100 text-xs">
                            <div class="bg-white p-1 rounded-full shadow-sm mt-0.5"><i data-lucide="alert-circle" class="w-4 h-4 text-amber-600"></i></div>
                            <div class="flex-1">
                                <strong class="block text-sm mb-0.5">Not Connected</strong>
                                <span class="opacity-80">Connect via OAuth or verify your manual key to start.</span>
                            </div>
                        </div>
                    `;
                } else if (s.authToken.startsWith('secret_')) {
                    statusEl.innerHTML = `
                        <div class="flex items-start gap-3 text-green-700 bg-green-50 p-3 rounded-lg border border-green-100 text-xs">
                            <div class="bg-white p-1 rounded-full shadow-sm mt-0.5"><i data-lucide="key" class="w-4 h-4 text-green-600"></i></div>
                            <div class="flex-1">
                                <strong class="block text-sm mb-0.5">Connected via Secret Key</strong>
                                <span class="opacity-80">Integration verified manually.</span>
                            </div>
                        </div>
                    `;
                } else {
                    statusEl.innerHTML = `
                        <div class="flex items-start gap-3 text-dull-purple bg-dull-purple/10 p-3 rounded-lg border border-dull-purple/20 text-xs">
                            <div class="bg-white p-1 rounded-full shadow-sm mt-0.5"><i data-lucide="zap" class="w-4 h-4 text-dull-purple"></i></div>
                            <div class="flex-1">
                                <strong class="block text-sm mb-0.5">Connected via OAuth</strong>
                                <span class="opacity-80">Access granted via standard Notion authorization.</span>
                            </div>
                        </div>
                    `;
                }
                lucide.createIcons();
            },
            populateSettingsInputs: () => {
                const s = Storage.getSettings();
                const isSecret = s.authToken && s.authToken.startsWith('secret_');
                document.getElementById('settingAuthToken').value = isSecret ? s.authToken : '';
                document.getElementById('settingWorkerUrl').value = s.workerUrl || '';
                document.getElementById('settingProxyToken').value = s.proxyToken || '';
                const hasVerifiedWorker = !!s.workerUrl;
                const authSection = document.getElementById('authSection');
                if (hasVerifiedWorker) {
                    authSection.classList.remove('opacity-50', 'pointer-events-none');
                } else {
                    authSection.classList.add('opacity-50', 'pointer-events-none');
                }
                const isAuthVerified = !!s.authToken;
                document.getElementById('saveSettingsBtn').disabled = !isAuthVerified;
            },
            onSettingInput: () => {
                const workerUrl = document.getElementById('settingWorkerUrl').value;
                document.getElementById('verifyWorkerBtn').disabled = !workerUrl;
            },
            verifyWorker: async () => {
                const btn = document.getElementById('verifyWorkerBtn');
                const originalText = btn.innerText;
                const workerUrl = document.getElementById('settingWorkerUrl').value.trim();
                const proxyToken = document.getElementById('settingProxyToken').value.trim();
                if (!workerUrl) return App.showToast("Enter a Worker URL first", "error");
                btn.innerText = "Checking...";
                btn.disabled = true;
                const cleanWorkerUrl = workerUrl.replace(/\/$/, '');
                let fetchUrl;
                try {
                    fetchUrl = new URL(cleanWorkerUrl);
                } catch (e) {
                    App.showToast("Invalid Worker URL format", "error");
                    btn.innerText = originalText;
                    btn.disabled = false;
                    return;
                }
                fetchUrl.searchParams.append('url', 'https://api.notion.com/v1/users/me');
                if (proxyToken) fetchUrl.searchParams.append('token', proxyToken);
                try {
                    const res = await fetch(fetchUrl.toString());
                    if (res.ok || res.status === 401) {
                        App.showToast("Proxy Verified!", "success");
                        const current = Storage.getSettings();
                        Storage.setSettings({ ...current, workerUrl, proxyToken });
                        document.getElementById('authSection').classList.remove('opacity-50', 'pointer-events-none');
                    } else {
                        throw new Error("Proxy returned status " + res.status);
                    }
                } catch (e) {
                    App.showToast("Verification failed. Check Worker URL & Proxy Secret.", "error");
                } finally {
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            },
            saveBeforeOAuth: () => {
                const workerUrl = document.getElementById('settingWorkerUrl').value;
                const proxyToken = document.getElementById('settingProxyToken').value;
                const current = Storage.getSettings();
                Storage.setSettings({ ...current, workerUrl, proxyToken });
                // Send the full, canonical URL for this page so the worker can redirect back here after OAuth
                const returnUrl = encodeURIComponent(new URL('index.html', window.location.href).toString());
                window.location.href = `https://notion-oauth-handler.mimansa-jaiswal.workers.dev/auth/login?from=${returnUrl}`;
            },
            testManualConnection: async (btn) => {
                const workerUrl = document.getElementById('settingWorkerUrl').value;
                const authToken = document.getElementById('settingAuthToken').value;
                const proxyToken = document.getElementById('settingProxyToken').value;
                if (!authToken || !workerUrl) return App.showToast("Token and Worker URL required", "error");
                const originalText = btn.innerText;
                btn.innerText = "Verifying...";
                btn.disabled = true;
                try {
                    const tempSettings = { workerUrl, authToken, proxyToken };
                    const res = await API.request('GET', '/users/me', null, tempSettings);
                    App.showToast(`Verified: ${res.bot?.workspace_name || 'Connected'}`, 'success');
                    Storage.setSettings(tempSettings);
                    App.renderSettingsStatus(tempSettings);
                    document.getElementById('saveSettingsBtn').disabled = false;
                    App.scanForDatabases(tempSettings);
                } catch (e) {
                    App.showToast(e.message, 'error');
                    document.getElementById('saveSettingsBtn').disabled = true;
                } finally {
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            },
            testConnection: async (btn) => {
                App.testManualConnection(btn);
            },
            saveSettings: () => {
                App.closeModal('settingsModal');
                App.showToast("Settings Closed", "success");
                App.renderWelcomeState();
            },
            openModal: (id) => {
                document.getElementById(id).classList.remove('hidden', 'flex');
                document.getElementById(id).classList.add('flex');
                if (id === 'settingsModal') {
                    App.populateSettingsInputs();
                    App.renderSettingsStatus();
                }
                if (id === 'entryModal' && !App.state.stream) App.initCamera();
                lucide.createIcons();
            },
            closeModal: (id) => {
                document.getElementById(id).classList.add('hidden');
                document.getElementById(id).classList.remove('flex');
                if (id === 'entryModal' && App.state.stream) App.state.stream.getTracks().forEach(t => t.stop());
            }
        };

        window.addEventListener('load', () => {
            App.init();
            registerServiceWorker();
        });
    </script>
</body>

</html>
