<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Chronicles</title>
    <meta name="theme-color" content="#857593">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Photo Chronicles">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="./manifest.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="./icons/icon-180.png">

    <!-- Tailwind CSS (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.561.0/dist/umd/lucide.min.js"></script>

    <!-- Fonts: Space Grotesk (Headers/Labels) & Inter (Body) -->
    <link
        href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">

    <!-- Tailwind Config for Custom Palette -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        oatmeal: '#E8E2D9',
                        'oatmeal-dark': '#D9D2C7',
                        'earth-metal': '#5C5650',
                        charcoal: '#2C2926',
                        'white-linen': '#F8F6F3',
                        'dull-purple': '#857593',
                        'dull-purple-hover': '#6E6180',
                        'muted-pink': '#C4A3AA',
                        'muted-pink-dim': '#B3929A'
                    },
                    fontFamily: {
                        display: ['"Space Grotesk"', 'system-ui', 'sans-serif'],
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 5px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #D9D2C7;
            border-radius: 2px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #857593;
        }

        /* Camera Overlay Transition */
        .overlay-ghost {
            transition: opacity 0.3s ease, clip-path 0.3s ease;
            pointer-events: none;
        }

        /* Loader */
        .loader {
            border: 2px solid #D9D2C7;
            border-top: 2px solid #857593;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Toast Animation */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast-enter {
            animation: slideIn 0.3s ease-out forwards;
        }

        .toast-exit {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Section Label Style */
        .section-label {
            font-family: 'Space Grotesk', system-ui, sans-serif;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            background: #2C2926;
            color: #F8F6F3;
            padding: 5px 12px;
            display: inline-block;
        }

        /* Entry card */
        .entry-card {
            transition: border-color 0.15s ease;
        }

        .entry-card:hover {
            border-color: #857593;
        }

        /* Welcome blurb */
        .welcome-blurb {
            font-family: 'Space Grotesk', system-ui, sans-serif;
            color: #857593;
            font-size: 0.9rem;
            line-height: 1.7;
        }

        /* Button base */
        .btn-primary {
            background: #2C2926;
            color: #F8F6F3;
            transition: background 0.15s ease;
        }

        .btn-primary:hover {
            background: #1a1816;
        }

        .btn-secondary {
            background: #857593;
            color: #F8F6F3;
            transition: background 0.15s ease;
        }

        .btn-secondary:hover {
            background: #6E6180;
        }

        /* Form inputs */
        input,
        textarea,
        select {
            border-radius: 6px;
        }

        /* Mobile bottom nav improved */
        @media (max-width: 767px) {
            .mobile-nav-btn {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 2px;
                font-size: 10px;
                padding: 8px 12px;
            }
        }

        /* Disable browser default touch behaviors on viewfinder canvas */
        #viewfinder {
            touch-action: none;
        }
    </style>
</head>

<body
    class="bg-oatmeal text-earth-metal font-sans h-[100dvh] flex flex-col md:flex-row overflow-hidden selection:bg-dull-purple selection:text-white">

    <!-- Toast Container -->
    <div id="toastContainer"
        class="fixed top-4 right-4 z-[100] flex flex-col gap-2 w-full max-w-sm pointer-events-none"></div>

    <!-- Hidden Canvas for Processing (Global) -->
    <canvas id="photoCanvas" class="hidden"></canvas>

    <!-- Sidebar (Desktop) / Bottom Nav (Mobile) -->
    <aside
        class="order-2 md:order-1 w-full md:w-64 h-16 md:h-full flex-shrink-0 flex flex-row md:flex-col border-t md:border-t-0 md:border-r border-oatmeal-dark bg-oatmeal/50 transition-all duration-300 justify-between z-20">

        <!-- Logo Area -->
        <div class="hidden md:flex h-14 px-5 border-b border-oatmeal-dark items-center gap-3 flex-shrink-0">
            <div class="w-7 h-7 bg-dull-purple flex items-center justify-center text-white-linen">
                <i data-lucide="camera" class="w-4 h-4"></i>
            </div>
            <div class="flex flex-col">
                <h1 class="font-display text-base font-semibold text-charcoal tracking-tight leading-none">Photo
                    Chronicles</h1>
                <span class="text-[9px] uppercase tracking-wider text-earth-metal/50 font-medium mt-0.5">Notion
                    Sync</span>
            </div>
        </div>

        <!-- Diary List -->
        <div class="hidden md:flex flex-col flex-1 overflow-hidden">
            <div class="flex-1 overflow-y-auto p-3 space-y-2" id="diaryListContainer">
                <!-- Diaries injected here -->
            </div>
            <!-- Data Safety Notice (Sidebar) -->
            <div class="p-3 text-[10px] text-earth-metal/40 leading-relaxed border-t border-oatmeal-dark bg-oatmeal/20">
                <i data-lucide="info" class="w-3 h-3 inline mb-0.5 mr-1"></i>
                This app stores the last 25 images locally for fast loading. Data is safely synced to Notion.
                <br><br>
                <span class="font-display font-medium text-earth-metal/50">Note:</span> Images shown here are compressed
                thumbnails. For full quality, please check your Notion data source.
            </div>
        </div>

        <!-- Mobile Nav Items (Only visible on small screens) -->
        <div class="md:hidden flex w-full justify-around items-center px-2 h-full">
            <button onclick="App.openModal('settingsModal')"
                class="mobile-nav-btn text-earth-metal hover:text-dull-purple" aria-label="Open settings">
                <i data-lucide="settings" class="w-5 h-5"></i>
                <span class="font-display font-medium">Settings</span>
            </button>
            <button onclick="App.initNewEntry()" aria-label="Add entry"
                class="mobile-nav-btn bg-charcoal text-white-linen px-5 py-2 hover:bg-dull-purple">
                <i data-lucide="plus" class="w-5 h-5"></i>
                <span class="font-display font-medium">New Entry</span>
            </button>
            <button onclick="App.attemptNewDiary()" class="mobile-nav-btn text-earth-metal hover:text-dull-purple"
                aria-label="Create new diary">
                <i data-lucide="book-plus" class="w-5 h-5"></i>
                <span class="font-display font-medium">New Diary</span>
            </button>
        </div>

        <!-- Sidebar Footer (Desktop) -->
        <div class="hidden md:block p-3 border-t border-oatmeal-dark space-y-1.5 flex-shrink-0">
            <button onclick="App.attemptNewDiary()"
                class="w-full flex items-center justify-start gap-2.5 p-2.5 hover:bg-white-linen text-dull-purple transition-colors font-display text-sm font-medium">
                <i data-lucide="plus" class="w-4 h-4"></i>
                <span>New Diary</span>
            </button>
            <button onclick="App.openModal('settingsModal')"
                class="w-full flex items-center justify-start gap-2.5 p-2.5 hover:bg-white-linen text-earth-metal transition-colors font-display text-sm">
                <i data-lucide="settings" class="w-4 h-4"></i>
                <span>Settings</span>
            </button>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="order-1 md:order-2 flex-1 flex flex-col min-h-0 relative" id="mainView">

        <!-- Header -->
        <header
            class="h-14 border-b border-oatmeal-dark flex items-center justify-between px-4 md:px-5 bg-white-linen z-10 flex-shrink-0">
            <div class="flex items-center gap-2.5 overflow-hidden">
                <!-- Mobile Diary Switcher Trigger -->
                <button id="mobileDiaryToggleBtn" onclick="App.toggleMobileDiaryMenu(event)"
                    aria-label="Toggle diary list"
                    class="md:hidden border border-oatmeal-dark w-8 h-8 text-earth-metal hover:bg-oatmeal transition-colors flex items-center justify-center">
                    <i data-lucide="library" class="w-4 h-4"></i>
                </button>

                <h2 id="activeDiaryTitle"
                    class="font-display text-lg md:text-xl font-semibold text-charcoal truncate tracking-tight">Select a
                    Diary</h2>
                <span id="syncStatus"
                    class="hidden flex-shrink-0 text-[9px] px-2 py-0.5 bg-oatmeal text-earth-metal items-center gap-1 font-display font-medium uppercase tracking-wide">
                    <span class="w-1.5 h-1.5 rounded-full bg-earth-metal/40"></span>
                    <span>Init</span>
                </span>
            </div>

            <div class="flex items-center gap-2">
                <button onclick="SyncManager.syncCurrentDiary()" title="Refresh Sync" aria-label="Refresh sync"
                    class="border border-oatmeal-dark w-8 h-8 text-earth-metal hover:bg-oatmeal transition-colors flex items-center justify-center">
                    <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                </button>
                <!-- Desktop Add Button -->
                <button id="addEntryBtn" onclick="App.initNewEntry()"
                    class="hidden md:flex bg-charcoal hover:bg-dull-purple text-white-linen px-4 py-2 transition-colors items-center gap-2 font-display text-sm font-medium">
                    <i data-lucide="plus" class="w-4 h-4"></i>
                    <span>Add Entry</span>
                </button>
            </div>
        </header>

        <!-- Mobile Diary Menu (Dropdown/Sheet) -->
        <div id="mobileDiaryMenu"
            class="md:hidden hidden absolute top-14 left-0 w-full bg-white-linen border-b border-oatmeal-dark z-20 max-h-[60vh] overflow-y-auto">
            <div class="p-2" id="mobileDiaryList">
                <!-- Diaries injected here -->
            </div>
        </div>

        <!-- Entry Gallery -->
        <div id="entryGallery" class="flex-1 overflow-y-auto p-4 md:p-8 pb-24 md:pb-8">
            <!-- Content injected via JS -->
        </div>

    </main>

    <!-- MODALS -->

    <!-- 1. Settings Modal -->
    <div id="settingsModal" role="dialog" aria-modal="true"
        class="fixed inset-0 bg-charcoal/30 hidden items-center justify-center z-50 p-4"
        onclick="if(event.target===this) App.closeModal('settingsModal')">
        <div class="bg-white-linen w-full max-w-md p-6 border border-oatmeal-dark relative max-h-full overflow-y-auto">
            <button onclick="App.closeModal('settingsModal')" aria-label="Close settings"
                class="absolute top-4 right-4 text-earth-metal/50 hover:text-charcoal">
                <i data-lucide="x" class="w-5 h-5"></i>
            </button>
            <h3 class="font-display text-lg font-semibold mb-4 text-charcoal tracking-tight">Settings</h3>

            <!-- Connection Status Indicator -->
            <div id="connectionStatus" class="mb-6"></div>

            <div class="space-y-6">

                <!-- Data Source Instructions (Before Proxy) -->
                <div class="bg-oatmeal border-l-2 border-dull-purple p-3 text-xs text-earth-metal leading-relaxed">
                    <p class="font-display font-semibold mb-1 text-charcoal">Required Notion Data Source Format:</p>
                    <p class="text-[11px] mb-2 opacity-70">Columns: Name (title), Tags (multi-select), Date (date),
                        Files (media), Notes (text).</p>
                    <p>
                        Need a template? <a
                            href="https://mimansajaiswal-embedded-dbs.notion.site/photo-chronicles-template?v=2b423941af7b8019977c000c05dd66cf"
                            target="_blank"
                            class="text-dull-purple underline hover:text-charcoal font-semibold">Duplicate this
                            one</a> and add your own tags to start.
                    </p>
                </div>

                <!-- 1. Proxy Settings (Step 1) -->
                <div class="space-y-3 bg-oatmeal/40 p-4 border border-oatmeal-dark relative">
                    <span class="section-label absolute -top-3 left-3">STEP 1: PROXY</span>

                    <div class="pt-2">
                        <div class="flex justify-between items-center mb-1">
                            <label
                                class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal">API
                                Proxy Worker URL</label>
                            <button onclick="App.openModal('workerHelpModal')" aria-label="Worker setup help"
                                class="text-earth-metal/50 hover:text-charcoal" title="How to set up Worker">
                                <i data-lucide="info" class="w-3.5 h-3.5"></i>
                            </button>
                        </div>
                        <input type="text" id="settingWorkerUrl" placeholder="https://..."
                            oninput="App.onSettingInput()"
                            class="w-full bg-white-linen border border-oatmeal-dark p-2.5 text-sm mb-2">
                    </div>
                    <div>
                        <label
                            class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1">Proxy
                            Secret (Optional)</label>
                        <input type="password" id="settingProxyToken" placeholder="ALL_CORS_PROXY_MATCH_TOKEN"
                            oninput="App.onSettingInput()"
                            class="w-full bg-white-linen border border-oatmeal-dark p-2.5 text-sm mb-2">
                    </div>
                    <button onclick="App.verifyWorker()" id="verifyWorkerBtn"
                        class="w-full bg-dull-purple hover:bg-dull-purple-hover text-white-linen py-2.5 text-xs font-display font-semibold uppercase tracking-wider transition-colors flex items-center justify-center gap-2">
                        Verify Proxy
                    </button>
                </div>

                <!-- 2. Authentication (Step 2) -->
                <div id="authSection"
                    class="bg-oatmeal/40 p-4 border border-oatmeal-dark relative opacity-50 pointer-events-none transition-opacity">
                    <span class="section-label absolute -top-3 left-3">STEP 2: AUTH</span>

                    <div class="flex justify-between items-center mb-2 mt-3">
                        <label
                            class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal">Authentication</label>
                        <a href="https://developers.notion.com/docs/create-a-notion-integration#create-your-integration-in-notion"
                            target="_blank" class="text-earth-metal/50 hover:text-charcoal" title="How to get a token">
                            <i data-lucide="info" class="w-3.5 h-3.5"></i>
                        </a>
                    </div>
                    <div class="flex gap-2 mb-2">
                        <button onclick="App.saveBeforeOAuth()"
                            class="flex-1 bg-muted-pink text-white-linen py-2.5 flex items-center justify-center gap-2 hover:bg-muted-pink-dim transition-colors group">
                            <i data-lucide="zap" class="w-4 h-4 text-white-linen"></i>
                            <span class="text-sm font-display font-medium">Connect via OAuth</span>
                        </button>
                    </div>
                    <div class="relative flex py-2 items-center">
                        <div class="flex-grow border-t border-oatmeal-dark"></div>
                        <span
                            class="flex-shrink-0 mx-2 text-[9px] text-earth-metal/50 font-display font-semibold uppercase tracking-widest">OR
                            MANUAL KEY</span>
                        <div class="flex-grow border-t border-oatmeal-dark"></div>
                    </div>

                    <!-- Updated Manual Key Input with Verify Button -->
                    <div class="flex gap-2">
                        <input type="password" id="settingAuthToken" placeholder="Paste 'secret_...' token here"
                            oninput="App.onSettingInput()"
                            class="flex-1 bg-white-linen border border-oatmeal-dark p-2.5 text-xs outline-none text-earth-metal placeholder-earth-metal/30">
                        <button onclick="App.testManualConnection(this)"
                            class="bg-dull-purple text-white-linen hover:bg-dull-purple-hover text-xs font-display font-medium px-4 transition-colors">
                            Verify Key
                        </button>
                    </div>
                </div>

                <!-- 3. Upload Limits -->
                <div class="space-y-2 bg-oatmeal/40 p-4 border border-oatmeal-dark">
                    <label
                        class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal">Upload
                        Size Cap</label>
                    <div class="text-[11px] text-earth-metal/60">Default is 5MB (Notion free plan). Paid plans allow up
                        to 20MB.</div>
                    <div class="flex flex-col gap-2 text-xs mt-2">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="uploadCapMb" value="5" onchange="App.setUploadCap(this.value)"
                                class="accent-dull-purple">
                            <span class="font-display">5 MB (Free plan)</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="uploadCapMb" value="20" onchange="App.setUploadCap(this.value)"
                                class="accent-dull-purple">
                            <span class="font-display">20 MB (Paid plan)</span>
                        </label>
                    </div>
                </div>
            </div>

            <details class="group mt-8 border-t border-oatmeal-dark pt-4">
                <summary
                    class="text-[10px] font-display font-semibold uppercase tracking-wider text-red-700 mb-2 cursor-pointer list-none flex items-center gap-2 outline-none">
                    <span class="flex-1">Danger Zone</span>
                    <i data-lucide="chevron-down"
                        class="w-4 h-4 text-red-700 group-open:rotate-180 transition-transform"></i>
                </summary>
                <div class="pt-2">
                    <button onclick="App.resetApp()"
                        class="w-full border border-red-300 bg-red-50 text-red-700 hover:bg-red-100 py-2.5 text-xs font-display font-medium flex items-center justify-center gap-2 transition-colors">
                        <i data-lucide="trash" class="w-3 h-3"></i> Reset App & Clear Cache
                    </button>
                </div>
            </details>

            <div class="mt-6 flex justify-end items-center gap-3">
                <button onclick="App.saveSettings()" id="saveSettingsBtn" disabled
                    class="px-5 py-2.5 bg-dull-purple text-white-linen hover:bg-dull-purple-hover font-display font-medium disabled:opacity-50 disabled:cursor-not-allowed transition-colors">Save
                    Settings</button>
            </div>
        </div>
    </div>

    <!-- 2. Worker Help Modal -->
    <div id="workerHelpModal" role="dialog" aria-modal="true"
        class="fixed inset-0 bg-charcoal/20 backdrop-blur-sm hidden items-center justify-center z-[60] p-4"
        onclick="if(event.target===this) App.closeModal('workerHelpModal')">
        <div class="bg-white-linen w-full max-w-2xl h-[80vh] p-6 border border-oatmeal-dark flex flex-col">
            <div class="flex justify-between items-center mb-4 border-b border-oatmeal-dark pb-2">
                <h3 class="font-display text-lg font-semibold text-charcoal tracking-tight">Setup Cloudflare Worker</h3>
                <button onclick="App.closeModal('workerHelpModal')" aria-label="Close worker help"
                    class="text-earth-metal/50 hover:text-earth-metal">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto space-y-4 text-sm text-earth-metal pr-2">
                <p>To bypass Notion's CORS restrictions, you need a small proxy. We use Cloudflare Workers (Free).</p>
                <ol class="list-decimal pl-5 space-y-2">
                    <li>Go to <a href="https://workers.cloudflare.com/" target="_blank"
                            class="text-dull-purple underline">Cloudflare Workers</a> and create a new Worker.</li>
                    <li>Copy the code below and paste it into the Worker editor (replace default code).</li>
                    <li>Save and Deploy.</li>
                    <li>(Optional) In Worker Settings > Variables, add <code>ALL_CORS_PROXY_MATCH_TOKEN</code> with a
                        secret password.</li>
                    <li>Copy your Worker's URL (e.g., <code>https://my-proxy.user.workers.dev</code>) and paste it into
                        the app settings.</li>
                </ol>
                <div class="relative">
                    <button onclick="App.copyWorkerCode(this)"
                        class="absolute top-2 right-2 bg-white/80 hover:bg-white px-2 py-1 rounded text-xs shadow text-charcoal font-bold">Copy
                        Code</button>
                    <pre id="workerCodeBlock"
                        class="bg-charcoal text-white-linen p-4 rounded text-xs font-mono overflow-x-auto">
export default {
  async fetch(request, env) {
      return await handleRequest(request, env);
  },
};

function getCorsHeaders(request) {
  return {
      "Access-Control-Allow-Origin": request.headers.get("Origin") || "*",
      "Access-Control-Allow-Methods": "GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization, Notion-Version",
  };
}

function handleOptions(request) {
  return new Response(null, {
      headers: getCorsHeaders(request),
  });
}

function withCors(request, response) {
  const corsHeaders = getCorsHeaders(request);
  const newResponse = new Response(response.body, response);
  for (const [key, value] of Object.entries(corsHeaders)) {
      newResponse.headers.set(key, value);
  }
  newResponse.headers.append("Vary", "Origin");
  return newResponse;
}

async function handleRequest(request, env) {
  if (request.method === "OPTIONS") {
      return handleOptions(request);
  }

  const url = new URL(request.url);
  const requiredToken = (env.ALL_CORS_PROXY_MATCH_TOKEN || "").trim();

  if (requiredToken !== "") {
      const providedToken = url.searchParams.get("token");
      if (providedToken !== requiredToken) {
          return withCors(request, new Response("Unauthorized", { status: 403 }));
      }
      url.searchParams.delete("token");
  }

  const targetUrlParam = url.searchParams.get("url");
  if (!targetUrlParam) {
      return withCors(request, new Response("Missing url parameter", { status: 400 }));
  }

  let targetUrl;
  try {
      targetUrl = new URL(targetUrlParam).toString();
  } catch (err) {
      return withCors(request, new Response("Invalid target URL", { status: 400 }));
  }

  const modifiedRequest = new Request(targetUrl, request);
  modifiedRequest.headers.set("Origin", new URL(targetUrl).origin);

  const response = await fetch(modifiedRequest);
  return withCors(request, response);
}
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- 3. New Diary Modal (Revamped) -->
    <div id="newDiaryModal" role="dialog" aria-modal="true"
        class="fixed inset-0 bg-charcoal/30 hidden items-center justify-center z-50 p-4"
        onclick="if(event.target===this) App.closeModal('newDiaryModal')">
        <div
            class="bg-white-linen w-full max-w-md p-6 border border-oatmeal-dark overflow-visible flex flex-col h-[500px]">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="font-display text-lg font-semibold text-charcoal tracking-tight">New Diary</h3>
                <button onclick="App.scanForDataSources()"
                    class="text-xs text-earth-metal hover:text-charcoal flex items-center gap-1 font-display"
                    id="refreshDbBtn">
                    <i data-lucide="refresh-cw" class="w-3 h-3"></i> Refresh
                </button>
            </div>

            <div class="space-y-4 flex-1 overflow-y-auto pr-1">

                <!-- Searchable Dropdown -->
                <div class="relative">
                    <label
                        class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1">Select
                        Notion Data Source</label>

                    <!-- Info Text Moved Here -->
                    <div class="text-[10px] text-earth-metal/50 mb-3 leading-tight">
                        Only showing datasources with required columns: Name (title), Date (date), Tags (multi-select),
                        Notes (text), Files (media).
                    </div>

                    <div class="relative">
                        <input type="text" id="dbSearchInput" placeholder="Search Data Sources..."
                            onfocus="App.toggleDbDropdown(true)" onkeyup="App.filterDbList(event)"
                            class="w-full bg-white-linen border border-oatmeal-dark p-2.5 text-sm focus:border-dull-purple outline-none"
                            autocomplete="off">
                        <i data-lucide="chevron-down"
                            class="absolute right-3 top-3 w-4 h-4 text-earth-metal/40 pointer-events-none"></i>
                    </div>

                    <!-- Dropdown List -->
                    <div id="dbDropdownList"
                        class="hidden absolute top-full left-0 w-full mt-1 bg-white-linen border border-oatmeal-dark max-h-60 overflow-y-auto z-50">
                        <!-- Items injected here -->
                        <div class="p-4 text-center text-xs text-earth-metal/50 font-display">Type to search...</div>
                    </div>
                </div>

                <!-- Selected DB Info -->
                <div id="selectedDbInfo" class="hidden bg-oatmeal border-l-2 border-dull-purple p-3 mt-4">
                    <div class="section-label mb-2">Selected</div>
                    <div class="font-display text-base font-semibold text-charcoal" id="previewDbTitle"></div>
                    <div class="text-xs text-earth-metal/60 mt-1 line-clamp-2" id="previewDbDesc"></div>
                </div>
            </div>

            <div class="mt-6 flex justify-end gap-3 flex-shrink-0 pt-4 border-t border-oatmeal-dark">
                <button onclick="App.closeModal('newDiaryModal')"
                    class="px-4 py-2 text-earth-metal hover:bg-oatmeal font-display text-sm">Cancel</button>
                <button onclick="App.createDiary()"
                    class="px-5 py-2 bg-charcoal text-white-linen hover:bg-dull-purple font-display font-medium text-sm">Create
                    Diary</button>
            </div>
        </div>
    </div>

    <!-- 4. Delete Confirmation Modal -->
    <div id="deleteModal" role="dialog" aria-modal="true"
        class="fixed inset-0 bg-charcoal/30 hidden items-center justify-center z-[70] p-4"
        onclick="if(event.target===this) App.closeModal('deleteModal')">
        <div class="bg-white-linen w-full max-w-sm p-6 border border-oatmeal-dark">
            <h3 class="font-display text-lg font-semibold text-charcoal mb-2 tracking-tight">Delete Entry?</h3>
            <p class="text-sm text-earth-metal/70 mb-6">This will remove the entry from your <b>local storage</b> AND
                <b>Notion</b>. This action cannot be undone.
            </p>
            <div class="flex justify-end gap-3">
                <button onclick="App.closeModal('deleteModal')"
                    class="px-4 py-2 text-earth-metal hover:bg-oatmeal text-sm font-display">Cancel</button>
                <button onclick="App.executeDelete()"
                    class="px-5 py-2 bg-red-600 text-white hover:bg-red-700 text-sm font-display font-medium">Delete
                    Everywhere</button>
            </div>
        </div>
    </div>

    <!-- 6. Reset Confirmation Modal (New) -->
    <div id="resetConfirmationModal" role="dialog" aria-modal="true"
        class="fixed inset-0 bg-charcoal/30 hidden items-center justify-center z-[80] p-4"
        onclick="if(event.target===this) App.closeModal('resetConfirmationModal')">
        <div class="bg-white-linen w-full max-w-sm p-6 border border-red-300">
            <div class="flex items-center gap-3 mb-2 text-red-700">
                <i data-lucide="alert-triangle" class="w-5 h-5"></i>
                <h3 class="font-display text-lg font-semibold tracking-tight">Reset App?</h3>
            </div>
            <p class="text-sm text-earth-metal/70 mb-6 leading-relaxed">
                This will <b>disconnect Notion</b> and <b>delete all local settings & cache</b>.
                <br><br>
                Your data stored in Notion will stay safe, but you will need to reconnect to see it again.
            </p>
            <div class="flex justify-end gap-3">
                <button onclick="App.closeModal('resetConfirmationModal')"
                    class="px-4 py-2 text-earth-metal hover:bg-oatmeal text-sm font-display">Cancel</button>
                <button onclick="App.executeReset()"
                    class="px-5 py-2 bg-red-600 text-white hover:bg-red-700 text-sm font-display font-medium">Yes, Reset
                    Everything</button>
            </div>
        </div>
    </div>

    <!-- 5. Entry Modal (Live Composite Layout) -->
    <div id="entryModal" role="dialog" aria-modal="true"
        class="fixed inset-0 bg-oatmeal z-50 hidden flex-col overflow-hidden">

        <!-- Close Button -->
        <button onclick="App.closeModal('entryModal')" aria-label="Close entry"
            class="absolute top-4 left-4 z-50 bg-charcoal text-white-linen p-2 hover:bg-dull-purple transition">
            <i data-lucide="x" class="w-5 h-5"></i>
        </button>

        <div id="entryLoadingOverlay"
            class="absolute inset-0 bg-white-linen/90 z-50 hidden items-center justify-center">
            <div class="flex flex-col items-center gap-3 text-earth-metal">
                <div class="loader w-8 h-8 border-2"></div>
                <span id="entryLoadingText"
                    class="text-xs font-display font-semibold tracking-wide uppercase">Processing...</span>
            </div>
        </div>

        <!-- Top Section: Camera Viewfinder (Canvas-based) -->
        <div id="cameraSection"
            class="relative w-full h-[40%] md:h-[50%] max-h-[600px] bg-charcoal/5 flex-shrink-0 flex items-center justify-center overflow-hidden group">

            <!-- Hidden Video Source -->
            <video id="videoSource" autoplay playsinline class="hidden"></video>

            <!-- The Viewfinder Canvas (Live Composite) -->
            <canvas id="viewfinder" class="w-full h-full object-contain z-10"></canvas>

            <!-- Ghost Overlay (Restored as img) -->
            <img id="ghostOverlay"
                class="absolute inset-0 w-full h-full object-contain z-30 pointer-events-none transition-opacity duration-200 opacity-0">

            <!-- Camera Controls -->
            <div id="camControls"
                class="absolute bottom-4 left-0 right-0 z-40 flex flex-col items-center gap-3 transition-opacity duration-200">

                <!-- Segment Indicator (If collage mode > 1) -->
                <div id="segmentIndicator"
                    class="text-charcoal/70 bg-white/80 px-2 py-1 rounded text-[10px] font-mono uppercase tracking-widest hidden shadow-sm">
                    Segment <span id="segCurrent">1</span>/<span id="segTotal">1</span>
                </div>

                <!-- Main Controls Row -->
                <div class="flex items-center justify-center gap-2 sm:gap-4 md:gap-6">

                    <!-- 1. Mirror Toggle (If user facing) -->
                    <button id="mirrorToggleBtn" onclick="App.toggleMirror()" aria-label="Toggle mirror"
                        class="hidden bg-black/40 backdrop-blur-md p-2 sm:p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="flip-horizontal" class="w-5 h-5 sm:w-6 sm:h-6"></i>
                    </button>

                    <!-- 2. Flip Camera Button -->
                    <button onclick="App.flipCamera()" aria-label="Flip camera"
                        class="bg-black/40 backdrop-blur-md p-2 sm:p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="refresh-ccw" class="w-5 h-5 sm:w-6 sm:h-6"></i>
                    </button>

                    <!-- 3. Insert Image (File Input) -->
                    <label aria-label="Insert image"
                        class="cursor-pointer bg-black/40 backdrop-blur-md p-2 sm:p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="image" class="w-5 h-5 sm:w-6 sm:h-6"></i>
                        <input type="file" id="fileInput" accept="image/*" class="hidden"
                            onchange="App.handleFileUpload(event)">
                    </label>

                    <!-- 4. Capture Button (Center) -->
                    <button onclick="App.captureSegment()" id="captureBtn" aria-label="Capture segment"
                        class="w-14 h-14 sm:w-16 sm:h-16 rounded-full border-4 border-white/80 bg-charcoal/60 shadow-[0_0_12px_rgba(0,0,0,0.5)] flex items-center justify-center hover:bg-black/70 transition active:scale-95 backdrop-blur-sm">
                        <div class="w-10 h-10 sm:w-12 sm:h-12 bg-white rounded-full shadow-inner"></div>
                    </button>

                    <!-- 5. Layout Button (Grid Mode) -->
                    <div class="relative group">
                        <button onclick="App.toggleCollageMenu()" id="gridBtn" aria-label="Select collage layout"
                            class="bg-black/40 backdrop-blur-md p-2 sm:p-3 rounded-full hover:bg-black/60 text-white transition font-bold text-[10px] sm:text-xs flex items-center justify-center w-10 h-10 sm:w-12 sm:h-12">
                            1x
                        </button>

                        <!-- Vertical Popup for Grid Selection -->
                        <div id="collageMenu"
                            class="hidden absolute bottom-full left-1/2 -translate-x-1/2 mb-2 bg-black/80 backdrop-blur-md rounded-xl flex-col p-2 gap-2 transition-all shadow-lg w-auto items-center z-50">

                            <!-- 1x -->
                            <button onclick="App.setCollageMode(1)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">1x</button>

                            <!-- 2x Row -->
                            <div class="flex gap-2">
                                <button onclick="App.setCollageMode(2)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">2x
                                    &rarr;</button>
                                <button onclick="App.setCollageMode(5)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">2x
                                    &darr;</button>
                            </div>

                            <!-- 3x Row -->
                            <div class="flex gap-2">
                                <button onclick="App.setCollageMode(3)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">3x
                                    &rarr;</button>
                                <button onclick="App.setCollageMode(6)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">3x
                                    &darr;</button>
                                <button onclick="App.setCollageMode(7)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">3x
                                    1/2</button>
                            </div>

                            <!-- 4x -->
                            <button onclick="App.setCollageMode(4)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">4x</button>
                        </div>
                    </div>

                    <!-- 6. Portrait/Landscape Toggle -->
                    <button onclick="App.toggleOrientation()" id="orientationBtn" aria-label="Toggle orientation"
                        class="bg-black/40 backdrop-blur-md p-2 sm:p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="rectangle-horizontal" class="w-5 h-5 sm:w-6 sm:h-6"></i>
                    </button>

                    <!-- 7. Ghost Button -->
                    <div class="relative flex items-center">
                        <button onclick="App.toggleGhost()" id="ghostToggleBtn" aria-label="Toggle ghost overlay"
                            class="bg-black/40 backdrop-blur-md p-2 sm:p-3 rounded-full hover:bg-black/60 text-white transition opacity-50 peer">
                            <i data-lucide="ghost" class="w-5 h-5 sm:w-6 sm:h-6"></i>
                        </button>
                        <!-- Slider ABOVE - Fixed width & Position -->
                        <div id="ghostSliderContainer"
                            class="hidden absolute bottom-full mb-4 -right-1 bg-black/60 p-2 rounded flex-col items-center">
                            <input type="range" min="0" max="1" step="0.1" value="0.3"
                                class="w-16 h-1 bg-white/50 rounded-lg appearance-none cursor-pointer"
                                oninput="App.setGhostOpacity(this.value)">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Image Manipulation Controls (shown when segment has image) -->
            <div id="imageManipControls"
                class="hidden absolute top-4 right-4 z-40 flex flex-col gap-2 bg-black/60 backdrop-blur-md rounded-xl p-2">
                <!-- Rotation Slider -->
                <div class="flex items-center gap-2 px-2">
                    <i data-lucide="rotate-cw" class="w-4 h-4 text-white/70"></i>
                    <input type="range" id="rotationSlider" min="-180" max="180" step="1" value="0"
                        class="w-20 h-1 bg-white/30 rounded-lg appearance-none cursor-pointer accent-dull-purple"
                        oninput="App.setSegmentRotation(this.value)">
                    <span id="rotationValue" class="text-[10px] text-white/70 w-8 text-right">0°</span>
                </div>
                <!-- Zoom Slider -->
                <div class="flex items-center gap-2 px-2">
                    <i data-lucide="zoom-in" class="w-4 h-4 text-white/70"></i>
                    <input type="range" id="zoomSlider" min="0.5" max="3" step="0.05" value="1"
                        class="w-20 h-1 bg-white/30 rounded-lg appearance-none cursor-pointer accent-dull-purple"
                        oninput="App.setSegmentZoom(this.value)">
                    <span id="zoomValue" class="text-[10px] text-white/70 w-8 text-right">1.0x</span>
                </div>
                <!-- Action Buttons -->
                <div class="flex justify-center gap-1 pt-1 border-t border-white/20">
                    <button onclick="App.flipSegmentHorizontal()" title="Flip Horizontal"
                        class="p-2 hover:bg-white/20 rounded text-white">
                        <i data-lucide="flip-horizontal" class="w-4 h-4"></i>
                    </button>
                    <button onclick="App.flipSegmentVertical()" title="Flip Vertical"
                        class="p-2 hover:bg-white/20 rounded text-white">
                        <i data-lucide="flip-vertical" class="w-4 h-4"></i>
                    </button>
                    <button onclick="App.resetSegmentTransform()" title="Reset"
                        class="p-2 hover:bg-white/20 rounded text-white">
                        <i data-lucide="undo-2" class="w-4 h-4"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Bottom Section: Form (Scrollable) -->
        <div id="formSection" class="flex-1 bg-white-linen p-5 md:p-8 overflow-y-auto w-full md:max-w-2xl md:mx-auto">
            <div class="space-y-5 pb-20">

                <!-- Taken Photo Preview & Retake UI (Hidden by default) -->
                <div id="takenPhotoUI" class="hidden flex-col gap-3 mb-4">
                    <div class="w-full h-64 bg-oatmeal overflow-hidden relative group cursor-pointer border border-oatmeal-dark"
                        onclick="App.handleCollageClick(event)">
                        <img id="smallPreview" class="w-full h-full object-contain">
                        <!-- Hint overlay -->
                        <div
                            class="absolute inset-0 bg-charcoal/30 opacity-0 group-hover:opacity-100 transition flex items-center justify-center text-white text-xs font-display font-medium pointer-events-none">
                            Click segment to edit
                        </div>
                    </div>
                    <div class="flex justify-center gap-2">
                        <button onclick="App.retakeAll()"
                            class="text-xs bg-muted-pink text-white-linen px-4 py-2 hover:bg-muted-pink-dim flex items-center gap-2 transition font-display font-medium">
                            <i data-lucide="refresh-cw" class="w-3 h-3"></i> Retake All
                        </button>
                    </div>
                </div>

                <!-- Segment Edit Overlay (Hidden by default) -->
                <div id="segmentEditOverlay"
                    class="hidden fixed inset-0 bg-charcoal/80 z-50 flex items-center justify-center p-4 overflow-y-auto">
                    <div class="bg-white-linen w-full max-w-sm p-5 space-y-4 my-auto">
                        <div class="flex justify-between items-center">
                            <h3 class="font-display font-semibold text-charcoal">Edit Segment <span
                                    id="editSegmentNum">1</span></h3>
                            <button onclick="App.closeSegmentEdit()" class="text-earth-metal hover:text-charcoal">
                                <i data-lucide="x" class="w-5 h-5"></i>
                            </button>
                        </div>

                        <!-- Live Preview -->
                        <div class="w-full aspect-square bg-charcoal overflow-hidden border border-oatmeal-dark">
                            <canvas id="segEditPreview" class="w-full h-full object-contain"></canvas>
                        </div>

                        <!-- Zoom -->
                        <div>
                            <label
                                class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Zoom</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="segEditZoom" min="0.5" max="3" step="0.05" value="1"
                                    oninput="App.setEditSegmentZoom(this.value)" class="flex-1 accent-dull-purple">
                                <span id="segEditZoomVal" class="text-xs font-display w-10 text-right">1.0x</span>
                            </div>
                        </div>

                        <!-- Rotate -->
                        <div>
                            <label
                                class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Rotate</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="segEditRotation" min="-180" max="180" step="1" value="0"
                                    oninput="App.setEditSegmentRotation(this.value)" class="flex-1 accent-dull-purple">
                                <span id="segEditRotationVal" class="text-xs font-display w-10 text-right">0°</span>
                            </div>
                        </div>

                        <!-- Framing X (Left/Right) -->
                        <div>
                            <label
                                class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Framing
                                X (Left ↔ Right)</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="segEditPanX" min="-300" max="300" step="1" value="0"
                                    oninput="App.setEditSegmentPanX(this.value)" class="flex-1 accent-dull-purple">
                                <span id="segEditPanXVal" class="text-xs font-display w-10 text-right">0</span>
                            </div>
                        </div>

                        <!-- Framing Y (Up/Down) -->
                        <div>
                            <label
                                class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Framing
                                Y (Up ↔ Down)</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="segEditPanY" min="-300" max="300" step="1" value="0"
                                    oninput="App.setEditSegmentPanY(this.value)" class="flex-1 accent-dull-purple">
                                <span id="segEditPanYVal" class="text-xs font-display w-10 text-right">0</span>
                            </div>
                        </div>

                        <!-- Flip buttons -->
                        <div class="flex gap-2 justify-center">
                            <button onclick="App.flipEditSegmentH()"
                                class="flex-1 p-2 bg-oatmeal hover:bg-oatmeal-dark transition flex items-center justify-center gap-1 text-xs font-display">
                                <i data-lucide="flip-horizontal" class="w-4 h-4"></i> Flip H
                            </button>
                            <button onclick="App.flipEditSegmentV()"
                                class="flex-1 p-2 bg-oatmeal hover:bg-oatmeal-dark transition flex items-center justify-center gap-1 text-xs font-display">
                                <i data-lucide="flip-vertical" class="w-4 h-4"></i> Flip V
                            </button>
                        </div>

                        <!-- Action buttons -->
                        <div class="flex gap-2 pt-2 border-t border-oatmeal-dark">
                            <button onclick="App.resetEditSegment()"
                                class="flex-1 p-2 bg-oatmeal hover:bg-oatmeal-dark transition text-xs font-display font-medium flex items-center justify-center gap-1">
                                <i data-lucide="rotate-ccw" class="w-3 h-3"></i> Reset
                            </button>
                            <button onclick="App.retakeEditSegment()"
                                class="flex-1 p-2 bg-muted-pink text-white-linen hover:bg-muted-pink-dim transition text-xs font-display font-medium flex items-center justify-center gap-1">
                                <i data-lucide="camera" class="w-3 h-3"></i> Retake
                            </button>
                            <button onclick="App.applySegmentEdit()"
                                class="flex-1 p-2 bg-dull-purple text-white-linen hover:bg-dull-purple-hover transition text-xs font-display font-medium flex items-center justify-center gap-1">
                                <i data-lucide="check" class="w-3 h-3"></i> Done
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Title -->
                <div>
                    <label
                        class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Title</label>
                    <input type="text" id="entryTitle"
                        class="w-full bg-oatmeal border border-oatmeal-dark p-3 focus:border-dull-purple outline-none text-base font-display font-medium"
                        placeholder="Untitled Entry">
                </div>

                <!-- Date -->
                <div>
                    <label
                        class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Date</label>
                    <input type="datetime-local" id="entryDate"
                        class="w-full bg-oatmeal border border-oatmeal-dark p-3 focus:border-dull-purple outline-none text-sm text-charcoal">
                </div>

                <!-- Notes -->
                <div>
                    <label
                        class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Notes</label>
                    <textarea id="entryNotes"
                        class="w-full bg-oatmeal border border-oatmeal-dark p-3 h-32 focus:border-dull-purple outline-none resize-none placeholder-earth-metal/40 leading-relaxed"
                        placeholder="What did you see today?"></textarea>
                </div>

                <!-- Tags -->
                <div>
                    <div class="flex justify-between items-center mb-1.5">
                        <label
                            class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal">Tags</label>
                        <button onclick="SyncManager.fetchTags(false)"
                            class="text-[10px] text-earth-metal/60 hover:text-charcoal flex items-center gap-1 font-display">
                            <i data-lucide="refresh-ccw" class="w-3 h-3"></i> Refresh
                        </button>
                    </div>
                    <div class="flex flex-wrap gap-2 mb-2" id="activeTags"></div>
                    <div class="relative">
                        <input type="text" id="tagInput" placeholder="Add a tag..."
                            class="w-full bg-oatmeal border border-oatmeal-dark p-3 focus:border-dull-purple outline-none"
                            onkeyup="App.handleTagInput(event)" onfocus="App.handleTagInput(event)">
                        <div id="tagSuggestions"
                            class="absolute top-full left-0 w-full bg-white-linen border border-oatmeal-dark mt-1 z-10 hidden max-h-32 overflow-y-auto">
                        </div>
                    </div>
                </div>

                <!-- Save Button -->
                <div class="pt-4 flex justify-end">
                    <button onclick="App.saveEntry()" id="saveEntryBtn" disabled
                        class="bg-charcoal hover:bg-dull-purple disabled:opacity-50 disabled:cursor-not-allowed text-white-linen px-8 py-3 transition-colors flex items-center justify-center gap-2 text-sm font-display font-semibold">
                        <span>Save Entry</span>
                        <i data-lucide="arrow-right" class="w-4 h-4"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- JAVASCRIPT LOGIC -->
    <script>
        const PWA_CACHE_PREFIX = 'photo-chronicles-cache';

        const registerServiceWorker = () => {
            if (!('serviceWorker' in navigator)) return;
            navigator.serviceWorker.register('./service-worker.js')
                .then((registration) => {
                    console.log('Service worker registered with scope:', registration.scope);
                })
                .catch((err) => console.error('Service worker registration failed:', err));
        };

        const clearPwaData = async () => {
            try {
                if ('caches' in window) {
                    const keys = await caches.keys();
                    await Promise.all(keys.filter((key) => key.startsWith(PWA_CACHE_PREFIX)).map((key) => caches.delete(key)));
                }
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    await Promise.all(
                        registrations
                            .filter((reg) => reg.scope && reg.scope.includes('/photo-chronicles/'))
                            .map((reg) => reg.unregister())
                    );
                }
                if ('indexedDB' in window) {
                    await new Promise((resolve) => {
                        const req = indexedDB.deleteDatabase('photo-chronicles-db');
                        req.onsuccess = () => resolve();
                        req.onerror = () => resolve();
                        req.onblocked = () => resolve();
                    });
                }
            } catch (err) {
                console.warn('PWA cleanup skipped:', err);
            }
        };

        const UTILS = {
            id: () => Math.random().toString(36).substr(2, 9),
            now: () => new Date().toISOString(),
            normalizeTag: (tag) => (tag || '').trim().toLowerCase(),
            sanitizeFilename: (name) => (name || 'photo')
                .toString()
                .replace(/[^a-z0-9-_]+/gi, '_')
                .replace(/^_+|_+$/g, '')
                .slice(0, 80) || 'photo',
            formatTimestampForFilename: (iso) => {
                const d = iso ? new Date(iso) : new Date();
                if (Number.isNaN(d.getTime())) return new Date().toISOString().replace(/[:.]/g, '').slice(0, 15);
                const pad = (n) => String(n).padStart(2, '0');
                return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
            },
            buildPhotoFilename: (diaryTitle, iso, ext = 'webp') => {
                const base = UTILS.sanitizeFilename(diaryTitle || 'Diary');
                const stamp = UTILS.formatTimestampForFilename(iso);
                return `${base}_${stamp}.${ext}`;
            },
            localToUTC: (localDateTimeString) => {
                if (!localDateTimeString) return new Date().toISOString();
                const d = new Date(localDateTimeString);
                return d.toISOString();
            },
            toLocalISO: (date) => {
                const offset = date.getTimezoneOffset() * 60000;
                return new Date(date.getTime() - offset).toISOString().slice(0, 16);
            },
            formatDate: (iso) => new Date(iso).toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }),
            toBase64: (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            }),
            dataURLtoBlob: (dataurl) => {
                var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
                    bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
                while (n--) { u8arr[n] = bstr.charCodeAt(n); }
                return new Blob([u8arr], { type: mime });
            },
            estimateDataUrlSize: (url) => (url.length * 3 / 4) - (url.indexOf(',') > -1 ? url.indexOf(',') : 0),
            // Create a local thumbnail version (350px, 0.6 quality, webp)
            processImage: (imageSource, width = 350, quality = 0.6) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous"; // Try to handle CORS
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const scale = width / img.width;
                        canvas.width = width;
                        canvas.height = img.height * scale;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        try {
                            const dataUrl = canvas.toDataURL('image/webp', quality);
                            resolve(dataUrl);
                        } catch (e) {
                            reject(e);
                        }
                    };
                    img.onerror = (e) => reject(e);
                    img.src = imageSource;
                });
            },
            // High Quality Compression with size cap
            compressToLimit: async (dataUrl, options = {}) => {
                const maxBytes = options.maxBytes ?? 5 * 1024 * 1024;
                const minQuality = options.minQuality ?? 0.86;
                const startQuality = options.startQuality ?? 0.96;
                const step = options.step ?? 0.04;
                const minScale = options.minScale ?? 0.7;

                const originalSize = UTILS.estimateDataUrlSize(dataUrl);
                if (originalSize <= maxBytes) return dataUrl;

                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        let quality = startQuality;
                        let result = dataUrl;
                        let size = originalSize;

                        while (quality >= minQuality) {
                            result = canvas.toDataURL('image/webp', quality);
                            size = UTILS.estimateDataUrlSize(result);
                            if (size <= maxBytes) {
                                resolve(result);
                                return;
                            }
                            quality -= step;
                        }

                        if (size > maxBytes) {
                            const scale = Math.max(minScale, Math.sqrt(maxBytes / size));
                            const newW = Math.max(1, Math.round(canvas.width * scale));
                            const newH = Math.max(1, Math.round(canvas.height * scale));
                            const scaledCanvas = document.createElement('canvas');
                            scaledCanvas.width = newW;
                            scaledCanvas.height = newH;
                            const sctx = scaledCanvas.getContext('2d');
                            sctx.drawImage(canvas, 0, 0, newW, newH);
                            result = scaledCanvas.toDataURL('image/webp', minQuality);
                        }

                        resolve(result);
                    };
                    img.src = dataUrl;
                });
            }
        };

        const ImageStore = {
            db: null,
            dbName: 'photo-chronicles-db',
            storeName: 'photos',
            version: 1,
            isAvailable: () => typeof indexedDB !== 'undefined',
            open: () => {
                if (!ImageStore.isAvailable()) return Promise.reject(new Error('IndexedDB unavailable'));
                if (ImageStore.db) return Promise.resolve(ImageStore.db);
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(ImageStore.dbName, ImageStore.version);
                    req.onupgradeneeded = () => {
                        const db = req.result;
                        if (!db.objectStoreNames.contains(ImageStore.storeName)) {
                            db.createObjectStore(ImageStore.storeName);
                        }
                    };
                    req.onsuccess = () => {
                        ImageStore.db = req.result;
                        resolve(req.result);
                    };
                    req.onerror = () => reject(req.error);
                });
            },
            get: (key) => ImageStore.open().then((db) => new Promise((resolve, reject) => {
                const tx = db.transaction(ImageStore.storeName, 'readonly');
                const store = tx.objectStore(ImageStore.storeName);
                const req = store.get(key);
                req.onsuccess = () => resolve(req.result || null);
                req.onerror = () => reject(req.error);
            })),
            set: (key, blob) => ImageStore.open().then((db) => new Promise((resolve, reject) => {
                const tx = db.transaction(ImageStore.storeName, 'readwrite');
                const store = tx.objectStore(ImageStore.storeName);
                const req = store.put(blob, key);
                req.onsuccess = () => resolve(true);
                req.onerror = () => {
                    const err = req.error;
                    if (err && (err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
                        err.isQuotaExceeded = true;
                    }
                    reject(err);
                };
                tx.onabort = () => {
                    const err = tx.error;
                    if (err && (err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
                        err.isQuotaExceeded = true;
                    }
                    reject(err || new Error('IndexedDB write aborted'));
                };
            })),
            del: (key) => ImageStore.open().then((db) => new Promise((resolve, reject) => {
                const tx = db.transaction(ImageStore.storeName, 'readwrite');
                const store = tx.objectStore(ImageStore.storeName);
                const req = store.delete(key);
                req.onsuccess = () => resolve(true);
                req.onerror = () => reject(req.error);
            }))
        };

        const Storage = {
            getSettings: () => {
                const fallback = {
                    workerUrl: "",
                    authToken: "",
                    proxyToken: "",
                    orientation: "landscape",
                    collageMode: 1,
                    ghostOpacity: 0.3,
                    uploadCapMb: 5
                };
                try {
                    const raw = localStorage.getItem('chronicles_settings');
                    return raw ? JSON.parse(raw) : fallback;
                } catch (e) {
                    localStorage.setItem('chronicles_settings', JSON.stringify(fallback));
                    return fallback;
                }
            },
            setSettings: (s) => localStorage.setItem('chronicles_settings', JSON.stringify(s)),
            getData: () => {
                try {
                    const raw = localStorage.getItem('chronicles_data');
                    return raw ? JSON.parse(raw) : [];
                } catch (e) {
                    localStorage.setItem('chronicles_data', JSON.stringify([]));
                    return [];
                }
            },
            setData: (d) => localStorage.setItem('chronicles_data', JSON.stringify(d)),
            getLastActiveDiaryId: () => localStorage.getItem('chronicles_last_diary'),
            setLastActiveDiaryId: (id) => {
                if (id) {
                    localStorage.setItem('chronicles_last_diary', id);
                } else {
                    localStorage.removeItem('chronicles_last_diary');
                }
            },

            // Cache for valid Notion data sources
            getCachedDataSources: () => {
                try {
                    const raw = localStorage.getItem('chronicles_ds_cache');
                    return raw ? JSON.parse(raw) : [];
                } catch (e) {
                    localStorage.setItem('chronicles_ds_cache', JSON.stringify([]));
                    return [];
                }
            },
            setCachedDataSources: (sources) => localStorage.setItem('chronicles_ds_cache', JSON.stringify(sources)),

            saveDiary: (diary) => {
                const data = Storage.getData();
                data.push(diary);
                Storage.setData(data);
            },
            deleteEntry: (diaryId, entryId) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.entries = diary.entries.filter(e => e.id !== entryId);
                    Storage.setData(data);
                }
            },
            saveEntry: (diaryId, entry) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.entries.unshift(entry);
                    const unique = [];
                    const map = new Map();
                    for (const item of diary.entries) {
                        const dedupeKey = item.notionId ? `notion:${item.notionId}` : `local:${item.id}`;
                        if (!map.has(dedupeKey)) {
                            map.set(dedupeKey, true);
                            unique.push(item);
                        }
                    }
                    // Limit to 25 entries to save local storage space
                    diary.entries = unique.slice(0, 25);
                    entry.tags.forEach(t => {
                        if (!diary.tags.includes(t)) diary.tags.push(t);
                    });
                    Storage.setData(data);
                }
            },
            updateEntrySyncStatus: (diaryId, entryId, status, notionId = null) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                const entry = diary?.entries.find(e => e.id === entryId);
                if (entry) {
                    entry.synced = status;
                    if (notionId) entry.notionId = notionId;
                    Storage.setData(data);
                }
            },
            updateDiaryTags: (diaryId, newTags) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    const merged = [...new Set([...diary.tags, ...newTags])];
                    diary.tags = merged;
                    Storage.setData(data);
                }
            },
            replaceDiaryTags: (diaryId, newTags) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.tags = [...new Set(newTags)];
                    Storage.setData(data);
                }
            },
            queuePendingTag: (diaryId, tag) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                const normalized = UTILS.normalizeTag(tag);
                if (diary && normalized) {
                    if (!Array.isArray(diary.pendingTags)) diary.pendingTags = [];
                    const exists = diary.pendingTags.some(t => UTILS.normalizeTag(t) === normalized);
                    if (!exists) diary.pendingTags.push(tag.trim());
                    Storage.setData(data);
                }
            },
            clearPendingTag: (diaryId, tag) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                const normalized = UTILS.normalizeTag(tag);
                if (diary && Array.isArray(diary.pendingTags) && normalized) {
                    diary.pendingTags = diary.pendingTags.filter(t => UTILS.normalizeTag(t) !== normalized);
                    Storage.setData(data);
                }
            },
            queuePendingEntry: (diaryId, entryId) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary && entryId) {
                    if (!Array.isArray(diary.pendingEntries)) diary.pendingEntries = [];
                    if (!diary.pendingEntries.includes(entryId)) {
                        diary.pendingEntries.push(entryId);
                        Storage.setData(data);
                    }
                }
            },
            clearPendingEntry: (diaryId, entryId) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary && Array.isArray(diary.pendingEntries)) {
                    diary.pendingEntries = diary.pendingEntries.filter(id => id !== entryId);
                    Storage.setData(data);
                }
            },
            getPendingEntries: (diaryId) => {
                const diary = Storage.getData().find(d => d.id === diaryId);
                return diary?.pendingEntries || [];
            },
            updateDiaryCameraConfig: (diaryId, config) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    const current = diary.cameraConfig || {};
                    diary.cameraConfig = { ...current, ...config };
                    Storage.setData(data);
                }
            },
            setLastFetch: (diaryId, timeStr) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.lastFetch = timeStr;
                    Storage.setData(data);
                }
            }
        };

        const API = {
            request: async (method, notionEndpoint, body = null, overrideSettings = null) => {
                const { workerUrl, authToken, proxyToken } = overrideSettings || Storage.getSettings();
                if (!workerUrl || !authToken) throw new Error("Missing Settings");

                const cleanWorkerUrl = workerUrl.trim().replace(/\/$/, '');
                const cleanToken = proxyToken ? proxyToken.trim() : null;
                const cleanAuth = authToken.trim();
                const target = `https://api.notion.com/v1${notionEndpoint}`;

                const fetchUrl = new URL(cleanWorkerUrl);
                fetchUrl.searchParams.append('url', target);
                if (cleanToken) fetchUrl.searchParams.append('token', cleanToken);

                const headers = { 'Authorization': `Bearer ${cleanAuth}`, 'Notion-Version': '2025-09-03' };
                if (!(body instanceof FormData)) {
                    headers['Content-Type'] = 'application/json';
                    body = body ? JSON.stringify(body) : null;
                }

                try {
                    const res = await fetch(fetchUrl.toString(), { method, headers, body });
                    if (!res.ok) {
                        const txt = await res.text();
                        let errorMsg = `API Error ${res.status}`;
                        try {
                            const json = JSON.parse(txt);
                            if (json.message) errorMsg = json.message;
                            else if (json.error && json.error.message) errorMsg = json.error.message;
                        } catch (e) {
                            if (txt && txt.length < 100) errorMsg += `: ${txt}`;
                        }
                        throw new Error(errorMsg);
                    }
                    return await res.json();
                } catch (e) {
                    if (e.name === 'TypeError' && e.message.includes('Failed to fetch')) {
                        if (!navigator.onLine) {
                            throw new Error("Network Error: You're offline.");
                        }
                        throw new Error("Network Error: Failed to reach proxy. Check Worker URL, CORS headers, or proxy token.");
                    }
                    throw e;
                }
            },
            uploadFileContent: async (uploadUrl, fileBlob) => {
                const { workerUrl, authToken, proxyToken } = Storage.getSettings();
                const cleanWorkerUrl = workerUrl.trim().replace(/\/$/, '');
                const fetchUrl = new URL(cleanWorkerUrl);
                fetchUrl.searchParams.append('url', uploadUrl);
                if (proxyToken) fetchUrl.searchParams.append('token', proxyToken);

                const formData = new FormData();
                formData.append("file", fileBlob, "photo.jpg");
                const headers = { 'Authorization': `Bearer ${authToken}`, 'Notion-Version': '2025-09-03' };

                const res = await fetch(fetchUrl.toString(), { method: 'POST', headers, body: formData });
                if (!res.ok) throw new Error(`Upload Failed`);
                return await res.json();
            },
            fetchDataSources: async (settings = null) => {
                let results = [];
                let hasMore = true;
                let nextCursor = undefined;
                while (hasMore) {
                    const payload = {
                        filter: { value: 'data_source', property: 'object' },
                        page_size: 100,
                        start_cursor: nextCursor
                    };
                    const res = await API.request('POST', '/search', payload, settings);
                    results = [...results, ...res.results];
                    hasMore = res.has_more;
                    nextCursor = res.next_cursor;
                    if (results.length > 300) hasMore = false;
                }
                return results;
            }
        };

        const SyncManager = {
            statusEl: null,
            tagSyncQueues: new Map(),
            tagSyncTimers: new Map(),
            retryTimers: new Map(),
            isSyncing: false,
            init: () => {
                SyncManager.statusEl = document.getElementById('syncStatus');
                window.addEventListener('online', SyncManager.syncCurrentDiary);
                if (App.state.activeDiaryId) SyncManager.syncCurrentDiary();
            },
            updateUI: (status) => {
                if (!SyncManager.statusEl) return;
                SyncManager.statusEl.classList.remove('hidden', 'flex');
                const textSpan = SyncManager.statusEl.querySelector('span:last-child');
                const dot = SyncManager.statusEl.querySelector('span:first-child');

                if (status === 'syncing') {
                    dot.className = "loader w-2 h-2 border-earth-metal";
                    textSpan.innerText = "Syncing...";
                } else if (status === 'offline') {
                    dot.className = "w-2 h-2 rounded-full bg-red-400";
                    textSpan.innerText = "Offline";
                } else if (status === 'synced') {
                    dot.className = "w-2 h-2 rounded-full bg-green-400";
                    textSpan.innerText = "Synced";
                    setTimeout(() => SyncManager.statusEl.classList.add('hidden'), 3000);
                } else {
                    dot.className = "w-2 h-2 rounded-full bg-red-600";
                    textSpan.innerText = "Error";
                }
            },

            fetchTags: async (silent = false) => {
                const diaryId = App.state.activeDiaryId;
                if (!diaryId) return;
                const diary = Storage.getData().find(d => d.id === diaryId);

                try {
                    if (!silent) App.showToast("Fetching tags...", "info");
                    const res = await API.request('GET', `/data_sources/${diary.dataSourceId}`);
                    const properties = res.properties || {};

                    if (properties["Tags"] && properties["Tags"].multi_select) {
                        const options = properties["Tags"].multi_select.options.map(o => o.name);
                        Storage.replaceDiaryTags(diaryId, options);
                        App.state.diaries = Storage.getData();
                        if (!silent) App.showToast(`Updated ${options.length} tags.`, "success");
                    }
                } catch (e) {
                    console.error("Tag fetch failed", e);
                    if (!silent) App.showToast("Could not fetch tags schema.", "error");
                }
            },
            queueTagSync: (diaryId, tag) => {
                if (!diaryId || !tag) return;
                const cleanTag = tag.trim();
                if (!cleanTag) return;
                const queue = SyncManager.tagSyncQueues.get(diaryId) || new Set();
                queue.add(cleanTag);
                SyncManager.tagSyncQueues.set(diaryId, queue);

                const existingTimer = SyncManager.tagSyncTimers.get(diaryId);
                if (existingTimer) clearTimeout(existingTimer);
                const timer = setTimeout(async () => {
                    SyncManager.tagSyncTimers.delete(diaryId);
                    const pending = Array.from(SyncManager.tagSyncQueues.get(diaryId) || []);
                    SyncManager.tagSyncQueues.delete(diaryId);
                    for (const pendingTag of pending) {
                        await SyncManager.addTagToNotion(diaryId, pendingTag);
                    }
                }, 400);
                SyncManager.tagSyncTimers.set(diaryId, timer);
            },
            scheduleRetry: (diaryId) => {
                if (!diaryId || !navigator.onLine) return;
                if (SyncManager.retryTimers.has(diaryId)) return;
                const timer = setTimeout(() => {
                    SyncManager.retryTimers.delete(diaryId);
                    SyncManager.syncCurrentDiary();
                }, 15000);
                SyncManager.retryTimers.set(diaryId, timer);
            },

            syncCurrentDiary: async () => {
                if (!navigator.onLine) { SyncManager.updateUI('offline'); return; }
                const diaryId = App.state.activeDiaryId;
                if (!diaryId) return;

                let diary = Storage.getData().find(d => d.id === diaryId);
                if (!diary || !diary.dataSourceId) return;
                if (SyncManager.isSyncing) return;
                SyncManager.isSyncing = true;

                SyncManager.updateUI('syncing');
                App.state.isLoading = true;
                App.renderDiaryView();

                try {
                    // 1. PUSH
                    const pendingIds = Storage.getPendingEntries(diaryId);
                    const pendingEntries = pendingIds.map(id => diary.entries.find(e => e.id === id)).filter(Boolean);
                    const unsynced = diary.entries.filter(e => !e.synced);
                    const pushQueue = [];
                    const pushSeen = new Set();
                    for (const item of [...pendingEntries, ...unsynced]) {
                        if (!item) continue;
                        const key = item.notionId ? `notion:${item.notionId}` : `local:${item.id}`;
                        if (pushSeen.has(key)) continue;
                        pushSeen.add(key);
                        pushQueue.push(item);
                    }
                    for (const entry of pushQueue) {
                        try {
                            // Ensure we push the high res if we have it, or the current local one
                            // Note: In saveEntry we now save LOW res to disk, but we should attempt to keep High Res in memory if possible?
                            // Actually, simplistic approach: if unsynced, just push what we have. 
                            // If user refreshed page, high res is gone, but local low res is better than nothing.
                            // Ideally app stays open.
                            const notionId = await SyncManager.pushEntryToNotion(diary.dataSourceId, entry);
                            Storage.updateEntrySyncStatus(diaryId, entry.id, true, notionId);
                            Storage.clearPendingEntry(diaryId, entry.id);
                            App.state.diaries = Storage.getData();
                        } catch (err) {
                            console.error("Failed to push entry", entry, err);
                            App.showToast(`Sync failed for entry "${entry.title}".`, "error");
                            Storage.queuePendingEntry(diaryId, entry.id);
                            SyncManager.scheduleRetry(diaryId);
                        }
                    }

                    // 2. PULL (Updated to Limit 25 & Process Images)
                    const fetchLimit = 25; // Reduced as requested
                    let payload = {
                        page_size: fetchLimit,
                        sorts: [{ property: 'Date', direction: 'descending' }]
                    };

                    const response = await API.request('POST', `/data_sources/${diary.dataSourceId}/query`, payload);

                    const currentData = Storage.getData();
                    const activeDiary = currentData.find(d => d.id === diaryId);

                    // We need to iterate and potentially fetch images
                    // Using for...of loop to handle async image processing sequentially/parallel-ish

                    for (const page of response.results) {
                        const localIndex = activeDiary.entries.findIndex(e => e.notionId === page.id);

                        const props = page.properties;
                        const getDate = (p) => p?.date?.start || UTILS.now();
                        const getTags = (p) => p?.multi_select?.map(x => x.name) || [];
                        const notesContent = props.Notes?.rich_text?.[0]?.plain_text || "";
                        const titleContent = props.Name?.title?.[0]?.plain_text || "(No Title)";

                        let notionPhotoUrl = null;
                        if (props.Files?.files?.length > 0) {
                            const f = props.Files.files[0];
                            notionPhotoUrl = f.file?.url || f.external?.url;
                        }

                        // Check if we need to download the image
                        let localPhotoData = null;
                        const existingEntry = localIndex > -1 ? activeDiary.entries[localIndex] : null;
                        let photoKey = existingEntry?.photoKey || null;
                        const entryId = existingEntry ? existingEntry.id : UTILS.id();

                        // If we have a local entry with a dataURL, keep it unless forced update (logic simplified here: keep local if exists)
                        if (existingEntry && existingEntry.photoDataURL && existingEntry.photoDataURL.startsWith('data:')) {
                            localPhotoData = existingEntry.photoDataURL;
                        }

                        // If no local photo but notion has one, fetch and compress it
                        if (!localPhotoData && !photoKey && notionPhotoUrl) {
                            try {
                                // Using the worker proxy to fetch image if needed to avoid strict CORS on signed URLs, 
                                // but usually signed S3 URLs are okay if origin is handled. 
                                // We'll try direct first, if that fails, we can't easily use the proxy for binary without encoding tweaks.
                                // Let's try UTILS.processImage directly on the URL.
                                const previewData = await UTILS.processImage(notionPhotoUrl, 640, 0.72);
                                if (ImageStore.isAvailable()) {
                                    const key = `entry_${entryId}_preview`;
                                    try {
                                        await ImageStore.set(key, UTILS.dataURLtoBlob(previewData));
                                        photoKey = key;
                                    } catch (storeErr) {
                                        if (storeErr?.isQuotaExceeded) {
                                            localPhotoData = previewData;
                                            App.showToast("Storage full; keeping preview in memory only.", "error");
                                        } else {
                                            throw storeErr;
                                        }
                                    }
                                } else {
                                    localPhotoData = previewData;
                                }
                            } catch (err) {
                                console.warn("Failed to download/process image from Notion", err);
                                // Avoid storing expiring signed URLs as permanent fallbacks.
                                localPhotoData = null;
                            }
                        }

                        const syncedEntry = {
                            id: entryId,
                            notionId: page.id,
                            date: getDate(props.Date),
                            title: titleContent,
                            notes: notesContent,
                            tags: getTags(props.Tags),
                            photoDataURL: localPhotoData,
                            photoKey: photoKey,
                            synced: true
                        };

                        if (localIndex > -1) {
                            activeDiary.entries[localIndex] = syncedEntry;
                        } else {
                            activeDiary.entries.push(syncedEntry);
                        }
                    }

                    // Sort and Limit
                    activeDiary.entries.sort((a, b) => new Date(b.date) - new Date(a.date));
                    if (activeDiary.entries.length > 25) {
                        activeDiary.entries = activeDiary.entries.slice(0, 25);
                    }

                    Storage.setData(currentData);
                    App.state.diaries = currentData;

                    SyncManager.updateUI('synced');
                    SyncManager.fetchTags(true);
                    SyncManager.syncPendingTags(diaryId);

                } catch (e) {
                    console.error("Sync Error", e);
                    SyncManager.updateUI('error');
                    if (e.message.includes("CORS") || e.message.includes("Network Error")) App.showToast(e.message, 'error');
                } finally {
                    App.state.isLoading = false;
                    App.renderDiaryView();
                    App.renderSidebar();
                    SyncManager.isSyncing = false;
                }
            },

            syncPendingTags: async (diaryId) => {
                const diary = Storage.getData().find(d => d.id === diaryId);
                const pending = diary?.pendingTags || [];
                for (const tag of pending) {
                    await SyncManager.addTagToNotion(diaryId, tag, { silent: true, fromQueue: true });
                }
            },

            addTagToNotion: async (diaryId, tag, options = {}) => {
                const diary = Storage.getData().find(d => d.id === diaryId);
                const cleanTag = tag ? tag.trim() : '';
                if (!diary || !diary.dataSourceId || !cleanTag) return;
                const normalized = UTILS.normalizeTag(cleanTag);

                try {
                    const res = await API.request('GET', `/data_sources/${diary.dataSourceId}`);
                    const properties = res.properties || {};
                    if (!properties["Tags"] || !properties["Tags"].multi_select) {
                        throw new Error("Tags property missing");
                    }

                    const currentOptions = properties["Tags"].multi_select.options.map(o => o.name);
                    const exists = currentOptions.some(t => UTILS.normalizeTag(t) === normalized);
                    const merged = exists ? currentOptions : [...currentOptions, cleanTag];
                    const unique = [];
                    const seen = new Set();
                    for (const name of merged) {
                        const key = UTILS.normalizeTag(name);
                        if (!key || seen.has(key)) continue;
                        seen.add(key);
                        unique.push({ name });
                    }

                    await API.request('PATCH', `/data_sources/${diary.dataSourceId}`, {
                        properties: { "Tags": { "multi_select": { "options": unique } } }
                    });

                    Storage.replaceDiaryTags(diaryId, unique.map(o => o.name));
                    Storage.clearPendingTag(diaryId, cleanTag);
                    App.state.diaries = Storage.getData();
                    if (!options.silent) App.showToast(`Added "${cleanTag}" tag in Notion.`, "success");
                } catch (e) {
                    console.error("Notion tag update failed", e);
                    if (!options.fromQueue) Storage.queuePendingTag(diaryId, cleanTag);
                    if (!options.silent) App.showToast("Couldn't update tags in Notion. Will retry later.", "error");
                }
            },

            pushEntryToNotion: async (dbId, entry) => {
                let uploadedFileId = null;

                // Prefer stored upload blob, then preview blob/data URL as fallback.
                const uploadBlob = await App.getUploadBlob(entry);
                if (uploadBlob) {
                    try {
                        const filename = UTILS.buildPhotoFilename(entry.diaryTitle || entry.title, entry.date, 'webp');
                        const initRes = await API.request('POST', '/file_uploads', {
                            "object": "file_upload", "filename": filename, "content_type": "image/webp"
                        });
                        await API.uploadFileContent(initRes.upload_url, uploadBlob);
                        uploadedFileId = initRes.id;
                    } catch (err) {
                        App.showToast("Image upload failed, saving text.", "error");
                    }
                }

                const titleToSend = entry.title || "Untitled Entry";

                const properties = {
                    "Name": { "title": [{ "text": { "content": titleToSend } }] },
                    "Date": { "date": { "start": entry.date } },
                    "Notes": { "rich_text": [{ "text": { "content": entry.notes } }] },
                    "Tags": { "multi_select": entry.tags.map(t => ({ "name": t })) }
                };

                if (uploadedFileId) {
                    properties["Files"] = { "files": [{ "type": "file_upload", "file_upload": { "id": uploadedFileId } }] };
                }

                const res = await API.request('POST', '/pages', {
                    parent: { data_source_id: dbId },
                    properties
                });
                return res.id;
            }
        };

        const App = {
            state: {
                diaries: [],
                activeDiaryId: null,
                stream: null,
                facingMode: 'environment',
                capturedImage: null, // Low res for UI
                capturedImageHighRes: null, // New: High res for upload
                captureBase: null,
                videoDims: { width: 0, height: 0 },
                currentTags: [],
                ghostMode: false,
                ghostImageObj: null,
                ghostImageUrl: null,
                ghostImageIsObjectUrl: false,
                ghostOpacity: 0.3,
                orientation: 'landscape',
                collageMode: 1,
                activeSegment: 0,
                segments: [],
                mirrorVideo: false,
                selectedDataSource: null,
                cachedDataSources: [],
                isLoading: false,
                imageUrlCache: new Map(),
                isEntryModalOpen: false,
                drawLoopHandle: null,
                entryLoading: false
            },
            getDiaryCameraConfig: (diary) => {
                const s = Storage.getSettings();
                const defaults = {
                    facingMode: 'environment',
                    mirrorVideo: false,
                    collageMode: s.collageMode || 1,
                    ghostOpacity: s.ghostOpacity || 0.3,
                    ghostMode: false
                };
                if (!diary) return defaults;
                const cfg = diary.cameraConfig || {};
                return {
                    facingMode: cfg.facingMode || defaults.facingMode,
                    mirrorVideo: typeof cfg.mirrorVideo === 'boolean' ? cfg.mirrorVideo : defaults.mirrorVideo,
                    collageMode: Number(cfg.collageMode) || defaults.collageMode,
                    ghostOpacity: typeof cfg.ghostOpacity === 'number' ? cfg.ghostOpacity : defaults.ghostOpacity,
                    ghostMode: typeof cfg.ghostMode === 'boolean' ? cfg.ghostMode : defaults.ghostMode
                };
            },
            applyDiaryCameraConfig: (diary) => {
                const cfg = App.getDiaryCameraConfig(diary);
                App.state.facingMode = cfg.facingMode;
                App.state.mirrorVideo = cfg.mirrorVideo;
                App.state.ghostOpacity = cfg.ghostOpacity;
                App.state.ghostMode = cfg.ghostMode;
                App.setCollageMode(cfg.collageMode);
            },
            persistActiveDiaryCameraConfig: (config) => {
                if (!App.state.activeDiaryId) return;
                Storage.updateDiaryCameraConfig(App.state.activeDiaryId, config);
                App.state.diaries = Storage.getData();
            },
            tagMatch: (list, tag) => list.find(t => UTILS.normalizeTag(t) === UTILS.normalizeTag(tag)),
            hasTag: (list, tag) => !!App.tagMatch(list, tag),
            getUploadCapBytes: () => {
                const s = Storage.getSettings();
                const mb = Number(s.uploadCapMb) || 5;
                return mb * 1024 * 1024;
            },
            getMaxUploadPixels: () => {
                const capMb = Number(Storage.getSettings().uploadCapMb) || 5;
                return capMb >= 20 ? 32000000 : 16000000;
            },
            getTargetBaseDimensions: () => {
                if (App.state.orientation === 'portrait') {
                    return { width: 1920, height: 2560 };
                }
                return { width: 2560, height: 1920 };
            },
            getMaxCropDimensions: (videoW, videoH, ratio) => {
                if (!videoW || !videoH) return null;
                const srcRatio = videoW / videoH;
                if (srcRatio > ratio) {
                    const h = videoH;
                    const w = Math.round(h * ratio);
                    return { width: w, height: h };
                }
                const w = videoW;
                const h = Math.round(w / ratio);
                return { width: w, height: h };
            },
            getBaseDimensions: (videoW, videoH) => {
                const target = App.getTargetBaseDimensions();
                const ratio = target.width / target.height;
                const maxFromVideo = App.getMaxCropDimensions(videoW, videoH, ratio);
                if (!maxFromVideo) return target;
                return {
                    width: Math.min(target.width, maxFromVideo.width),
                    height: Math.min(target.height, maxFromVideo.height)
                };
            },
            getFinalCanvasDimensions: (baseW, baseH, multW, multH) => {
                let W = baseW * multW;
                let H = baseH * multH;
                const maxPixels = App.getMaxUploadPixels();
                const totalPixels = W * H;
                if (totalPixels > maxPixels) {
                    const scale = Math.sqrt(maxPixels / totalPixels);
                    W = Math.max(1, Math.round(W * scale));
                    H = Math.max(1, Math.round(H * scale));
                }
                return { width: W, height: H };
            },
            getVideoConstraints: () => {
                const target = App.getTargetBaseDimensions();
                return {
                    facingMode: App.state.facingMode,
                    width: { ideal: target.width },
                    height: { ideal: target.height },
                    aspectRatio: { ideal: target.width / target.height }
                };
            },
            clearImageUrlCache: () => {
                App.state.imageUrlCache.forEach((val) => {
                    if (val && val.isObjectUrl) URL.revokeObjectURL(val.src);
                });
                App.state.imageUrlCache.clear();
            },
            revokeEntryImageCache: (entryId) => {
                const cached = App.state.imageUrlCache.get(entryId);
                if (cached && cached.isObjectUrl) URL.revokeObjectURL(cached.src);
                App.state.imageUrlCache.delete(entryId);
            },
            setEntryLoading: (isLoading, message = "Processing...") => {
                App.state.entryLoading = isLoading;
                const overlay = document.getElementById('entryLoadingOverlay');
                const text = document.getElementById('entryLoadingText');
                if (text) text.innerText = message;
                if (overlay) {
                    overlay.classList.toggle('hidden', !isLoading);
                    overlay.classList.toggle('flex', isLoading);
                }
                const saveBtn = document.getElementById('saveEntryBtn');
                const captureBtn = document.getElementById('captureBtn');
                if (saveBtn) {
                    if (isLoading) {
                        saveBtn.dataset.wasDisabled = saveBtn.disabled ? "1" : "0";
                        saveBtn.disabled = true;
                    } else {
                        if (saveBtn.dataset.wasDisabled === "0") saveBtn.disabled = false;
                        delete saveBtn.dataset.wasDisabled;
                    }
                }
                if (captureBtn) {
                    if (isLoading) {
                        captureBtn.dataset.wasDisabled = captureBtn.disabled ? "1" : "0";
                        captureBtn.disabled = true;
                    } else {
                        if (captureBtn.dataset.wasDisabled === "0") captureBtn.disabled = false;
                        delete captureBtn.dataset.wasDisabled;
                    }
                }
            },
            hasUnsavedEntry: () => {
                if (!App.state.isEntryModalOpen) return false;
                const title = document.getElementById('entryTitle')?.value?.trim() || '';
                const notes = document.getElementById('entryNotes')?.value?.trim() || '';
                const hasSegments = Array.isArray(App.state.segments) && App.state.segments.some(Boolean);
                return !!(App.state.capturedImage || hasSegments || App.state.currentTags.length || title || notes);
            },
            startDrawLoop: () => {
                if (App.state.drawLoopHandle) return;
                App.state.drawLoopHandle = requestAnimationFrame(App.drawLoop);
            },
            stopDrawLoop: () => {
                if (App.state.drawLoopHandle) {
                    cancelAnimationFrame(App.state.drawLoopHandle);
                    App.state.drawLoopHandle = null;
                }
            },
            loadEntryImage: async (entry) => {
                if (!entry) return null;
                if (entry.photoDataURL) return { src: entry.photoDataURL, isObjectUrl: false };
                if (entry.photoKey && ImageStore.isAvailable()) {
                    try {
                        const blob = await ImageStore.get(entry.photoKey);
                        if (blob) {
                            return { src: URL.createObjectURL(blob), isObjectUrl: true };
                        }
                    } catch (e) {
                    }
                }
                return null;
            },
            loadEntryImages: async (entries) => {
                App.clearImageUrlCache();
                const results = await Promise.all(entries.map(async (entry) => {
                    const res = await App.loadEntryImage(entry);
                    if (res) App.state.imageUrlCache.set(entry.id, res);
                    return { id: entry.id, src: res?.src || null };
                }));
                const map = new Map();
                results.forEach(r => map.set(r.id, r.src));
                return map;
            },
            getUploadBlob: async (entry) => {
                if (!entry) return null;
                if (entry.uploadKey && ImageStore.isAvailable()) {
                    try {
                        const blob = await ImageStore.get(entry.uploadKey);
                        if (blob) return blob;
                    } catch (e) {
                    }
                }
                if (entry.photoKey && ImageStore.isAvailable()) {
                    try {
                        const blob = await ImageStore.get(entry.photoKey);
                        if (blob) return blob;
                    } catch (e) {
                    }
                }
                if (entry.uploadDataURL && entry.uploadDataURL.startsWith('data:')) {
                    return UTILS.dataURLtoBlob(entry.uploadDataURL);
                }
                if (entry.photoDataURL && entry.photoDataURL.startsWith('data:')) {
                    return UTILS.dataURLtoBlob(entry.photoDataURL);
                }
                return null;
            },
            migratePhotoStorage: async () => {
                if (!ImageStore.isAvailable()) return;
                const data = Storage.getData();
                let changed = false;
                for (const diary of data) {
                    for (const entry of diary.entries || []) {
                        if (entry.photoDataURL && entry.photoDataURL.startsWith('data:') && !entry.photoKey) {
                            const key = `entry_${entry.id}_preview`;
                            try {
                                await ImageStore.set(key, UTILS.dataURLtoBlob(entry.photoDataURL));
                                entry.photoKey = key;
                                delete entry.photoDataURL;
                                changed = true;
                            } catch (e) {
                            }
                        }
                        if (entry.uploadDataURL && entry.uploadDataURL.startsWith('data:') && !entry.uploadKey) {
                            const key = `entry_${entry.id}_upload`;
                            try {
                                await ImageStore.set(key, UTILS.dataURLtoBlob(entry.uploadDataURL));
                                entry.uploadKey = key;
                                delete entry.uploadDataURL;
                                changed = true;
                            } catch (e) {
                            }
                        }
                    }
                }
                if (changed) Storage.setData(data);
                App.state.diaries = data;
            },

            collageConfigs: {
                1: [{ x: 0, y: 0, w: 1, h: 1 }],
                2: [{ x: 0, y: 0, w: 0.5, h: 1 }, { x: 0.5, y: 0, w: 0.5, h: 1 }],
                3: [{ x: 0, y: 0, w: 0.3333, h: 1 }, { x: 0.3333, y: 0, w: 0.3333, h: 1 }, { x: 0.6666, y: 0, w: 0.3334, h: 1 }],
                4: [{ x: 0, y: 0, w: 0.5, h: 0.5 }, { x: 0.5, y: 0, w: 0.5, h: 0.5 }, { x: 0, y: 0.5, w: 0.5, h: 0.5 }, { x: 0.5, y: 0.5, w: 0.5, h: 0.5 }],
                5: [{ x: 0, y: 0, w: 1, h: 0.5 }, { x: 0, y: 0.5, w: 1, h: 0.5 }],
                6: [{ x: 0, y: 0, w: 1, h: 0.3333 }, { x: 0, y: 0.3333, w: 1, h: 0.3333 }, { x: 0, y: 0.6666, w: 1, h: 0.3334 }],
                7: [{ x: 0.25, y: 0, w: 0.5, h: 0.5 }, { x: 0, y: 0.5, w: 0.5, h: 0.5 }, { x: 0.5, y: 0.5, w: 0.5, h: 0.5 }]
            },

            init: () => {
                lucide.createIcons();
                App.state.diaries = Storage.getData();
                App.renderSidebar();
                App.migratePhotoStorage().then(() => {
                    App.state.diaries = Storage.getData();
                    App.renderSidebar();
                    App.renderDiaryView();
                });

                const s = Storage.getSettings();
                App.state.orientation = s.orientation || 'landscape';
                App.state.collageMode = s.collageMode || 1;
                App.state.ghostOpacity = s.ghostOpacity || 0.3;

                const oBtn = document.getElementById('orientationBtn');
                if (oBtn) {
                    const iconName = App.state.orientation === 'landscape' ? 'rectangle-horizontal' : 'rectangle-vertical';
                    oBtn.innerHTML = `<i data-lucide="${iconName}" class="w-6 h-6"></i>`;
                    lucide.createIcons();
                }

                const urlParams = new URLSearchParams(window.location.search);
                const newAuth = urlParams.get('accessToken');

                if (newAuth) {
                    const settings = Storage.getSettings();
                    const newSettings = { ...settings, authToken: newAuth };
                    Storage.setSettings(newSettings);
                    window.history.replaceState({}, document.title, window.location.pathname);
                    App.showToast(`Connected! Scanning data sources...`, 'success');
                    if (newSettings.workerUrl) App.scanForDataSources(newSettings);
                }

                if (App.state.diaries.length > 0) {
                    const lastDiaryId = Storage.getLastActiveDiaryId();
                    const hasLast = lastDiaryId && App.state.diaries.some(diary => diary.id === lastDiaryId);
                    const fallbackId = window.innerWidth < 768 ? App.state.diaries[0].id : null;
                    const diaryToSelect = hasLast ? lastDiaryId : fallbackId;
                    if (diaryToSelect) {
                        App.selectDiary(diaryToSelect);
                    } else {
                        App.renderWelcomeState();
                    }
                } else {
                    App.renderWelcomeState();
                }

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        const modals = ['settingsModal', 'newDiaryModal', 'workerHelpModal', 'deleteModal', 'entryModal'];
                        for (const id of modals) {
                            const el = document.getElementById(id);
                            if (el && !el.classList.contains('hidden')) {
                                const closed = App.closeModal(id);
                                if (!closed) return;
                            }
                        }
                        document.getElementById('mobileDiaryMenu').classList.add('hidden');
                    }
                });

                document.addEventListener('click', (e) => {
                    const dropdown = document.getElementById('dbDropdownList');
                    const input = document.getElementById('dbSearchInput');
                    if (dropdown && !dropdown.classList.contains('hidden') && !dropdown.contains(e.target) && e.target !== input) {
                        dropdown.classList.add('hidden');
                    }
                    const mobMenu = document.getElementById('mobileDiaryMenu');
                    const isBtn = e.target.closest('#mobileDiaryToggleBtn');
                    const isMenu = e.target.closest('#mobileDiaryMenu');
                    if (mobMenu && !mobMenu.classList.contains('hidden') && !isMenu && !isBtn) {
                        mobMenu.classList.add('hidden');
                    }
                });

                SyncManager.init();
            },

            isValidChronicleSource: (props) => {
                if (!props['Name'] || props['Name'].type !== 'title') return false;
                if (!props['Tags'] || props['Tags'].type !== 'multi_select') return false;
                if (!props['Date'] || props['Date'].type !== 'date') return false;
                if (!props['Notes'] || props['Notes'].type !== 'rich_text') return false;
                if (!props['Files'] || props['Files'].type !== 'files') return false;
                return true;
            },

            scanForDataSources: async (settings = null) => {
                const btn = document.getElementById('refreshDbBtn');
                if (btn) {
                    const icon = btn.querySelector('svg');
                    if (icon) icon.classList.add('animate-spin');
                }
                App.state.cachedDataSources = [];
                try {
                    const allSources = await API.fetchDataSources(settings);
                    const validSources = allSources
                        .filter(src => App.isValidChronicleSource(src.properties))
                        .map(src => ({
                            id: src.id,
                            title: src.title?.[0]?.plain_text || "Untitled Data Source",
                            description: src.description?.[0]?.plain_text || ""
                        }));
                    Storage.setCachedDataSources(validSources);
                    App.state.cachedDataSources = validSources;
                    if (document.getElementById('newDiaryModal').classList.contains('flex')) {
                        App.renderDbDropdownItems(validSources);
                    }
                    if (!settings) App.showToast(`Found ${validSources.length} compatible data sources.`, "success");
                } catch (e) {
                    console.error(e);
                    App.showToast("Failed to fetch data sources", "error");
                } finally {
                    if (btn) {
                        const icon = btn.querySelector('svg');
                        if (icon) icon.classList.remove('animate-spin');
                    }
                }
            },

            toggleDbDropdown: (forceShow = null) => {
                const list = document.getElementById('dbDropdownList');
                if (forceShow === true) list.classList.remove('hidden');
                else if (forceShow === false) list.classList.add('hidden');
                else list.classList.toggle('hidden');
                if (!list.classList.contains('hidden') && document.getElementById('dbSearchInput').value === '') {
                    App.renderDbDropdownItems(App.state.cachedDataSources);
                }
            },

            filterDbList: (e) => {
                const term = e.target.value.toLowerCase();
                const filtered = App.state.cachedDataSources.filter(db => db.title.toLowerCase().includes(term));
                App.renderDbDropdownItems(filtered);
                App.toggleDbDropdown(true);
            },

            renderDbDropdownItems: (dbs) => {
                const list = document.getElementById('dbDropdownList');
                list.innerHTML = '';
                const usedIds = App.state.diaries.map(d => d.dataSourceId);
                const availableDbs = dbs.filter(db => !usedIds.includes(db.id));
                if (availableDbs.length === 0) {
                    list.innerHTML = `<div class="p-4 text-center text-xs text-earth-metal/50">No data sources found.</div>`;
                    return;
                }
                availableDbs.forEach(db => {
                    const el = document.createElement('div');
                    el.className = "p-3 border-b border-oatmeal-dark last:border-0 hover:bg-white-linen cursor-pointer transition-colors flex flex-col gap-1";
                    el.onclick = () => App.selectDataSource(db);
                    el.innerHTML = `
                        <div class="flex items-center justify-between">
                            <span class="font-bold text-sm text-charcoal">${db.title}</span>
                        </div>
                        ${db.description ? `<div class="text-[10px] text-earth-metal/60 truncate">${db.description}</div>` : ''}
                    `;
                    list.appendChild(el);
                });
            },

            selectDataSource: (db) => {
                App.state.selectedDataSource = db;
                const input = document.getElementById('dbSearchInput');
                input.value = db.title;
                const infoBox = document.getElementById('selectedDbInfo');
                document.getElementById('previewDbTitle').innerText = db.title;
                document.getElementById('previewDbDesc').innerText = db.description || "No description";
                infoBox.classList.remove('hidden');
                App.toggleDbDropdown(false);
            },

            attemptNewDiary: () => {
                App.state.selectedDataSource = null;
                document.getElementById('dbSearchInput').value = '';
                document.getElementById('selectedDbInfo').classList.add('hidden');
                const s = Storage.getSettings();
                if (!s.workerUrl || !s.authToken) {
                    App.showToast("Please connect to Notion first.", "error");
                    App.openModal('settingsModal');
                } else {
                    App.openModal('newDiaryModal');
                    const cached = Storage.getCachedDataSources();
                    App.state.cachedDataSources = cached;
                    if (cached.length > 0) {
                        App.renderDbDropdownItems(cached);
                    } else {
                        App.scanForDataSources();
                    }
                }
            },

            createDiary: async () => {
                if (!App.state.selectedDataSource) return App.showToast("Please select a data source.", "error");
                const db = App.state.selectedDataSource;
                const newDiary = {
                    id: UTILS.id(),
                    title: db.title,
                    dataSourceId: db.id,
                    description: db.description,
                    tags: [],
                    pendingTags: [],
                    entries: [],
                    cameraConfig: {
                        facingMode: App.state.facingMode,
                        mirrorVideo: App.state.mirrorVideo,
                        collageMode: App.state.collageMode
                    }
                };
                Storage.saveDiary(newDiary);
                App.state.diaries = Storage.getData();
                App.closeModal('newDiaryModal');
                App.selectDiary(newDiary.id);
                App.showToast("Diary Created!", "success");
            },

            resetApp: () => {
                App.openModal('resetConfirmationModal');
            },

            executeReset: async () => {
                try {
                    ['chronicles_settings', 'chronicles_data', 'chronicles_ds_cache'].forEach(k => localStorage.removeItem(k));
                    await clearPwaData();
                    window.location.href = window.location.pathname;
                } catch (e) {
                    console.error(e);
                    App.showToast("Failed to clear storage automatically. Please clear browser cache.", "error");
                }
            },

            toggleMobileDiaryMenu: (e) => {
                if (e) e.stopPropagation();
                const menu = document.getElementById('mobileDiaryMenu');
                const list = document.getElementById('mobileDiaryList');
                if (menu.classList.contains('hidden')) {
                    menu.classList.remove('hidden');
                    list.innerHTML = '';
                    if (App.state.diaries.length === 0) {
                        list.innerHTML = `<div class="p-4 text-center text-xs text-earth-metal/40 font-display">No diaries yet.</div>`;
                    } else {
                        App.state.diaries.forEach(diary => {
                            const isActive = diary.id === App.state.activeDiaryId;
                            const div = document.createElement('div');
                            div.className = `p-3 cursor-pointer flex items-center justify-between mb-0.5 border-l-2 font-display text-sm ${isActive ? 'bg-oatmeal border-dull-purple font-semibold text-charcoal' : 'border-transparent hover:bg-oatmeal hover:border-oatmeal-dark text-earth-metal'}`;
                            div.onclick = () => {
                                App.selectDiary(diary.id);
                                menu.classList.add('hidden');
                            };
                            div.innerHTML = `<span>${diary.title}</span> ${isActive ? '<i data-lucide="check" class="w-4 h-4 text-dull-purple"></i>' : ''}`;
                            list.appendChild(div);
                        });
                        lucide.createIcons();
                    }
                } else {
                    menu.classList.add('hidden');
                }
            },

            showToast: (message, type = 'info') => {
                const container = document.getElementById('toastContainer');
                const el = document.createElement('div');
                let bg = type === 'success' ? 'bg-white-linen border-dull-purple' : (type === 'error' ? 'bg-white-linen border-red-600' : 'bg-white-linen border-charcoal');
                let icon = type === 'success' ? 'check-circle' : (type === 'error' ? 'alert-circle' : 'info');
                el.className = `toast-enter pointer-events-auto p-4 flex gap-3 text-sm ${bg} border-l-2 transition-all font-display`;
                el.innerHTML = `<i data-lucide="${icon}" class="w-5 h-5 mt-0.5"></i><div class="flex-1">${message}</div>`;
                container.appendChild(el);
                lucide.createIcons();
                let timeout = type === 'error' ? 3000 : 1500;
                setTimeout(() => { el.classList.add('toast-exit'); setTimeout(() => el.remove(), 300); }, timeout);
            },

            renderSidebar: () => {
                const container = document.getElementById('diaryListContainer');
                container.innerHTML = '';
                if (App.state.diaries.length === 0) {
                    container.innerHTML = `<div class="text-xs text-center text-earth-metal/40 mt-4 font-display">No diaries yet.</div>`;
                    return;
                }
                App.state.diaries.forEach(diary => {
                    const isActive = diary.id === App.state.activeDiaryId;
                    const div = document.createElement('div');
                    const count = diary.entries.length;
                    const countDisplay = count > 50 ? "50+" : count;
                    div.className = `p-3 cursor-pointer flex flex-col gap-0.5 transition-colors border-l-2 ${isActive ? 'bg-white-linen border-dull-purple' : 'border-transparent hover:bg-oatmeal-dark/30 hover:border-oatmeal-dark'}`;
                    div.onclick = () => App.selectDiary(diary.id);
                    div.innerHTML = `
                        <div class="font-display font-medium text-sm text-charcoal truncate">${diary.title}</div>
                        <div class="text-[9px] text-earth-metal/50 font-display uppercase tracking-wide">${countDisplay} entries</div>
                    `;
                    container.appendChild(div);
                });
            },

            renderWelcomeState: () => {
                const gallery = document.getElementById('entryGallery');
                const s = Storage.getSettings();
                const isConnected = s.workerUrl && s.authToken;
                const hasDiaries = App.state.diaries.length > 0;
                if (!isConnected) {
                    gallery.innerHTML = `
                        <div class="h-full flex flex-col items-center justify-center text-center gap-4">
                            <div class="bg-dull-purple p-4"><i data-lucide="plug" class="w-8 h-8 text-white-linen"></i></div>
                            <div>
                                <h3 class="font-display text-xl font-semibold text-charcoal mb-2 tracking-tight">Welcome to Photo Chronicles</h3>
                                <p class="welcome-blurb max-w-md mx-auto mb-3">Photo Chronicles is your cozy, camera-first diary that turns daily snaps into a living timeline—auto-sorted, timestamped, and synced privately to Notion so memories stay safe and easy to revisit.</p>
                                <p class="text-earth-metal/50 max-w-xs mx-auto mb-6 text-sm">Connect your Notion workspace to start tracking.</p>
                                <button onclick="App.openModal('settingsModal')" class="bg-charcoal text-white-linen px-6 py-3 font-display font-medium hover:bg-dull-purple transition">Connect to Notion</button>
                            </div>
                        </div>`;
                } else if (!hasDiaries) {
                    gallery.innerHTML = `
                        <div class="h-full flex flex-col items-center justify-center text-center gap-4">
                            <div class="bg-muted-pink p-4"><i data-lucide="book-plus" class="w-8 h-8 text-white-linen"></i></div>
                            <div>
                                <h3 class="font-display text-xl font-semibold text-charcoal mb-2 tracking-tight">You're Connected!</h3>
                                <p class="text-earth-metal/50 max-w-xs mx-auto mb-6 text-sm">Create your first diary to link a Notion data source.</p>
                                <button onclick="App.attemptNewDiary()" class="bg-charcoal text-white-linen px-6 py-3 font-display font-medium hover:bg-dull-purple transition">Create First Diary</button>
                            </div>
                        </div>`;
                } else {
                    gallery.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-center text-earth-metal/50"><i data-lucide="book-open" class="w-10 h-10 mb-4 opacity-40"></i><p class="font-display">Select a diary.</p></div>`;
                }
                lucide.createIcons();
            },

            renderDiaryView: async () => {
                const diary = App.state.diaries.find(d => d.id === App.state.activeDiaryId);
                const gallery = document.getElementById('entryGallery');
                const title = document.getElementById('activeDiaryTitle');

                if (!diary) return;
                title.innerText = diary.title;

                if (App.state.isLoading && diary.entries.length === 0) {
                    gallery.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-center text-earth-metal/60">
                        <div class="loader w-8 h-8 border-4 border-dull-purple border-t-transparent rounded-full mb-4"></div>
                        <p>Loading entries...</p>
                    </div>`;
                    App.clearImageUrlCache();
                    return;
                }

                if (diary.entries.length === 0) {
                    gallery.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-center text-earth-metal/60"><i data-lucide="camera" class="w-12 h-12 mb-4 opacity-50"></i><p>Empty.</p></div>`;
                    lucide.createIcons();
                    App.clearImageUrlCache();
                    return;
                }

                // Limit to 25 entries display if more exist (safety)
                const displayEntries = diary.entries.slice(0, 25);
                const imageMap = await App.loadEntryImages(displayEntries);

                // Clear gallery after async work to prevent race condition duplicates
                gallery.innerHTML = '';

                // Updated Denser Grid
                const grid = document.createElement('div');
                grid.className = "grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3";

                displayEntries.forEach(entry => {
                    const card = document.createElement('div');
                    card.className = "entry-card relative group bg-white-linen overflow-hidden border border-oatmeal-dark flex flex-col";

                    const imgSrc = imageMap.get(entry.id);
                    const imgHtml = imgSrc
                        ? `<img src="${imgSrc}" class="w-full aspect-square object-cover bg-oatmeal" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNjY2MiIHN0cm9rZS13aWR0aD0iMiI+PHJlY3QgeD0iMyIgeT0iMyIgd2lkdGg9IjE4IiBoZWlnaHQ9IjE4IiByeD0iMiIgcnk9IjIiPjwvcmVjdD48Y2lyY2xlIGN4PSI4LjUiIGN5PSI4LjUiIHI9IjEuNSI+PC9jaXJjbGU+PHBvbHlsaW5lIHBvaW50cz0iMjEgMTUgMTYgMTAgNSAyMSI+PC9wb2x5bGluZT48L3N2Zz4n">`
                        : `<div class="w-full aspect-square bg-oatmeal flex items-center justify-center text-earth-metal/30"><i data-lucide="image-off"></i></div>`;

                    const dispTitle = entry.title || "Untitled";

                    const deleteBtn = `
                        <div class="absolute top-1 right-1 opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-opacity z-10">
                            <button onclick="event.stopPropagation(); App.confirmDelete('${diary.id}', '${entry.id}')" class="bg-white-linen hover:bg-muted-pink hover:text-white-linen text-muted-pink-dim p-1.5 transition">
                                <i data-lucide="trash-2" class="w-3 h-3"></i>
                            </button>
                        </div>
                    `;

                    card.innerHTML = `
                        ${deleteBtn}
                        ${imgHtml}
                        <div class="p-2.5 flex flex-col gap-1">
                            <div class="flex justify-between items-center">
                                <span class="text-[9px] font-display text-earth-metal/50 truncate uppercase tracking-wide">${UTILS.formatDate(entry.date)}</span>
                                <div class="w-1.5 h-1.5 ${entry.synced ? 'bg-dull-purple' : 'bg-muted-pink'}" title="${entry.synced ? 'Synced' : 'Local'}"></div>
                            </div>
                            <h4 class="font-display font-semibold text-xs text-charcoal truncate leading-tight">${dispTitle}</h4>
                        </div>
                    `;
                    grid.appendChild(card);
                });
                gallery.appendChild(grid);

                const footerMsg = diary.entries.length >= 25
                    ? "Showing last 25 entries. (Thumbnails only - check Notion for full quality)"
                    : "End of entries. (Thumbnails only - check Notion for full quality)";
                let footer = document.createElement('div');
                footer.id = 'galleryFooter';
                footer.className = "text-center text-[10px] text-earth-metal/40 py-8 font-display uppercase tracking-wide";
                footer.innerText = footerMsg;
                gallery.appendChild(footer);

                lucide.createIcons();
            },

            selectDiary: (id) => {
                App.state.activeDiaryId = id;
                Storage.setLastActiveDiaryId(id);
                const diary = App.state.diaries.find(d => d.id === id);
                if (diary) {
                    App.applyDiaryCameraConfig(diary);
                }
                App.renderSidebar();
                App.renderDiaryView();
                SyncManager.syncCurrentDiary();
            },

            initNewEntry: async () => {
                App.state.currentTags = [];
                App.state.capturedImage = null;
                App.state.capturedImageHighRes = null; // Reset High Res
                App.state.captureBase = null;
                App.state.activeSegment = 0;
                App.state.segments = [];
                App.state.ghostImageObj = null;
                if (App.state.ghostImageIsObjectUrl && App.state.ghostImageUrl) {
                    URL.revokeObjectURL(App.state.ghostImageUrl);
                }
                App.state.ghostImageUrl = null;
                App.state.ghostImageIsObjectUrl = false;

                document.getElementById('entryNotes').value = '';
                document.getElementById('entryTitle').value = '';
                document.getElementById('entryDate').value = UTILS.toLocalISO(new Date());
                document.getElementById('activeTags').innerHTML = '';
                document.getElementById('tagInput').value = '';
                document.getElementById('saveEntryBtn').disabled = true;
                document.getElementById('mirrorToggleBtn').classList.add('hidden');

                document.getElementById('takenPhotoUI').classList.remove('flex');
                document.getElementById('takenPhotoUI').classList.add('hidden');
                document.getElementById('cameraSection').classList.remove('hidden');
                document.getElementById('imageManipControls').classList.add('hidden');

                const diary = App.state.diaries.find(d => d.id === App.state.activeDiaryId);
                if (!diary) return App.showToast("Create a diary first.", "error");
                App.applyDiaryCameraConfig(diary);

                const toggleBtn = document.getElementById('ghostToggleBtn');
                const lastEntryWithPhoto = diary.entries.find(e => e.photoDataURL || e.photoKey);
                const ghostImg = document.getElementById('ghostOverlay');
                const ghostCfg = App.getDiaryCameraConfig(diary);
                App.state.ghostOpacity = ghostCfg.ghostOpacity;
                App.state.ghostMode = ghostCfg.ghostMode;

                if (lastEntryWithPhoto) {
                    const ghostData = await App.loadEntryImage(lastEntryWithPhoto);
                    if (!ghostData) {
                        toggleBtn.classList.add('hidden');
                        App.state.ghostMode = false;
                        ghostImg.src = '';
                        App.state.ghostImageUrl = null;
                        App.state.ghostImageIsObjectUrl = false;
                        ghostImg.style.opacity = '0';
                        ghostImg.classList.add('opacity-0');
                        document.getElementById('ghostSliderContainer').classList.add('hidden');
                    } else {
                        ghostImg.src = ghostData.src;
                        App.state.ghostImageUrl = ghostData.src;
                        App.state.ghostImageIsObjectUrl = !!ghostData.isObjectUrl;
                        toggleBtn.classList.remove('hidden');
                        if (App.state.ghostMode) {
                            toggleBtn.classList.remove('opacity-50');
                        } else {
                            toggleBtn.classList.add('opacity-50');
                        }
                        const savedOpacity = App.state.ghostOpacity;
                        if (App.state.ghostMode) {
                            ghostImg.classList.remove('opacity-0');
                            ghostImg.style.opacity = savedOpacity;
                        } else {
                            ghostImg.classList.add('opacity-0');
                            ghostImg.style.opacity = '0';
                        }
                        const sliderInput = document.querySelector('#ghostSliderContainer input');
                        if (sliderInput) sliderInput.value = savedOpacity;
                        document.getElementById('ghostSliderContainer').classList.add('hidden');
                        const img = new Image();
                        img.onload = () => { App.state.ghostImageObj = img; };
                        img.src = ghostData.src;
                    }
                } else {
                    toggleBtn.classList.add('hidden');
                    App.state.ghostMode = false;
                    ghostImg.src = '';
                    App.state.ghostImageUrl = null;
                    App.state.ghostImageIsObjectUrl = false;
                    ghostImg.style.opacity = '0';
                    ghostImg.classList.add('opacity-0');
                    document.getElementById('ghostSliderContainer').classList.add('hidden');
                }

                App.openModal('entryModal');
                SyncManager.fetchTags(true);
            },

            setCollageMode: (mode) => {
                App.state.collageMode = mode;
                App.state.activeSegment = 0;
                App.state.segments = [];
                App.persistActiveDiaryCameraConfig({ collageMode: mode });
                document.querySelectorAll('.collage-btn').forEach(btn => {
                    btn.classList.add('bg-white/20', 'hover:bg-white/10');
                    btn.classList.remove('bg-white', 'text-black');
                });
                const modeToIdx = { 1: 0, 2: 1, 5: 2, 3: 3, 6: 4, 7: 5, 4: 6 };
                const btns = document.querySelectorAll('.collage-btn');
                const targetBtn = btns[modeToIdx[mode]];
                if (targetBtn) {
                    targetBtn.classList.remove('bg-white/20', 'hover:bg-white/10');
                    targetBtn.classList.add('bg-white', 'text-black');
                }

                const segInd = document.getElementById('segmentIndicator');
                if (mode > 1) {
                    segInd.classList.remove('hidden');
                    document.getElementById('segTotal').innerText = App.collageConfigs[mode].length;
                    document.getElementById('segCurrent').innerText = 1;
                } else {
                    segInd.classList.add('hidden');
                }
                document.getElementById('collageMenu').classList.add('hidden');
                document.getElementById('collageMenu').classList.remove('flex');
                let label = "1x";
                if (mode === 2) label = "2x →";
                if (mode === 3) label = "3x →";
                if (mode === 4) label = "4x";
                if (mode === 5) label = "2x ↓";
                if (mode === 6) label = "3x ↓";
                if (mode === 7) label = "3x 1/2";
                document.getElementById('gridBtn').innerText = label;
            },

            toggleCollageMenu: () => {
                const menu = document.getElementById('collageMenu');
                if (menu.classList.contains('hidden')) {
                    menu.classList.remove('hidden');
                    menu.classList.add('flex');
                } else {
                    menu.classList.add('hidden');
                    menu.classList.remove('flex');
                }
            },

            toggleOrientation: () => {
                const current = App.state.orientation;
                const next = current === 'landscape' ? 'portrait' : 'landscape';
                App.state.orientation = next;
                const s = Storage.getSettings();
                s.orientation = next;
                Storage.setSettings(s);
                const btn = document.getElementById('orientationBtn');
                if (btn) {
                    const iconName = next === 'landscape' ? 'rectangle-horizontal' : 'rectangle-vertical';
                    btn.innerHTML = `<i data-lucide="${iconName}" class="w-6 h-6"></i>`;
                    lucide.createIcons();
                }
            },

            pointers: new Map(),
            interactionTarget: null,
            prevPinchDist: 0,
            prevPinchAngle: 0,
            prevPinchCenter: null,
            lastPointerPos: null,

            getDist: (p1, p2) => Math.hypot(p1.clientX - p2.clientX, p1.clientY - p2.clientY),
            getAngle: (p1, p2) => Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX),
            getCenter: (p1, p2) => ({ x: (p1.clientX + p2.clientX) / 2, y: (p1.clientY + p2.clientY) / 2 }),

            handlePointerDown: (e) => {
                if (!App.state.isEntryModalOpen) return;
                const cvs = document.getElementById('viewfinder');
                cvs.setPointerCapture(e.pointerId);
                App.state.pointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY, pointerId: e.pointerId });

                // Find target segment
                const rect = cvs.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;
                const layout = App.collageConfigs[App.state.collageMode];

                // Check existing segments first
                const clickedIdx = layout.findIndex(slot => x >= slot.x && x <= slot.x + slot.w && y >= slot.y && y <= slot.y + slot.h);

                if (clickedIdx !== -1 && App.state.segments[clickedIdx]) {
                    App.state.interactionTarget = clickedIdx;
                    App.state.activeSegment = clickedIdx;
                    document.getElementById('segCurrent').innerText = clickedIdx + 1;
                    App.updateManipControlsVisibility();
                } else {
                    App.state.interactionTarget = null;
                }

                // Store initial position for single-finger pan
                App.state.lastPointerPos = { x: e.clientX, y: e.clientY };

                if (App.state.pointers.size === 2) {
                    const points = Array.from(App.state.pointers.values());
                    App.state.prevPinchDist = App.getDist(points[0], points[1]);
                    App.state.prevPinchAngle = App.getAngle(points[0], points[1]);
                    App.state.prevPinchCenter = App.getCenter(points[0], points[1]);
                }
            },

            handlePointerMove: (e) => {
                if (!App.state.pointers.has(e.pointerId)) return;

                const oldPointer = App.state.pointers.get(e.pointerId);
                const newPointer = { clientX: e.clientX, clientY: e.clientY, pointerId: e.pointerId };
                App.state.pointers.set(e.pointerId, newPointer);

                const targetIdx = App.state.interactionTarget;
                if (targetIdx === null || !App.state.segments[targetIdx]) return;

                const seg = App.state.segments[targetIdx];
                if (!seg.isManipulatable) return;

                const points = Array.from(App.state.pointers.values());
                const cvs = document.getElementById('viewfinder');
                const scaleX = cvs.width / cvs.clientWidth;
                const scaleY = cvs.height / cvs.clientHeight;

                if (points.length === 1) {
                    // Single finger pan
                    const dx = e.clientX - oldPointer.clientX;
                    const dy = e.clientY - oldPointer.clientY;
                    seg.x += dx * scaleX;
                    seg.y += dy * scaleY;

                } else if (points.length === 2) {
                    // Pinch to zoom/rotate + two-finger pan
                    const dist = App.getDist(points[0], points[1]);
                    const angle = App.getAngle(points[0], points[1]);
                    const center = App.getCenter(points[0], points[1]);

                    // Zoom
                    if (App.state.prevPinchDist > 0) {
                        const scaleFactor = dist / App.state.prevPinchDist;
                        seg.scale *= scaleFactor;
                        // Clamp scale
                        seg.scale = Math.max(0.1, Math.min(seg.scale, 10));
                    }

                    // Rotate
                    const angleDelta = angle - App.state.prevPinchAngle;
                    seg.rotation += angleDelta;

                    // Pan (two-finger drag)
                    if (App.state.prevPinchCenter) {
                        const dx = center.x - App.state.prevPinchCenter.x;
                        const dy = center.y - App.state.prevPinchCenter.y;
                        seg.x += dx * scaleX;
                        seg.y += dy * scaleY;
                    }

                    App.state.prevPinchDist = dist;
                    App.state.prevPinchAngle = angle;
                    App.state.prevPinchCenter = center;

                    // Update UI sliders to reflect changes
                    App.updateManipControlsVisibility();
                }
            },

            handlePointerUp: (e) => {
                App.state.pointers.delete(e.pointerId);
                if (App.state.pointers.size < 2) {
                    App.state.prevPinchDist = 0;
                    App.state.prevPinchAngle = 0;
                    App.state.prevPinchCenter = null;
                }
                if (App.state.pointers.size === 0) {
                    App.state.interactionTarget = null;
                    App.state.lastPointerPos = null;
                    App.updateManipControlsVisibility();
                }
            },

            initCamera: async () => {
                const video = document.getElementById('videoSource');
                const cvs = document.getElementById('viewfinder');

                // Attach pointer events if not already
                if (!cvs.dataset.listening) {
                    cvs.addEventListener('pointerdown', App.handlePointerDown);
                    cvs.addEventListener('pointermove', App.handlePointerMove);
                    cvs.addEventListener('pointerup', App.handlePointerUp);
                    cvs.addEventListener('pointercancel', App.handlePointerUp);
                    cvs.dataset.listening = "true";
                }

                try {
                    if (App.state.stream) {
                        App.state.stream.getTracks().forEach(t => t.stop());
                    }
                    App.state.stream = await navigator.mediaDevices.getUserMedia({
                        video: App.getVideoConstraints(),
                        audio: false
                    });
                    video.srcObject = App.state.stream;
                    video.onloadedmetadata = () => {
                        App.state.videoDims = { width: video.videoWidth, height: video.videoHeight };
                    };
                    const mirrorBtn = document.getElementById('mirrorToggleBtn');
                    if (App.state.facingMode === 'user') {
                        mirrorBtn.classList.remove('hidden');
                        if (App.state.mirrorVideo) {
                            mirrorBtn.classList.add('bg-white/40');
                            mirrorBtn.classList.remove('bg-black/40');
                        } else {
                            mirrorBtn.classList.remove('bg-white/40');
                            mirrorBtn.classList.add('bg-black/40');
                        }
                    } else {
                        mirrorBtn.classList.add('hidden');
                        App.state.mirrorVideo = false;
                        App.persistActiveDiaryCameraConfig({
                            facingMode: App.state.facingMode,
                            mirrorVideo: App.state.mirrorVideo
                        });
                        const btn = document.getElementById('mirrorToggleBtn');
                        btn.classList.remove('bg-white/40');
                        btn.classList.add('bg-black/40');
                    }
                } catch (e) {
                    console.error("Camera init failed", e);
                    App.showToast("Camera access failed. Check permissions or use file upload.", "error");
                }
            },

            drawLoop: () => {
                if (!App.state.isEntryModalOpen) {
                    App.stopDrawLoop();
                    return;
                }
                const video = document.getElementById('videoSource');
                const cvs = document.getElementById('viewfinder');
                const ctx = cvs.getContext('2d');
                const mode = App.state.collageMode;
                const baseDims = App.getBaseDimensions(video.videoWidth || App.state.videoDims.width, video.videoHeight || App.state.videoDims.height);
                let multW = 1;
                let multH = 1;
                if (mode === 2) multW = 2;
                else if (mode === 3) multW = 3;
                else if (mode === 4) { multW = 2; multH = 2; }
                else if (mode === 5) { multH = 2; }
                else if (mode === 6) { multH = 3; }
                else if (mode === 7) { multW = 2; multH = 2; }
                const dims = App.getFinalCanvasDimensions(baseDims.width, baseDims.height, multW, multH);
                const W = dims.width;
                const H = dims.height;
                if (cvs.width !== W || cvs.height !== H) {
                    cvs.width = W;
                    cvs.height = H;
                }
                ctx.clearRect(0, 0, W, H);
                const layout = App.collageConfigs[App.state.collageMode];
                if (App.state.ghostMode && App.state.ghostImageObj) {
                    ctx.save();
                    ctx.globalAlpha = App.state.ghostOpacity;
                    const img = App.state.ghostImageObj;
                    const imgW = img.width;
                    const imgH = img.height;
                    const srcRatio = imgW / imgH;
                    const dstRatio = W / H;
                    let gsx, gsy, gsw, gsh;
                    if (srcRatio > dstRatio) {
                        gsh = imgH; gsw = gsh * dstRatio; gsy = 0; gsx = (imgW - gsw) / 2;
                    } else {
                        gsw = imgW; gsh = gsw / dstRatio; gsx = 0; gsy = (imgH - gsh) / 2;
                    }
                    ctx.drawImage(img, gsx, gsy, gsw, gsh, 0, 0, W, H);
                    ctx.restore();
                }
                layout.forEach((slot, idx) => {
                    const dx = slot.x * W;
                    const dy = slot.y * H;
                    const dw = slot.w * W;
                    const dh = slot.h * H;

                    const seg = App.state.segments[idx];

                    if (seg) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(dx, dy, dw, dh);
                        ctx.clip();

                        if (seg.isManipulatable) {
                            const cx = dx + dw / 2;
                            const cy = dy + dh / 2;
                            ctx.translate(cx, cy);
                            ctx.translate(seg.x, seg.y);
                            ctx.rotate(seg.rotation);
                            const flipScaleX = seg.flipH ? -1 : 1;
                            const flipScaleY = seg.flipV ? -1 : 1;
                            ctx.scale(seg.scale * flipScaleX, seg.scale * flipScaleY);
                            ctx.drawImage(seg.source, -seg.source.width / 2, -seg.source.height / 2);
                        } else {
                            // Legacy canvas
                            ctx.drawImage(seg, 0, 0, seg.width, seg.height, dx, dy, dw, dh);
                        }
                        ctx.restore();
                    } else if (idx === App.state.activeSegment && video.readyState === 4) {
                        ctx.save();
                        const vidW = video.videoWidth;
                        const vidH = video.videoHeight;
                        const srcRatio = vidW / vidH;
                        const dstRatio = dw / dh;
                        let sx, sy, sw, sh;
                        if (srcRatio > dstRatio) {
                            sh = vidH; sw = sh * dstRatio; sy = 0; sx = (vidW - sw) / 2;
                        } else {
                            sw = vidW; sh = sw / dstRatio; sx = 0; sy = (vidH - sh) / 2;
                        }
                        if (App.state.mirrorVideo && App.state.facingMode === 'user') {
                            ctx.translate(dx + dw, dy);
                            ctx.scale(-1, 1);
                            ctx.drawImage(video, sx, sy, sw, sh, 0, 0, dw, dh);
                        } else {
                            ctx.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh);
                        }
                        ctx.restore();
                    } else {
                        ctx.fillStyle = "#111";
                        ctx.fillRect(dx, dy, dw, dh);
                    }

                    if (idx === App.state.activeSegment) {
                        ctx.strokeStyle = "rgba(145, 127, 179, 0.8)";
                        ctx.lineWidth = 4;
                    } else {
                        ctx.strokeStyle = "rgba(255,255,255,0.1)";
                        ctx.lineWidth = 2;
                    }
                    ctx.strokeRect(dx, dy, dw, dh);
                });
                App.state.drawLoopHandle = requestAnimationFrame(App.drawLoop);
            },

            flipCamera: () => {
                App.state.facingMode = App.state.facingMode === 'user' ? 'environment' : 'user';
                if (App.state.facingMode !== 'user') {
                    App.state.mirrorVideo = false;
                }
                App.persistActiveDiaryCameraConfig({
                    facingMode: App.state.facingMode,
                    mirrorVideo: App.state.mirrorVideo
                });
                App.initCamera();
            },

            toggleMirror: () => {
                App.state.mirrorVideo = !App.state.mirrorVideo;
                const btn = document.getElementById('mirrorToggleBtn');
                if (App.state.mirrorVideo) {
                    btn.classList.add('bg-white/40');
                    btn.classList.remove('bg-black/40');
                } else {
                    btn.classList.remove('bg-white/40');
                    btn.classList.add('bg-black/40');
                }
                App.persistActiveDiaryCameraConfig({ mirrorVideo: App.state.mirrorVideo });
            },

            toggleGhost: () => {
                const ghost = document.getElementById('ghostOverlay');
                const btn = document.getElementById('ghostToggleBtn');
                const slider = document.getElementById('ghostSliderContainer');
                if (App.state.ghostMode) {
                    if (slider.classList.contains('hidden')) {
                        slider.classList.remove('hidden');
                    } else {
                        App.state.ghostMode = false;
                        ghost.classList.add('opacity-0');
                        btn.classList.add('opacity-50');
                        slider.classList.add('hidden');
                    }
                } else {
                    App.state.ghostMode = true;
                    ghost.classList.remove('opacity-0');
                    ghost.style.opacity = App.state.ghostOpacity;
                    btn.classList.remove('opacity-50');
                    slider.classList.remove('hidden');
                }
                App.persistActiveDiaryCameraConfig({ ghostMode: App.state.ghostMode });
            },

            setGhostOpacity: (val) => {
                const newVal = parseFloat(val);
                App.state.ghostOpacity = newVal;
                const ghost = document.getElementById('ghostOverlay');
                if (App.state.ghostMode) ghost.style.opacity = newVal;
                const s = Storage.getSettings();
                s.ghostOpacity = newVal;
                Storage.setSettings(s);
                App.persistActiveDiaryCameraConfig({ ghostOpacity: newVal });
            },

            handleTagInput: (e) => {
                const rawVal = e.target.value;
                const val = rawVal.trim();
                const normalized = UTILS.normalizeTag(val);
                const suggestions = document.getElementById('tagSuggestions');
                const diary = App.state.diaries.find(d => d.id === App.state.activeDiaryId);
                const allTags = diary ? diary.tags : [];
                const available = allTags.filter(t => !App.hasTag(App.state.currentTags, t));
                const matches = normalized
                    ? available.filter(t => t.toLowerCase().includes(normalized))
                    : available;
                const exactMatch = normalized && App.hasTag(allTags, val);
                const showAdd = normalized && !exactMatch;
                if (matches.length > 0 || showAdd) {
                    suggestions.classList.remove('hidden');
                    const items = [];
                    if (showAdd) {
                        const safeLabel = val.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                        const encoded = encodeURIComponent(val);
                        items.push(`<div class="p-2 hover:bg-oatmeal cursor-pointer text-sm font-semibold" onclick="App.addNewTag(decodeURIComponent('${encoded}'))">Add "${safeLabel}"</div>`);
                    }
                    matches.forEach(t => {
                        const encoded = encodeURIComponent(t);
                        items.push(`<div class="p-2 hover:bg-oatmeal cursor-pointer text-sm" onclick="App.addTag(decodeURIComponent('${encoded}'))">${t}</div>`);
                    });
                    suggestions.innerHTML = items.join('');
                } else {
                    suggestions.classList.add('hidden');
                }
                if (e.key === 'Enter' && val) {
                    if (exactMatch) {
                        const existing = App.tagMatch(allTags, val);
                        App.addTag(existing || val);
                    } else {
                        App.addNewTag(val);
                    }
                }
            },

            addTag: (t) => {
                const tag = t ? t.trim() : '';
                if (!tag) return;
                if (!App.hasTag(App.state.currentTags, tag)) {
                    App.state.currentTags.push(tag);
                    App.renderTags();
                    document.getElementById('tagInput').value = '';
                    document.getElementById('tagSuggestions').classList.add('hidden');
                }
            },
            addNewTag: async (t) => {
                const tag = t ? t.trim() : '';
                if (!tag) return;
                const diaryId = App.state.activeDiaryId;
                const diary = App.state.diaries.find(d => d.id === diaryId);
                const existing = diary ? App.tagMatch(diary.tags, tag) : null;
                const resolvedTag = existing || tag;
                App.addTag(resolvedTag);
                if (diaryId) {
                    Storage.updateDiaryTags(diaryId, [resolvedTag]);
                    App.state.diaries = Storage.getData();
                    SyncManager.queueTagSync(diaryId, resolvedTag);
                }
            },

            renderTags: () => {
                const container = document.getElementById('activeTags');
                container.innerHTML = App.state.currentTags.map(t => `
                    <span class="bg-dull-purple text-white-linen px-2.5 py-1 text-xs flex items-center gap-1.5 font-display">
                        ${t}
                        <button onclick="App.removeTag('${t}')" class="hover:text-muted-pink"><i data-lucide="x" class="w-3 h-3"></i></button>
                    </span>
                `).join('');
                lucide.createIcons();
            },

            removeTag: (t) => {
                const normalized = UTILS.normalizeTag(t);
                App.state.currentTags = App.state.currentTags.filter(x => UTILS.normalizeTag(x) !== normalized);
                App.renderTags();
            },

            confirmDelete: (diaryId, entryId) => {
                App.state.pendingDelete = { diaryId, entryId };
                App.openModal('deleteModal');
            },

            executeDelete: async () => {
                const { diaryId, entryId } = App.state.pendingDelete;
                if (!diaryId || !entryId) return;
                App.closeModal('deleteModal');
                const diary = Storage.getData().find(d => d.id === diaryId);
                const entry = diary?.entries.find(e => e.id === entryId);
                const notionId = entry?.notionId;
                App.revokeEntryImageCache(entryId);
                if (entry && ImageStore.isAvailable()) {
                    if (entry.photoKey) await ImageStore.del(entry.photoKey);
                    if (entry.uploadKey) await ImageStore.del(entry.uploadKey);
                }
                Storage.deleteEntry(diaryId, entryId);
                App.state.diaries = Storage.getData();
                App.renderDiaryView();
                App.renderSidebar();
                App.showToast("Deleted locally", "success");
                if (notionId) {
                    try {
                        await API.request('PATCH', `/pages/${notionId}`, { archived: true });
                        App.showToast("Deleted from Notion", "success");
                    } catch (e) {
                        console.error("Notion delete failed", e);
                        App.showToast("Failed to delete from Notion", "error");
                    }
                }
            },

            saveEntry: async () => {
                const notes = document.getElementById('entryNotes').value;
                const titleInput = document.getElementById('entryTitle').value;
                const dateVal = document.getElementById('entryDate').value;
                const date = UTILS.localToUTC(dateVal);
                const title = titleInput.trim() || new Date(dateVal).toLocaleString(undefined, {
                    weekday: 'short', year: 'numeric', month: 'short', day: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });
                const diary = Storage.getData().find(d => d.id === App.state.activeDiaryId);
                const diaryTitle = diary?.title || "Diary";

                if (!App.state.capturedImage) return App.showToast('An image is required.', 'error');
                App.setEntryLoading(true, "Saving entry...");

                // Generate both versions if not already done (though finalizeCollage creates UI version)
                // We should ensure we save the Low Res version to local storage to save space
                let photoToSave = App.state.capturedImage;
                let photoToUpload = App.state.capturedImageHighRes || App.state.capturedImage;

                const entryId = UTILS.id();
                let photoKey = null;
                let uploadKey = null;
                let photoDataURL = null;
                let uploadDataURL = null;

                try {
                    if (ImageStore.isAvailable()) {
                        const previewKey = `entry_${entryId}_preview`;
                        const uploadKeyName = `entry_${entryId}_upload`;
                        try {
                            await ImageStore.set(previewKey, UTILS.dataURLtoBlob(photoToSave));
                            await ImageStore.set(uploadKeyName, UTILS.dataURLtoBlob(photoToUpload));
                            photoKey = previewKey;
                            uploadKey = uploadKeyName;
                        } catch (e) {
                            if (e?.isQuotaExceeded) {
                                App.showToast("Storage full; saving images inline.", "error");
                            }
                            photoDataURL = photoToSave;
                            uploadDataURL = photoToUpload;
                        }
                    } else {
                        photoDataURL = photoToSave;
                        uploadDataURL = photoToUpload;
                    }

                    const newEntry = {
                        id: entryId,
                        date: date,
                        title: title,
                        notes: notes,
                        tags: App.state.currentTags,
                        diaryTitle: diaryTitle,
                        photoDataURL: photoDataURL,
                        photoKey: photoKey,
                        uploadKey: uploadKey,
                        uploadDataURL: uploadDataURL,
                        synced: false,
                        notionId: null
                    };

                    Storage.saveEntry(App.state.activeDiaryId, newEntry);
                    App.state.diaries = Storage.getData();

                    App.closeModal('entryModal', { force: true });
                    App.renderDiaryView();
                    App.showToast("Saved locally", 'success');

                    // For sync, we temporarily attach the High Res image to the entry object in memory 
                    // so the push function uses it, but we don't save it to localStorage
                    // Or we can just pass it directly if we restructure sync. 
                    // Simplest hack: Modify the entry object in memory before calling sync
                    const entryForSync = { ...newEntry, photoDataURL: photoToUpload };

                    // We need to manually trigger push for this specific entry with high res data
                    // Because SyncManager reads from Storage (which has low res)
                    // So we bypass standard sync loop for this new entry
                    try {
                        SyncManager.updateUI('syncing');
                        const notionId = await SyncManager.pushEntryToNotion(diary.dataSourceId, entryForSync);
                        Storage.updateEntrySyncStatus(App.state.activeDiaryId, newEntry.id, true, notionId);
                        SyncManager.updateUI('synced');
                        App.state.diaries = Storage.getData();
                        App.renderDiaryView();
                    } catch (e) {
                        console.error("Immediate sync failed", e);
                        SyncManager.updateUI('error');
                        // It will retry later with low res version from storage, which is acceptable fallback
                        Storage.queuePendingEntry(App.state.activeDiaryId, newEntry.id);
                        SyncManager.scheduleRetry(App.state.activeDiaryId);
                    }
                } finally {
                    App.setEntryLoading(false);
                }
            },

            copyWorkerCode: async (btn) => {
                const code = document.getElementById('workerCodeBlock').innerText;
                try {
                    if (navigator.clipboard?.writeText) {
                        await navigator.clipboard.writeText(code);
                    } else {
                        const textArea = document.createElement('textarea');
                        textArea.value = code;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                    }
                    const originalText = btn.innerText;
                    btn.innerText = "Copied!";
                    setTimeout(() => btn.innerText = originalText, 2000);
                } catch (err) {
                    console.error('Copy failed', err);
                    App.showToast("Copy failed. Please copy manually.", "error");
                }
            },

            captureSegment: () => {
                const video = document.getElementById('videoSource');
                const canvas = document.createElement('canvas');

                // Use full resolution from video or base dims
                // Actually, let's just capture the full video frame to allow manipulation
                const vidW = video.videoWidth;
                const vidH = video.videoHeight;
                canvas.width = vidW;
                canvas.height = vidH;
                const ctx = canvas.getContext('2d');

                if (App.state.mirrorVideo && App.state.facingMode === 'user') {
                    ctx.save();
                    ctx.translate(vidW, 0);
                    ctx.scale(-1, 1);
                    ctx.drawImage(video, 0, 0, vidW, vidH);
                    ctx.restore();
                } else {
                    ctx.drawImage(video, 0, 0, vidW, vidH);
                }

                // Convert to Image for manipulation source
                const img = new Image();
                img.src = canvas.toDataURL('image/webp', 0.9);

                img.onload = () => {
                    // Calculate slot dimensions and scale
                    const baseDims = App.state.captureBase || App.getBaseDimensions(vidW, vidH);
                    const BaseW = baseDims.width;
                    const BaseH = baseDims.height;

                    const layout = App.collageConfigs[App.state.collageMode];
                    const slot = layout[App.state.activeSegment];

                    let multW = 1; let multH = 1;
                    const mode = App.state.collageMode;
                    if (mode === 2) multW = 2;
                    else if (mode === 3) multW = 3;
                    else if (mode === 4) { multW = 2; multH = 2; }
                    else if (mode === 5) { multH = 2; }
                    else if (mode === 6) { multH = 3; }
                    else if (mode === 7) { multW = 2; multH = 2; }

                    const finalDims = App.getFinalCanvasDimensions(BaseW, BaseH, multW, multH);
                    const slotPixelW = slot.w * finalDims.width;
                    const slotPixelH = slot.h * finalDims.height;

                    const scaleW = slotPixelW / vidW;
                    const scaleH = slotPixelH / vidH;
                    const scale = Math.max(scaleW, scaleH);

                    App.state.segments[App.state.activeSegment] = {
                        source: img,
                        isManipulatable: true,
                        x: 0,
                        y: 0,
                        scale: scale,
                        baseScale: scale,
                        rotation: 0,
                        flipH: false,
                        flipV: false,
                        width: vidW,
                        height: vidH
                    };

                    if (!App.state.captureBase) {
                        App.state.captureBase = { width: BaseW, height: BaseH };
                    }

                    const total = layout.length;
                    let allFilled = true;
                    let nextEmpty = -1;
                    for (let i = 0; i < total; i++) {
                        if (!App.state.segments[i]) {
                            allFilled = false;
                            if (nextEmpty === -1) nextEmpty = i;
                        }
                    }
                    if (allFilled) {
                        App.finalizeCollage();
                    } else {
                        App.state.activeSegment = nextEmpty;
                        document.getElementById('segCurrent').innerText = App.state.activeSegment + 1;
                    }
                    App.updateManipControlsVisibility();
                };
            },

            finalizeCollage: async () => {
                const layout = App.collageConfigs[App.state.collageMode];
                const finalCanvas = document.getElementById('photoCanvas');
                if (!finalCanvas) return;
                App.setEntryLoading(true, "Processing photo...");
                const mode = App.state.collageMode;
                const baseDims = App.state.captureBase || App.getBaseDimensions(App.state.videoDims.width, App.state.videoDims.height);
                const BaseW = baseDims.width;
                const BaseH = baseDims.height;
                let multW = 1;
                let multH = 1;
                if (mode === 2) multW = 2;
                else if (mode === 3) multW = 3;
                else if (mode === 4) { multW = 2; multH = 2; }
                else if (mode === 5) { multH = 2; }
                else if (mode === 6) { multH = 3; }
                else if (mode === 7) { multW = 2; multH = 2; }
                const dims = App.getFinalCanvasDimensions(BaseW, BaseH, multW, multH);
                const W = dims.width;
                const H = dims.height;
                finalCanvas.width = W; finalCanvas.height = H;
                const ctx = finalCanvas.getContext('2d');
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, W, H);
                layout.forEach((slot, idx) => {
                    const seg = App.state.segments[idx];
                    if (seg) {
                        const dx = slot.x * W;
                        const dy = slot.y * H;
                        const dw = slot.w * W;
                        const dh = slot.h * H;

                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(dx, dy, dw, dh);
                        ctx.clip();

                        if (seg.isManipulatable) {
                            const cx = dx + dw / 2;
                            const cy = dy + dh / 2;
                            ctx.translate(cx, cy);
                            ctx.translate(seg.x, seg.y);
                            ctx.rotate(seg.rotation);
                            const flipScaleX = seg.flipH ? -1 : 1;
                            const flipScaleY = seg.flipV ? -1 : 1;
                            ctx.scale(seg.scale * flipScaleX, seg.scale * flipScaleY);
                            ctx.drawImage(seg.source, -seg.source.width / 2, -seg.source.height / 2);
                        } else {
                            ctx.drawImage(seg, 0, 0, seg.width, seg.height, dx, dy, dw, dh);
                        }
                        ctx.restore();
                    }
                });

                try {
                    // 1. Generate High Res Version for Upload (WebP Max Quality)
                    // We must ensure it's under the selected cap
                    const highResBase = finalCanvas.toDataURL('image/webp', 0.96);
                    const capBytes = App.getUploadCapBytes();
                    App.state.capturedImageHighRes = await UTILS.compressToLimit(highResBase, { maxBytes: capBytes });

                    // 2. Generate Preview Version for UI (larger thumbnail for IndexedDB)
                    App.state.capturedImage = await UTILS.processImage(highResBase, 640, 0.72);

                    document.getElementById('cameraSection').classList.add('hidden');
                    document.getElementById('imageManipControls').classList.add('hidden');
                    document.getElementById('smallPreview').src = App.state.capturedImage; // Show low res preview
                    document.getElementById('takenPhotoUI').classList.remove('hidden');
                    document.getElementById('takenPhotoUI').classList.add('flex');
                    document.getElementById('saveEntryBtn').disabled = false;

                    if (App.state.stream) App.state.stream.getTracks().forEach(t => t.stop());
                } finally {
                    App.setEntryLoading(false);
                }
            },

            handleCollageClick: (e) => {
                // Use the smallPreview image element, not e.target (which could be overlay div)
                const img = document.getElementById('smallPreview');
                if (!img) return;
                const rect = img.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;
                const layout = App.collageConfigs[App.state.collageMode];
                const clickedIdx = layout.findIndex(slot => x >= slot.x && x <= slot.x + slot.w && y >= slot.y && y <= slot.y + slot.h);
                if (clickedIdx !== -1 && App.state.segments[clickedIdx]) {
                    App.openSegmentEdit(clickedIdx);
                }
            },

            editingSegmentIdx: null,
            segEditAnimFrame: null,

            openSegmentEdit: (idx) => {
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;

                App.state.editingSegmentIdx = idx;
                document.getElementById('editSegmentNum').textContent = idx + 1;

                // Set current values
                const zoomRatio = seg.scale / seg.baseScale;
                const rotDeg = Math.round((seg.rotation * 180) / Math.PI);

                document.getElementById('segEditZoom').value = zoomRatio;
                document.getElementById('segEditZoomVal').textContent = zoomRatio.toFixed(1) + 'x';
                document.getElementById('segEditRotation').value = rotDeg;
                document.getElementById('segEditRotationVal').textContent = rotDeg + '°';
                document.getElementById('segEditPanX').value = seg.x;
                document.getElementById('segEditPanXVal').textContent = Math.round(seg.x);
                document.getElementById('segEditPanY').value = seg.y;
                document.getElementById('segEditPanYVal').textContent = Math.round(seg.y);

                document.getElementById('segmentEditOverlay').classList.remove('hidden');
                lucide.createIcons();

                // Start live preview loop
                App.startSegEditPreview();
            },

            closeSegmentEdit: () => {
                App.stopSegEditPreview();
                document.getElementById('segmentEditOverlay').classList.add('hidden');
                App.state.editingSegmentIdx = null;
                // Regenerate preview
                App.regeneratePreview();
            },

            startSegEditPreview: () => {
                const render = () => {
                    App.renderSegEditPreview();
                    App.state.segEditAnimFrame = requestAnimationFrame(render);
                };
                render();
            },

            stopSegEditPreview: () => {
                if (App.state.segEditAnimFrame) {
                    cancelAnimationFrame(App.state.segEditAnimFrame);
                    App.state.segEditAnimFrame = null;
                }
            },

            renderSegEditPreview: () => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;

                const canvas = document.getElementById('segEditPreview');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                // Get the slot dimensions for this segment
                const layout = App.collageConfigs[App.state.collageMode];
                const slot = layout[idx];
                const mode = App.state.collageMode;
                const baseDims = App.state.captureBase || App.getTargetBaseDimensions();
                let multW = 1, multH = 1;
                if (mode === 2) multW = 2;
                else if (mode === 3) multW = 3;
                else if (mode === 4) { multW = 2; multH = 2; }
                else if (mode === 5) { multH = 2; }
                else if (mode === 6) { multH = 3; }
                else if (mode === 7) { multW = 2; multH = 2; }
                const dims = App.getFinalCanvasDimensions(baseDims.width, baseDims.height, multW, multH);
                const slotW = slot.w * dims.width;
                const slotH = slot.h * dims.height;

                // Set canvas to match slot aspect ratio
                const previewSize = 300;
                const slotAspect = slotW / slotH;
                if (slotAspect >= 1) {
                    canvas.width = previewSize;
                    canvas.height = previewSize / slotAspect;
                } else {
                    canvas.height = previewSize;
                    canvas.width = previewSize * slotAspect;
                }

                const W = canvas.width;
                const H = canvas.height;
                const scaleRatio = W / slotW;

                ctx.fillStyle = "#1a1a1a";
                ctx.fillRect(0, 0, W, H);

                // Draw the segment with transforms
                ctx.save();
                const cx = W / 2;
                const cy = H / 2;
                ctx.translate(cx, cy);
                ctx.translate(seg.x * scaleRatio, seg.y * scaleRatio);
                ctx.rotate(seg.rotation);
                const flipScaleX = seg.flipH ? -1 : 1;
                const flipScaleY = seg.flipV ? -1 : 1;
                ctx.scale(seg.scale * scaleRatio * flipScaleX, seg.scale * scaleRatio * flipScaleY);
                ctx.drawImage(seg.source, -seg.source.width / 2, -seg.source.height / 2);
                ctx.restore();

                // Draw border
                ctx.strokeStyle = "rgba(133, 117, 147, 0.8)";
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, W, H);
            },

            setEditSegmentZoom: (val) => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                const r = parseFloat(val);
                seg.scale = seg.baseScale * r;
                document.getElementById('segEditZoomVal').textContent = r.toFixed(2) + 'x';
            },

            setEditSegmentRotation: (val) => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                seg.rotation = (parseFloat(val) * Math.PI) / 180;
                document.getElementById('segEditRotationVal').textContent = val + '°';
            },

            setEditSegmentPanX: (val) => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                seg.x = parseFloat(val);
                document.getElementById('segEditPanXVal').textContent = Math.round(seg.x);
            },

            setEditSegmentPanY: (val) => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                seg.y = parseFloat(val);
                document.getElementById('segEditPanYVal').textContent = Math.round(seg.y);
            },

            flipEditSegmentH: () => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                seg.flipH = !seg.flipH;
            },

            flipEditSegmentV: () => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                seg.flipV = !seg.flipV;
            },

            resetEditSegment: () => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                seg.x = 0;
                seg.y = 0;
                seg.rotation = 0;
                seg.scale = seg.baseScale;
                seg.flipH = false;
                seg.flipV = false;
                // Update sliders
                document.getElementById('segEditZoom').value = 1;
                document.getElementById('segEditZoomVal').textContent = '1.00x';
                document.getElementById('segEditRotation').value = 0;
                document.getElementById('segEditRotationVal').textContent = '0°';
                document.getElementById('segEditPanX').value = 0;
                document.getElementById('segEditPanXVal').textContent = '0';
                document.getElementById('segEditPanY').value = 0;
                document.getElementById('segEditPanYVal').textContent = '0';
            },

            retakeEditSegment: () => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                App.stopSegEditPreview();
                App.state.activeSegment = idx;
                App.state.segments[idx] = null;
                document.getElementById('segmentEditOverlay').classList.add('hidden');
                App.state.editingSegmentIdx = null;
                App.retakePartial();
            },

            applySegmentEdit: () => {
                App.closeSegmentEdit();
            },

            regeneratePreview: async () => {
                // Re-render the collage to smallPreview after edits
                const layout = App.collageConfigs[App.state.collageMode];
                const tempCanvas = document.createElement('canvas');
                const mode = App.state.collageMode;
                const baseDims = App.state.captureBase || App.getTargetBaseDimensions();
                const BaseW = baseDims.width;
                const BaseH = baseDims.height;
                let multW = 1, multH = 1;
                if (mode === 2) multW = 2;
                else if (mode === 3) multW = 3;
                else if (mode === 4) { multW = 2; multH = 2; }
                else if (mode === 5) { multH = 2; }
                else if (mode === 6) { multH = 3; }
                else if (mode === 7) { multW = 2; multH = 2; }
                const dims = App.getFinalCanvasDimensions(BaseW, BaseH, multW, multH);
                const W = dims.width;
                const H = dims.height;
                tempCanvas.width = W;
                tempCanvas.height = H;
                const ctx = tempCanvas.getContext('2d');
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, W, H);

                layout.forEach((slot, idx) => {
                    const seg = App.state.segments[idx];
                    if (seg) {
                        const dx = slot.x * W;
                        const dy = slot.y * H;
                        const dw = slot.w * W;
                        const dh = slot.h * H;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(dx, dy, dw, dh);
                        ctx.clip();
                        if (seg.isManipulatable) {
                            const cx = dx + dw / 2;
                            const cy = dy + dh / 2;
                            ctx.translate(cx, cy);
                            ctx.translate(seg.x, seg.y);
                            ctx.rotate(seg.rotation);
                            const flipScaleX = seg.flipH ? -1 : 1;
                            const flipScaleY = seg.flipV ? -1 : 1;
                            ctx.scale(seg.scale * flipScaleX, seg.scale * flipScaleY);
                            ctx.drawImage(seg.source, -seg.source.width / 2, -seg.source.height / 2);
                        } else {
                            ctx.drawImage(seg, 0, 0, seg.width, seg.height, dx, dy, dw, dh);
                        }
                        ctx.restore();
                    }
                });

                // Generate preview and high-res versions
                const highResBase = tempCanvas.toDataURL('image/webp', 0.96);
                const capBytes = App.getUploadCapBytes();
                App.state.capturedImageHighRes = await UTILS.compressToLimit(highResBase, { maxBytes: capBytes });
                App.state.capturedImage = await UTILS.processImage(highResBase, 640, 0.72);
                document.getElementById('smallPreview').src = App.state.capturedImage;
            },

            retakePartial: () => {
                document.getElementById('takenPhotoUI').classList.add('hidden');
                document.getElementById('takenPhotoUI').classList.remove('flex');
                document.getElementById('cameraSection').classList.remove('hidden');
                App.initCamera();

                document.getElementById('segCurrent').innerText = App.state.activeSegment + 1;
                App.updateManipControlsVisibility();
            },

            retakeAll: () => {
                App.state.activeSegment = 0;
                App.state.segments = [];
                App.state.captureBase = null;
                document.getElementById('takenPhotoUI').classList.add('hidden');
                document.getElementById('takenPhotoUI').classList.remove('flex');
                document.getElementById('cameraSection').classList.remove('hidden');
                document.getElementById('imageManipControls').classList.add('hidden');
                document.getElementById('saveEntryBtn').disabled = true;
                App.initCamera();
                App.setCollageMode(App.state.collageMode);
            },

            retakePhoto: () => { App.retakeAll(); },

            updateManipControlsVisibility: () => {
                const seg = App.state.segments[App.state.activeSegment];
                const controls = document.getElementById('imageManipControls');
                if (seg && seg.isManipulatable) {
                    controls.classList.remove('hidden');
                    const rotSlider = document.getElementById('rotationSlider');
                    const zoomSlider = document.getElementById('zoomSlider');
                    const rotVal = document.getElementById('rotationValue');
                    const zoomVal = document.getElementById('zoomValue');
                    const rotDeg = Math.round((seg.rotation * 180) / Math.PI);
                    rotSlider.value = rotDeg;
                    rotVal.textContent = rotDeg + '°';
                    const zoomRatio = seg.scale / seg.baseScale;
                    zoomSlider.value = zoomRatio;
                    zoomVal.textContent = zoomRatio.toFixed(1) + 'x';
                    lucide.createIcons();
                } else {
                    controls.classList.add('hidden');
                }
            },

            setSegmentRotation: (deg) => {
                const seg = App.state.segments[App.state.activeSegment];
                if (seg && seg.isManipulatable) {
                    seg.rotation = (parseFloat(deg) * Math.PI) / 180;
                    document.getElementById('rotationValue').textContent = deg + '°';
                }
            },

            setSegmentZoom: (ratio) => {
                const seg = App.state.segments[App.state.activeSegment];
                if (seg && seg.isManipulatable) {
                    const r = parseFloat(ratio);
                    seg.scale = seg.baseScale * r;
                    document.getElementById('zoomValue').textContent = r.toFixed(1) + 'x';
                }
            },

            flipSegmentHorizontal: () => {
                const seg = App.state.segments[App.state.activeSegment];
                if (seg && seg.isManipulatable) {
                    seg.flipH = !seg.flipH;
                }
            },

            flipSegmentVertical: () => {
                const seg = App.state.segments[App.state.activeSegment];
                if (seg && seg.isManipulatable) {
                    seg.flipV = !seg.flipV;
                }
            },

            resetSegmentTransform: () => {
                const seg = App.state.segments[App.state.activeSegment];
                if (seg && seg.isManipulatable) {
                    seg.x = 0;
                    seg.y = 0;
                    seg.rotation = 0;
                    seg.scale = seg.baseScale;
                    seg.flipH = false;
                    seg.flipV = false;
                    App.updateManipControlsVisibility();
                }
            },

            handleFileUpload: async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const base64 = await UTILS.toBase64(file);
                    const img = new Image();
                    img.src = base64;
                    img.onload = () => {
                        // Calculate slot dimensions
                        const baseDims = App.state.captureBase || App.getTargetBaseDimensions();
                        const layout = App.collageConfigs[App.state.collageMode];
                        const slot = layout[App.state.activeSegment];

                        // We need the absolute dimensions of the slot in the "virtual" canvas
                        // But wait, the virtual canvas size depends on the mode multW/multH.
                        // However, simpler approach:
                        // The 'scale' should be relative to the image itself being drawn into the slot.
                        // We want the image to COVER the slot.
                        // We need to know the slot's aspect ratio.
                        // Slot W relative = slot.w, Slot H relative = slot.h
                        // But we need the aspect ratio of the slot in pixels.
                        // Assume BaseW/BaseH is the 1x1 size.
                        const BaseW = baseDims.width;
                        const BaseH = baseDims.height;

                        // We need to know the multiplier for the current mode to get true aspect?
                        // Actually App.getFinalCanvasDimensions does this.
                        let multW = 1; let multH = 1;
                        const mode = App.state.collageMode;
                        if (mode === 2) multW = 2;
                        else if (mode === 3) multW = 3;
                        else if (mode === 4) { multW = 2; multH = 2; }
                        else if (mode === 5) { multH = 2; }
                        else if (mode === 6) { multH = 3; }
                        else if (mode === 7) { multW = 2; multH = 2; }

                        // But wait, slot.w is percentage of Final Width.
                        // So we just need Final Width / Final Height ratio?
                        // Actually, let's just use the current canvas dimensions if available, or estimate.
                        // Safest is to use the logic from drawLoop:
                        const finalDims = App.getFinalCanvasDimensions(BaseW, BaseH, multW, multH);
                        const slotPixelW = slot.w * finalDims.width;
                        const slotPixelH = slot.h * finalDims.height;

                        const imgW = img.width;
                        const imgH = img.height;

                        // Calculate Scale to COVER
                        const scaleW = slotPixelW / imgW;
                        const scaleH = slotPixelH / imgH;
                        const scale = Math.max(scaleW, scaleH);

                        App.state.segments[App.state.activeSegment] = {
                            source: img,
                            isManipulatable: true,
                            x: 0,
                            y: 0,
                            scale: scale,
                            baseScale: scale,
                            rotation: 0,
                            flipH: false,
                            flipV: false,
                            width: imgW,
                            height: imgH
                        };

                        if (!App.state.captureBase) {
                            App.state.captureBase = { width: BaseW, height: BaseH };
                        }

                        // Auto-advance
                        const total = layout.length;
                        let allFilled = true;
                        let nextEmpty = -1;
                        for (let i = 0; i < total; i++) {
                            if (!App.state.segments[i]) {
                                allFilled = false;
                                if (nextEmpty === -1) nextEmpty = i;
                            }
                        }

                        if (allFilled) {
                            App.finalizeCollage();
                        } else {
                            if (nextEmpty !== -1) {
                                App.state.activeSegment = nextEmpty;
                                document.getElementById('segCurrent').innerText = App.state.activeSegment + 1;
                            }
                        }
                        App.updateManipControlsVisibility();
                    }
                }
            },
            renderSettingsStatus: (settings) => {
                const statusEl = document.getElementById('connectionStatus');
                const s = settings || Storage.getSettings();
                if (!s.authToken) {
                    statusEl.innerHTML = `
                        <div class="flex items-start gap-3 text-amber-700 bg-amber-50 p-3 rounded-lg border border-amber-100 text-xs">
                            <div class="bg-white p-1 rounded-full shadow-sm mt-0.5"><i data-lucide="alert-circle" class="w-4 h-4 text-amber-600"></i></div>
                            <div class="flex-1">
                                <strong class="block text-sm mb-0.5">Not Connected</strong>
                                <span class="opacity-80">Connect via OAuth or verify your manual key to start.</span>
                            </div>
                        </div>
                    `;
                } else if (s.authToken.startsWith('secret_')) {
                    statusEl.innerHTML = `
                        <div class="flex items-start gap-3 text-green-700 bg-green-50 p-3 rounded-lg border border-green-100 text-xs">
                            <div class="bg-white p-1 rounded-full shadow-sm mt-0.5"><i data-lucide="key" class="w-4 h-4 text-green-600"></i></div>
                            <div class="flex-1">
                                <strong class="block text-sm mb-0.5">Connected via Secret Key</strong>
                                <span class="opacity-80">Integration verified manually.</span>
                            </div>
                        </div>
                    `;
                } else {
                    statusEl.innerHTML = `
                        <div class="flex items-start gap-3 text-dull-purple bg-dull-purple/10 p-3 rounded-lg border border-dull-purple/20 text-xs">
                            <div class="bg-white p-1 rounded-full shadow-sm mt-0.5"><i data-lucide="zap" class="w-4 h-4 text-dull-purple"></i></div>
                            <div class="flex-1">
                                <strong class="block text-sm mb-0.5">Connected via OAuth</strong>
                                <span class="opacity-80">Access granted via standard Notion authorization.</span>
                            </div>
                        </div>
                    `;
                }
                lucide.createIcons();
            },
            populateSettingsInputs: () => {
                const s = Storage.getSettings();
                const isSecret = s.authToken && s.authToken.startsWith('secret_');
                document.getElementById('settingAuthToken').value = isSecret ? s.authToken : '';
                document.getElementById('settingWorkerUrl').value = s.workerUrl || '';
                document.getElementById('settingProxyToken').value = s.proxyToken || '';
                const capValue = String(s.uploadCapMb || 5);
                document.querySelectorAll('input[name="uploadCapMb"]').forEach((input) => {
                    input.checked = input.value === capValue;
                });
                const hasVerifiedWorker = !!s.workerUrl;
                const authSection = document.getElementById('authSection');
                if (hasVerifiedWorker) {
                    authSection.classList.remove('opacity-50', 'pointer-events-none');
                } else {
                    authSection.classList.add('opacity-50', 'pointer-events-none');
                }
                const isAuthVerified = !!s.authToken;
                document.getElementById('saveSettingsBtn').disabled = !isAuthVerified;
            },
            onSettingInput: () => {
                const workerUrl = document.getElementById('settingWorkerUrl').value;
                document.getElementById('verifyWorkerBtn').disabled = !workerUrl;
            },
            setUploadCap: (value) => {
                const cap = Number(value) || 5;
                const current = Storage.getSettings();
                Storage.setSettings({ ...current, uploadCapMb: cap });
                App.showToast(`Upload cap set to ${cap}MB`, "success");
            },
            verifyWorker: async () => {
                const btn = document.getElementById('verifyWorkerBtn');
                const originalText = btn.innerText;
                const workerUrl = document.getElementById('settingWorkerUrl').value.trim();
                const proxyToken = document.getElementById('settingProxyToken').value.trim();
                if (!workerUrl) return App.showToast("Enter a Worker URL first", "error");
                btn.innerText = "Checking...";
                btn.disabled = true;
                const cleanWorkerUrl = workerUrl.replace(/\/$/, '');
                let fetchUrl;
                try {
                    fetchUrl = new URL(cleanWorkerUrl);
                } catch (e) {
                    App.showToast("Invalid Worker URL format", "error");
                    btn.innerText = originalText;
                    btn.disabled = false;
                    return;
                }
                fetchUrl.searchParams.append('url', 'https://api.notion.com/v1/users/me');
                if (proxyToken) fetchUrl.searchParams.append('token', proxyToken);
                try {
                    const res = await fetch(fetchUrl.toString());
                    if (res.ok || res.status === 401) {
                        App.showToast("Proxy Verified!", "success");
                        const current = Storage.getSettings();
                        Storage.setSettings({ ...current, workerUrl, proxyToken });
                        document.getElementById('authSection').classList.remove('opacity-50', 'pointer-events-none');
                    } else {
                        throw new Error("Proxy returned status " + res.status);
                    }
                } catch (e) {
                    App.showToast("Verification failed. Check Worker URL & Proxy Secret.", "error");
                } finally {
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            },
            saveBeforeOAuth: () => {
                const workerUrl = document.getElementById('settingWorkerUrl').value;
                const proxyToken = document.getElementById('settingProxyToken').value;
                const current = Storage.getSettings();
                Storage.setSettings({ ...current, workerUrl, proxyToken });
                // Send the full, canonical URL for this page so the worker can redirect back here after OAuth
                const returnUrl = encodeURIComponent(new URL('index.html', window.location.href).toString());
                window.location.href = `https://notion-oauth-handler.mimansa-jaiswal.workers.dev/auth/login?from=${returnUrl}`;
            },
            testManualConnection: async (btn) => {
                const workerUrl = document.getElementById('settingWorkerUrl').value;
                const authToken = document.getElementById('settingAuthToken').value;
                const proxyToken = document.getElementById('settingProxyToken').value;
                if (!authToken || !workerUrl) return App.showToast("Token and Worker URL required", "error");
                const originalText = btn.innerText;
                btn.innerText = "Verifying...";
                btn.disabled = true;
                try {
                    const tempSettings = { workerUrl, authToken, proxyToken };
                    const res = await API.request('GET', '/users/me', null, tempSettings);
                    App.showToast(`Verified: ${res.bot?.workspace_name || 'Connected'}`, 'success');
                    Storage.setSettings(tempSettings);
                    App.renderSettingsStatus(tempSettings);
                    document.getElementById('saveSettingsBtn').disabled = false;
                    App.scanForDataSources(tempSettings);
                } catch (e) {
                    App.showToast(e.message, 'error');
                    document.getElementById('saveSettingsBtn').disabled = true;
                } finally {
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            },
            testConnection: async (btn) => {
                App.testManualConnection(btn);
            },
            saveSettings: () => {
                App.closeModal('settingsModal');
                App.showToast("Settings Closed", "success");
                App.renderWelcomeState();
            },
            openModal: (id) => {
                document.getElementById(id).classList.remove('hidden', 'flex');
                document.getElementById(id).classList.add('flex');
                if (id === 'settingsModal') {
                    App.populateSettingsInputs();
                    App.renderSettingsStatus();
                }
                if (id === 'entryModal') {
                    App.state.isEntryModalOpen = true;
                    const streamStopped = App.state.stream
                        ? App.state.stream.getTracks().every(t => t.readyState === 'ended')
                        : true;
                    if (!App.state.stream || streamStopped) App.initCamera();
                    App.startDrawLoop();
                }
                lucide.createIcons();
            },
            closeModal: (id, options = {}) => {
                const { force = false } = options;
                if (id === 'entryModal') {
                    if (!force && App.hasUnsavedEntry()) {
                        const ok = confirm("Discard this entry? Your captured photo and notes will be lost.");
                        if (!ok) return false;
                    }
                    App.state.isEntryModalOpen = false;
                    App.stopDrawLoop();
                    if (App.state.stream) {
                        App.state.stream.getTracks().forEach(t => t.stop());
                        App.state.stream = null;
                    }
                    if (App.state.ghostImageIsObjectUrl && App.state.ghostImageUrl) {
                        URL.revokeObjectURL(App.state.ghostImageUrl);
                    }
                    App.state.ghostImageUrl = null;
                    App.state.ghostImageIsObjectUrl = false;
                }
                document.getElementById(id).classList.add('hidden');
                document.getElementById(id).classList.remove('flex');
                return true;
            }
        };

        window.addEventListener('load', () => {
            App.init();
            registerServiceWorker();
        });
    </script>
</body>

</html>