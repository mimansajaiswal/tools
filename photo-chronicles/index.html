<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Chronicles</title>
    <meta name="theme-color" content="#857593">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Photo Chronicles">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="./manifest.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="./icons/icon-180.png">

    <!-- Tailwind CSS (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.561.0/dist/umd/lucide.min.js"></script>

    <!-- Fonts: Space Grotesk (Headers/Labels) & Inter (Body) -->
    <link
        href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">

    <!-- Tailwind Config for Custom Palette -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        oatmeal: '#E8E2D9',
                        'oatmeal-dark': '#D9D2C7',
                        'earth-metal': '#5C5650',
                        charcoal: '#2C2926',
                        'white-linen': '#F8F6F3',
                        'dull-purple': '#857593',
                        'dull-purple-hover': '#6E6180',
                        'muted-pink': '#C4A3AA',
                        'muted-pink-dim': '#B3929A'
                    },
                    fontFamily: {
                        display: ['"Space Grotesk"', 'system-ui', 'sans-serif'],
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 5px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #D9D2C7;
            border-radius: 2px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #857593;
        }

        /* Camera Overlay Transition */
        .overlay-ghost {
            transition: opacity 0.3s ease, clip-path 0.3s ease;
            pointer-events: none;
        }

        /* Loader */
        .loader {
            border: 2px solid #D9D2C7;
            border-top: 2px solid #857593;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Toast Animation */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast-enter {
            animation: slideIn 0.3s ease-out forwards;
        }

        .toast-exit {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Section Label Style */
        .section-label {
            font-family: 'Space Grotesk', system-ui, sans-serif;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            background: #2C2926;
            color: #F8F6F3;
            padding: 5px 12px;
            display: inline-block;
        }

        /* Entry card */
        .entry-card {
            transition: border-color 0.15s ease;
        }

        .entry-card:hover {
            border-color: #857593;
        }

        /* Welcome blurb */
        .welcome-blurb {
            font-family: 'Space Grotesk', system-ui, sans-serif;
            color: #857593;
            font-size: 0.9rem;
            line-height: 1.7;
        }

        /* Button base */
        .btn-primary {
            background: #2C2926;
            color: #F8F6F3;
            transition: background 0.15s ease;
        }

        .btn-primary:hover {
            background: #1a1816;
        }

        .btn-secondary {
            background: #857593;
            color: #F8F6F3;
            transition: background 0.15s ease;
        }

        .btn-secondary:hover {
            background: #6E6180;
        }

        /* Form inputs */
        input,
        textarea,
        select {
            border-radius: 6px;
        }

        /* Mobile bottom nav improved */
        @media (max-width: 767px) {
            .mobile-nav-btn {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 2px;
                font-size: 10px;
                padding: 8px 12px;
            }
        }

        /* Disable browser default touch behaviors on viewfinder canvas */
        #viewfinder {
            touch-action: none;
        }

        /* Header Sync Widget */
        .sync-status {
            min-width: 128px;
            max-width: 160px;
            padding: 5px 8px 6px;
            border: 1px solid #D9D2C7;
            background: rgba(248, 246, 243, 0.85);
            display: flex;
            flex-direction: column;
            gap: 4px;
            transition: border-color 0.2s ease, background 0.2s ease;
        }

        .sync-status-meta {
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: 'Space Grotesk', system-ui, sans-serif;
            font-size: 9px;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #5C5650;
        }

        .sync-status-dot {
            width: 6px;
            height: 6px;
            border-radius: 9999px;
            background: #B8B0A4;
            transition: background 0.2s ease;
            flex-shrink: 0;
        }

        .sync-status-icon {
            display: none;
            width: 14px;
            height: 14px;
            border-radius: 9999px;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            line-height: 1;
            font-weight: 700;
            color: #fff;
            background: #857593;
            flex-shrink: 0;
        }

        .sync-status-track {
            width: 100%;
            height: 3px;
            background: #E8E2D9;
            overflow: hidden;
        }

        .sync-status-bar {
            display: block;
            width: 0%;
            height: 100%;
            background: #857593;
            transition: width 0.35s ease, background 0.2s ease;
        }

        .sync-status[data-state="syncing"] {
            border-color: #C8BECF;
            background: rgba(133, 117, 147, 0.08);
        }

        .sync-status[data-state="syncing"] .sync-status-dot {
            background: #857593;
        }

        .sync-status[data-state="synced"] {
            border-color: #B8AFC1;
            background: rgba(133, 117, 147, 0.12);
        }

        .sync-status[data-state="synced"] .sync-status-dot {
            display: none;
        }

        .sync-status[data-state="synced"] .sync-status-icon {
            display: inline-flex;
        }

        .sync-status[data-state="synced"] .sync-status-track {
            display: none;
        }

        .sync-status[data-state="offline"],
        .sync-status[data-state="error"] {
            border-color: #E7C0C0;
            background: rgba(251, 235, 235, 0.75);
        }

        .sync-status[data-state="offline"] .sync-status-dot,
        .sync-status[data-state="error"] .sync-status-dot {
            background: #C24D4D;
        }
    </style>
</head>

<body
    class="bg-oatmeal text-earth-metal font-sans h-[100dvh] flex flex-col md:flex-row overflow-hidden selection:bg-dull-purple selection:text-white">

    <!-- Toast Container -->
    <div id="toastContainer"
        class="fixed top-4 right-4 z-[100] flex flex-col gap-2 w-full max-w-sm pointer-events-none"></div>

    <!-- Hidden Canvas for Processing (Global) -->
    <canvas id="photoCanvas" class="hidden"></canvas>

    <!-- Sidebar (Desktop) / Bottom Nav (Mobile) -->
    <aside
        class="order-2 md:order-1 w-full md:w-64 h-16 md:h-full flex-shrink-0 flex flex-row md:flex-col border-t md:border-t-0 md:border-r border-oatmeal-dark bg-oatmeal/50 transition-all duration-300 justify-between z-20">

        <!-- Logo Area -->
        <div class="hidden md:flex h-14 px-5 border-b border-oatmeal-dark items-center gap-3 flex-shrink-0">
            <div class="w-7 h-7 bg-dull-purple flex items-center justify-center text-white-linen">
                <i data-lucide="camera" class="w-4 h-4"></i>
            </div>
            <div class="flex flex-col">
                <h1 class="font-display text-base font-semibold text-charcoal tracking-tight leading-none">Photo
                    Chronicles</h1>
                <span class="text-[9px] uppercase tracking-wider text-earth-metal/50 font-medium mt-0.5">Notion
                    Sync</span>
            </div>
        </div>

        <!-- Diary List -->
        <div class="hidden md:flex flex-col flex-1 overflow-hidden">
            <div class="flex-1 overflow-y-auto p-3 space-y-2" id="diaryListContainer">
                <!-- Diaries injected here -->
            </div>
            <!-- Data Safety Notice (Sidebar) -->
            <div class="p-3 text-[10px] text-earth-metal/40 leading-relaxed border-t border-oatmeal-dark bg-oatmeal/20">
                <i data-lucide="info" class="w-3 h-3 inline mb-0.5 mr-1"></i>
                This app stores the last 25 images locally for fast loading. Data is safely synced to Notion.
                <br><br>
                <span class="font-display font-medium text-earth-metal/50">Note:</span> Images shown here are compressed
                thumbnails. For full quality, please check your Notion data source.
            </div>
        </div>

        <!-- Mobile Nav Items (Only visible on small screens) -->
        <div class="md:hidden flex w-full justify-around items-center px-2 h-full">
            <button onclick="App.openModal('settingsModal')"
                class="mobile-nav-btn text-earth-metal hover:text-dull-purple" aria-label="Open settings">
                <i data-lucide="settings" class="w-5 h-5"></i>
                <span class="font-display font-medium">Settings</span>
            </button>
            <button onclick="App.initNewEntry()" aria-label="Add entry"
                class="mobile-nav-btn bg-charcoal text-white-linen px-5 py-2 hover:bg-dull-purple">
                <i data-lucide="plus" class="w-5 h-5"></i>
                <span class="font-display font-medium">New Entry</span>
            </button>
            <button onclick="App.attemptNewDiary()" class="mobile-nav-btn text-earth-metal hover:text-dull-purple"
                aria-label="Link diary">
                <i data-lucide="book-plus" class="w-5 h-5"></i>
                <span class="font-display font-medium">Link Diary</span>
            </button>
        </div>

        <!-- Sidebar Footer (Desktop) -->
        <div class="hidden md:block p-3 border-t border-oatmeal-dark space-y-1.5 flex-shrink-0">
            <button onclick="App.attemptNewDiary()"
                class="w-full flex items-center justify-start gap-2.5 p-2.5 hover:bg-white-linen text-dull-purple transition-colors font-display text-sm font-medium">
                <i data-lucide="plus" class="w-4 h-4"></i>
                <span>Link Diary</span>
            </button>
            <button onclick="App.openModal('settingsModal')"
                class="w-full flex items-center justify-start gap-2.5 p-2.5 hover:bg-white-linen text-earth-metal transition-colors font-display text-sm">
                <i data-lucide="settings" class="w-4 h-4"></i>
                <span>Settings</span>
            </button>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="order-1 md:order-2 flex-1 flex flex-col min-h-0 relative" id="mainView">

        <!-- Header -->
        <header
            class="h-14 border-b border-oatmeal-dark flex items-center justify-between px-4 md:px-5 bg-white-linen z-10 flex-shrink-0">
            <div class="flex items-center gap-2.5 overflow-hidden">
                <!-- Mobile Diary Switcher Trigger -->
                <button id="mobileDiaryToggleBtn" onclick="App.toggleMobileDiaryMenu(event)"
                    aria-label="Toggle diary list"
                    class="md:hidden border border-oatmeal-dark w-8 h-8 text-earth-metal hover:bg-oatmeal transition-colors flex items-center justify-center">
                    <i data-lucide="library" class="w-4 h-4"></i>
                </button>

                <h2 id="activeDiaryTitle"
                    class="font-display text-lg md:text-xl font-semibold text-charcoal truncate tracking-tight">Select a
                    Diary</h2>
                <div id="syncStatus" data-state="idle" class="sync-status hidden sm:flex flex-shrink-0">
                    <div class="sync-status-meta">
                        <span id="syncStatusDot" class="sync-status-dot"></span>
                        <span id="syncStatusIcon" class="sync-status-icon" aria-hidden="true">✓</span>
                        <span id="syncStatusText">Init</span>
                    </div>
                    <div class="sync-status-track">
                        <span id="syncStatusBar" class="sync-status-bar"></span>
                    </div>
                </div>
            </div>

            <div class="flex items-center gap-2">
                <button onclick="SyncManager.syncCurrentDiary()" title="Refresh Sync" aria-label="Refresh sync"
                    class="border border-oatmeal-dark w-8 h-8 text-earth-metal hover:bg-oatmeal transition-colors flex items-center justify-center">
                    <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                </button>
                <!-- Desktop Add Button -->
                <button id="addEntryBtn" onclick="App.initNewEntry()"
                    class="hidden md:flex bg-charcoal hover:bg-dull-purple text-white-linen px-4 py-2 transition-colors items-center gap-2 font-display text-sm font-medium">
                    <i data-lucide="plus" class="w-4 h-4"></i>
                    <span>Add Entry</span>
                </button>
            </div>
        </header>

        <!-- Mobile Diary Menu (Dropdown/Sheet) -->
        <div id="mobileDiaryMenu"
            class="md:hidden hidden absolute top-14 left-0 w-full bg-white-linen border-b border-oatmeal-dark z-20 max-h-[60vh] overflow-y-auto">
            <div class="p-2" id="mobileDiaryList">
                <!-- Diaries injected here -->
            </div>
        </div>

        <!-- Entry Gallery -->
        <div id="entryGallery" class="flex-1 overflow-y-auto p-4 md:p-8 pb-24 md:pb-8">
            <!-- Content injected via JS -->
        </div>

    </main>

    <!-- MODALS -->

    <!-- 1. Settings Modal -->
    <div id="settingsModal" role="dialog" aria-modal="true"
        class="fixed inset-0 bg-charcoal/30 hidden items-center justify-center z-50 p-4"
        onclick="if(event.target===this) App.closeModal('settingsModal')">
        <div class="bg-white-linen w-full max-w-md p-6 border border-oatmeal-dark relative max-h-full overflow-y-auto">
            <button onclick="App.closeModal('settingsModal')" aria-label="Close settings"
                class="absolute top-4 right-4 text-earth-metal/50 hover:text-charcoal">
                <i data-lucide="x" class="w-5 h-5"></i>
            </button>
            <h3 class="font-display text-lg font-semibold mb-4 text-charcoal tracking-tight">Settings</h3>

            <!-- Connection Status Indicator -->
            <div id="connectionStatus" class="mb-6"></div>

            <form id="settingsForm" onsubmit="event.preventDefault()" autocomplete="off" class="space-y-6">

                <!-- Data Source Instructions (Before Proxy) -->
                <div class="bg-oatmeal border-l-2 border-dull-purple p-3 text-xs text-earth-metal leading-relaxed">
                    <p class="font-display font-semibold mb-1 text-charcoal">Required Notion Data Source Format:</p>
                    <p class="text-[11px] mb-2 opacity-70">Columns: Name (title), Tags (multi-select), Date (date),
                        Files (media), Notes (text).</p>
                    <p>
                        Need a template? <a
                            href="https://mimansajaiswal-embedded-dbs.notion.site/photo-chronicles-template?v=2b423941af7b8019977c000c05dd66cf"
                            target="_blank"
                            class="text-dull-purple underline hover:text-charcoal font-semibold">Duplicate this
                            one</a> and add your own tags to start.
                    </p>
                </div>

                <!-- 1. Proxy Settings (Step 1) -->
                <div class="space-y-3 bg-oatmeal/40 p-4 border border-oatmeal-dark relative">
                    <span class="section-label absolute -top-3 left-3">STEP 1: PROXY</span>

                    <div class="pt-2">
                        <div class="flex justify-between items-center mb-1">
                            <label
                                class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal">API
                                Proxy Worker URL</label>
                            <button onclick="App.openModal('workerHelpModal')" aria-label="Worker setup help"
                                class="text-earth-metal/50 hover:text-charcoal" title="How to set up Worker">
                                <i data-lucide="info" class="w-3.5 h-3.5"></i>
                            </button>
                        </div>
                        <input type="text" id="settingWorkerUrl" placeholder="https://..."
                            oninput="App.onSettingInput()"
                            class="w-full bg-white-linen border border-oatmeal-dark p-2.5 text-sm mb-2">
                    </div>
                    <div>
                        <label
                            class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1">Proxy
                            Secret (Optional)</label>
                        <input type="password" id="settingProxyToken" placeholder="ALL_CORS_PROXY_MATCH_TOKEN"
                            autocomplete="off" oninput="App.onSettingInput()"
                            class="w-full bg-white-linen border border-oatmeal-dark p-2.5 text-sm mb-2">
                    </div>
                    <button type="button" onclick="App.verifyWorker()" id="verifyWorkerBtn"
                        class="w-full bg-dull-purple hover:bg-dull-purple-hover text-white-linen py-2.5 text-xs font-display font-semibold uppercase tracking-wider transition-colors flex items-center justify-center gap-2">
                        Verify Proxy
                    </button>
                </div>

                <!-- 2. Authentication (Step 2) -->
                <div id="authSection"
                    class="bg-oatmeal/40 p-4 border border-oatmeal-dark relative opacity-50 pointer-events-none transition-opacity">
                    <span class="section-label absolute -top-3 left-3">STEP 2: AUTH</span>

                    <div class="flex justify-between items-center mb-2 mt-3">
                        <label
                            class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal">Authentication</label>
                        <a href="https://developers.notion.com/docs/create-a-notion-integration#create-your-integration-in-notion"
                            target="_blank" class="text-earth-metal/50 hover:text-charcoal" title="How to get a token">
                            <i data-lucide="info" class="w-3.5 h-3.5"></i>
                        </a>
                    </div>
                    <div class="flex gap-2 mb-2">
                        <button type="button" onclick="App.saveBeforeOAuth()"
                            class="flex-1 bg-muted-pink text-white-linen py-2.5 flex items-center justify-center gap-2 hover:bg-muted-pink-dim transition-colors group">
                            <i data-lucide="zap" class="w-4 h-4 text-white-linen"></i>
                            <span class="text-sm font-display font-medium">Connect via OAuth</span>
                        </button>
                    </div>
                    <div class="relative flex py-2 items-center">
                        <div class="flex-grow border-t border-oatmeal-dark"></div>
                        <span
                            class="flex-shrink-0 mx-2 text-[9px] text-earth-metal/50 font-display font-semibold uppercase tracking-widest">OR
                            MANUAL KEY</span>
                        <div class="flex-grow border-t border-oatmeal-dark"></div>
                    </div>

                    <!-- Updated Manual Key Input with Verify Button -->
                    <div class="flex gap-2">
                        <input type="password" id="settingAuthToken" placeholder="Paste 'secret_...' token here"
                            autocomplete="off" oninput="App.onSettingInput()"
                            class="flex-1 bg-white-linen border border-oatmeal-dark p-2.5 text-xs outline-none text-earth-metal placeholder-earth-metal/30">
                        <button type="button" onclick="App.testManualConnection(this)"
                            class="bg-dull-purple text-white-linen hover:bg-dull-purple-hover text-xs font-display font-medium px-4 transition-colors">
                            Verify Key
                        </button>
                    </div>
                </div>

                <!-- 3. Upload Limits -->
                <div class="space-y-2 bg-oatmeal/40 p-4 border border-oatmeal-dark">
                    <label
                        class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal">Upload
                        Size Cap</label>
                    <div class="text-[11px] text-earth-metal/60">Default is 5MB (Notion free plan). Paid plans allow up
                        to 20MB.</div>
                    <div class="flex flex-col gap-2 text-xs mt-2">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="uploadCapMb" value="5" onchange="App.setUploadCap(this.value)"
                                class="accent-dull-purple">
                            <span class="font-display">5 MB (Free plan)</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="uploadCapMb" value="20" onchange="App.setUploadCap(this.value)"
                                class="accent-dull-purple">
                            <span class="font-display">20 MB (Paid plan)</span>
                        </label>
                    </div>
                </div>
            </form>

            <details class="group mt-8 border-t border-oatmeal-dark pt-4">
                <summary
                    class="text-[10px] font-display font-semibold uppercase tracking-wider text-red-700 mb-2 cursor-pointer list-none flex items-center gap-2 outline-none">
                    <span class="flex-1">Danger Zone</span>
                    <i data-lucide="chevron-down"
                        class="w-4 h-4 text-red-700 group-open:rotate-180 transition-transform"></i>
                </summary>
                <div class="pt-2">
                    <button onclick="App.resetApp()"
                        class="w-full border border-red-300 bg-red-50 text-red-700 hover:bg-red-100 py-2.5 text-xs font-display font-medium flex items-center justify-center gap-2 transition-colors">
                        <i data-lucide="trash" class="w-3 h-3"></i> Reset App & Clear Cache
                    </button>
                </div>
            </details>

            <div class="mt-6 flex justify-end items-center gap-3">
                <button onclick="App.saveSettings()" id="saveSettingsBtn" disabled
                    class="px-5 py-2.5 bg-dull-purple text-white-linen hover:bg-dull-purple-hover font-display font-medium disabled:opacity-50 disabled:cursor-not-allowed transition-colors">Save
                    Settings</button>
            </div>
        </div>
    </div>

    <!-- 2. Worker Help Modal -->
    <div id="workerHelpModal" role="dialog" aria-modal="true"
        class="fixed inset-0 bg-charcoal/20 backdrop-blur-sm hidden items-center justify-center z-[60] p-4"
        onclick="if(event.target===this) App.closeModal('workerHelpModal')">
        <div class="bg-white-linen w-full max-w-2xl h-[80vh] p-6 border border-oatmeal-dark flex flex-col">
            <div class="flex justify-between items-center mb-4 border-b border-oatmeal-dark pb-2">
                <h3 class="font-display text-lg font-semibold text-charcoal tracking-tight">Setup Cloudflare Worker</h3>
                <button onclick="App.closeModal('workerHelpModal')" aria-label="Close worker help"
                    class="text-earth-metal/50 hover:text-earth-metal">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto space-y-4 text-sm text-earth-metal pr-2">
                <p>To bypass Notion's CORS restrictions, you need a small proxy. We use Cloudflare Workers (Free).</p>
                <ol class="list-decimal pl-5 space-y-2">
                    <li>Go to <a href="https://workers.cloudflare.com/" target="_blank"
                            class="text-dull-purple underline">Cloudflare Workers</a> and create a new Worker.</li>
                    <li>Copy the code below and paste it into the Worker editor (replace default code).</li>
                    <li>Save and Deploy.</li>
                    <li>(Optional) In Worker Settings > Variables, add <code>ALL_CORS_PROXY_MATCH_TOKEN</code>. Then
                        send
                        that value as <code>X-Proxy-Token</code> (query <code>?token=</code> still supported).</li>
                    <li>Copy your Worker's URL (e.g., <code>https://my-proxy.user.workers.dev</code>) and paste it into
                        the app settings.</li>
                </ol>
                <div class="relative">
                    <button onclick="App.copyWorkerCode(this)"
                        class="absolute top-2 right-2 bg-white/80 hover:bg-white px-2 py-1 rounded text-xs shadow text-charcoal font-bold">Copy
                        Code</button>
                    <pre id="workerCodeBlock"
                        class="bg-charcoal text-white-linen p-4 rounded text-xs font-mono overflow-x-auto">
function getAllowedOrigins(env) {
  const raw = (env.ALLOWED_ORIGINS || "https://mimansajaiswal.github.io").trim();
  return raw.split(",").map((s) => s.trim()).filter(Boolean);
}

function isLocalDevOrigin(origin) {
  if (!origin) return false;
  try {
    const parsed = new URL(origin);
    if (parsed.protocol !== "http:" && parsed.protocol !== "https:") return false;
    return parsed.hostname === "localhost" || parsed.hostname === "127.0.0.1";
  } catch (_) {
    return false;
  }
}

function isAllowedOrigin(origin, allowed) {
  if (!origin) return false;
  return allowed.includes(origin) || isLocalDevOrigin(origin);
}

function getCorsHeaders(request, env) {
  const origin = request.headers.get("Origin");
  const allowed = getAllowedOrigins(env);
  const allowOrigin = isAllowedOrigin(origin, allowed) ? origin : allowed[0];
  return {
    "Access-Control-Allow-Origin": allowOrigin,
    "Access-Control-Allow-Methods": "GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization, Notion-Version, X-Proxy-Token",
    "Vary": "Origin",
  };
}

function withCors(request, env, response) {
  const cors = getCorsHeaders(request, env);
  const out = new Response(response.body, response);
  for (const [key, value] of Object.entries(cors)) out.headers.set(key, value);
  out.headers.set("Cache-Control", "no-store");
  return out;
}

function unauthorized(request, env) {
  return withCors(request, env, new Response("Unauthorized", { status: 403 }));
}

function getProxyToken(request) {
  const url = new URL(request.url);
  return request.headers.get("X-Proxy-Token") || url.searchParams.get("token");
}

function buildProxyRequest(targetUrl, request) {
  const headers = new Headers();
  for (const [key, value] of request.headers.entries()) {
    const k = key.toLowerCase();
    if (k === "host") continue;
    if (k === "cookie") continue;
    if (k.startsWith("cf-")) continue;
    if (k === "x-proxy-token") continue;
    headers.set(key, value);
  }

  return new Request(targetUrl, {
    method: request.method,
    headers,
    body: request.method === "GET" || request.method === "HEAD" ? undefined : request.body,
    redirect: "follow",
  });
}

export default {
  async fetch(request, env) {
    if (request.method === "OPTIONS") {
      return new Response(null, { headers: getCorsHeaders(request, env) });
    }

    const url = new URL(request.url);
    const requiredToken = (env.ALL_CORS_PROXY_MATCH_TOKEN || "").trim();
    if (requiredToken) {
      const provided = getProxyToken(request);
      if (!provided || provided !== requiredToken) return unauthorized(request, env);
    }

    const targetUrlParam = url.searchParams.get("url");
    if (!targetUrlParam) {
      return withCors(request, env, new Response("Missing url parameter", { status: 400 }));
    }

    let targetUrl;
    try {
      targetUrl = new URL(targetUrlParam).toString();
    } catch (_) {
      return withCors(request, env, new Response("Invalid target URL", { status: 400 }));
    }

    try {
      const upstream = await fetch(buildProxyRequest(targetUrl, request));
      return withCors(request, env, upstream);
    } catch (e) {
      return withCors(request, env, new Response(`Upstream request failed: ${e?.message || "unknown error"}`, { status: 502 }));
    }
  },
};
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- 3. Link Diary Modal -->
    <div id="newDiaryModal" role="dialog" aria-modal="true"
        class="fixed inset-0 bg-charcoal/30 hidden items-center justify-center z-50 p-4"
        onclick="if(event.target===this) App.closeModal('newDiaryModal')">
        <div
            class="bg-white-linen w-full max-w-md p-6 border border-oatmeal-dark overflow-visible flex flex-col h-[500px]">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="font-display text-lg font-semibold text-charcoal tracking-tight">Link Diary</h3>
                <button onclick="App.scanForDataSources()"
                    class="text-xs text-earth-metal hover:text-charcoal flex items-center gap-1 font-display"
                    id="refreshDbBtn">
                    <i data-lucide="refresh-cw" class="w-3 h-3"></i> Refresh
                </button>
            </div>

            <div class="space-y-4 flex-1 overflow-y-auto pr-1">

                <!-- Searchable Dropdown -->
                <div class="relative">
                    <label
                        class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1">Select
                        Notion Data Source</label>

                    <!-- Info Text Moved Here -->
                    <div class="text-[10px] text-earth-metal/50 mb-3 leading-tight">
                        Only showing datasources with required columns: Name (title), Date (date), Tags (multi-select),
                        Notes (text), Files (media).
                    </div>

                    <div class="relative">
                        <input type="text" id="dbSearchInput" placeholder="Search Data Sources..."
                            onfocus="App.toggleDbDropdown(true)" onkeyup="App.filterDbList(event)"
                            class="w-full bg-white-linen border border-oatmeal-dark p-2.5 text-sm focus:border-dull-purple outline-none"
                            autocomplete="off">
                        <i data-lucide="chevron-down"
                            class="absolute right-3 top-3 w-4 h-4 text-earth-metal/40 pointer-events-none"></i>
                    </div>

                    <!-- Dropdown List -->
                    <div id="dbDropdownList"
                        class="hidden absolute top-full left-0 w-full mt-1 bg-white-linen border border-oatmeal-dark max-h-60 overflow-y-auto z-50">
                        <!-- Items injected here -->
                        <div class="p-4 text-center text-xs text-earth-metal/50 font-display">Type to search...</div>
                    </div>
                </div>

                <!-- Selected DB Info -->
                <div id="selectedDbInfo" class="hidden bg-oatmeal border-l-2 border-dull-purple p-3 mt-4">
                    <div class="section-label mb-2">Selected</div>
                    <div class="font-display text-base font-semibold text-charcoal" id="previewDbTitle"></div>
                    <div class="text-xs text-earth-metal/60 mt-1 line-clamp-2" id="previewDbDesc"></div>
                </div>
            </div>

            <div class="mt-6 flex justify-end gap-3 flex-shrink-0 pt-4 border-t border-oatmeal-dark">
                <button onclick="App.closeModal('newDiaryModal')"
                    class="px-4 py-2 text-earth-metal hover:bg-oatmeal font-display text-sm">Cancel</button>
                <button onclick="App.createDiary()"
                    class="px-5 py-2 bg-charcoal text-white-linen hover:bg-dull-purple font-display font-medium text-sm">Link
                    Diary</button>
            </div>
        </div>
    </div>

    <!-- 4. Delete Confirmation Modal -->
    <div id="deleteModal" role="dialog" aria-modal="true"
        class="fixed inset-0 bg-charcoal/30 hidden items-center justify-center z-[70] p-4"
        onclick="if(event.target===this) App.closeModal('deleteModal')">
        <div class="bg-white-linen w-full max-w-sm p-6 border border-oatmeal-dark">
            <h3 class="font-display text-lg font-semibold text-charcoal mb-2 tracking-tight">Delete Entry?</h3>
            <p class="text-sm text-earth-metal/70 mb-6">This will remove the entry from your <b>local storage</b> AND
                <b>Notion</b>. This action cannot be undone.
            </p>
            <div class="flex justify-end gap-3">
                <button onclick="App.closeModal('deleteModal')"
                    class="px-4 py-2 text-earth-metal hover:bg-oatmeal text-sm font-display">Cancel</button>
                <button onclick="App.executeDelete()"
                    class="px-5 py-2 bg-red-600 text-white hover:bg-red-700 text-sm font-display font-medium">Delete
                    Everywhere</button>
            </div>
        </div>
    </div>

    <!-- 6. Reset Confirmation Modal (New) -->
    <div id="resetConfirmationModal" role="dialog" aria-modal="true"
        class="fixed inset-0 bg-charcoal/30 hidden items-center justify-center z-[80] p-4"
        onclick="if(event.target===this) App.closeModal('resetConfirmationModal')">
        <div class="bg-white-linen w-full max-w-sm p-6 border border-red-300">
            <div class="flex items-center gap-3 mb-2 text-red-700">
                <i data-lucide="alert-triangle" class="w-5 h-5"></i>
                <h3 class="font-display text-lg font-semibold tracking-tight">Reset App?</h3>
            </div>
            <p class="text-sm text-earth-metal/70 mb-6 leading-relaxed">
                This will <b>disconnect Notion</b> and <b>delete all local settings & cache</b>.
                <br><br>
                Your data stored in Notion will stay safe, but you will need to reconnect to see it again.
            </p>
            <div class="flex justify-end gap-3">
                <button onclick="App.closeModal('resetConfirmationModal')"
                    class="px-4 py-2 text-earth-metal hover:bg-oatmeal text-sm font-display">Cancel</button>
                <button onclick="App.executeReset()"
                    class="px-5 py-2 bg-red-600 text-white hover:bg-red-700 text-sm font-display font-medium">Yes, Reset
                    Everything</button>
            </div>
        </div>
    </div>

    <!-- 5. Entry Modal (Live Composite Layout) -->
    <div id="entryModal" role="dialog" aria-modal="true"
        class="fixed inset-0 bg-oatmeal z-50 hidden flex-col overflow-hidden">

        <!-- Close Button -->
        <button onclick="App.closeModal('entryModal')" aria-label="Close entry"
            class="absolute top-4 left-4 z-50 bg-charcoal text-white-linen p-2 hover:bg-dull-purple transition">
            <i data-lucide="x" class="w-5 h-5"></i>
        </button>

        <div id="entryLoadingOverlay"
            class="absolute inset-0 bg-white-linen/90 z-50 hidden items-center justify-center">
            <div class="flex flex-col items-center gap-3 text-earth-metal">
                <div class="loader w-8 h-8 border-2"></div>
                <span id="entryLoadingText"
                    class="text-xs font-display font-semibold tracking-wide uppercase">Processing...</span>
            </div>
        </div>

        <!-- Top Section: Camera Viewfinder (Canvas-based) -->
        <div id="cameraSection"
            class="relative w-full h-[40%] md:h-[50%] max-h-[600px] bg-charcoal/5 flex-shrink-0 flex items-center justify-center overflow-hidden group">

            <!-- Hidden Video Source -->
            <video id="videoSource" autoplay playsinline class="hidden"></video>

            <!-- The Viewfinder Canvas (Live Composite) -->
            <canvas id="viewfinder" class="w-full h-full object-contain z-10"></canvas>

            <!-- Ghost Overlay (Restored as img) -->
            <img id="ghostOverlay"
                class="absolute inset-0 w-full h-full object-contain z-30 pointer-events-none transition-opacity duration-200 opacity-0">

            <!-- Camera Controls -->
            <div id="camControls"
                class="absolute bottom-4 left-0 right-0 z-40 flex flex-col items-center gap-3 transition-opacity duration-200">

                <!-- Segment Indicator (If collage mode > 1) -->
                <div id="segmentIndicator"
                    class="text-charcoal/70 bg-white/80 px-2 py-1 rounded text-[10px] font-mono uppercase tracking-widest hidden shadow-sm">
                    Segment <span id="segCurrent">1</span>/<span id="segTotal">1</span>
                </div>

                <!-- Main Controls Row -->
                <div class="flex items-center justify-center gap-2 sm:gap-4 md:gap-6">

                    <!-- 1. Mirror Toggle (If user facing) -->
                    <button id="mirrorToggleBtn" onclick="App.toggleMirror()" aria-label="Toggle mirror"
                        class="hidden bg-black/40 backdrop-blur-md p-2 sm:p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="flip-horizontal" class="w-5 h-5 sm:w-6 sm:h-6"></i>
                    </button>

                    <!-- 2. Flip Camera Button -->
                    <button onclick="App.flipCamera()" aria-label="Flip camera"
                        class="bg-black/40 backdrop-blur-md p-2 sm:p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="refresh-ccw" class="w-5 h-5 sm:w-6 sm:h-6"></i>
                    </button>

                    <!-- 3. Insert Image (File Input) -->
                    <label aria-label="Insert image"
                        class="cursor-pointer bg-black/40 backdrop-blur-md p-2 sm:p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="image" class="w-5 h-5 sm:w-6 sm:h-6"></i>
                        <input type="file" id="fileInput" accept="image/*" class="hidden"
                            onchange="App.handleFileUpload(event)">
                    </label>

                    <!-- 4. Capture Button (Center) -->
                    <button onclick="App.captureSegment()" id="captureBtn" aria-label="Capture segment"
                        class="w-14 h-14 sm:w-16 sm:h-16 rounded-full border-4 border-white/80 bg-charcoal/60 shadow-[0_0_12px_rgba(0,0,0,0.5)] flex items-center justify-center hover:bg-black/70 transition active:scale-95 backdrop-blur-sm">
                        <div class="w-10 h-10 sm:w-12 sm:h-12 bg-white rounded-full shadow-inner"></div>
                    </button>

                    <!-- 5. Layout Button (Grid Mode) -->
                    <div class="relative group">
                        <button onclick="App.toggleCollageMenu()" id="gridBtn" aria-label="Select collage layout"
                            class="bg-black/40 backdrop-blur-md p-2 sm:p-3 rounded-full hover:bg-black/60 text-white transition font-bold text-[10px] sm:text-xs flex items-center justify-center w-10 h-10 sm:w-12 sm:h-12">
                            1x
                        </button>

                        <!-- Vertical Popup for Grid Selection -->
                        <div id="collageMenu"
                            class="hidden absolute bottom-full left-1/2 -translate-x-1/2 mb-2 bg-black/80 backdrop-blur-md rounded-xl flex-col p-2 gap-2 transition-all shadow-lg w-auto items-center z-50">

                            <!-- 1x -->
                            <button onclick="App.setCollageMode(1)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">1x</button>

                            <!-- 2x Row -->
                            <div class="flex gap-2">
                                <button onclick="App.setCollageMode(2)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">2x
                                    &rarr;</button>
                                <button onclick="App.setCollageMode(5)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">2x
                                    &darr;</button>
                            </div>

                            <!-- 3x Row -->
                            <div class="flex gap-2">
                                <button onclick="App.setCollageMode(3)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">3x
                                    &rarr;</button>
                                <button onclick="App.setCollageMode(6)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">3x
                                    &darr;</button>
                                <button onclick="App.setCollageMode(7)"
                                    class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">3x
                                    1/2</button>
                            </div>

                            <!-- 4x -->
                            <button onclick="App.setCollageMode(4)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">4x</button>
                        </div>
                    </div>

                    <!-- 6. Portrait/Landscape Toggle -->
                    <button onclick="App.toggleOrientation()" id="orientationBtn" aria-label="Toggle orientation"
                        class="bg-black/40 backdrop-blur-md p-2 sm:p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="rectangle-horizontal" class="w-5 h-5 sm:w-6 sm:h-6"></i>
                    </button>

                    <!-- 7. Ghost Button -->
                    <div class="relative flex items-center">
                        <button onclick="App.toggleGhost()" id="ghostToggleBtn" aria-label="Toggle ghost overlay"
                            class="bg-black/40 backdrop-blur-md p-2 sm:p-3 rounded-full hover:bg-black/60 text-white transition opacity-50 peer">
                            <i data-lucide="ghost" class="w-5 h-5 sm:w-6 sm:h-6"></i>
                        </button>
                        <!-- Slider ABOVE - Fixed width & Position -->
                        <div id="ghostSliderContainer"
                            class="hidden absolute bottom-full mb-4 -right-1 bg-black/60 p-2 rounded flex-col items-center">
                            <input type="range" min="0" max="1" step="0.1" value="0.3"
                                class="w-16 h-1 bg-white/50 rounded-lg appearance-none cursor-pointer"
                                oninput="App.setGhostOpacity(this.value)">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Image Manipulation Controls (shown when segment has image) -->
            <div id="imageManipControls"
                class="hidden absolute top-4 right-4 z-40 flex flex-col gap-2 bg-black/60 backdrop-blur-md rounded-xl p-2">
                <!-- Rotation Slider -->
                <div class="flex items-center gap-2 px-2">
                    <i data-lucide="rotate-cw" class="w-4 h-4 text-white/70"></i>
                    <input type="range" id="rotationSlider" min="-180" max="180" step="1" value="0"
                        class="w-20 h-1 bg-white/30 rounded-lg appearance-none cursor-pointer accent-dull-purple"
                        oninput="App.setSegmentRotation(this.value)">
                    <span id="rotationValue" class="text-[10px] text-white/70 w-8 text-right">0°</span>
                </div>
                <!-- Zoom Slider -->
                <div class="flex items-center gap-2 px-2">
                    <i data-lucide="zoom-in" class="w-4 h-4 text-white/70"></i>
                    <input type="range" id="zoomSlider" min="0.5" max="3" step="0.05" value="1"
                        class="w-20 h-1 bg-white/30 rounded-lg appearance-none cursor-pointer accent-dull-purple"
                        oninput="App.setSegmentZoom(this.value)">
                    <span id="zoomValue" class="text-[10px] text-white/70 w-8 text-right">1.0x</span>
                </div>
                <!-- Action Buttons -->
                <div class="flex justify-center gap-1 pt-1 border-t border-white/20">
                    <button onclick="App.flipSegmentHorizontal()" title="Flip Horizontal"
                        class="p-2 hover:bg-white/20 rounded text-white">
                        <i data-lucide="flip-horizontal" class="w-4 h-4"></i>
                    </button>
                    <button onclick="App.flipSegmentVertical()" title="Flip Vertical"
                        class="p-2 hover:bg-white/20 rounded text-white">
                        <i data-lucide="flip-vertical" class="w-4 h-4"></i>
                    </button>
                    <button onclick="App.resetSegmentTransform()" title="Reset"
                        class="p-2 hover:bg-white/20 rounded text-white">
                        <i data-lucide="undo-2" class="w-4 h-4"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Bottom Section: Form (Scrollable) -->
        <div id="formSection" class="flex-1 bg-white-linen p-5 md:p-8 overflow-y-auto w-full md:max-w-2xl md:mx-auto">
            <div class="space-y-5 pb-20">

                <!-- Taken Photo Preview & Retake UI (Hidden by default) -->
                <div id="takenPhotoUI" class="hidden flex-col gap-3 mb-4">
                    <div class="w-full h-64 bg-oatmeal overflow-hidden relative group cursor-pointer border border-oatmeal-dark"
                        onclick="App.handleCollageClick(event)">
                        <img id="smallPreview" class="w-full h-full object-contain">
                        <!-- Hint overlay -->
                        <div
                            class="absolute inset-0 bg-charcoal/30 opacity-0 group-hover:opacity-100 transition flex items-center justify-center text-white text-xs font-display font-medium pointer-events-none">
                            Click segment to edit
                        </div>
                    </div>
                    <div class="flex justify-center gap-2">
                        <button onclick="App.retakeAll()"
                            class="text-xs bg-muted-pink text-white-linen px-4 py-2 hover:bg-muted-pink-dim flex items-center gap-2 transition font-display font-medium">
                            <i data-lucide="refresh-cw" class="w-3 h-3"></i> Retake All
                        </button>
                    </div>
                </div>

                <!-- Segment Edit Overlay (Hidden by default) -->
                <div id="segmentEditOverlay"
                    class="hidden fixed inset-0 bg-charcoal/80 z-50 flex items-center justify-center p-4 overflow-y-auto">
                    <div class="bg-white-linen w-full max-w-sm p-5 space-y-4 my-auto">
                        <div class="flex justify-between items-center">
                            <h3 class="font-display font-semibold text-charcoal">Edit Segment <span
                                    id="editSegmentNum">1</span></h3>
                            <button onclick="App.closeSegmentEdit()" class="text-earth-metal hover:text-charcoal">
                                <i data-lucide="x" class="w-5 h-5"></i>
                            </button>
                        </div>

                        <!-- Live Preview -->
                        <div class="w-full aspect-square bg-charcoal overflow-hidden border border-oatmeal-dark">
                            <canvas id="segEditPreview" class="w-full h-full object-contain"></canvas>
                        </div>

                        <!-- Zoom -->
                        <div>
                            <label
                                class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Zoom</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="segEditZoom" min="0.5" max="3" step="0.05" value="1"
                                    oninput="App.setEditSegmentZoom(this.value)" class="flex-1 accent-dull-purple">
                                <span id="segEditZoomVal" class="text-xs font-display w-10 text-right">1.0x</span>
                            </div>
                        </div>

                        <!-- Rotate -->
                        <div>
                            <label
                                class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Rotate</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="segEditRotation" min="-180" max="180" step="1" value="0"
                                    oninput="App.setEditSegmentRotation(this.value)" class="flex-1 accent-dull-purple">
                                <span id="segEditRotationVal" class="text-xs font-display w-10 text-right">0°</span>
                            </div>
                        </div>

                        <!-- Framing X (Left/Right) -->
                        <div>
                            <label
                                class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Framing
                                X (Left ↔ Right)</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="segEditPanX" min="-300" max="300" step="1" value="0"
                                    oninput="App.setEditSegmentPanX(this.value)" class="flex-1 accent-dull-purple">
                                <span id="segEditPanXVal" class="text-xs font-display w-10 text-right">0</span>
                            </div>
                        </div>

                        <!-- Framing Y (Up/Down) -->
                        <div>
                            <label
                                class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Framing
                                Y (Up ↔ Down)</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="segEditPanY" min="-300" max="300" step="1" value="0"
                                    oninput="App.setEditSegmentPanY(this.value)" class="flex-1 accent-dull-purple">
                                <span id="segEditPanYVal" class="text-xs font-display w-10 text-right">0</span>
                            </div>
                        </div>

                        <!-- Flip buttons -->
                        <div class="flex gap-2 justify-center">
                            <button onclick="App.flipEditSegmentH()"
                                class="flex-1 p-2 bg-oatmeal hover:bg-oatmeal-dark transition flex items-center justify-center gap-1 text-xs font-display">
                                <i data-lucide="flip-horizontal" class="w-4 h-4"></i> Flip H
                            </button>
                            <button onclick="App.flipEditSegmentV()"
                                class="flex-1 p-2 bg-oatmeal hover:bg-oatmeal-dark transition flex items-center justify-center gap-1 text-xs font-display">
                                <i data-lucide="flip-vertical" class="w-4 h-4"></i> Flip V
                            </button>
                        </div>

                        <!-- Action buttons -->
                        <div class="flex gap-2 pt-2 border-t border-oatmeal-dark">
                            <button onclick="App.resetEditSegment()"
                                class="flex-1 p-2 bg-oatmeal hover:bg-oatmeal-dark transition text-xs font-display font-medium flex items-center justify-center gap-1">
                                <i data-lucide="rotate-ccw" class="w-3 h-3"></i> Reset
                            </button>
                            <button onclick="App.retakeEditSegment()"
                                class="flex-1 p-2 bg-muted-pink text-white-linen hover:bg-muted-pink-dim transition text-xs font-display font-medium flex items-center justify-center gap-1">
                                <i data-lucide="camera" class="w-3 h-3"></i> Retake
                            </button>
                            <button onclick="App.applySegmentEdit()"
                                class="flex-1 p-2 bg-dull-purple text-white-linen hover:bg-dull-purple-hover transition text-xs font-display font-medium flex items-center justify-center gap-1">
                                <i data-lucide="check" class="w-3 h-3"></i> Done
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Title -->
                <div>
                    <label
                        class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Title</label>
                    <input type="text" id="entryTitle"
                        class="w-full bg-oatmeal border border-oatmeal-dark p-3 focus:border-dull-purple outline-none text-base font-display font-medium"
                        placeholder="Untitled Entry">
                </div>

                <!-- Date -->
                <div>
                    <label
                        class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Date</label>
                    <input type="datetime-local" id="entryDate"
                        class="w-full bg-oatmeal border border-oatmeal-dark p-3 focus:border-dull-purple outline-none text-sm text-charcoal">
                </div>

                <!-- Notes -->
                <div>
                    <label
                        class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal mb-1.5">Notes</label>
                    <textarea id="entryNotes"
                        class="w-full bg-oatmeal border border-oatmeal-dark p-3 h-32 focus:border-dull-purple outline-none resize-none placeholder-earth-metal/40 leading-relaxed"
                        placeholder="What did you see today?"></textarea>
                </div>

                <!-- Tags -->
                <div>
                    <div class="flex justify-between items-center mb-1.5">
                        <label
                            class="block text-[10px] font-display font-semibold uppercase tracking-wider text-earth-metal">Tags</label>
                        <button onclick="SyncManager.fetchTags(false)"
                            class="text-[10px] text-earth-metal/60 hover:text-charcoal flex items-center gap-1 font-display">
                            <i data-lucide="refresh-ccw" class="w-3 h-3"></i> Refresh
                        </button>
                    </div>
                    <div class="flex flex-wrap gap-2 mb-2" id="activeTags"></div>
                    <div class="relative">
                        <input type="text" id="tagInput" placeholder="Add a tag..."
                            class="w-full bg-oatmeal border border-oatmeal-dark p-3 focus:border-dull-purple outline-none"
                            onkeyup="App.handleTagInput(event)" onfocus="App.handleTagInput(event)">
                        <div id="tagSuggestions"
                            class="absolute top-full left-0 w-full bg-white-linen border border-oatmeal-dark mt-1 z-10 hidden max-h-32 overflow-y-auto">
                        </div>
                    </div>
                </div>

                <!-- Save Button -->
                <div class="pt-4 flex justify-end">
                    <button onclick="App.saveEntry()" id="saveEntryBtn" disabled
                        class="bg-charcoal hover:bg-dull-purple disabled:opacity-50 disabled:cursor-not-allowed text-white-linen px-8 py-3 transition-colors flex items-center justify-center gap-2 text-sm font-display font-semibold">
                        <span>Save Entry</span>
                        <i data-lucide="arrow-right" class="w-4 h-4"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- JAVASCRIPT LOGIC -->
    <script>
        const PWA_CACHE_PREFIX = 'photo-chronicles-cache';
        const LOCAL_SYNCED_ENTRY_LIMIT = 25;
        const NOTE_RICH_TEXT_CHUNK_SIZE = 1900;
        const NOTE_RICH_TEXT_MAX_CHUNKS = 100;
        const OAUTH_HANDLER_URL = 'https://notion-oauth-handler.mimansa-jaiswal.workers.dev';
        const OAUTH_DEV_PASSWORD_KEY = 'oauth_dev_password';

        const registerServiceWorker = () => {
            if (!('serviceWorker' in navigator)) return;
            navigator.serviceWorker.register('./service-worker.js')
                .then((registration) => {
                    console.log('Service worker registered with scope:', registration.scope);
                })
                .catch((err) => console.error('Service worker registration failed:', err));
        };

        const clearPwaData = async () => {
            try {
                if ('caches' in window) {
                    const keys = await caches.keys();
                    await Promise.all(keys.filter((key) => key.startsWith(PWA_CACHE_PREFIX)).map((key) => caches.delete(key)));
                }
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    await Promise.all(
                        registrations
                            .filter((reg) => reg.scope && reg.scope.includes('/photo-chronicles/'))
                            .map((reg) => reg.unregister())
                    );
                }
                if ('indexedDB' in window) {
                    await new Promise((resolve) => {
                        const req = indexedDB.deleteDatabase('photo-chronicles-db');
                        req.onsuccess = () => resolve();
                        req.onerror = () => resolve();
                        req.onblocked = () => resolve();
                    });
                }
            } catch (err) {
                console.warn('PWA cleanup skipped:', err);
            }
        };

        const UTILS = {
            id: () => Math.random().toString(36).substr(2, 9),
            now: () => new Date().toISOString(),
            hash: (value) => {
                const input = String(value || '');
                let hash = 0;
                for (let i = 0; i < input.length; i++) {
                    hash = ((hash << 5) - hash) + input.charCodeAt(i);
                    hash |= 0;
                }
                return Math.abs(hash).toString(36);
            },
            normalizeTag: (tag) => (tag || '').trim().toLowerCase(),
            plainTextFromRichText: (items) => {
                if (!Array.isArray(items) || items.length === 0) return "";
                return items.map((x) => x?.plain_text || x?.text?.content || "").join("");
            },
            truncateText: (value, max = 2000) => {
                const text = String(value || "");
                if (text.length <= max) return text;
                return text.slice(0, max);
            },
            chunkText: (value, chunkSize = NOTE_RICH_TEXT_CHUNK_SIZE, maxChunks = NOTE_RICH_TEXT_MAX_CHUNKS) => {
                const text = String(value || "");
                if (!text) return [];
                const chunks = [];
                for (let i = 0; i < text.length && chunks.length < maxChunks; i += chunkSize) {
                    chunks.push(text.slice(i, i + chunkSize));
                }
                return chunks;
            },
            toNotionRichText: (value) => {
                const normalized = String(value || "").replace(/\r\n/g, '\n');
                if (!normalized.trim()) return [];
                return UTILS.chunkText(normalized).map((content) => ({ text: { content } }));
            },
            sanitizeFilename: (name) => (name || 'photo')
                .toString()
                .replace(/[^a-z0-9-_]+/gi, '_')
                .replace(/^_+|_+$/g, '')
                .slice(0, 80) || 'photo',
            formatTimestampForFilename: (iso) => {
                const d = iso ? new Date(iso) : new Date();
                if (Number.isNaN(d.getTime())) return new Date().toISOString().replace(/[:.]/g, '').slice(0, 15);
                const pad = (n) => String(n).padStart(2, '0');
                return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
            },
            buildPhotoFilename: (diaryTitle, iso, ext = 'webp') => {
                const base = UTILS.sanitizeFilename(diaryTitle || 'Diary');
                const stamp = UTILS.formatTimestampForFilename(iso);
                return `${base}_${stamp}.${ext}`;
            },
            localToUTC: (localDateTimeString) => {
                if (!localDateTimeString) return new Date().toISOString();
                const d = new Date(localDateTimeString);
                return d.toISOString();
            },
            toLocalISO: (date) => {
                const offset = date.getTimezoneOffset() * 60000;
                return new Date(date.getTime() - offset).toISOString().slice(0, 16);
            },
            formatDate: (iso) => new Date(iso).toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }),
            toBase64: (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            }),
            dataURLtoBlob: (dataurl) => {
                var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
                    bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
                while (n--) { u8arr[n] = bstr.charCodeAt(n); }
                return new Blob([u8arr], { type: mime });
            },
            estimateDataUrlSize: (url) => (url.length * 3 / 4) - (url.indexOf(',') > -1 ? url.indexOf(',') : 0),
            // Create a local thumbnail version (350px, 0.6 quality, webp)
            processImage: (imageSource, width = 350, quality = 0.6) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous"; // Try to handle CORS
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const scale = width / img.width;
                        canvas.width = width;
                        canvas.height = img.height * scale;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        try {
                            const dataUrl = canvas.toDataURL('image/webp', quality);
                            resolve(dataUrl);
                        } catch (e) {
                            reject(e);
                        }
                    };
                    img.onerror = (e) => reject(e);
                    img.src = imageSource;
                });
            },
            // High Quality Compression with size cap
            compressToLimit: async (dataUrl, options = {}) => {
                const maxBytes = options.maxBytes ?? 5 * 1024 * 1024;
                const minQuality = options.minQuality ?? 0.86;
                const startQuality = options.startQuality ?? 0.96;
                const step = options.step ?? 0.04;
                const minScale = options.minScale ?? 0.7;

                const originalSize = UTILS.estimateDataUrlSize(dataUrl);
                if (originalSize <= maxBytes) return dataUrl;

                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        let quality = startQuality;
                        let result = dataUrl;
                        let size = originalSize;

                        while (quality >= minQuality) {
                            result = canvas.toDataURL('image/webp', quality);
                            size = UTILS.estimateDataUrlSize(result);
                            if (size <= maxBytes) {
                                resolve(result);
                                return;
                            }
                            quality -= step;
                        }

                        if (size > maxBytes) {
                            const scale = Math.max(minScale, Math.sqrt(maxBytes / size));
                            const newW = Math.max(1, Math.round(canvas.width * scale));
                            const newH = Math.max(1, Math.round(canvas.height * scale));
                            const scaledCanvas = document.createElement('canvas');
                            scaledCanvas.width = newW;
                            scaledCanvas.height = newH;
                            const sctx = scaledCanvas.getContext('2d');
                            sctx.drawImage(canvas, 0, 0, newW, newH);
                            result = scaledCanvas.toDataURL('image/webp', minQuality);
                        }

                        resolve(result);
                    };
                    img.src = dataUrl;
                });
            }
        };

        const ImageStore = {
            db: null,
            dbName: 'photo-chronicles-db',
            storeName: 'photos',
            version: 1,
            isAvailable: () => typeof indexedDB !== 'undefined',
            open: () => {
                if (!ImageStore.isAvailable()) return Promise.reject(new Error('IndexedDB unavailable'));
                if (ImageStore.db) return Promise.resolve(ImageStore.db);
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(ImageStore.dbName, ImageStore.version);
                    req.onupgradeneeded = () => {
                        const db = req.result;
                        if (!db.objectStoreNames.contains(ImageStore.storeName)) {
                            db.createObjectStore(ImageStore.storeName);
                        }
                    };
                    req.onsuccess = () => {
                        ImageStore.db = req.result;
                        resolve(req.result);
                    };
                    req.onerror = () => reject(req.error);
                });
            },
            get: (key) => ImageStore.open().then((db) => new Promise((resolve, reject) => {
                const tx = db.transaction(ImageStore.storeName, 'readonly');
                const store = tx.objectStore(ImageStore.storeName);
                const req = store.get(key);
                req.onsuccess = () => resolve(req.result || null);
                req.onerror = () => reject(req.error);
            })),
            set: (key, blob) => ImageStore.open().then((db) => new Promise((resolve, reject) => {
                const tx = db.transaction(ImageStore.storeName, 'readwrite');
                const store = tx.objectStore(ImageStore.storeName);
                const req = store.put(blob, key);
                req.onsuccess = () => resolve(true);
                req.onerror = () => {
                    const err = req.error;
                    if (err && (err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
                        err.isQuotaExceeded = true;
                    }
                    reject(err);
                };
                tx.onabort = () => {
                    const err = tx.error;
                    if (err && (err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
                        err.isQuotaExceeded = true;
                    }
                    reject(err || new Error('IndexedDB write aborted'));
                };
            })),
            del: (key) => ImageStore.open().then((db) => new Promise((resolve, reject) => {
                const tx = db.transaction(ImageStore.storeName, 'readwrite');
                const store = tx.objectStore(ImageStore.storeName);
                const req = store.delete(key);
                req.onsuccess = () => resolve(true);
                req.onerror = () => reject(req.error);
            }))
        };

        const Storage = {
            getSettings: () => {
                const fallback = {
                    workerUrl: "",
                    authToken: "",
                    proxyToken: "",
                    orientation: "landscape",
                    collageMode: 1,
                    ghostOpacity: 0.3,
                    uploadCapMb: 5
                };
                try {
                    const raw = localStorage.getItem('chronicles_settings');
                    return raw ? JSON.parse(raw) : fallback;
                } catch (e) {
                    localStorage.setItem('chronicles_settings', JSON.stringify(fallback));
                    return fallback;
                }
            },
            setSettings: (s) => {
                const prev = Storage.getSettings();
                localStorage.setItem('chronicles_settings', JSON.stringify(s));
                const prevToken = (prev.authToken || '').trim();
                const nextToken = (s.authToken || '').trim();
                if (prevToken !== nextToken) {
                    Storage.clearAllDataSourceCaches();
                }
            },
            getData: () => {
                try {
                    const raw = localStorage.getItem('chronicles_data');
                    return raw ? JSON.parse(raw) : [];
                } catch (e) {
                    localStorage.setItem('chronicles_data', JSON.stringify([]));
                    return [];
                }
            },
            setData: (d) => localStorage.setItem('chronicles_data', JSON.stringify(d)),
            getLastActiveDiaryId: () => localStorage.getItem('chronicles_last_diary'),
            setLastActiveDiaryId: (id) => {
                if (id) {
                    localStorage.setItem('chronicles_last_diary', id);
                } else {
                    localStorage.removeItem('chronicles_last_diary');
                }
            },

            // Cache for valid Notion data sources
            dataSourceCachePrefix: 'chronicles_ds_cache:',
            getDataSourceCacheKey: (settings = null) => {
                const s = settings || Storage.getSettings();
                const token = (s.authToken || '').trim();
                const scope = token ? UTILS.hash(token) : 'anon';
                return `${Storage.dataSourceCachePrefix}${scope}`;
            },
            getCachedDataSources: (settings = null) => {
                const cacheKey = Storage.getDataSourceCacheKey(settings);
                try {
                    const raw = localStorage.getItem(cacheKey);
                    return raw ? JSON.parse(raw) : [];
                } catch (e) {
                    localStorage.setItem(cacheKey, JSON.stringify([]));
                    return [];
                }
            },
            setCachedDataSources: (sources, settings = null) => {
                const cacheKey = Storage.getDataSourceCacheKey(settings);
                localStorage.setItem(cacheKey, JSON.stringify(sources));
            },
            clearAllDataSourceCaches: () => {
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(Storage.dataSourceCachePrefix)) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach((key) => localStorage.removeItem(key));
            },
            cleanupEntryAssets: (entry) => {
                if (!entry || !ImageStore.isAvailable()) return;
                if (entry.photoKey) {
                    ImageStore.del(entry.photoKey).catch(() => { });
                }
                if (entry.uploadKey) {
                    ImageStore.del(entry.uploadKey).catch(() => { });
                }
            },
            cleanupReplacedEntryAssets: (oldEntry, newEntry) => {
                if (!oldEntry) return;
                const changedPhoto = oldEntry.photoKey && oldEntry.photoKey !== newEntry?.photoKey;
                const changedUpload = oldEntry.uploadKey && oldEntry.uploadKey !== newEntry?.uploadKey;
                if (changedPhoto || changedUpload) {
                    Storage.cleanupEntryAssets({
                        photoKey: changedPhoto ? oldEntry.photoKey : null,
                        uploadKey: changedUpload ? oldEntry.uploadKey : null
                    });
                }
            },
            pruneDiaryEntries: (diary, maxSyncedEntries = LOCAL_SYNCED_ENTRY_LIMIT) => {
                if (!diary || !Array.isArray(diary.entries)) return [];
                const pendingEntryIds = new Set(diary.pendingEntries || []);
                const pendingDeleteEntryIds = new Set((diary.pendingDeleteOps || []).map((op) => op.entryId).filter(Boolean));
                const protectedEntries = [];
                const syncedCandidates = [];
                const evicted = [];

                for (const entry of diary.entries) {
                    const isProtected = pendingEntryIds.has(entry.id) || !entry.synced || pendingDeleteEntryIds.has(entry.id);
                    if (isProtected) {
                        protectedEntries.push(entry);
                        continue;
                    }
                    if (entry.deletedLocally) {
                        evicted.push(entry);
                        continue;
                    }
                    syncedCandidates.push(entry);
                }

                syncedCandidates.sort((a, b) => new Date(b.date) - new Date(a.date));
                const keptSynced = syncedCandidates.slice(0, maxSyncedEntries);
                const trimmedSynced = syncedCandidates.slice(maxSyncedEntries);
                evicted.push(...trimmedSynced);

                const merged = [...protectedEntries, ...keptSynced];
                merged.sort((a, b) => new Date(b.date) - new Date(a.date));
                diary.entries = merged;

                evicted.forEach(Storage.cleanupEntryAssets);
                return evicted;
            },

            saveDiary: (diary) => {
                const data = Storage.getData();
                data.push(diary);
                Storage.setData(data);
            },
            removeEntry: (diaryId, entryId) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                let removed = null;
                if (diary) {
                    const idx = diary.entries.findIndex(e => e.id === entryId);
                    if (idx > -1) {
                        removed = diary.entries[idx];
                        diary.entries.splice(idx, 1);
                    }
                    Storage.setData(data);
                }
                return removed;
            },
            deleteEntry: (diaryId, entryId) => {
                const removed = Storage.removeEntry(diaryId, entryId);
                if (removed) Storage.cleanupEntryAssets(removed);
                return removed;
            },
            markEntryDeletedLocally: (diaryId, entryId) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (!diary) return null;
                const entry = diary.entries.find(e => e.id === entryId);
                if (!entry) return null;
                entry.deletedLocally = true;
                entry.lastDeleteAttempt = UTILS.now();
                Storage.setData(data);
                return entry;
            },
            queuePendingDelete: (diaryId, op) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (!diary || !op?.notionId) return;
                if (!Array.isArray(diary.pendingDeleteOps)) diary.pendingDeleteOps = [];
                const exists = diary.pendingDeleteOps.some((x) => x.notionId === op.notionId);
                if (!exists) {
                    diary.pendingDeleteOps.push({
                        entryId: op.entryId || null,
                        notionId: op.notionId,
                        createdAt: op.createdAt || UTILS.now()
                    });
                    Storage.setData(data);
                }
            },
            clearPendingDelete: (diaryId, notionId) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (!diary || !Array.isArray(diary.pendingDeleteOps) || !notionId) return;
                diary.pendingDeleteOps = diary.pendingDeleteOps.filter((op) => op.notionId !== notionId);
                Storage.setData(data);
            },
            getPendingDeletes: (diaryId) => {
                const diary = Storage.getData().find(d => d.id === diaryId);
                return Array.isArray(diary?.pendingDeleteOps) ? diary.pendingDeleteOps : [];
            },
            finalizeDeletedEntry: (diaryId, entryId, notionId) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (!diary) return null;
                if (!Array.isArray(diary.pendingDeleteOps)) diary.pendingDeleteOps = [];
                if (notionId) {
                    diary.pendingDeleteOps = diary.pendingDeleteOps.filter((op) => op.notionId !== notionId);
                }
                let removed = null;
                if (entryId) {
                    const idx = diary.entries.findIndex((e) => e.id === entryId);
                    if (idx > -1) {
                        removed = diary.entries[idx];
                        diary.entries.splice(idx, 1);
                    }
                }
                if (!removed && notionId) {
                    const idx = diary.entries.findIndex((e) => e.notionId === notionId);
                    if (idx > -1) {
                        removed = diary.entries[idx];
                        diary.entries.splice(idx, 1);
                    }
                }
                Storage.setData(data);
                if (removed) Storage.cleanupEntryAssets(removed);
                return removed;
            },
            saveEntry: (diaryId, entry) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.entries.unshift(entry);
                    const unique = [];
                    const map = new Map();
                    const dedupeEvicted = [];
                    for (const item of diary.entries) {
                        const dedupeKey = item.notionId ? `notion:${item.notionId}` : `local:${item.id}`;
                        if (!map.has(dedupeKey)) {
                            map.set(dedupeKey, true);
                            unique.push(item);
                        } else {
                            dedupeEvicted.push(item);
                        }
                    }
                    diary.entries = unique;
                    dedupeEvicted.forEach(Storage.cleanupEntryAssets);
                    Storage.pruneDiaryEntries(diary, LOCAL_SYNCED_ENTRY_LIMIT);
                    entry.tags.forEach(t => {
                        if (!diary.tags.includes(t)) diary.tags.push(t);
                    });
                    Storage.setData(data);
                }
            },
            updateEntrySyncStatus: (diaryId, entryId, status, notionId = null) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                const entry = diary?.entries.find(e => e.id === entryId);
                if (entry) {
                    entry.synced = status;
                    if (notionId) entry.notionId = notionId;
                    Storage.setData(data);
                }
            },
            updateEntryClientId: (diaryId, entryId, clientEntryId) => {
                if (!clientEntryId) return;
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                const entry = diary?.entries.find(e => e.id === entryId);
                if (entry && !entry.clientEntryId) {
                    entry.clientEntryId = clientEntryId;
                    Storage.setData(data);
                }
            },
            updateDiaryTags: (diaryId, newTags) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    const merged = [...new Set([...diary.tags, ...newTags])];
                    diary.tags = merged;
                    Storage.setData(data);
                }
            },
            replaceDiaryTags: (diaryId, newTags) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.tags = [...new Set(newTags)];
                    Storage.setData(data);
                }
            },
            queuePendingTag: (diaryId, tag) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                const normalized = UTILS.normalizeTag(tag);
                if (diary && normalized) {
                    if (!Array.isArray(diary.pendingTags)) diary.pendingTags = [];
                    const exists = diary.pendingTags.some(t => UTILS.normalizeTag(t) === normalized);
                    if (!exists) diary.pendingTags.push(tag.trim());
                    Storage.setData(data);
                }
            },
            clearPendingTag: (diaryId, tag) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                const normalized = UTILS.normalizeTag(tag);
                if (diary && Array.isArray(diary.pendingTags) && normalized) {
                    diary.pendingTags = diary.pendingTags.filter(t => UTILS.normalizeTag(t) !== normalized);
                    Storage.setData(data);
                }
            },
            queuePendingEntry: (diaryId, entryId) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary && entryId) {
                    if (!Array.isArray(diary.pendingEntries)) diary.pendingEntries = [];
                    if (!diary.pendingEntries.includes(entryId)) {
                        diary.pendingEntries.push(entryId);
                        Storage.setData(data);
                    }
                }
            },
            clearPendingEntry: (diaryId, entryId) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary && Array.isArray(diary.pendingEntries)) {
                    diary.pendingEntries = diary.pendingEntries.filter(id => id !== entryId);
                    Storage.setData(data);
                }
            },
            getPendingEntries: (diaryId) => {
                const diary = Storage.getData().find(d => d.id === diaryId);
                return diary?.pendingEntries || [];
            },
            updateDiaryCameraConfig: (diaryId, config) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    const current = diary.cameraConfig || {};
                    diary.cameraConfig = { ...current, ...config };
                    Storage.setData(data);
                }
            },
            setLastFetch: (diaryId, timeStr) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.lastFetch = timeStr;
                    Storage.setData(data);
                }
            }
        };

        const API = {
            request: async (method, notionEndpoint, body = null, overrideSettings = null) => {
                const { workerUrl, authToken, proxyToken } = overrideSettings || Storage.getSettings();
                if (!workerUrl || !authToken) throw new Error("Missing Settings");

                const cleanWorkerUrl = workerUrl.trim().replace(/\/$/, '');
                const cleanToken = proxyToken ? proxyToken.trim() : null;
                const cleanAuth = authToken.trim();
                const target = `https://api.notion.com/v1${notionEndpoint}`;

                const fetchUrl = new URL(cleanWorkerUrl);
                fetchUrl.searchParams.append('url', target);

                const headers = { 'Authorization': `Bearer ${cleanAuth}`, 'Notion-Version': '2025-09-03' };
                if (cleanToken) headers['X-Proxy-Token'] = cleanToken;
                if (!(body instanceof FormData)) {
                    headers['Content-Type'] = 'application/json';
                    body = body ? JSON.stringify(body) : null;
                }

                try {
                    const res = await fetch(fetchUrl.toString(), { method, headers, body });
                    if (!res.ok) {
                        const txt = await res.text();
                        let errorMsg = `API Error ${res.status}`;
                        try {
                            const json = JSON.parse(txt);
                            if (json.message) errorMsg = json.message;
                            else if (json.error && json.error.message) errorMsg = json.error.message;
                        } catch (e) {
                            if (txt && txt.length < 100) errorMsg += `: ${txt}`;
                        }
                        throw new Error(errorMsg);
                    }
                    return await res.json();
                } catch (e) {
                    if (e.name === 'TypeError' && e.message.includes('Failed to fetch')) {
                        if (!navigator.onLine) {
                            throw new Error("Network Error: You're offline.");
                        }
                        throw new Error("Network Error: Failed to reach proxy. Check Worker URL, CORS headers, or proxy token.");
                    }
                    throw e;
                }
            },
            uploadFileContent: async (uploadUrl, fileBlob) => {
                const { workerUrl, authToken, proxyToken } = Storage.getSettings();
                const cleanWorkerUrl = workerUrl.trim().replace(/\/$/, '');
                const cleanToken = proxyToken ? proxyToken.trim() : null;
                const fetchUrl = new URL(cleanWorkerUrl);
                fetchUrl.searchParams.append('url', uploadUrl);

                const formData = new FormData();
                formData.append("file", fileBlob, "photo.jpg");
                const headers = { 'Authorization': `Bearer ${authToken}`, 'Notion-Version': '2025-09-03' };
                if (cleanToken) headers['X-Proxy-Token'] = cleanToken;

                const res = await fetch(fetchUrl.toString(), { method: 'POST', headers, body: formData });
                if (!res.ok) throw new Error(`Upload Failed`);
                return await res.json();
            },
            fetchDataSources: async (settings = null) => {
                let results = [];
                let hasMore = true;
                let nextCursor = undefined;
                while (hasMore) {
                    const payload = {
                        filter: { value: 'data_source', property: 'object' },
                        page_size: 100,
                        start_cursor: nextCursor
                    };
                    const res = await API.request('POST', '/search', payload, settings);
                    results = [...results, ...res.results];
                    hasMore = res.has_more;
                    nextCursor = res.next_cursor;
                    if (results.length > 300) hasMore = false;
                }
                return results;
            }
        };

        const SyncManager = {
            statusEl: null,
            statusTextEl: null,
            statusBarEl: null,
            hideTimer: null,
            tagSyncQueues: new Map(),
            tagSyncTimers: new Map(),
            retryTimers: new Map(),
            clientIdPropertyReady: new Set(),
            isSyncing: false,
            init: () => {
                SyncManager.statusEl = document.getElementById('syncStatus');
                SyncManager.statusTextEl = document.getElementById('syncStatusText');
                SyncManager.statusBarEl = document.getElementById('syncStatusBar');
                window.addEventListener('online', SyncManager.syncAllDiaries);
                SyncManager.syncAllDiaries();
            },
            updateUI: (status) => {
                const statusEl = SyncManager.statusEl;
                if (!statusEl) return;
                statusEl.classList.remove('hidden');
                if (SyncManager.hideTimer) {
                    clearTimeout(SyncManager.hideTimer);
                    SyncManager.hideTimer = null;
                }

                const textEl = SyncManager.statusTextEl;
                const barEl = SyncManager.statusBarEl;

                const setState = (state, label, progress, color) => {
                    statusEl.setAttribute('data-state', state);
                    if (textEl) textEl.innerText = label;
                    if (barEl) {
                        barEl.style.width = `${progress}%`;
                        if (color) barEl.style.background = color;
                    }
                };

                if (status === 'syncing') {
                    setState('syncing', 'Syncing', 72, '#857593');
                } else if (status === 'offline') {
                    setState('offline', 'Offline', 24, '#C24D4D');
                } else if (status === 'synced') {
                    setState('synced', 'Synced', 100, '#857593');
                } else {
                    setState('error', 'Error', 100, '#C24D4D');
                }
            },
            withSyncLock: async (fn) => {
                if (SyncManager.isSyncing) return false;
                SyncManager.isSyncing = true;
                try {
                    await fn();
                } finally {
                    SyncManager.isSyncing = false;
                }
                return true;
            },
            getDiariesWithPendingWork: () => {
                const data = Storage.getData();
                return data
                    .filter((diary) => {
                        const pendingEntries = Array.isArray(diary.pendingEntries) && diary.pendingEntries.length > 0;
                        const pendingDeletes = Array.isArray(diary.pendingDeleteOps) && diary.pendingDeleteOps.length > 0;
                        const unsynced = (diary.entries || []).some((entry) => !entry.synced && !entry.deletedLocally);
                        return pendingEntries || pendingDeletes || unsynced;
                    })
                    .map((diary) => diary.id);
            },
            fetchTags: async (silent = false) => {
                const diaryId = App.state.activeDiaryId;
                if (!diaryId) return;
                const diary = Storage.getData().find(d => d.id === diaryId);
                if (!diary?.dataSourceId) return;

                try {
                    if (!silent) App.showToast("Fetching tags...", "info");
                    const res = await API.request('GET', `/data_sources/${diary.dataSourceId}`);
                    const properties = res.properties || {};
                    if (properties["Tags"] && properties["Tags"].multi_select) {
                        const options = properties["Tags"].multi_select.options.map(o => o.name);
                        Storage.replaceDiaryTags(diaryId, options);
                        App.state.diaries = Storage.getData();
                        if (!silent) App.showToast(`Updated ${options.length} tags.`, "success");
                    }
                } catch (e) {
                    console.error("Tag fetch failed", e);
                    if (!silent) App.showToast("Could not fetch tags schema.", "error");
                }
            },
            queueTagSync: (diaryId, tag) => {
                if (!diaryId || !tag) return;
                const cleanTag = tag.trim();
                if (!cleanTag) return;
                const queue = SyncManager.tagSyncQueues.get(diaryId) || new Set();
                queue.add(cleanTag);
                SyncManager.tagSyncQueues.set(diaryId, queue);

                const existingTimer = SyncManager.tagSyncTimers.get(diaryId);
                if (existingTimer) clearTimeout(existingTimer);
                const timer = setTimeout(async () => {
                    SyncManager.tagSyncTimers.delete(diaryId);
                    const pending = Array.from(SyncManager.tagSyncQueues.get(diaryId) || []);
                    SyncManager.tagSyncQueues.delete(diaryId);
                    for (const pendingTag of pending) {
                        await SyncManager.addTagToNotion(diaryId, pendingTag);
                    }
                }, 400);
                SyncManager.tagSyncTimers.set(diaryId, timer);
            },
            scheduleRetry: (diaryId) => {
                if (!diaryId || !navigator.onLine) return;
                if (SyncManager.retryTimers.has(diaryId)) return;
                const timer = setTimeout(() => {
                    SyncManager.retryTimers.delete(diaryId);
                    SyncManager.syncAllDiaries();
                }, 15000);
                SyncManager.retryTimers.set(diaryId, timer);
            },
            syncAllDiaries: async () => {
                const activeDiaryId = App.state.activeDiaryId;
                if (!activeDiaryId && SyncManager.getDiariesWithPendingWork().length === 0) return;
                await SyncManager.withSyncLock(async () => {
                    if (!navigator.onLine) {
                        if (activeDiaryId) SyncManager.updateUI('offline');
                        return;
                    }
                    const pendingDiaryIds = SyncManager.getDiariesWithPendingWork();
                    const orderedDiaryIds = [...new Set([activeDiaryId, ...pendingDiaryIds].filter(Boolean))];
                    for (const diaryId of orderedDiaryIds) {
                        const includePull = diaryId === activeDiaryId;
                        const showUi = diaryId === activeDiaryId;
                        await SyncManager.syncDiary(diaryId, { includePull, showUi });
                    }
                });
            },
            syncCurrentDiary: async () => {
                const diaryId = App.state.activeDiaryId;
                if (!diaryId) return;
                await SyncManager.withSyncLock(async () => {
                    await SyncManager.syncDiary(diaryId, { includePull: true, showUi: true });
                });
            },
            syncDiary: async (diaryId, options = {}) => {
                if (!diaryId) return;
                const includePull = options.includePull !== false;
                const showUi = options.showUi === true;

                let diary = Storage.getData().find(d => d.id === diaryId);
                if (!diary || !diary.dataSourceId) return;
                if (!navigator.onLine) {
                    if (showUi) SyncManager.updateUI('offline');
                    return;
                }

                if (showUi) {
                    SyncManager.updateUI('syncing');
                    App.state.isLoading = true;
                    App.renderDiaryView();
                }

                try {
                    await SyncManager.syncPendingDeletes(diaryId);
                    diary = Storage.getData().find(d => d.id === diaryId);
                    if (!diary) return;

                    const pendingIds = Storage.getPendingEntries(diaryId);
                    const pendingEntries = pendingIds
                        .map((id) => diary.entries.find((e) => e.id === id))
                        .filter((entry) => entry && !entry.deletedLocally);
                    const unsynced = (diary.entries || []).filter((entry) => !entry.synced && !entry.deletedLocally);
                    const pushQueue = [];
                    const pushSeen = new Set();
                    for (const item of [...pendingEntries, ...unsynced]) {
                        if (!item) continue;
                        const dedupe = item.notionId
                            ? `notion:${item.notionId}`
                            : `client:${item.clientEntryId || item.id}`;
                        if (pushSeen.has(dedupe)) continue;
                        pushSeen.add(dedupe);
                        pushQueue.push(item);
                    }

                    for (const entry of pushQueue) {
                        if (!entry.clientEntryId) {
                            const generatedClientId = (typeof crypto !== 'undefined' && crypto.randomUUID)
                                ? crypto.randomUUID()
                                : `entry-${entry.id}-${Date.now()}`;
                            Storage.updateEntryClientId(diaryId, entry.id, generatedClientId);
                            entry.clientEntryId = generatedClientId;
                        }
                        try {
                            const notionId = await SyncManager.pushEntryToNotion(diary.dataSourceId, entry);
                            Storage.updateEntrySyncStatus(diaryId, entry.id, true, notionId);
                            Storage.clearPendingEntry(diaryId, entry.id);
                            App.state.diaries = Storage.getData();
                        } catch (err) {
                            console.error("Failed to push entry", entry, err);
                            Storage.queuePendingEntry(diaryId, entry.id);
                            SyncManager.scheduleRetry(diaryId);
                            if (showUi) {
                                App.showToast(`Sync failed for entry "${entry.title}".`, "error");
                            }
                        }
                    }

                    if (includePull) {
                        const payload = {
                            page_size: LOCAL_SYNCED_ENTRY_LIMIT,
                            sorts: [{ property: 'Date', direction: 'descending' }]
                        };
                        const response = await API.request('POST', `/data_sources/${diary.dataSourceId}/query`, payload);
                        const currentData = Storage.getData();
                        const activeDiary = currentData.find((d) => d.id === diaryId);
                        if (!activeDiary) return;
                        const pendingDeleteNotionIds = new Set(
                            (activeDiary.pendingDeleteOps || []).map((op) => op.notionId).filter(Boolean)
                        );

                        for (const page of response.results) {
                            const props = page.properties || {};
                            const clientEntryIdFromNotion = UTILS.plainTextFromRichText(props["Client Entry ID"]?.rich_text);
                            const localIndex = activeDiary.entries.findIndex((entry) => (
                                entry.notionId === page.id ||
                                (clientEntryIdFromNotion && entry.clientEntryId === clientEntryIdFromNotion)
                            ));
                            const existingEntry = localIndex > -1 ? activeDiary.entries[localIndex] : null;
                            if (pendingDeleteNotionIds.has(page.id) || existingEntry?.deletedLocally) {
                                continue;
                            }

                            const getDate = (p) => p?.date?.start || UTILS.now();
                            const getTags = (p) => p?.multi_select?.map(x => x.name) || [];
                            const notesContent = UTILS.plainTextFromRichText(props.Notes?.rich_text);
                            const titleContent = UTILS.plainTextFromRichText(props.Name?.title) || "(No Title)";

                            let notionPhotoUrl = null;
                            if (props.Files?.files?.length > 0) {
                                const f = props.Files.files[0];
                                notionPhotoUrl = f.file?.url || f.external?.url;
                            }

                            let localPhotoData = null;
                            let photoKey = existingEntry?.photoKey || null;
                            const entryId = existingEntry ? existingEntry.id : UTILS.id();
                            if (existingEntry?.photoDataURL && existingEntry.photoDataURL.startsWith('data:')) {
                                localPhotoData = existingEntry.photoDataURL;
                            }

                            if (!localPhotoData && !photoKey && notionPhotoUrl) {
                                try {
                                    const previewData = await UTILS.processImage(notionPhotoUrl, 640, 0.72);
                                    if (ImageStore.isAvailable()) {
                                        const key = `entry_${entryId}_preview`;
                                        try {
                                            await ImageStore.set(key, UTILS.dataURLtoBlob(previewData));
                                            photoKey = key;
                                        } catch (storeErr) {
                                            if (storeErr?.isQuotaExceeded) {
                                                localPhotoData = previewData;
                                                if (showUi) App.showToast("Storage full; keeping preview in memory only.", "error");
                                            } else {
                                                throw storeErr;
                                            }
                                        }
                                    } else {
                                        localPhotoData = previewData;
                                    }
                                } catch (err) {
                                    console.warn("Failed to download/process image from Notion", err);
                                    localPhotoData = null;
                                }
                            }

                            const syncedEntry = {
                                id: entryId,
                                clientEntryId: clientEntryIdFromNotion || existingEntry?.clientEntryId || `entry-${entryId}`,
                                notionId: page.id,
                                date: getDate(props.Date),
                                title: titleContent,
                                notes: notesContent,
                                tags: getTags(props.Tags),
                                photoDataURL: localPhotoData,
                                photoKey: photoKey,
                                synced: true,
                                deletedLocally: false
                            };

                            if (localIndex > -1) {
                                Storage.cleanupReplacedEntryAssets(existingEntry, syncedEntry);
                                activeDiary.entries[localIndex] = syncedEntry;
                            } else {
                                activeDiary.entries.push(syncedEntry);
                            }
                        }

                        activeDiary.entries.sort((a, b) => new Date(b.date) - new Date(a.date));
                        Storage.pruneDiaryEntries(activeDiary, LOCAL_SYNCED_ENTRY_LIMIT);
                        Storage.setData(currentData);
                        App.state.diaries = currentData;
                        await SyncManager.fetchTags(true);
                    }
                    await SyncManager.syncPendingTags(diaryId);

                    if (showUi) SyncManager.updateUI('synced');
                } catch (e) {
                    console.error("Sync Error", e);
                    if (showUi) {
                        SyncManager.updateUI('error');
                        if (e.message.includes("CORS") || e.message.includes("Network Error")) {
                            App.showToast(e.message, 'error');
                        }
                    }
                    SyncManager.scheduleRetry(diaryId);
                } finally {
                    if (showUi) {
                        App.state.isLoading = false;
                        App.renderDiaryView();
                        App.renderSidebar();
                    }
                }
            },
            syncPendingDeletes: async (diaryId) => {
                const pendingDeletes = Storage.getPendingDeletes(diaryId);
                for (const op of pendingDeletes) {
                    if (!op?.notionId) continue;
                    try {
                        await API.request('PATCH', `/pages/${op.notionId}`, { archived: true });
                        const removed = Storage.finalizeDeletedEntry(diaryId, op.entryId, op.notionId);
                        if (removed?.id) App.revokeEntryImageCache(removed.id);
                    } catch (err) {
                        const msg = String(err?.message || '').toLowerCase();
                        if (msg.includes('not found') || msg.includes('could not find')) {
                            const removed = Storage.finalizeDeletedEntry(diaryId, op.entryId, op.notionId);
                            if (removed?.id) App.revokeEntryImageCache(removed.id);
                            continue;
                        }
                        console.error("Pending delete failed", op, err);
                        SyncManager.scheduleRetry(diaryId);
                    }
                }
                App.state.diaries = Storage.getData();
            },
            syncPendingTags: async (diaryId) => {
                const diary = Storage.getData().find(d => d.id === diaryId);
                const pending = diary?.pendingTags || [];
                for (const tag of pending) {
                    await SyncManager.addTagToNotion(diaryId, tag, { silent: true, fromQueue: true });
                }
            },
            addTagToNotion: async (diaryId, tag, options = {}) => {
                const diary = Storage.getData().find(d => d.id === diaryId);
                const cleanTag = tag ? tag.trim() : '';
                if (!diary || !diary.dataSourceId || !cleanTag) return;
                const normalized = UTILS.normalizeTag(cleanTag);

                try {
                    const res = await API.request('GET', `/data_sources/${diary.dataSourceId}`);
                    const properties = res.properties || {};
                    if (!properties["Tags"] || !properties["Tags"].multi_select) {
                        throw new Error("Tags property missing");
                    }

                    const currentOptions = properties["Tags"].multi_select.options.map(o => o.name);
                    const exists = currentOptions.some(t => UTILS.normalizeTag(t) === normalized);
                    const merged = exists ? currentOptions : [...currentOptions, cleanTag];
                    const unique = [];
                    const seen = new Set();
                    for (const name of merged) {
                        const key = UTILS.normalizeTag(name);
                        if (!key || seen.has(key)) continue;
                        seen.add(key);
                        unique.push({ name });
                    }

                    await API.request('PATCH', `/data_sources/${diary.dataSourceId}`, {
                        properties: { "Tags": { "multi_select": { "options": unique } } }
                    });

                    Storage.replaceDiaryTags(diaryId, unique.map(o => o.name));
                    Storage.clearPendingTag(diaryId, cleanTag);
                    App.state.diaries = Storage.getData();
                    if (!options.silent) App.showToast(`Added "${cleanTag}" tag in Notion.`, "success");
                } catch (e) {
                    console.error("Notion tag update failed", e);
                    if (!options.fromQueue) Storage.queuePendingTag(diaryId, cleanTag);
                    if (!options.silent) App.showToast("Couldn't update tags in Notion. Will retry later.", "error");
                }
            },
            ensureClientEntryIdProperty: async (dbId) => {
                if (SyncManager.clientIdPropertyReady.has(dbId)) return true;
                try {
                    const ds = await API.request('GET', `/data_sources/${dbId}`);
                    const properties = ds.properties || {};
                    if (properties["Client Entry ID"]) {
                        if (properties["Client Entry ID"].type === 'rich_text') {
                            SyncManager.clientIdPropertyReady.add(dbId);
                            return true;
                        }
                        return false;
                    }
                    await API.request('PATCH', `/data_sources/${dbId}`, {
                        properties: {
                            "Client Entry ID": { rich_text: {} }
                        }
                    });
                    SyncManager.clientIdPropertyReady.add(dbId);
                    return true;
                } catch (err) {
                    console.warn("Client Entry ID property setup failed", err);
                    return false;
                }
            },
            findExistingPageByClientEntryId: async (dbId, clientEntryId) => {
                if (!clientEntryId) return null;
                try {
                    const res = await API.request('POST', `/data_sources/${dbId}/query`, {
                        page_size: 1,
                        filter: {
                            property: "Client Entry ID",
                            rich_text: { equals: clientEntryId }
                        }
                    });
                    return res.results?.[0]?.id || null;
                } catch (err) {
                    return null;
                }
            },
            buildEntryProperties: (entry, uploadedFileId = null) => {
                const titleToSend = UTILS.truncateText(entry.title || "Untitled Entry", 2000);
                const properties = {
                    "Name": { "title": [{ "text": { "content": titleToSend } }] },
                    "Date": { "date": { "start": entry.date } },
                    "Notes": { "rich_text": UTILS.toNotionRichText(entry.notes) },
                    "Tags": { "multi_select": (entry.tags || []).map((t) => ({ "name": t })) }
                };
                if (entry.clientEntryId) {
                    properties["Client Entry ID"] = {
                        "rich_text": [{ "text": { "content": entry.clientEntryId } }]
                    };
                }
                if (uploadedFileId) {
                    properties["Files"] = {
                        "files": [{ "type": "file_upload", "file_upload": { "id": uploadedFileId } }]
                    };
                }
                return properties;
            },
            pushEntryToNotion: async (dbId, entry) => {
                let uploadedFileId = null;
                const clientEntryId = entry.clientEntryId || `entry-${entry.id || UTILS.id()}`;
                entry.clientEntryId = clientEntryId;

                const uploadBlob = await App.getUploadBlob(entry);
                if (uploadBlob) {
                    try {
                        const filename = UTILS.buildPhotoFilename(entry.diaryTitle || entry.title, entry.date, 'webp');
                        const initRes = await API.request('POST', '/file_uploads', {
                            "object": "file_upload", "filename": filename, "content_type": "image/webp"
                        });
                        await API.uploadFileContent(initRes.upload_url, uploadBlob);
                        uploadedFileId = initRes.id;
                    } catch (err) {
                        App.showToast("Image upload failed, saving text.", "error");
                    }
                }

                const supportsClientId = await SyncManager.ensureClientEntryIdProperty(dbId);
                const properties = SyncManager.buildEntryProperties(entry, uploadedFileId);
                if (supportsClientId) {
                    const existingId = await SyncManager.findExistingPageByClientEntryId(dbId, clientEntryId);
                    if (existingId) {
                        await API.request('PATCH', `/pages/${existingId}`, { properties });
                        return existingId;
                    }
                }

                const res = await API.request('POST', '/pages', {
                    parent: { data_source_id: dbId },
                    properties
                });
                return res.id;
            }
        };

        const App = {
            state: {
                diaries: [],
                activeDiaryId: null,
                stream: null,
                facingMode: 'environment',
                capturedImage: null, // Low res for UI
                capturedImageHighRes: null, // New: High res for upload
                captureBase: null,
                videoDims: { width: 0, height: 0 },
                currentTags: [],
                ghostMode: false,
                ghostImageObj: null,
                ghostImageUrl: null,
                ghostImageIsObjectUrl: false,
                ghostOpacity: 0.3,
                orientation: 'landscape',
                collageMode: 1,
                activeSegment: 0,
                segments: [],
                mirrorVideo: false,
                selectedDataSource: null,
                cachedDataSources: [],
                isLoading: false,
                imageUrlCache: new Map(),
                isEntryModalOpen: false,
                drawLoopHandle: null,
                entryLoading: false
            },
            getDiaryCameraConfig: (diary) => {
                const s = Storage.getSettings();
                const defaults = {
                    facingMode: 'environment',
                    mirrorVideo: false,
                    collageMode: s.collageMode || 1,
                    ghostOpacity: s.ghostOpacity || 0.3,
                    ghostMode: false
                };
                if (!diary) return defaults;
                const cfg = diary.cameraConfig || {};
                return {
                    facingMode: cfg.facingMode || defaults.facingMode,
                    mirrorVideo: typeof cfg.mirrorVideo === 'boolean' ? cfg.mirrorVideo : defaults.mirrorVideo,
                    collageMode: Number(cfg.collageMode) || defaults.collageMode,
                    ghostOpacity: typeof cfg.ghostOpacity === 'number' ? cfg.ghostOpacity : defaults.ghostOpacity,
                    ghostMode: typeof cfg.ghostMode === 'boolean' ? cfg.ghostMode : defaults.ghostMode
                };
            },
            applyDiaryCameraConfig: (diary) => {
                const cfg = App.getDiaryCameraConfig(diary);
                App.state.facingMode = cfg.facingMode;
                App.state.mirrorVideo = cfg.mirrorVideo;
                App.state.ghostOpacity = cfg.ghostOpacity;
                App.state.ghostMode = cfg.ghostMode;
                App.setCollageMode(cfg.collageMode);
            },
            persistActiveDiaryCameraConfig: (config) => {
                if (!App.state.activeDiaryId) return;
                Storage.updateDiaryCameraConfig(App.state.activeDiaryId, config);
                App.state.diaries = Storage.getData();
            },
            tagMatch: (list, tag) => list.find(t => UTILS.normalizeTag(t) === UTILS.normalizeTag(tag)),
            hasTag: (list, tag) => !!App.tagMatch(list, tag),
            getVisibleEntries: (diary) => (diary?.entries || []).filter((entry) => !entry.deletedLocally),
            getUploadCapBytes: () => {
                const s = Storage.getSettings();
                const mb = Number(s.uploadCapMb) || 5;
                return mb * 1024 * 1024;
            },
            getMaxUploadPixels: () => {
                const capMb = Number(Storage.getSettings().uploadCapMb) || 5;
                return capMb >= 20 ? 32000000 : 16000000;
            },
            getTargetBaseDimensions: () => {
                if (App.state.orientation === 'portrait') {
                    return { width: 1920, height: 2560 };
                }
                return { width: 2560, height: 1920 };
            },
            getMaxCropDimensions: (videoW, videoH, ratio) => {
                if (!videoW || !videoH) return null;
                const srcRatio = videoW / videoH;
                if (srcRatio > ratio) {
                    const h = videoH;
                    const w = Math.round(h * ratio);
                    return { width: w, height: h };
                }
                const w = videoW;
                const h = Math.round(w / ratio);
                return { width: w, height: h };
            },
            getBaseDimensions: (videoW, videoH) => {
                const target = App.getTargetBaseDimensions();
                const ratio = target.width / target.height;
                const maxFromVideo = App.getMaxCropDimensions(videoW, videoH, ratio);
                if (!maxFromVideo) return target;
                return {
                    width: Math.min(target.width, maxFromVideo.width),
                    height: Math.min(target.height, maxFromVideo.height)
                };
            },
            getFinalCanvasDimensions: (baseW, baseH, multW, multH) => {
                let W = baseW * multW;
                let H = baseH * multH;
                const maxPixels = App.getMaxUploadPixels();
                const totalPixels = W * H;
                if (totalPixels > maxPixels) {
                    const scale = Math.sqrt(maxPixels / totalPixels);
                    W = Math.max(1, Math.round(W * scale));
                    H = Math.max(1, Math.round(H * scale));
                }
                return { width: W, height: H };
            },
            getVideoConstraints: () => {
                const target = App.getTargetBaseDimensions();
                return {
                    facingMode: App.state.facingMode,
                    width: { ideal: target.width },
                    height: { ideal: target.height },
                    aspectRatio: { ideal: target.width / target.height }
                };
            },
            clearImageUrlCache: () => {
                App.state.imageUrlCache.forEach((val) => {
                    if (val && val.isObjectUrl) URL.revokeObjectURL(val.src);
                });
                App.state.imageUrlCache.clear();
            },
            revokeEntryImageCache: (entryId) => {
                const cached = App.state.imageUrlCache.get(entryId);
                if (cached && cached.isObjectUrl) URL.revokeObjectURL(cached.src);
                App.state.imageUrlCache.delete(entryId);
            },
            setEntryLoading: (isLoading, message = "Processing...") => {
                App.state.entryLoading = isLoading;
                const overlay = document.getElementById('entryLoadingOverlay');
                const text = document.getElementById('entryLoadingText');
                if (text) text.innerText = message;
                if (overlay) {
                    overlay.classList.toggle('hidden', !isLoading);
                    overlay.classList.toggle('flex', isLoading);
                }
                const saveBtn = document.getElementById('saveEntryBtn');
                const captureBtn = document.getElementById('captureBtn');
                if (saveBtn) {
                    if (isLoading) {
                        saveBtn.dataset.wasDisabled = saveBtn.disabled ? "1" : "0";
                        saveBtn.disabled = true;
                    } else {
                        if (saveBtn.dataset.wasDisabled === "0") saveBtn.disabled = false;
                        delete saveBtn.dataset.wasDisabled;
                    }
                }
                if (captureBtn) {
                    if (isLoading) {
                        captureBtn.dataset.wasDisabled = captureBtn.disabled ? "1" : "0";
                        captureBtn.disabled = true;
                    } else {
                        if (captureBtn.dataset.wasDisabled === "0") captureBtn.disabled = false;
                        delete captureBtn.dataset.wasDisabled;
                    }
                }
            },
            hasUnsavedEntry: () => {
                if (!App.state.isEntryModalOpen) return false;
                const title = document.getElementById('entryTitle')?.value?.trim() || '';
                const notes = document.getElementById('entryNotes')?.value?.trim() || '';
                const hasSegments = Array.isArray(App.state.segments) && App.state.segments.some(Boolean);
                return !!(App.state.capturedImage || hasSegments || App.state.currentTags.length || title || notes);
            },
            startDrawLoop: () => {
                if (App.state.drawLoopHandle) return;
                App.state.drawLoopHandle = requestAnimationFrame(App.drawLoop);
            },
            stopDrawLoop: () => {
                if (App.state.drawLoopHandle) {
                    cancelAnimationFrame(App.state.drawLoopHandle);
                    App.state.drawLoopHandle = null;
                }
            },
            loadEntryImage: async (entry) => {
                if (!entry) return null;
                if (entry.photoDataURL) return { src: entry.photoDataURL, isObjectUrl: false };
                if (entry.photoKey && ImageStore.isAvailable()) {
                    try {
                        const blob = await ImageStore.get(entry.photoKey);
                        if (blob) {
                            return { src: URL.createObjectURL(blob), isObjectUrl: true };
                        }
                    } catch (e) {
                    }
                }
                return null;
            },
            loadEntryImages: async (entries) => {
                App.clearImageUrlCache();
                const results = await Promise.all(entries.map(async (entry) => {
                    const res = await App.loadEntryImage(entry);
                    if (res) App.state.imageUrlCache.set(entry.id, res);
                    return { id: entry.id, src: res?.src || null };
                }));
                const map = new Map();
                results.forEach(r => map.set(r.id, r.src));
                return map;
            },
            getUploadBlob: async (entry) => {
                if (!entry) return null;
                if (entry.uploadKey && ImageStore.isAvailable()) {
                    try {
                        const blob = await ImageStore.get(entry.uploadKey);
                        if (blob) return blob;
                    } catch (e) {
                    }
                }
                if (entry.photoKey && ImageStore.isAvailable()) {
                    try {
                        const blob = await ImageStore.get(entry.photoKey);
                        if (blob) return blob;
                    } catch (e) {
                    }
                }
                if (entry.uploadDataURL && entry.uploadDataURL.startsWith('data:')) {
                    return UTILS.dataURLtoBlob(entry.uploadDataURL);
                }
                if (entry.photoDataURL && entry.photoDataURL.startsWith('data:')) {
                    return UTILS.dataURLtoBlob(entry.photoDataURL);
                }
                return null;
            },
            migratePhotoStorage: async () => {
                if (!ImageStore.isAvailable()) return;
                const data = Storage.getData();
                let changed = false;
                for (const diary of data) {
                    for (const entry of diary.entries || []) {
                        if (entry.photoDataURL && entry.photoDataURL.startsWith('data:') && !entry.photoKey) {
                            const key = `entry_${entry.id}_preview`;
                            try {
                                await ImageStore.set(key, UTILS.dataURLtoBlob(entry.photoDataURL));
                                entry.photoKey = key;
                                delete entry.photoDataURL;
                                changed = true;
                            } catch (e) {
                            }
                        }
                        if (entry.uploadDataURL && entry.uploadDataURL.startsWith('data:') && !entry.uploadKey) {
                            const key = `entry_${entry.id}_upload`;
                            try {
                                await ImageStore.set(key, UTILS.dataURLtoBlob(entry.uploadDataURL));
                                entry.uploadKey = key;
                                delete entry.uploadDataURL;
                                changed = true;
                            } catch (e) {
                            }
                        }
                    }
                }
                if (changed) Storage.setData(data);
                App.state.diaries = data;
            },

            collageConfigs: {
                1: [{ x: 0, y: 0, w: 1, h: 1 }],
                2: [{ x: 0, y: 0, w: 0.5, h: 1 }, { x: 0.5, y: 0, w: 0.5, h: 1 }],
                3: [{ x: 0, y: 0, w: 0.3333, h: 1 }, { x: 0.3333, y: 0, w: 0.3333, h: 1 }, { x: 0.6666, y: 0, w: 0.3334, h: 1 }],
                4: [{ x: 0, y: 0, w: 0.5, h: 0.5 }, { x: 0.5, y: 0, w: 0.5, h: 0.5 }, { x: 0, y: 0.5, w: 0.5, h: 0.5 }, { x: 0.5, y: 0.5, w: 0.5, h: 0.5 }],
                5: [{ x: 0, y: 0, w: 1, h: 0.5 }, { x: 0, y: 0.5, w: 1, h: 0.5 }],
                6: [{ x: 0, y: 0, w: 1, h: 0.3333 }, { x: 0, y: 0.3333, w: 1, h: 0.3333 }, { x: 0, y: 0.6666, w: 1, h: 0.3334 }],
                7: [{ x: 0.25, y: 0, w: 0.5, h: 0.5 }, { x: 0, y: 0.5, w: 0.5, h: 0.5 }, { x: 0.5, y: 0.5, w: 0.5, h: 0.5 }]
            },

            init: () => {
                lucide.createIcons();
                App.state.diaries = Storage.getData();
                App.renderSidebar();
                App.migratePhotoStorage().then(() => {
                    App.state.diaries = Storage.getData();
                    App.renderSidebar();
                    App.renderDiaryView();
                });

                const s = Storage.getSettings();
                App.state.orientation = s.orientation || 'landscape';
                App.state.collageMode = s.collageMode || 1;
                App.state.ghostOpacity = s.ghostOpacity || 0.3;

                const oBtn = document.getElementById('orientationBtn');
                if (oBtn) {
                    const iconName = App.state.orientation === 'landscape' ? 'rectangle-horizontal' : 'rectangle-vertical';
                    oBtn.innerHTML = `<i data-lucide="${iconName}" class="w-6 h-6"></i>`;
                    lucide.createIcons();
                }

                const urlParams = new URLSearchParams(window.location.search);
                const hashParams = new URLSearchParams((window.location.hash || '').replace(/^#/, ''));
                const newAuth = hashParams.get('accessToken') || urlParams.get('accessToken');

                if (newAuth) {
                    const settings = Storage.getSettings();
                    const newSettings = { ...settings, authToken: newAuth };
                    Storage.setSettings(newSettings);
                    const cleanUrl = new URL(window.location.href);
                    cleanUrl.searchParams.delete('accessToken');
                    cleanUrl.searchParams.delete('botId');
                    cleanUrl.searchParams.delete('workspaceName');
                    cleanUrl.searchParams.delete('workspaceIcon');
                    cleanUrl.hash = '';
                    window.history.replaceState({}, document.title, cleanUrl.pathname + cleanUrl.search);
                    App.showToast(`Connected! Scanning data sources...`, 'success');
                    if (newSettings.workerUrl) App.scanForDataSources(newSettings);
                }

                if (App.state.diaries.length > 0) {
                    const lastDiaryId = Storage.getLastActiveDiaryId();
                    const hasLast = lastDiaryId && App.state.diaries.some(diary => diary.id === lastDiaryId);
                    const fallbackId = window.innerWidth < 768 ? App.state.diaries[0].id : null;
                    const diaryToSelect = hasLast ? lastDiaryId : fallbackId;
                    if (diaryToSelect) {
                        App.selectDiary(diaryToSelect);
                    } else {
                        App.renderWelcomeState();
                    }
                } else {
                    App.renderWelcomeState();
                }

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        const modals = ['settingsModal', 'newDiaryModal', 'workerHelpModal', 'deleteModal', 'entryModal'];
                        for (const id of modals) {
                            const el = document.getElementById(id);
                            if (el && !el.classList.contains('hidden')) {
                                const closed = App.closeModal(id);
                                if (!closed) return;
                            }
                        }
                        document.getElementById('mobileDiaryMenu').classList.add('hidden');
                    }
                });

                document.addEventListener('click', (e) => {
                    const dropdown = document.getElementById('dbDropdownList');
                    const input = document.getElementById('dbSearchInput');
                    if (dropdown && !dropdown.classList.contains('hidden') && !dropdown.contains(e.target) && e.target !== input) {
                        dropdown.classList.add('hidden');
                    }
                    const mobMenu = document.getElementById('mobileDiaryMenu');
                    const isBtn = e.target.closest('#mobileDiaryToggleBtn');
                    const isMenu = e.target.closest('#mobileDiaryMenu');
                    if (mobMenu && !mobMenu.classList.contains('hidden') && !isMenu && !isBtn) {
                        mobMenu.classList.add('hidden');
                    }
                });

                SyncManager.init();
            },

            isValidChronicleSource: (props) => {
                if (!props['Name'] || props['Name'].type !== 'title') return false;
                if (!props['Tags'] || props['Tags'].type !== 'multi_select') return false;
                if (!props['Date'] || props['Date'].type !== 'date') return false;
                if (!props['Notes'] || props['Notes'].type !== 'rich_text') return false;
                if (!props['Files'] || props['Files'].type !== 'files') return false;
                return true;
            },

            scanForDataSources: async (settings = null) => {
                const btn = document.getElementById('refreshDbBtn');
                if (btn) {
                    const icon = btn.querySelector('svg');
                    if (icon) icon.classList.add('animate-spin');
                }
                App.state.cachedDataSources = [];
                try {
                    const allSources = await API.fetchDataSources(settings);
                    const validSources = allSources
                        .filter(src => App.isValidChronicleSource(src.properties))
                        .map(src => ({
                            id: src.id,
                            title: src.title?.[0]?.plain_text || "Untitled Data Source",
                            description: src.description?.[0]?.plain_text || ""
                        }));
                    Storage.setCachedDataSources(validSources, settings);
                    App.state.cachedDataSources = validSources;
                    if (document.getElementById('newDiaryModal').classList.contains('flex')) {
                        App.renderDbDropdownItems(validSources);
                    }
                    if (!settings) App.showToast(`Found ${validSources.length} compatible data sources.`, "success");
                } catch (e) {
                    console.error(e);
                    App.showToast("Failed to fetch data sources", "error");
                } finally {
                    if (btn) {
                        const icon = btn.querySelector('svg');
                        if (icon) icon.classList.remove('animate-spin');
                    }
                }
            },

            toggleDbDropdown: (forceShow = null) => {
                const list = document.getElementById('dbDropdownList');
                if (forceShow === true) list.classList.remove('hidden');
                else if (forceShow === false) list.classList.add('hidden');
                else list.classList.toggle('hidden');
                if (!list.classList.contains('hidden') && document.getElementById('dbSearchInput').value === '') {
                    App.renderDbDropdownItems(App.state.cachedDataSources);
                }
            },

            filterDbList: (e) => {
                const term = e.target.value.toLowerCase();
                const filtered = App.state.cachedDataSources.filter(db => db.title.toLowerCase().includes(term));
                App.renderDbDropdownItems(filtered);
                App.toggleDbDropdown(true);
            },

            renderDbDropdownItems: (dbs) => {
                const list = document.getElementById('dbDropdownList');
                list.innerHTML = '';
                const usedIds = App.state.diaries.map(d => d.dataSourceId);
                const availableDbs = dbs.filter(db => !usedIds.includes(db.id));
                if (availableDbs.length === 0) {
                    list.innerHTML = `<div class="p-4 text-center text-xs text-earth-metal/50">No data sources found.</div>`;
                    return;
                }
                availableDbs.forEach(db => {
                    const el = document.createElement('div');
                    el.className = "p-3 border-b border-oatmeal-dark last:border-0 hover:bg-white-linen cursor-pointer transition-colors flex flex-col gap-1";
                    el.onclick = () => App.selectDataSource(db);
                    el.innerHTML = `
                        <div class="flex items-center justify-between">
                            <span class="font-bold text-sm text-charcoal">${db.title}</span>
                        </div>
                        ${db.description ? `<div class="text-[10px] text-earth-metal/60 truncate">${db.description}</div>` : ''}
                    `;
                    list.appendChild(el);
                });
            },

            selectDataSource: (db) => {
                App.state.selectedDataSource = db;
                const input = document.getElementById('dbSearchInput');
                input.value = db.title;
                const infoBox = document.getElementById('selectedDbInfo');
                document.getElementById('previewDbTitle').innerText = db.title;
                document.getElementById('previewDbDesc').innerText = db.description || "No description";
                infoBox.classList.remove('hidden');
                App.toggleDbDropdown(false);
            },

            attemptNewDiary: () => {
                App.state.selectedDataSource = null;
                document.getElementById('dbSearchInput').value = '';
                document.getElementById('selectedDbInfo').classList.add('hidden');
                const s = Storage.getSettings();
                if (!s.workerUrl || !s.authToken) {
                    App.showToast("Please connect to Notion first.", "error");
                    App.openModal('settingsModal');
                } else {
                    App.openModal('newDiaryModal');
                    const cached = Storage.getCachedDataSources(s);
                    App.state.cachedDataSources = cached;
                    if (cached.length > 0) {
                        App.renderDbDropdownItems(cached);
                    } else {
                        App.scanForDataSources();
                    }
                }
            },

            createDiary: async () => {
                if (!App.state.selectedDataSource) return App.showToast("Please select a data source.", "error");
                const db = App.state.selectedDataSource;
                const newDiary = {
                    id: UTILS.id(),
                    title: db.title,
                    dataSourceId: db.id,
                    description: db.description,
                    tags: [],
                    pendingTags: [],
                    pendingEntries: [],
                    pendingDeleteOps: [],
                    entries: [],
                    cameraConfig: {
                        facingMode: App.state.facingMode,
                        mirrorVideo: App.state.mirrorVideo,
                        collageMode: App.state.collageMode
                    }
                };
                Storage.saveDiary(newDiary);
                App.state.diaries = Storage.getData();
                App.closeModal('newDiaryModal');
                App.selectDiary(newDiary.id);
                App.showToast("Diary Linked!", "success");
            },

            resetApp: () => {
                App.openModal('resetConfirmationModal');
            },

            executeReset: async () => {
                try {
                    Storage.clearAllDataSourceCaches();
                    ['chronicles_settings', 'chronicles_data', 'chronicles_last_diary'].forEach(k => localStorage.removeItem(k));
                    await clearPwaData();
                    window.location.href = window.location.pathname;
                } catch (e) {
                    console.error(e);
                    App.showToast("Failed to clear storage automatically. Please clear browser cache.", "error");
                }
            },

            toggleMobileDiaryMenu: (e) => {
                if (e) e.stopPropagation();
                const menu = document.getElementById('mobileDiaryMenu');
                const list = document.getElementById('mobileDiaryList');
                if (menu.classList.contains('hidden')) {
                    menu.classList.remove('hidden');
                    list.innerHTML = '';
                    if (App.state.diaries.length === 0) {
                        list.innerHTML = `<div class="p-4 text-center text-xs text-earth-metal/40 font-display">No diaries yet.</div>`;
                    } else {
                        App.state.diaries.forEach(diary => {
                            const isActive = diary.id === App.state.activeDiaryId;
                            const div = document.createElement('div');
                            div.className = `p-3 cursor-pointer flex items-center justify-between mb-0.5 border-l-2 font-display text-sm ${isActive ? 'bg-oatmeal border-dull-purple font-semibold text-charcoal' : 'border-transparent hover:bg-oatmeal hover:border-oatmeal-dark text-earth-metal'}`;
                            div.onclick = () => {
                                App.selectDiary(diary.id);
                                menu.classList.add('hidden');
                            };
                            div.innerHTML = `<span>${diary.title}</span> ${isActive ? '<i data-lucide="check" class="w-4 h-4 text-dull-purple"></i>' : ''}`;
                            list.appendChild(div);
                        });
                        lucide.createIcons();
                    }
                } else {
                    menu.classList.add('hidden');
                }
            },

            showToast: (message, type = 'info') => {
                const container = document.getElementById('toastContainer');
                const el = document.createElement('div');
                let bg = type === 'success' ? 'bg-white-linen border-dull-purple' : (type === 'error' ? 'bg-white-linen border-red-600' : 'bg-white-linen border-charcoal');
                let icon = type === 'success' ? 'check-circle' : (type === 'error' ? 'alert-circle' : 'info');
                el.className = `toast-enter pointer-events-auto p-4 flex gap-3 text-sm ${bg} border-l-2 transition-all font-display`;
                el.innerHTML = `<i data-lucide="${icon}" class="w-5 h-5 mt-0.5"></i><div class="flex-1">${message}</div>`;
                container.appendChild(el);
                lucide.createIcons();
                let timeout = type === 'error' ? 3000 : 1500;
                setTimeout(() => { el.classList.add('toast-exit'); setTimeout(() => el.remove(), 300); }, timeout);
            },

            renderSidebar: () => {
                const container = document.getElementById('diaryListContainer');
                container.innerHTML = '';
                if (App.state.diaries.length === 0) {
                    container.innerHTML = `<div class="text-xs text-center text-earth-metal/40 mt-4 font-display">No diaries yet.</div>`;
                    return;
                }
                App.state.diaries.forEach(diary => {
                    const isActive = diary.id === App.state.activeDiaryId;
                    const div = document.createElement('div');
                    const count = App.getVisibleEntries(diary).length;
                    const countDisplay = count > 50 ? "50+" : count;
                    div.className = `p-3 cursor-pointer flex flex-col gap-0.5 transition-colors border-l-2 ${isActive ? 'bg-white-linen border-dull-purple' : 'border-transparent hover:bg-oatmeal-dark/30 hover:border-oatmeal-dark'}`;
                    div.onclick = () => App.selectDiary(diary.id);
                    div.innerHTML = `
                        <div class="font-display font-medium text-sm text-charcoal truncate">${diary.title}</div>
                        <div class="text-[9px] text-earth-metal/50 font-display uppercase tracking-wide">${countDisplay} entries</div>
                    `;
                    container.appendChild(div);
                });
            },

            renderWelcomeState: () => {
                const gallery = document.getElementById('entryGallery');
                const s = Storage.getSettings();
                const isConnected = s.workerUrl && s.authToken;
                const hasDiaries = App.state.diaries.length > 0;
                if (!isConnected) {
                    gallery.innerHTML = `
                        <div class="h-full flex flex-col items-center justify-center text-center gap-4">
                            <div class="bg-dull-purple p-4"><i data-lucide="plug" class="w-8 h-8 text-white-linen"></i></div>
                            <div>
                                <h3 class="font-display text-xl font-semibold text-charcoal mb-2 tracking-tight">Welcome to Photo Chronicles</h3>
                                <p class="welcome-blurb max-w-md mx-auto mb-3">Photo Chronicles is your cozy, camera-first diary that turns daily snaps into a living timeline—auto-sorted, timestamped, and synced privately to Notion so memories stay safe and easy to revisit.</p>
                                <p class="text-earth-metal/50 max-w-xs mx-auto mb-6 text-sm">Connect your Notion workspace to start tracking.</p>
                                <button onclick="App.openModal('settingsModal')" class="bg-charcoal text-white-linen px-6 py-3 font-display font-medium hover:bg-dull-purple transition">Connect to Notion</button>
                            </div>
                        </div>`;
                } else if (!hasDiaries) {
                    gallery.innerHTML = `
                        <div class="h-full flex flex-col items-center justify-center text-center gap-4">
                            <div class="bg-muted-pink p-4"><i data-lucide="book-plus" class="w-8 h-8 text-white-linen"></i></div>
                            <div>
                                <h3 class="font-display text-xl font-semibold text-charcoal mb-2 tracking-tight">You're Connected!</h3>
                                <p class="text-earth-metal/50 max-w-xs mx-auto mb-6 text-sm">Select an existing Notion data source to link your first diary.</p>
                                <button onclick="App.attemptNewDiary()" class="bg-charcoal text-white-linen px-6 py-3 font-display font-medium hover:bg-dull-purple transition">Link First Diary</button>
                            </div>
                        </div>`;
                } else {
                    gallery.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-center text-earth-metal/50"><i data-lucide="book-open" class="w-10 h-10 mb-4 opacity-40"></i><p class="font-display">Select a diary.</p></div>`;
                }
                lucide.createIcons();
            },

            renderDiaryView: async () => {
                const diary = App.state.diaries.find(d => d.id === App.state.activeDiaryId);
                const gallery = document.getElementById('entryGallery');
                const title = document.getElementById('activeDiaryTitle');
                const visibleEntries = App.getVisibleEntries(diary);

                if (!diary) return;
                title.innerText = diary.title;

                if (App.state.isLoading && visibleEntries.length === 0) {
                    gallery.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-center text-earth-metal/60">
                        <div class="loader w-8 h-8 border-4 border-dull-purple border-t-transparent rounded-full mb-4"></div>
                        <p>Loading entries...</p>
                    </div>`;
                    App.clearImageUrlCache();
                    return;
                }

                if (visibleEntries.length === 0) {
                    gallery.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-center text-earth-metal/60"><i data-lucide="camera" class="w-12 h-12 mb-4 opacity-50"></i><p>Empty.</p></div>`;
                    lucide.createIcons();
                    App.clearImageUrlCache();
                    return;
                }

                const displayEntries = visibleEntries.slice(0, LOCAL_SYNCED_ENTRY_LIMIT);
                const imageMap = await App.loadEntryImages(displayEntries);

                // Clear gallery after async work to prevent race condition duplicates
                gallery.innerHTML = '';

                // Updated Denser Grid
                const grid = document.createElement('div');
                grid.className = "grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3";

                displayEntries.forEach(entry => {
                    const card = document.createElement('div');
                    card.className = "entry-card relative group bg-white-linen overflow-hidden border border-oatmeal-dark flex flex-col";

                    const imgSrc = imageMap.get(entry.id);
                    const imgHtml = imgSrc
                        ? `<img src="${imgSrc}" class="w-full aspect-square object-cover bg-oatmeal" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNjY2MiIHN0cm9rZS13aWR0aD0iMiI+PHJlY3QgeD0iMyIgeT0iMyIgd2lkdGg9IjE4IiBoZWlnaHQ9IjE4IiByeD0iMiIgcnk9IjIiPjwvcmVjdD48Y2lyY2xlIGN4PSI4LjUiIGN5PSI4LjUiIHI9IjEuNSI+PC9jaXJjbGU+PHBvbHlsaW5lIHBvaW50cz0iMjEgMTUgMTYgMTAgNSAyMSI+PC9wb2x5bGluZT48L3N2Zz4n">`
                        : `<div class="w-full aspect-square bg-oatmeal flex items-center justify-center text-earth-metal/30"><i data-lucide="image-off"></i></div>`;

                    const dispTitle = entry.title || "Untitled";

                    const deleteBtn = `
                        <div class="absolute top-1 right-1 opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-opacity z-10">
                            <button onclick="event.stopPropagation(); App.confirmDelete('${diary.id}', '${entry.id}')" class="bg-white-linen hover:bg-muted-pink hover:text-white-linen text-muted-pink-dim p-1.5 transition">
                                <i data-lucide="trash-2" class="w-3 h-3"></i>
                            </button>
                        </div>
                    `;

                    card.innerHTML = `
                        ${deleteBtn}
                        ${imgHtml}
                        <div class="p-2.5 flex flex-col gap-1">
                            <div class="flex justify-between items-center">
                                <span class="text-[9px] font-display text-earth-metal/50 truncate uppercase tracking-wide">${UTILS.formatDate(entry.date)}</span>
                                <div class="w-1.5 h-1.5 ${entry.synced ? 'bg-dull-purple' : 'bg-muted-pink'}" title="${entry.synced ? 'Synced' : 'Local'}"></div>
                            </div>
                            <h4 class="font-display font-semibold text-xs text-charcoal truncate leading-tight">${dispTitle}</h4>
                        </div>
                    `;
                    grid.appendChild(card);
                });
                gallery.appendChild(grid);

                const footerMsg = visibleEntries.length >= LOCAL_SYNCED_ENTRY_LIMIT
                    ? "Showing last 25 entries. (Thumbnails only - check Notion for full quality)"
                    : "End of entries. (Thumbnails only - check Notion for full quality)";
                let footer = document.createElement('div');
                footer.id = 'galleryFooter';
                footer.className = "text-center text-[10px] text-earth-metal/40 py-8 font-display uppercase tracking-wide";
                footer.innerText = footerMsg;
                gallery.appendChild(footer);

                lucide.createIcons();
            },

            selectDiary: (id) => {
                App.state.activeDiaryId = id;
                Storage.setLastActiveDiaryId(id);
                const diary = App.state.diaries.find(d => d.id === id);
                if (diary) {
                    App.applyDiaryCameraConfig(diary);
                }
                App.renderSidebar();
                App.renderDiaryView();
                SyncManager.syncCurrentDiary();
            },

            initNewEntry: async () => {
                App.state.currentTags = [];
                App.state.capturedImage = null;
                App.state.capturedImageHighRes = null; // Reset High Res
                App.state.captureBase = null;
                App.state.activeSegment = 0;
                App.state.segments = [];
                App.state.ghostImageObj = null;
                if (App.state.ghostImageIsObjectUrl && App.state.ghostImageUrl) {
                    URL.revokeObjectURL(App.state.ghostImageUrl);
                }
                App.state.ghostImageUrl = null;
                App.state.ghostImageIsObjectUrl = false;

                document.getElementById('entryNotes').value = '';
                document.getElementById('entryTitle').value = '';
                document.getElementById('entryDate').value = UTILS.toLocalISO(new Date());
                document.getElementById('activeTags').innerHTML = '';
                document.getElementById('tagInput').value = '';
                document.getElementById('saveEntryBtn').disabled = true;
                document.getElementById('mirrorToggleBtn').classList.add('hidden');

                document.getElementById('takenPhotoUI').classList.remove('flex');
                document.getElementById('takenPhotoUI').classList.add('hidden');
                document.getElementById('cameraSection').classList.remove('hidden');
                document.getElementById('imageManipControls').classList.add('hidden');

                const diary = App.state.diaries.find(d => d.id === App.state.activeDiaryId);
                if (!diary) return App.showToast("Select a diary first.", "error");
                App.applyDiaryCameraConfig(diary);

                const toggleBtn = document.getElementById('ghostToggleBtn');
                const lastEntryWithPhoto = App.getVisibleEntries(diary).find(e => e.photoDataURL || e.photoKey);
                const ghostImg = document.getElementById('ghostOverlay');
                const ghostCfg = App.getDiaryCameraConfig(diary);
                App.state.ghostOpacity = ghostCfg.ghostOpacity;
                App.state.ghostMode = ghostCfg.ghostMode;

                if (lastEntryWithPhoto) {
                    const ghostData = await App.loadEntryImage(lastEntryWithPhoto);
                    if (!ghostData) {
                        toggleBtn.classList.add('hidden');
                        App.state.ghostMode = false;
                        ghostImg.src = '';
                        App.state.ghostImageUrl = null;
                        App.state.ghostImageIsObjectUrl = false;
                        ghostImg.style.opacity = '0';
                        ghostImg.classList.add('opacity-0');
                        document.getElementById('ghostSliderContainer').classList.add('hidden');
                    } else {
                        ghostImg.src = ghostData.src;
                        App.state.ghostImageUrl = ghostData.src;
                        App.state.ghostImageIsObjectUrl = !!ghostData.isObjectUrl;
                        toggleBtn.classList.remove('hidden');
                        if (App.state.ghostMode) {
                            toggleBtn.classList.remove('opacity-50');
                        } else {
                            toggleBtn.classList.add('opacity-50');
                        }
                        const savedOpacity = App.state.ghostOpacity;
                        if (App.state.ghostMode) {
                            ghostImg.classList.remove('opacity-0');
                            ghostImg.style.opacity = savedOpacity;
                        } else {
                            ghostImg.classList.add('opacity-0');
                            ghostImg.style.opacity = '0';
                        }
                        const sliderInput = document.querySelector('#ghostSliderContainer input');
                        if (sliderInput) sliderInput.value = savedOpacity;
                        document.getElementById('ghostSliderContainer').classList.add('hidden');
                        const img = new Image();
                        img.onload = () => { App.state.ghostImageObj = img; };
                        img.src = ghostData.src;
                    }
                } else {
                    toggleBtn.classList.add('hidden');
                    App.state.ghostMode = false;
                    ghostImg.src = '';
                    App.state.ghostImageUrl = null;
                    App.state.ghostImageIsObjectUrl = false;
                    ghostImg.style.opacity = '0';
                    ghostImg.classList.add('opacity-0');
                    document.getElementById('ghostSliderContainer').classList.add('hidden');
                }

                App.openModal('entryModal');
                SyncManager.fetchTags(true);
            },

            setCollageMode: (mode) => {
                App.state.collageMode = mode;
                App.state.activeSegment = 0;
                App.state.segments = [];
                App.persistActiveDiaryCameraConfig({ collageMode: mode });
                document.querySelectorAll('.collage-btn').forEach(btn => {
                    btn.classList.add('bg-white/20', 'hover:bg-white/10');
                    btn.classList.remove('bg-white', 'text-black');
                });
                const modeToIdx = { 1: 0, 2: 1, 5: 2, 3: 3, 6: 4, 7: 5, 4: 6 };
                const btns = document.querySelectorAll('.collage-btn');
                const targetBtn = btns[modeToIdx[mode]];
                if (targetBtn) {
                    targetBtn.classList.remove('bg-white/20', 'hover:bg-white/10');
                    targetBtn.classList.add('bg-white', 'text-black');
                }

                const segInd = document.getElementById('segmentIndicator');
                if (mode > 1) {
                    segInd.classList.remove('hidden');
                    document.getElementById('segTotal').innerText = App.collageConfigs[mode].length;
                    document.getElementById('segCurrent').innerText = 1;
                } else {
                    segInd.classList.add('hidden');
                }
                document.getElementById('collageMenu').classList.add('hidden');
                document.getElementById('collageMenu').classList.remove('flex');
                let label = "1x";
                if (mode === 2) label = "2x →";
                if (mode === 3) label = "3x →";
                if (mode === 4) label = "4x";
                if (mode === 5) label = "2x ↓";
                if (mode === 6) label = "3x ↓";
                if (mode === 7) label = "3x 1/2";
                document.getElementById('gridBtn').innerText = label;
            },

            toggleCollageMenu: () => {
                const menu = document.getElementById('collageMenu');
                if (menu.classList.contains('hidden')) {
                    menu.classList.remove('hidden');
                    menu.classList.add('flex');
                } else {
                    menu.classList.add('hidden');
                    menu.classList.remove('flex');
                }
            },

            toggleOrientation: () => {
                const current = App.state.orientation;
                const next = current === 'landscape' ? 'portrait' : 'landscape';
                App.state.orientation = next;
                const s = Storage.getSettings();
                s.orientation = next;
                Storage.setSettings(s);
                const btn = document.getElementById('orientationBtn');
                if (btn) {
                    const iconName = next === 'landscape' ? 'rectangle-horizontal' : 'rectangle-vertical';
                    btn.innerHTML = `<i data-lucide="${iconName}" class="w-6 h-6"></i>`;
                    lucide.createIcons();
                }
            },

            pointers: new Map(),
            interactionTarget: null,
            prevPinchDist: 0,
            prevPinchAngle: 0,
            prevPinchCenter: null,
            lastPointerPos: null,

            getDist: (p1, p2) => Math.hypot(p1.clientX - p2.clientX, p1.clientY - p2.clientY),
            getAngle: (p1, p2) => Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX),
            getCenter: (p1, p2) => ({ x: (p1.clientX + p2.clientX) / 2, y: (p1.clientY + p2.clientY) / 2 }),

            handlePointerDown: (e) => {
                if (!App.state.isEntryModalOpen) return;
                const cvs = document.getElementById('viewfinder');
                cvs.setPointerCapture(e.pointerId);
                App.state.pointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY, pointerId: e.pointerId });

                // Find target segment
                const rect = cvs.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;
                const layout = App.collageConfigs[App.state.collageMode];

                // Check existing segments first
                const clickedIdx = layout.findIndex(slot => x >= slot.x && x <= slot.x + slot.w && y >= slot.y && y <= slot.y + slot.h);

                if (clickedIdx !== -1 && App.state.segments[clickedIdx]) {
                    App.state.interactionTarget = clickedIdx;
                    App.state.activeSegment = clickedIdx;
                    document.getElementById('segCurrent').innerText = clickedIdx + 1;
                    App.updateManipControlsVisibility();
                } else {
                    App.state.interactionTarget = null;
                }

                // Store initial position for single-finger pan
                App.state.lastPointerPos = { x: e.clientX, y: e.clientY };

                if (App.state.pointers.size === 2) {
                    const points = Array.from(App.state.pointers.values());
                    App.state.prevPinchDist = App.getDist(points[0], points[1]);
                    App.state.prevPinchAngle = App.getAngle(points[0], points[1]);
                    App.state.prevPinchCenter = App.getCenter(points[0], points[1]);
                }
            },

            handlePointerMove: (e) => {
                if (!App.state.pointers.has(e.pointerId)) return;

                const oldPointer = App.state.pointers.get(e.pointerId);
                const newPointer = { clientX: e.clientX, clientY: e.clientY, pointerId: e.pointerId };
                App.state.pointers.set(e.pointerId, newPointer);

                const targetIdx = App.state.interactionTarget;
                if (targetIdx === null || !App.state.segments[targetIdx]) return;

                const seg = App.state.segments[targetIdx];
                if (!seg.isManipulatable) return;

                const points = Array.from(App.state.pointers.values());
                const cvs = document.getElementById('viewfinder');
                const scaleX = cvs.width / cvs.clientWidth;
                const scaleY = cvs.height / cvs.clientHeight;

                if (points.length === 1) {
                    // Single finger pan
                    const dx = e.clientX - oldPointer.clientX;
                    const dy = e.clientY - oldPointer.clientY;
                    seg.x += dx * scaleX;
                    seg.y += dy * scaleY;

                } else if (points.length === 2) {
                    // Pinch to zoom/rotate + two-finger pan
                    const dist = App.getDist(points[0], points[1]);
                    const angle = App.getAngle(points[0], points[1]);
                    const center = App.getCenter(points[0], points[1]);

                    // Zoom
                    if (App.state.prevPinchDist > 0) {
                        const scaleFactor = dist / App.state.prevPinchDist;
                        seg.scale *= scaleFactor;
                        // Clamp scale
                        seg.scale = Math.max(0.1, Math.min(seg.scale, 10));
                    }

                    // Rotate
                    const angleDelta = angle - App.state.prevPinchAngle;
                    seg.rotation += angleDelta;

                    // Pan (two-finger drag)
                    if (App.state.prevPinchCenter) {
                        const dx = center.x - App.state.prevPinchCenter.x;
                        const dy = center.y - App.state.prevPinchCenter.y;
                        seg.x += dx * scaleX;
                        seg.y += dy * scaleY;
                    }

                    App.state.prevPinchDist = dist;
                    App.state.prevPinchAngle = angle;
                    App.state.prevPinchCenter = center;

                    // Update UI sliders to reflect changes
                    App.updateManipControlsVisibility();
                }
            },

            handlePointerUp: (e) => {
                App.state.pointers.delete(e.pointerId);
                if (App.state.pointers.size < 2) {
                    App.state.prevPinchDist = 0;
                    App.state.prevPinchAngle = 0;
                    App.state.prevPinchCenter = null;
                }
                if (App.state.pointers.size === 0) {
                    App.state.interactionTarget = null;
                    App.state.lastPointerPos = null;
                    App.updateManipControlsVisibility();
                }
            },

            initCamera: async () => {
                const video = document.getElementById('videoSource');
                const cvs = document.getElementById('viewfinder');

                // Attach pointer events if not already
                if (!cvs.dataset.listening) {
                    cvs.addEventListener('pointerdown', App.handlePointerDown);
                    cvs.addEventListener('pointermove', App.handlePointerMove);
                    cvs.addEventListener('pointerup', App.handlePointerUp);
                    cvs.addEventListener('pointercancel', App.handlePointerUp);
                    cvs.dataset.listening = "true";
                }

                try {
                    if (App.state.stream) {
                        App.state.stream.getTracks().forEach(t => t.stop());
                    }
                    App.state.stream = await navigator.mediaDevices.getUserMedia({
                        video: App.getVideoConstraints(),
                        audio: false
                    });
                    video.srcObject = App.state.stream;
                    video.onloadedmetadata = () => {
                        App.state.videoDims = { width: video.videoWidth, height: video.videoHeight };
                    };
                    const mirrorBtn = document.getElementById('mirrorToggleBtn');
                    if (App.state.facingMode === 'user') {
                        mirrorBtn.classList.remove('hidden');
                        if (App.state.mirrorVideo) {
                            mirrorBtn.classList.add('bg-white/40');
                            mirrorBtn.classList.remove('bg-black/40');
                        } else {
                            mirrorBtn.classList.remove('bg-white/40');
                            mirrorBtn.classList.add('bg-black/40');
                        }
                    } else {
                        mirrorBtn.classList.add('hidden');
                        App.state.mirrorVideo = false;
                        App.persistActiveDiaryCameraConfig({
                            facingMode: App.state.facingMode,
                            mirrorVideo: App.state.mirrorVideo
                        });
                        const btn = document.getElementById('mirrorToggleBtn');
                        btn.classList.remove('bg-white/40');
                        btn.classList.add('bg-black/40');
                    }
                } catch (e) {
                    console.error("Camera init failed", e);
                    App.showToast("Camera access failed. Check permissions or use file upload.", "error");
                }
            },

            drawLoop: () => {
                if (!App.state.isEntryModalOpen) {
                    App.stopDrawLoop();
                    return;
                }
                const video = document.getElementById('videoSource');
                const cvs = document.getElementById('viewfinder');
                const ctx = cvs.getContext('2d');
                const mode = App.state.collageMode;
                const baseDims = App.getBaseDimensions(video.videoWidth || App.state.videoDims.width, video.videoHeight || App.state.videoDims.height);
                let multW = 1;
                let multH = 1;
                if (mode === 2) multW = 2;
                else if (mode === 3) multW = 3;
                else if (mode === 4) { multW = 2; multH = 2; }
                else if (mode === 5) { multH = 2; }
                else if (mode === 6) { multH = 3; }
                else if (mode === 7) { multW = 2; multH = 2; }
                const dims = App.getFinalCanvasDimensions(baseDims.width, baseDims.height, multW, multH);
                const W = dims.width;
                const H = dims.height;
                if (cvs.width !== W || cvs.height !== H) {
                    cvs.width = W;
                    cvs.height = H;
                }
                ctx.clearRect(0, 0, W, H);
                const layout = App.collageConfigs[App.state.collageMode];
                if (App.state.ghostMode && App.state.ghostImageObj) {
                    ctx.save();
                    ctx.globalAlpha = App.state.ghostOpacity;
                    const img = App.state.ghostImageObj;
                    const imgW = img.width;
                    const imgH = img.height;
                    const srcRatio = imgW / imgH;
                    const dstRatio = W / H;
                    let gsx, gsy, gsw, gsh;
                    if (srcRatio > dstRatio) {
                        gsh = imgH; gsw = gsh * dstRatio; gsy = 0; gsx = (imgW - gsw) / 2;
                    } else {
                        gsw = imgW; gsh = gsw / dstRatio; gsx = 0; gsy = (imgH - gsh) / 2;
                    }
                    ctx.drawImage(img, gsx, gsy, gsw, gsh, 0, 0, W, H);
                    ctx.restore();
                }
                layout.forEach((slot, idx) => {
                    const dx = slot.x * W;
                    const dy = slot.y * H;
                    const dw = slot.w * W;
                    const dh = slot.h * H;

                    const seg = App.state.segments[idx];

                    if (seg) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(dx, dy, dw, dh);
                        ctx.clip();

                        if (seg.isManipulatable) {
                            const cx = dx + dw / 2;
                            const cy = dy + dh / 2;
                            ctx.translate(cx, cy);
                            ctx.translate(seg.x, seg.y);
                            ctx.rotate(seg.rotation);
                            const flipScaleX = seg.flipH ? -1 : 1;
                            const flipScaleY = seg.flipV ? -1 : 1;
                            ctx.scale(seg.scale * flipScaleX, seg.scale * flipScaleY);
                            ctx.drawImage(seg.source, -seg.source.width / 2, -seg.source.height / 2);
                        } else {
                            // Legacy canvas
                            ctx.drawImage(seg, 0, 0, seg.width, seg.height, dx, dy, dw, dh);
                        }
                        ctx.restore();
                    } else if (idx === App.state.activeSegment && video.readyState === 4) {
                        ctx.save();
                        const vidW = video.videoWidth;
                        const vidH = video.videoHeight;
                        const srcRatio = vidW / vidH;
                        const dstRatio = dw / dh;
                        let sx, sy, sw, sh;
                        if (srcRatio > dstRatio) {
                            sh = vidH; sw = sh * dstRatio; sy = 0; sx = (vidW - sw) / 2;
                        } else {
                            sw = vidW; sh = sw / dstRatio; sx = 0; sy = (vidH - sh) / 2;
                        }
                        if (App.state.mirrorVideo && App.state.facingMode === 'user') {
                            ctx.translate(dx + dw, dy);
                            ctx.scale(-1, 1);
                            ctx.drawImage(video, sx, sy, sw, sh, 0, 0, dw, dh);
                        } else {
                            ctx.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh);
                        }
                        ctx.restore();
                    } else {
                        ctx.fillStyle = "#111";
                        ctx.fillRect(dx, dy, dw, dh);
                    }

                    if (idx === App.state.activeSegment) {
                        ctx.strokeStyle = "rgba(145, 127, 179, 0.8)";
                        ctx.lineWidth = 4;
                    } else {
                        ctx.strokeStyle = "rgba(255,255,255,0.1)";
                        ctx.lineWidth = 2;
                    }
                    ctx.strokeRect(dx, dy, dw, dh);
                });
                App.state.drawLoopHandle = requestAnimationFrame(App.drawLoop);
            },

            flipCamera: () => {
                App.state.facingMode = App.state.facingMode === 'user' ? 'environment' : 'user';
                if (App.state.facingMode !== 'user') {
                    App.state.mirrorVideo = false;
                }
                App.persistActiveDiaryCameraConfig({
                    facingMode: App.state.facingMode,
                    mirrorVideo: App.state.mirrorVideo
                });
                App.initCamera();
            },

            toggleMirror: () => {
                App.state.mirrorVideo = !App.state.mirrorVideo;
                const btn = document.getElementById('mirrorToggleBtn');
                if (App.state.mirrorVideo) {
                    btn.classList.add('bg-white/40');
                    btn.classList.remove('bg-black/40');
                } else {
                    btn.classList.remove('bg-white/40');
                    btn.classList.add('bg-black/40');
                }
                App.persistActiveDiaryCameraConfig({ mirrorVideo: App.state.mirrorVideo });
            },

            toggleGhost: () => {
                const ghost = document.getElementById('ghostOverlay');
                const btn = document.getElementById('ghostToggleBtn');
                const slider = document.getElementById('ghostSliderContainer');
                if (App.state.ghostMode) {
                    if (slider.classList.contains('hidden')) {
                        slider.classList.remove('hidden');
                    } else {
                        App.state.ghostMode = false;
                        ghost.classList.add('opacity-0');
                        btn.classList.add('opacity-50');
                        slider.classList.add('hidden');
                    }
                } else {
                    App.state.ghostMode = true;
                    ghost.classList.remove('opacity-0');
                    ghost.style.opacity = App.state.ghostOpacity;
                    btn.classList.remove('opacity-50');
                    slider.classList.remove('hidden');
                }
                App.persistActiveDiaryCameraConfig({ ghostMode: App.state.ghostMode });
            },

            setGhostOpacity: (val) => {
                const newVal = parseFloat(val);
                App.state.ghostOpacity = newVal;
                const ghost = document.getElementById('ghostOverlay');
                if (App.state.ghostMode) ghost.style.opacity = newVal;
                const s = Storage.getSettings();
                s.ghostOpacity = newVal;
                Storage.setSettings(s);
                App.persistActiveDiaryCameraConfig({ ghostOpacity: newVal });
            },

            handleTagInput: (e) => {
                const rawVal = e.target.value;
                const val = rawVal.trim();
                const normalized = UTILS.normalizeTag(val);
                const suggestions = document.getElementById('tagSuggestions');
                const diary = App.state.diaries.find(d => d.id === App.state.activeDiaryId);
                const allTags = diary ? diary.tags : [];
                const available = allTags.filter(t => !App.hasTag(App.state.currentTags, t));
                const matches = normalized
                    ? available.filter(t => t.toLowerCase().includes(normalized))
                    : available;
                const exactMatch = normalized && App.hasTag(allTags, val);
                const showAdd = normalized && !exactMatch;
                if (matches.length > 0 || showAdd) {
                    suggestions.classList.remove('hidden');
                    const items = [];
                    if (showAdd) {
                        const safeLabel = val.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                        const encoded = encodeURIComponent(val);
                        items.push(`<div class="p-2 hover:bg-oatmeal cursor-pointer text-sm font-semibold" onclick="App.addNewTag(decodeURIComponent('${encoded}'))">Add "${safeLabel}"</div>`);
                    }
                    matches.forEach(t => {
                        const encoded = encodeURIComponent(t);
                        items.push(`<div class="p-2 hover:bg-oatmeal cursor-pointer text-sm" onclick="App.addTag(decodeURIComponent('${encoded}'))">${t}</div>`);
                    });
                    suggestions.innerHTML = items.join('');
                } else {
                    suggestions.classList.add('hidden');
                }
                if (e.key === 'Enter' && val) {
                    if (exactMatch) {
                        const existing = App.tagMatch(allTags, val);
                        App.addTag(existing || val);
                    } else {
                        App.addNewTag(val);
                    }
                }
            },

            addTag: (t) => {
                const tag = t ? t.trim() : '';
                if (!tag) return;
                if (!App.hasTag(App.state.currentTags, tag)) {
                    App.state.currentTags.push(tag);
                    App.renderTags();
                    document.getElementById('tagInput').value = '';
                    document.getElementById('tagSuggestions').classList.add('hidden');
                }
            },
            addNewTag: async (t) => {
                const tag = t ? t.trim() : '';
                if (!tag) return;
                const diaryId = App.state.activeDiaryId;
                const diary = App.state.diaries.find(d => d.id === diaryId);
                const existing = diary ? App.tagMatch(diary.tags, tag) : null;
                const resolvedTag = existing || tag;
                App.addTag(resolvedTag);
                if (diaryId) {
                    Storage.updateDiaryTags(diaryId, [resolvedTag]);
                    App.state.diaries = Storage.getData();
                    SyncManager.queueTagSync(diaryId, resolvedTag);
                }
            },

            renderTags: () => {
                const container = document.getElementById('activeTags');
                container.innerHTML = App.state.currentTags.map(t => `
                    <span class="bg-dull-purple text-white-linen px-2.5 py-1 text-xs flex items-center gap-1.5 font-display">
                        ${t}
                        <button onclick="App.removeTag('${t}')" class="hover:text-muted-pink"><i data-lucide="x" class="w-3 h-3"></i></button>
                    </span>
                `).join('');
                lucide.createIcons();
            },

            removeTag: (t) => {
                const normalized = UTILS.normalizeTag(t);
                App.state.currentTags = App.state.currentTags.filter(x => UTILS.normalizeTag(x) !== normalized);
                App.renderTags();
            },

            confirmDelete: (diaryId, entryId) => {
                App.state.pendingDelete = { diaryId, entryId };
                App.openModal('deleteModal');
            },

            executeDelete: async () => {
                const { diaryId, entryId } = App.state.pendingDelete;
                if (!diaryId || !entryId) return;
                App.closeModal('deleteModal');
                const diary = Storage.getData().find(d => d.id === diaryId);
                const entry = diary?.entries.find(e => e.id === entryId);
                const notionId = entry?.notionId;
                App.revokeEntryImageCache(entryId);
                if (notionId) {
                    const marked = Storage.markEntryDeletedLocally(diaryId, entryId);
                    Storage.clearPendingEntry(diaryId, entryId);
                    Storage.queuePendingDelete(diaryId, { entryId, notionId, createdAt: UTILS.now() });
                    if (marked) Storage.cleanupEntryAssets(marked);
                } else {
                    Storage.deleteEntry(diaryId, entryId);
                }
                App.state.diaries = Storage.getData();
                App.renderDiaryView();
                App.renderSidebar();
                App.showToast("Deleted locally", "success");
                if (notionId) {
                    App.showToast("Delete queued for Notion sync.", "info");
                    SyncManager.syncCurrentDiary();
                }
            },

            saveEntry: async () => {
                const notes = document.getElementById('entryNotes').value;
                const titleInput = document.getElementById('entryTitle').value;
                const dateVal = document.getElementById('entryDate').value;
                const date = UTILS.localToUTC(dateVal);
                const title = titleInput.trim() || new Date(dateVal).toLocaleString(undefined, {
                    weekday: 'short', year: 'numeric', month: 'short', day: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });
                const diary = Storage.getData().find(d => d.id === App.state.activeDiaryId);
                const diaryTitle = diary?.title || "Diary";

                if (!App.state.capturedImage) return App.showToast('An image is required.', 'error');
                App.setEntryLoading(true, "Saving entry...");

                // Generate both versions if not already done (though finalizeCollage creates UI version)
                // We should ensure we save the Low Res version to local storage to save space
                let photoToSave = App.state.capturedImage;
                let photoToUpload = App.state.capturedImageHighRes || App.state.capturedImage;

                const entryId = UTILS.id();
                let photoKey = null;
                let uploadKey = null;
                let photoDataURL = null;
                let uploadDataURL = null;

                try {
                    if (ImageStore.isAvailable()) {
                        const previewKey = `entry_${entryId}_preview`;
                        const uploadKeyName = `entry_${entryId}_upload`;
                        try {
                            await ImageStore.set(previewKey, UTILS.dataURLtoBlob(photoToSave));
                            await ImageStore.set(uploadKeyName, UTILS.dataURLtoBlob(photoToUpload));
                            photoKey = previewKey;
                            uploadKey = uploadKeyName;
                        } catch (e) {
                            if (e?.isQuotaExceeded) {
                                App.showToast("Storage full; saving images inline.", "error");
                            }
                            photoDataURL = photoToSave;
                            uploadDataURL = photoToUpload;
                        }
                    } else {
                        photoDataURL = photoToSave;
                        uploadDataURL = photoToUpload;
                    }

                    const newEntry = {
                        id: entryId,
                        clientEntryId: (typeof crypto !== 'undefined' && crypto.randomUUID) ? crypto.randomUUID() : `entry-${entryId}-${Date.now()}`,
                        date: date,
                        title: title,
                        notes: notes,
                        tags: App.state.currentTags,
                        diaryTitle: diaryTitle,
                        photoDataURL: photoDataURL,
                        photoKey: photoKey,
                        uploadKey: uploadKey,
                        uploadDataURL: uploadDataURL,
                        synced: false,
                        notionId: null,
                        deletedLocally: false
                    };

                    Storage.saveEntry(App.state.activeDiaryId, newEntry);
                    Storage.queuePendingEntry(App.state.activeDiaryId, newEntry.id);
                    App.state.diaries = Storage.getData();

                    App.closeModal('entryModal', { force: true });
                    App.renderDiaryView();
                    App.showToast("Saved locally", 'success');
                    if (navigator.onLine) {
                        SyncManager.syncCurrentDiary();
                    } else {
                        SyncManager.updateUI('offline');
                    }
                } finally {
                    App.setEntryLoading(false);
                }
            },

            copyWorkerCode: async (btn) => {
                const code = document.getElementById('workerCodeBlock').innerText;
                try {
                    if (navigator.clipboard?.writeText) {
                        await navigator.clipboard.writeText(code);
                    } else {
                        const textArea = document.createElement('textarea');
                        textArea.value = code;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                    }
                    const originalText = btn.innerText;
                    btn.innerText = "Copied!";
                    setTimeout(() => btn.innerText = originalText, 2000);
                } catch (err) {
                    console.error('Copy failed', err);
                    App.showToast("Copy failed. Please copy manually.", "error");
                }
            },

            captureSegment: () => {
                const video = document.getElementById('videoSource');
                const canvas = document.createElement('canvas');

                // Use full resolution from video or base dims
                // Actually, let's just capture the full video frame to allow manipulation
                const vidW = video.videoWidth;
                const vidH = video.videoHeight;
                canvas.width = vidW;
                canvas.height = vidH;
                const ctx = canvas.getContext('2d');

                if (App.state.mirrorVideo && App.state.facingMode === 'user') {
                    ctx.save();
                    ctx.translate(vidW, 0);
                    ctx.scale(-1, 1);
                    ctx.drawImage(video, 0, 0, vidW, vidH);
                    ctx.restore();
                } else {
                    ctx.drawImage(video, 0, 0, vidW, vidH);
                }

                // Convert to Image for manipulation source
                const img = new Image();
                img.src = canvas.toDataURL('image/webp', 0.9);

                img.onload = () => {
                    // Calculate slot dimensions and scale
                    const baseDims = App.state.captureBase || App.getBaseDimensions(vidW, vidH);
                    const BaseW = baseDims.width;
                    const BaseH = baseDims.height;

                    const layout = App.collageConfigs[App.state.collageMode];
                    const slot = layout[App.state.activeSegment];

                    let multW = 1; let multH = 1;
                    const mode = App.state.collageMode;
                    if (mode === 2) multW = 2;
                    else if (mode === 3) multW = 3;
                    else if (mode === 4) { multW = 2; multH = 2; }
                    else if (mode === 5) { multH = 2; }
                    else if (mode === 6) { multH = 3; }
                    else if (mode === 7) { multW = 2; multH = 2; }

                    const finalDims = App.getFinalCanvasDimensions(BaseW, BaseH, multW, multH);
                    const slotPixelW = slot.w * finalDims.width;
                    const slotPixelH = slot.h * finalDims.height;

                    const scaleW = slotPixelW / vidW;
                    const scaleH = slotPixelH / vidH;
                    const scale = Math.max(scaleW, scaleH);

                    App.state.segments[App.state.activeSegment] = {
                        source: img,
                        isManipulatable: true,
                        x: 0,
                        y: 0,
                        scale: scale,
                        baseScale: scale,
                        rotation: 0,
                        flipH: false,
                        flipV: false,
                        width: vidW,
                        height: vidH
                    };

                    if (!App.state.captureBase) {
                        App.state.captureBase = { width: BaseW, height: BaseH };
                    }

                    const total = layout.length;
                    let allFilled = true;
                    let nextEmpty = -1;
                    for (let i = 0; i < total; i++) {
                        if (!App.state.segments[i]) {
                            allFilled = false;
                            if (nextEmpty === -1) nextEmpty = i;
                        }
                    }
                    if (allFilled) {
                        App.finalizeCollage();
                    } else {
                        App.state.activeSegment = nextEmpty;
                        document.getElementById('segCurrent').innerText = App.state.activeSegment + 1;
                    }
                    App.updateManipControlsVisibility();
                };
            },

            finalizeCollage: async () => {
                const layout = App.collageConfigs[App.state.collageMode];
                const finalCanvas = document.getElementById('photoCanvas');
                if (!finalCanvas) return;
                App.setEntryLoading(true, "Processing photo...");
                const mode = App.state.collageMode;
                const baseDims = App.state.captureBase || App.getBaseDimensions(App.state.videoDims.width, App.state.videoDims.height);
                const BaseW = baseDims.width;
                const BaseH = baseDims.height;
                let multW = 1;
                let multH = 1;
                if (mode === 2) multW = 2;
                else if (mode === 3) multW = 3;
                else if (mode === 4) { multW = 2; multH = 2; }
                else if (mode === 5) { multH = 2; }
                else if (mode === 6) { multH = 3; }
                else if (mode === 7) { multW = 2; multH = 2; }
                const dims = App.getFinalCanvasDimensions(BaseW, BaseH, multW, multH);
                const W = dims.width;
                const H = dims.height;
                finalCanvas.width = W; finalCanvas.height = H;
                const ctx = finalCanvas.getContext('2d');
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, W, H);
                layout.forEach((slot, idx) => {
                    const seg = App.state.segments[idx];
                    if (seg) {
                        const dx = slot.x * W;
                        const dy = slot.y * H;
                        const dw = slot.w * W;
                        const dh = slot.h * H;

                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(dx, dy, dw, dh);
                        ctx.clip();

                        if (seg.isManipulatable) {
                            const cx = dx + dw / 2;
                            const cy = dy + dh / 2;
                            ctx.translate(cx, cy);
                            ctx.translate(seg.x, seg.y);
                            ctx.rotate(seg.rotation);
                            const flipScaleX = seg.flipH ? -1 : 1;
                            const flipScaleY = seg.flipV ? -1 : 1;
                            ctx.scale(seg.scale * flipScaleX, seg.scale * flipScaleY);
                            ctx.drawImage(seg.source, -seg.source.width / 2, -seg.source.height / 2);
                        } else {
                            ctx.drawImage(seg, 0, 0, seg.width, seg.height, dx, dy, dw, dh);
                        }
                        ctx.restore();
                    }
                });

                try {
                    // 1. Generate High Res Version for Upload (WebP Max Quality)
                    // We must ensure it's under the selected cap
                    const highResBase = finalCanvas.toDataURL('image/webp', 0.96);
                    const capBytes = App.getUploadCapBytes();
                    App.state.capturedImageHighRes = await UTILS.compressToLimit(highResBase, { maxBytes: capBytes });

                    // 2. Generate Preview Version for UI (larger thumbnail for IndexedDB)
                    App.state.capturedImage = await UTILS.processImage(highResBase, 640, 0.72);

                    document.getElementById('cameraSection').classList.add('hidden');
                    document.getElementById('imageManipControls').classList.add('hidden');
                    document.getElementById('smallPreview').src = App.state.capturedImage; // Show low res preview
                    document.getElementById('takenPhotoUI').classList.remove('hidden');
                    document.getElementById('takenPhotoUI').classList.add('flex');
                    document.getElementById('saveEntryBtn').disabled = false;

                    if (App.state.stream) App.state.stream.getTracks().forEach(t => t.stop());
                } finally {
                    App.setEntryLoading(false);
                }
            },

            handleCollageClick: (e) => {
                // Use the smallPreview image element, not e.target (which could be overlay div)
                const img = document.getElementById('smallPreview');
                if (!img) return;
                const rect = img.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;
                const layout = App.collageConfigs[App.state.collageMode];
                const clickedIdx = layout.findIndex(slot => x >= slot.x && x <= slot.x + slot.w && y >= slot.y && y <= slot.y + slot.h);
                if (clickedIdx !== -1 && App.state.segments[clickedIdx]) {
                    App.openSegmentEdit(clickedIdx);
                }
            },

            editingSegmentIdx: null,
            segEditAnimFrame: null,

            openSegmentEdit: (idx) => {
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;

                App.state.editingSegmentIdx = idx;
                document.getElementById('editSegmentNum').textContent = idx + 1;

                // Set current values
                const zoomRatio = seg.scale / seg.baseScale;
                const rotDeg = Math.round((seg.rotation * 180) / Math.PI);

                document.getElementById('segEditZoom').value = zoomRatio;
                document.getElementById('segEditZoomVal').textContent = zoomRatio.toFixed(1) + 'x';
                document.getElementById('segEditRotation').value = rotDeg;
                document.getElementById('segEditRotationVal').textContent = rotDeg + '°';
                document.getElementById('segEditPanX').value = seg.x;
                document.getElementById('segEditPanXVal').textContent = Math.round(seg.x);
                document.getElementById('segEditPanY').value = seg.y;
                document.getElementById('segEditPanYVal').textContent = Math.round(seg.y);

                document.getElementById('segmentEditOverlay').classList.remove('hidden');
                lucide.createIcons();

                // Start live preview loop
                App.startSegEditPreview();
            },

            closeSegmentEdit: () => {
                App.stopSegEditPreview();
                document.getElementById('segmentEditOverlay').classList.add('hidden');
                App.state.editingSegmentIdx = null;
                // Regenerate preview
                App.regeneratePreview();
            },

            startSegEditPreview: () => {
                const render = () => {
                    App.renderSegEditPreview();
                    App.state.segEditAnimFrame = requestAnimationFrame(render);
                };
                render();
            },

            stopSegEditPreview: () => {
                if (App.state.segEditAnimFrame) {
                    cancelAnimationFrame(App.state.segEditAnimFrame);
                    App.state.segEditAnimFrame = null;
                }
            },

            renderSegEditPreview: () => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;

                const canvas = document.getElementById('segEditPreview');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                // Get the slot dimensions for this segment
                const layout = App.collageConfigs[App.state.collageMode];
                const slot = layout[idx];
                const mode = App.state.collageMode;
                const baseDims = App.state.captureBase || App.getTargetBaseDimensions();
                let multW = 1, multH = 1;
                if (mode === 2) multW = 2;
                else if (mode === 3) multW = 3;
                else if (mode === 4) { multW = 2; multH = 2; }
                else if (mode === 5) { multH = 2; }
                else if (mode === 6) { multH = 3; }
                else if (mode === 7) { multW = 2; multH = 2; }
                const dims = App.getFinalCanvasDimensions(baseDims.width, baseDims.height, multW, multH);
                const slotW = slot.w * dims.width;
                const slotH = slot.h * dims.height;

                // Set canvas to match slot aspect ratio
                const previewSize = 300;
                const slotAspect = slotW / slotH;
                if (slotAspect >= 1) {
                    canvas.width = previewSize;
                    canvas.height = previewSize / slotAspect;
                } else {
                    canvas.height = previewSize;
                    canvas.width = previewSize * slotAspect;
                }

                const W = canvas.width;
                const H = canvas.height;
                const scaleRatio = W / slotW;

                ctx.fillStyle = "#1a1a1a";
                ctx.fillRect(0, 0, W, H);

                // Draw the segment with transforms
                ctx.save();
                const cx = W / 2;
                const cy = H / 2;
                ctx.translate(cx, cy);
                ctx.translate(seg.x * scaleRatio, seg.y * scaleRatio);
                ctx.rotate(seg.rotation);
                const flipScaleX = seg.flipH ? -1 : 1;
                const flipScaleY = seg.flipV ? -1 : 1;
                ctx.scale(seg.scale * scaleRatio * flipScaleX, seg.scale * scaleRatio * flipScaleY);
                ctx.drawImage(seg.source, -seg.source.width / 2, -seg.source.height / 2);
                ctx.restore();

                // Draw border
                ctx.strokeStyle = "rgba(133, 117, 147, 0.8)";
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, W, H);
            },

            setEditSegmentZoom: (val) => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                const r = parseFloat(val);
                seg.scale = seg.baseScale * r;
                document.getElementById('segEditZoomVal').textContent = r.toFixed(2) + 'x';
            },

            setEditSegmentRotation: (val) => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                seg.rotation = (parseFloat(val) * Math.PI) / 180;
                document.getElementById('segEditRotationVal').textContent = val + '°';
            },

            setEditSegmentPanX: (val) => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                seg.x = parseFloat(val);
                document.getElementById('segEditPanXVal').textContent = Math.round(seg.x);
            },

            setEditSegmentPanY: (val) => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                seg.y = parseFloat(val);
                document.getElementById('segEditPanYVal').textContent = Math.round(seg.y);
            },

            flipEditSegmentH: () => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                seg.flipH = !seg.flipH;
            },

            flipEditSegmentV: () => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                seg.flipV = !seg.flipV;
            },

            resetEditSegment: () => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                const seg = App.state.segments[idx];
                if (!seg || !seg.isManipulatable) return;
                seg.x = 0;
                seg.y = 0;
                seg.rotation = 0;
                seg.scale = seg.baseScale;
                seg.flipH = false;
                seg.flipV = false;
                // Update sliders
                document.getElementById('segEditZoom').value = 1;
                document.getElementById('segEditZoomVal').textContent = '1.00x';
                document.getElementById('segEditRotation').value = 0;
                document.getElementById('segEditRotationVal').textContent = '0°';
                document.getElementById('segEditPanX').value = 0;
                document.getElementById('segEditPanXVal').textContent = '0';
                document.getElementById('segEditPanY').value = 0;
                document.getElementById('segEditPanYVal').textContent = '0';
            },

            retakeEditSegment: () => {
                const idx = App.state.editingSegmentIdx;
                if (idx === null) return;
                App.stopSegEditPreview();
                App.state.activeSegment = idx;
                App.state.segments[idx] = null;
                document.getElementById('segmentEditOverlay').classList.add('hidden');
                App.state.editingSegmentIdx = null;
                App.retakePartial();
            },

            applySegmentEdit: () => {
                App.closeSegmentEdit();
            },

            regeneratePreview: async () => {
                // Re-render the collage to smallPreview after edits
                const layout = App.collageConfigs[App.state.collageMode];
                const tempCanvas = document.createElement('canvas');
                const mode = App.state.collageMode;
                const baseDims = App.state.captureBase || App.getTargetBaseDimensions();
                const BaseW = baseDims.width;
                const BaseH = baseDims.height;
                let multW = 1, multH = 1;
                if (mode === 2) multW = 2;
                else if (mode === 3) multW = 3;
                else if (mode === 4) { multW = 2; multH = 2; }
                else if (mode === 5) { multH = 2; }
                else if (mode === 6) { multH = 3; }
                else if (mode === 7) { multW = 2; multH = 2; }
                const dims = App.getFinalCanvasDimensions(BaseW, BaseH, multW, multH);
                const W = dims.width;
                const H = dims.height;
                tempCanvas.width = W;
                tempCanvas.height = H;
                const ctx = tempCanvas.getContext('2d');
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, W, H);

                layout.forEach((slot, idx) => {
                    const seg = App.state.segments[idx];
                    if (seg) {
                        const dx = slot.x * W;
                        const dy = slot.y * H;
                        const dw = slot.w * W;
                        const dh = slot.h * H;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(dx, dy, dw, dh);
                        ctx.clip();
                        if (seg.isManipulatable) {
                            const cx = dx + dw / 2;
                            const cy = dy + dh / 2;
                            ctx.translate(cx, cy);
                            ctx.translate(seg.x, seg.y);
                            ctx.rotate(seg.rotation);
                            const flipScaleX = seg.flipH ? -1 : 1;
                            const flipScaleY = seg.flipV ? -1 : 1;
                            ctx.scale(seg.scale * flipScaleX, seg.scale * flipScaleY);
                            ctx.drawImage(seg.source, -seg.source.width / 2, -seg.source.height / 2);
                        } else {
                            ctx.drawImage(seg, 0, 0, seg.width, seg.height, dx, dy, dw, dh);
                        }
                        ctx.restore();
                    }
                });

                // Generate preview and high-res versions
                const highResBase = tempCanvas.toDataURL('image/webp', 0.96);
                const capBytes = App.getUploadCapBytes();
                App.state.capturedImageHighRes = await UTILS.compressToLimit(highResBase, { maxBytes: capBytes });
                App.state.capturedImage = await UTILS.processImage(highResBase, 640, 0.72);
                document.getElementById('smallPreview').src = App.state.capturedImage;
            },

            retakePartial: () => {
                document.getElementById('takenPhotoUI').classList.add('hidden');
                document.getElementById('takenPhotoUI').classList.remove('flex');
                document.getElementById('cameraSection').classList.remove('hidden');
                App.initCamera();

                document.getElementById('segCurrent').innerText = App.state.activeSegment + 1;
                App.updateManipControlsVisibility();
            },

            retakeAll: () => {
                App.state.activeSegment = 0;
                App.state.segments = [];
                App.state.captureBase = null;
                document.getElementById('takenPhotoUI').classList.add('hidden');
                document.getElementById('takenPhotoUI').classList.remove('flex');
                document.getElementById('cameraSection').classList.remove('hidden');
                document.getElementById('imageManipControls').classList.add('hidden');
                document.getElementById('saveEntryBtn').disabled = true;
                App.initCamera();
                App.setCollageMode(App.state.collageMode);
            },

            retakePhoto: () => { App.retakeAll(); },

            updateManipControlsVisibility: () => {
                const seg = App.state.segments[App.state.activeSegment];
                const controls = document.getElementById('imageManipControls');
                if (seg && seg.isManipulatable) {
                    controls.classList.remove('hidden');
                    const rotSlider = document.getElementById('rotationSlider');
                    const zoomSlider = document.getElementById('zoomSlider');
                    const rotVal = document.getElementById('rotationValue');
                    const zoomVal = document.getElementById('zoomValue');
                    const rotDeg = Math.round((seg.rotation * 180) / Math.PI);
                    rotSlider.value = rotDeg;
                    rotVal.textContent = rotDeg + '°';
                    const zoomRatio = seg.scale / seg.baseScale;
                    zoomSlider.value = zoomRatio;
                    zoomVal.textContent = zoomRatio.toFixed(1) + 'x';
                    lucide.createIcons();
                } else {
                    controls.classList.add('hidden');
                }
            },

            setSegmentRotation: (deg) => {
                const seg = App.state.segments[App.state.activeSegment];
                if (seg && seg.isManipulatable) {
                    seg.rotation = (parseFloat(deg) * Math.PI) / 180;
                    document.getElementById('rotationValue').textContent = deg + '°';
                }
            },

            setSegmentZoom: (ratio) => {
                const seg = App.state.segments[App.state.activeSegment];
                if (seg && seg.isManipulatable) {
                    const r = parseFloat(ratio);
                    seg.scale = seg.baseScale * r;
                    document.getElementById('zoomValue').textContent = r.toFixed(1) + 'x';
                }
            },

            flipSegmentHorizontal: () => {
                const seg = App.state.segments[App.state.activeSegment];
                if (seg && seg.isManipulatable) {
                    seg.flipH = !seg.flipH;
                }
            },

            flipSegmentVertical: () => {
                const seg = App.state.segments[App.state.activeSegment];
                if (seg && seg.isManipulatable) {
                    seg.flipV = !seg.flipV;
                }
            },

            resetSegmentTransform: () => {
                const seg = App.state.segments[App.state.activeSegment];
                if (seg && seg.isManipulatable) {
                    seg.x = 0;
                    seg.y = 0;
                    seg.rotation = 0;
                    seg.scale = seg.baseScale;
                    seg.flipH = false;
                    seg.flipV = false;
                    App.updateManipControlsVisibility();
                }
            },

            handleFileUpload: async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const base64 = await UTILS.toBase64(file);
                    const img = new Image();
                    img.src = base64;
                    img.onload = () => {
                        // Calculate slot dimensions
                        const baseDims = App.state.captureBase || App.getTargetBaseDimensions();
                        const layout = App.collageConfigs[App.state.collageMode];
                        const slot = layout[App.state.activeSegment];

                        // We need the absolute dimensions of the slot in the "virtual" canvas
                        // But wait, the virtual canvas size depends on the mode multW/multH.
                        // However, simpler approach:
                        // The 'scale' should be relative to the image itself being drawn into the slot.
                        // We want the image to COVER the slot.
                        // We need to know the slot's aspect ratio.
                        // Slot W relative = slot.w, Slot H relative = slot.h
                        // But we need the aspect ratio of the slot in pixels.
                        // Assume BaseW/BaseH is the 1x1 size.
                        const BaseW = baseDims.width;
                        const BaseH = baseDims.height;

                        // We need to know the multiplier for the current mode to get true aspect?
                        // Actually App.getFinalCanvasDimensions does this.
                        let multW = 1; let multH = 1;
                        const mode = App.state.collageMode;
                        if (mode === 2) multW = 2;
                        else if (mode === 3) multW = 3;
                        else if (mode === 4) { multW = 2; multH = 2; }
                        else if (mode === 5) { multH = 2; }
                        else if (mode === 6) { multH = 3; }
                        else if (mode === 7) { multW = 2; multH = 2; }

                        // But wait, slot.w is percentage of Final Width.
                        // So we just need Final Width / Final Height ratio?
                        // Actually, let's just use the current canvas dimensions if available, or estimate.
                        // Safest is to use the logic from drawLoop:
                        const finalDims = App.getFinalCanvasDimensions(BaseW, BaseH, multW, multH);
                        const slotPixelW = slot.w * finalDims.width;
                        const slotPixelH = slot.h * finalDims.height;

                        const imgW = img.width;
                        const imgH = img.height;

                        // Calculate Scale to COVER
                        const scaleW = slotPixelW / imgW;
                        const scaleH = slotPixelH / imgH;
                        const scale = Math.max(scaleW, scaleH);

                        App.state.segments[App.state.activeSegment] = {
                            source: img,
                            isManipulatable: true,
                            x: 0,
                            y: 0,
                            scale: scale,
                            baseScale: scale,
                            rotation: 0,
                            flipH: false,
                            flipV: false,
                            width: imgW,
                            height: imgH
                        };

                        if (!App.state.captureBase) {
                            App.state.captureBase = { width: BaseW, height: BaseH };
                        }

                        // Auto-advance
                        const total = layout.length;
                        let allFilled = true;
                        let nextEmpty = -1;
                        for (let i = 0; i < total; i++) {
                            if (!App.state.segments[i]) {
                                allFilled = false;
                                if (nextEmpty === -1) nextEmpty = i;
                            }
                        }

                        if (allFilled) {
                            App.finalizeCollage();
                        } else {
                            if (nextEmpty !== -1) {
                                App.state.activeSegment = nextEmpty;
                                document.getElementById('segCurrent').innerText = App.state.activeSegment + 1;
                            }
                        }
                        App.updateManipControlsVisibility();
                    }
                }
            },
            renderSettingsStatus: (settings) => {
                const statusEl = document.getElementById('connectionStatus');
                const s = settings || Storage.getSettings();
                if (!s.authToken) {
                    statusEl.innerHTML = `
                        <div class="flex items-start gap-3 text-amber-700 bg-amber-50 p-3 rounded-lg border border-amber-100 text-xs">
                            <div class="bg-white p-1 rounded-full shadow-sm mt-0.5"><i data-lucide="alert-circle" class="w-4 h-4 text-amber-600"></i></div>
                            <div class="flex-1">
                                <strong class="block text-sm mb-0.5">Not Connected</strong>
                                <span class="opacity-80">Connect via OAuth or verify your manual key to start.</span>
                            </div>
                        </div>
                    `;
                } else if (s.authToken.startsWith('secret_')) {
                    statusEl.innerHTML = `
                        <div class="flex items-start gap-3 text-green-700 bg-green-50 p-3 rounded-lg border border-green-100 text-xs">
                            <div class="bg-white p-1 rounded-full shadow-sm mt-0.5"><i data-lucide="key" class="w-4 h-4 text-green-600"></i></div>
                            <div class="flex-1">
                                <strong class="block text-sm mb-0.5">Connected via Secret Key</strong>
                                <span class="opacity-80">Integration verified manually.</span>
                            </div>
                        </div>
                    `;
                } else {
                    statusEl.innerHTML = `
                        <div class="flex items-start gap-3 text-dull-purple bg-dull-purple/10 p-3 rounded-lg border border-dull-purple/20 text-xs">
                            <div class="bg-white p-1 rounded-full shadow-sm mt-0.5"><i data-lucide="zap" class="w-4 h-4 text-dull-purple"></i></div>
                            <div class="flex-1">
                                <strong class="block text-sm mb-0.5">Connected via OAuth</strong>
                                <span class="opacity-80">Access granted via standard Notion authorization.</span>
                            </div>
                        </div>
                    `;
                }
                lucide.createIcons();
            },
            populateSettingsInputs: () => {
                const s = Storage.getSettings();
                const isSecret = s.authToken && s.authToken.startsWith('secret_');
                document.getElementById('settingAuthToken').value = isSecret ? s.authToken : '';
                document.getElementById('settingWorkerUrl').value = s.workerUrl || '';
                document.getElementById('settingProxyToken').value = s.proxyToken || '';
                const capValue = String(s.uploadCapMb || 5);
                document.querySelectorAll('input[name="uploadCapMb"]').forEach((input) => {
                    input.checked = input.value === capValue;
                });
                const hasVerifiedWorker = !!s.workerUrl;
                const authSection = document.getElementById('authSection');
                if (hasVerifiedWorker) {
                    authSection.classList.remove('opacity-50', 'pointer-events-none');
                } else {
                    authSection.classList.add('opacity-50', 'pointer-events-none');
                }
                const isAuthVerified = !!s.authToken;
                document.getElementById('saveSettingsBtn').disabled = !isAuthVerified;
            },
            onSettingInput: () => {
                const workerUrl = document.getElementById('settingWorkerUrl').value;
                document.getElementById('verifyWorkerBtn').disabled = !workerUrl;
            },
            setUploadCap: (value) => {
                const cap = Number(value) || 5;
                const current = Storage.getSettings();
                Storage.setSettings({ ...current, uploadCapMb: cap });
                App.showToast(`Upload cap set to ${cap}MB`, "success");
            },
            verifyWorker: async () => {
                const btn = document.getElementById('verifyWorkerBtn');
                const originalText = btn.innerText;
                const workerUrl = document.getElementById('settingWorkerUrl').value.trim();
                const proxyToken = document.getElementById('settingProxyToken').value.trim();
                if (!workerUrl) return App.showToast("Enter a Worker URL first", "error");
                btn.innerText = "Checking...";
                btn.disabled = true;
                const cleanWorkerUrl = workerUrl.replace(/\/$/, '');
                let fetchUrl;
                try {
                    fetchUrl = new URL(cleanWorkerUrl);
                } catch (e) {
                    App.showToast("Invalid Worker URL format", "error");
                    btn.innerText = originalText;
                    btn.disabled = false;
                    return;
                }
                fetchUrl.searchParams.append('url', 'https://api.notion.com/v1/users/me');
                try {
                    const headers = {};
                    if (proxyToken) headers['X-Proxy-Token'] = proxyToken;
                    const res = await fetch(fetchUrl.toString(), { headers });
                    if (res.ok || res.status === 401) {
                        App.showToast("Proxy Verified!", "success");
                        const current = Storage.getSettings();
                        Storage.setSettings({ ...current, workerUrl, proxyToken });
                        document.getElementById('authSection').classList.remove('opacity-50', 'pointer-events-none');
                    } else {
                        throw new Error("Proxy returned status " + res.status);
                    }
                } catch (e) {
                    App.showToast("Verification failed. Check Worker URL & Proxy Secret.", "error");
                } finally {
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            },
            isLocalDevPage: () => {
                const host = window.location.hostname;
                return host === 'localhost' || host === '127.0.0.1';
            },
            saveBeforeOAuth: async () => {
                const workerUrl = document.getElementById('settingWorkerUrl').value;
                const proxyToken = document.getElementById('settingProxyToken').value;
                const current = Storage.getSettings();
                Storage.setSettings({ ...current, workerUrl, proxyToken });
                const returnTo = new URL('index.html', window.location.href).toString();
                const loginUrl = new URL(`${OAUTH_HANDLER_URL}/auth/login`);
                loginUrl.searchParams.set('from', returnTo);

                if (App.isLocalDevPage()) {
                    const devPassword = localStorage.getItem(OAUTH_DEV_PASSWORD_KEY);
                    if (!devPassword) {
                        App.showToast("Set localStorage oauth_dev_password for localhost OAuth", "error");
                        return;
                    }
                    try {
                        const unlockResponse = await fetch(`${OAUTH_HANDLER_URL}/auth/dev-unlock`, {
                            method: 'POST',
                            headers: { 'X-OAuth-Dev-Password': devPassword }
                        });
                        if (!unlockResponse.ok) {
                            const body = await unlockResponse.text();
                            throw new Error(body || `Status ${unlockResponse.status}`);
                        }
                        const unlock = await unlockResponse.json();
                        if (!unlock?.unlockToken) {
                            throw new Error("Missing unlock token");
                        }
                        loginUrl.searchParams.set('dev_unlock', unlock.unlockToken);
                    } catch (e) {
                        App.showToast(`OAuth dev unlock failed: ${e.message || 'unknown error'}`, "error");
                        return;
                    }
                }

                window.location.href = loginUrl.toString();
            },
            testManualConnection: async (btn) => {
                const workerUrl = document.getElementById('settingWorkerUrl').value;
                const authToken = document.getElementById('settingAuthToken').value;
                const proxyToken = document.getElementById('settingProxyToken').value;
                if (!authToken || !workerUrl) return App.showToast("Token and Worker URL required", "error");
                const originalText = btn.innerText;
                btn.innerText = "Verifying...";
                btn.disabled = true;
                try {
                    const tempSettings = { workerUrl, authToken, proxyToken };
                    const res = await API.request('GET', '/users/me', null, tempSettings);
                    App.showToast(`Verified: ${res.bot?.workspace_name || 'Connected'}`, 'success');
                    Storage.setSettings(tempSettings);
                    App.renderSettingsStatus(tempSettings);
                    document.getElementById('saveSettingsBtn').disabled = false;
                    App.scanForDataSources(tempSettings);
                } catch (e) {
                    App.showToast(e.message, 'error');
                    document.getElementById('saveSettingsBtn').disabled = true;
                } finally {
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            },
            testConnection: async (btn) => {
                App.testManualConnection(btn);
            },
            saveSettings: () => {
                App.closeModal('settingsModal');
                App.showToast("Settings Closed", "success");
                App.renderWelcomeState();
            },
            openModal: (id) => {
                document.getElementById(id).classList.remove('hidden', 'flex');
                document.getElementById(id).classList.add('flex');
                if (id === 'settingsModal') {
                    App.populateSettingsInputs();
                    App.renderSettingsStatus();
                }
                if (id === 'entryModal') {
                    App.state.isEntryModalOpen = true;
                    const streamStopped = App.state.stream
                        ? App.state.stream.getTracks().every(t => t.readyState === 'ended')
                        : true;
                    if (!App.state.stream || streamStopped) App.initCamera();
                    App.startDrawLoop();
                }
                lucide.createIcons();
            },
            closeModal: (id, options = {}) => {
                const { force = false } = options;
                if (id === 'entryModal') {
                    if (!force && App.hasUnsavedEntry()) {
                        const ok = confirm("Discard this entry? Your captured photo and notes will be lost.");
                        if (!ok) return false;
                    }
                    App.state.isEntryModalOpen = false;
                    App.stopDrawLoop();
                    if (App.state.stream) {
                        App.state.stream.getTracks().forEach(t => t.stop());
                        App.state.stream = null;
                    }
                    if (App.state.ghostImageIsObjectUrl && App.state.ghostImageUrl) {
                        URL.revokeObjectURL(App.state.ghostImageUrl);
                    }
                    App.state.ghostImageUrl = null;
                    App.state.ghostImageIsObjectUrl = false;
                }
                document.getElementById(id).classList.add('hidden');
                document.getElementById(id).classList.remove('flex');
                return true;
            }
        };

        window.addEventListener('load', () => {
            App.init();
            registerServiceWorker();
        });
    </script>
</body>

</html>