<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GhostInk Flashcards</title>
    <meta name="theme-color" content="#917FB3">
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="icons/icon-96.png" sizes="96x96">

    <!-- Preconnect hints for CDN domains -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>

    <!-- Tailwind (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Markdown renderer -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.2/sql-wasm.js"></script>
    <!-- KaTeX for equations -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>

    <!-- GLightbox (CSS before JS) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox/dist/css/glightbox.min.css" />
    <script src="https://cdn.jsdelivr.net/gh/mcstudios/glightbox/dist/js/glightbox.min.js"></script>

    <!-- Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Fraunces:wght@600;700&family=Sora:wght@400;500;600&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">

    <script>
        (() => {
            const raw = localStorage.getItem('ghostink_settings_v1');
            let mode = 'system';
            let font = 'serif';
            try {
                const s = raw ? JSON.parse(raw) : {};
                mode = s.themeMode || 'system';
                font = s.fontMode || 'serif';
            } catch (_) { }
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const theme = mode === 'system' ? (prefersDark ? 'dark' : 'light') : mode;
            const root = document.documentElement;
            root.setAttribute('data-theme', theme);
            root.setAttribute('data-font', font);
            root.style.colorScheme = theme === 'dark' ? 'dark' : 'light';
        })();
    </script>

    <script>
        tailwind.config = {
            darkMode: ['class', '[data-theme="dark"]'],
            theme: {
                extend: {
                    colors: {
                        oatmeal: {
                            DEFAULT: 'rgb(var(--oatmeal-rgb) / <alpha-value>)',
                            dark: 'rgb(var(--oatmeal-dark-rgb) / <alpha-value>)',
                            hover: 'rgb(var(--oatmeal-hover-rgb) / <alpha-value>)'
                        },
                        'earth-metal': 'rgb(var(--earth-metal-rgb) / <alpha-value>)',
                        charcoal: 'rgb(var(--charcoal-rgb) / <alpha-value>)',
                        'white-linen': 'rgb(var(--linen-rgb) / <alpha-value>)',
                        'dull-purple': {
                            DEFAULT: 'rgb(var(--dull-purple-rgb) / <alpha-value>)',
                            hover: 'rgb(var(--dull-purple-hover-rgb) / <alpha-value>)'
                        },
                        'muted-pink': {
                            DEFAULT: 'rgb(var(--muted-pink-rgb) / <alpha-value>)',
                            hover: 'rgb(var(--muted-pink-hover-rgb) / <alpha-value>)'
                        }
                    },
                    fontFamily: {
                        display: ['var(--font-display, "Fraunces")', 'serif'],
                        sans: ['var(--font-sans, "Sora")', 'system-ui', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        :root {
            /* Light Theme Components */
            --oatmeal-rgb: 243 240 230;
            --oatmeal-dark-rgb: 230 226 214;
            --oatmeal-hover-rgb: 235 232 222;
            --earth-metal-rgb: 74 74 74;
            --charcoal-rgb: 31 31 31;
            --linen-rgb: 250 249 246;
            --dull-purple-rgb: 145 127 179;
            --dull-purple-hover-rgb: 130 113 161;
            --muted-pink-rgb: 216 167 177;
            --muted-pink-hover-rgb: 201 150 160;

            --oatmeal: rgb(var(--oatmeal-rgb));
            --oatmeal-dark: rgb(var(--oatmeal-dark-rgb));
            --earth-metal: rgb(var(--earth-metal-rgb));
            --charcoal: rgb(var(--charcoal-rgb));
            --linen: rgb(var(--linen-rgb));
            --dull-purple: rgb(var(--dull-purple-rgb));
            --muted-pink: rgb(var(--muted-pink-rgb));

            --card-bg: rgba(var(--linen-rgb), 0.9);
            --card-border: rgba(var(--charcoal-rgb), 0.06);
            --text-main: var(--charcoal);
            --text-sub: rgba(var(--charcoal-rgb), 0.7);
            --surface: var(--linen);
            --surface-strong: var(--oatmeal);
            --border-weak: var(--card-border);
            --bg: #f6f3eb;
        }

        body {
            background: var(--bg);
            color: var(--text-main);
            font-family: var(--font-sans, "Manrope"), system-ui, sans-serif;
        }

        html[data-font="mono"] body,
        body[data-font="mono"] {
            --font-display: "JetBrains Mono";
            --font-sans: "JetBrains Mono";
            font-family: "JetBrains Mono", monospace;
        }

        html:not([data-font="mono"]) body,
        body:not([data-font="mono"]) {
            --font-display: "Fraunces";
            --font-sans: "Sora";
        }

        body[data-theme="dark"],
        html[data-theme="dark"] body {
            color-scheme: dark;
            /* Dark Theme Components */
            --oatmeal-rgb: 31 28 43;
            --oatmeal-dark-rgb: 37 35 53;
            --oatmeal-hover-rgb: 42 39 61;
            --earth-metal-rgb: 244 241 255;
            --charcoal-rgb: 244 241 255;
            --linen-rgb: 27 25 23;
            --dull-purple-rgb: 120 100 160;
            --dull-purple-hover-rgb: 138 114 181;
            --muted-pink-rgb: 209 138 152;
            --muted-pink-hover-rgb: 224 155 171;

            --card-bg: #201d1b;
            --card-border: rgba(255, 255, 255, 0.08);
            --text-main: #f4f1ff;
            --text-sub: rgba(244, 241, 255, 0.7);
            --surface: #1f1c1a;
            --surface-strong: #1b1917;
            --border-weak: rgba(255, 255, 255, 0.08);
            --bg: #1b1917;
        }

        .card {
            border: 1px solid var(--card-border);
            background: var(--card-bg);
            backdrop-filter: blur(12px);
        }

        .media-embed {
            margin: 0.75rem 0;
            padding: 0.6rem;
            border: 1px solid var(--card-border);
            border-radius: 14px;
            background: color-mix(in srgb, var(--surface) 70%, transparent);
            position: relative;
        }

        .media-embed img,
        .media-embed video {
            display: block;
            width: 100%;
            max-width: 100%;
            border-radius: 12px;
            cursor: zoom-in;
        }

        .media-embed video {
            max-height: 420px;
            background: #000;
        }

        /* Mobile FAB position is configured via a settings picker (no drag-to-reposition mode). */

        .dash {
            background: repeating-linear-gradient(-45deg,
                    rgba(145, 127, 179, 0.08),
                    rgba(145, 127, 179, 0.08) 12px,
                    transparent 12px,
                    transparent 24px);
        }

        .pill {
            border: 1px solid var(--card-border);
        }

        .glass {
            background: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .shadow-soft {
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.08);
        }

        html[data-theme="dark"] .shadow-soft {
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
        }

        kbd {
            font-family: "JetBrains Mono", "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        /* Custom tooltip that appears below element (desktop only) */
        @media (min-width: 641px) {
            [data-tooltip] {
                position: relative;
            }

            [data-tooltip]::after {
                content: attr(data-tooltip);
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                margin-top: 6px;
                padding: 4px 8px;
                background: var(--text-main, #1b1917);
                color: var(--bg, #faf9f6);
                font-size: 11px;
                white-space: nowrap;
                border-radius: 6px;
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.15s;
                z-index: 100;
            }

            [data-tooltip]:hover::after {
                opacity: 1;
            }
        }

        /* Notion color helpers */
        .notion-color-default {
            color: inherit;
        }

        .notion-color-gray {
            color: #9b9a97;
        }

        .notion-color-brown {
            color: #64473a;
        }

        .notion-color-orange {
            color: #d9730d;
        }

        .notion-color-yellow {
            color: #e0a30b;
        }

        .notion-color-green {
            color: #0f7b6c;
        }

        .notion-color-blue {
            color: #0b6ae6;
        }

        .notion-color-purple {
            color: #6940a5;
        }

        .notion-color-pink {
            color: #ad1a72;
        }

        .notion-color-red {
            color: #e03e3e;
        }

        .notion-color-gray-background {
            background: #ebeced;
        }

        .notion-color-brown-background {
            background: #ede4de;
        }

        .notion-color-orange-background {
            background: #faebdd;
        }

        .notion-color-yellow-background {
            background: #fbf3db;
        }

        .notion-color-green-background {
            background: #ddebea;
        }

        .notion-color-blue-background {
            background: #e7f3f8;
        }

        .notion-color-purple-background {
            background: #f1ecf9;
        }

        .notion-color-pink-background {
            background: #f6e0e9;
        }

        .notion-color-red-background {
            background: #fdebec;
        }

        html[data-theme="dark"] .notion-color-gray {
            color: #868686;
        }

        html[data-theme="dark"] .notion-color-brown {
            color: #b0937c;
        }

        html[data-theme="dark"] .notion-color-orange {
            color: #ffb45b;
        }

        html[data-theme="dark"] .notion-color-yellow {
            color: #f7cd46;
        }

        html[data-theme="dark"] .notion-color-green {
            color: #5bc0a7;
        }

        html[data-theme="dark"] .notion-color-blue {
            color: #6ab7ff;
        }

        html[data-theme="dark"] .notion-color-purple {
            color: #b18cff;
        }

        html[data-theme="dark"] .notion-color-pink {
            color: #ff8fb1;
        }

        html[data-theme="dark"] .notion-color-red {
            color: #ff7b73;
        }

        html[data-theme="dark"] .notion-color-gray-background {
            background: #2f3134;
        }

        html[data-theme="dark"] .notion-color-brown-background {
            background: #352922;
        }

        html[data-theme="dark"] .notion-color-orange-background {
            background: #422a15;
        }

        html[data-theme="dark"] .notion-color-yellow-background {
            background: #443716;
        }

        html[data-theme="dark"] .notion-color-green-background {
            background: #183a33;
        }

        html[data-theme="dark"] .notion-color-blue-background {
            background: #152f4d;
        }

        html[data-theme="dark"] .notion-color-purple-background {
            background: #2b2340;
        }

        html[data-theme="dark"] .notion-color-pink-background {
            background: #3b2431;
        }

        html[data-theme="dark"] .notion-color-red-background {
            background: #442022;
        }

        .cloze-blank {
            padding: 2px 6px;
            border-bottom: 1px dashed var(--dull-purple);
            background: linear-gradient(90deg, rgb(var(--dull-purple-rgb) / 0.14), rgba(216, 167, 177, 0.14));
            border-radius: 6px;
        }

        .cloze-blank .cloze-answer {
            display: none;
        }

        .cloze-blank .cloze-placeholder {
            color: var(--dull-purple);
            font-style: italic;
        }

        .cloze-blank.revealed .cloze-answer {
            display: inline;
            color: var(--dull-purple);
            font-weight: 600;
        }

        .cloze-blank.revealed .cloze-placeholder {
            display: none;
        }

        /* Link styling in card content and notes */
        #cardFront a,
        #cardBack a,
        #notesPreview a,
        #aiFeedback a,
        #blockNotePreview a {
            color: var(--dull-purple);
            text-decoration: underline;
        }

        #cardFront a:hover,
        #cardBack a:hover,
        #notesPreview a:hover,
        #aiFeedback a:hover,
        #blockNotePreview a:hover {
            opacity: 0.8;
        }

        /* Minimal markdown typography (works without Tailwind Typography plugin) */
        .md-content :is(p, ul, ol, pre, blockquote, table) {
            margin: 0.65rem 0;
        }

        .md-content :is(h1, h2, h3) {
            margin: 0.9rem 0 0.5rem;
            font-family: var(--font-display, "Fraunces"), serif;
            color: var(--text-main);
            line-height: 1.15;
        }

        .md-content h1 {
            font-size: 1.25rem;
        }

        .md-content h2 {
            font-size: 1.1rem;
        }

        .md-content h3 {
            font-size: 1rem;
        }

        .md-content ul {
            padding-left: 1.2rem;
            list-style: disc;
        }

        .md-content ol {
            padding-left: 1.2rem;
            list-style: decimal;
        }

        .md-content li {
            margin: 0.25rem 0;
        }

        .md-content blockquote {
            padding: 0.5rem 0.75rem;
            border-left: 3px solid color-mix(in srgb, var(--dull-purple) 55%, transparent);
            background: color-mix(in srgb, var(--surface-strong) 65%, transparent);
            border-radius: 12px;
            color: var(--text-sub);
        }

        .md-content :is(code, kbd) {
            background: color-mix(in srgb, var(--surface-strong) 78%, transparent);
            border: 1px solid var(--card-border);
            padding: 0.08rem 0.35rem;
            border-radius: 8px;
            font-size: 0.92em;
        }

        .md-content pre {
            padding: 0.75rem;
            border-radius: 14px;
            overflow: auto;
            background: color-mix(in srgb, var(--surface-strong) 88%, transparent);
            border: 1px solid var(--card-border);
        }

        .md-content pre code {
            background: transparent;
            border: 0;
            padding: 0;
        }

        .media-embed-frame {
            position: relative;
            width: 100%;
            padding-top: 56.25%;
            border-radius: 12px;
            overflow: hidden;
            background: #000;
        }

        .media-embed-frame iframe {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            border: 0;
        }

        .media-embed figcaption {
            margin-top: 0.4rem;
            font-size: 11px;
            color: var(--text-sub);
            word-break: break-word;
        }

        .media-embed figcaption a {
            color: var(--dull-purple);
        }

        .scroll-minimal::-webkit-scrollbar {
            width: 8px;
        }

        .scroll-minimal::-webkit-scrollbar-thumb {
            background: rgba(73, 73, 73, 0.25);
            border-radius: 10px;
        }

        /* Mobile FAB cluster - Joystick and action bar */
        @media (max-width: 640px) {
            .mobile-fab-cluster {
                position: fixed;
                bottom: 12px;
                left: 12px;
                display: flex;
                flex-direction: row;
                align-items: flex-end;
                gap: 8px;
                padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
                pointer-events: none;
                z-index: 50;
            }

            .mobile-fab-cluster>* {
                pointer-events: auto;
            }

            /* Joystick wrapper with action buttons on right */
            .joystick-wrapper {
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 6px;
            }

            /* Side action buttons (next to joystick) */
            .joystick-side-actions {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .fab-btn {
                width: 36px;
                height: 36px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                border: none;
                cursor: pointer;
                transition: all 0.15s ease;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
            }

            .fab-btn:active {
                transform: scale(0.92);
            }

            .fab-btn-secondary {
                background: var(--surface-strong);
                border: 1px solid var(--card-border);
                color: var(--text-sub);
            }

            .fab-btn-secondary svg {
                width: 16px;
                height: 16px;
            }

            .fab-btn-primary {
                background: #494949;
                color: white;
                width: 40px;
                height: 40px;
            }

            .fab-btn-primary svg {
                width: 18px;
                height: 18px;
            }

            .fab-btn.hidden {
                display: none;
            }

            /* Joystick - circular arcade style */
            .joystick-container {
                position: relative;
                width: 96px;
                height: 96px;
            }

            .joystick {
                background: linear-gradient(var(--surface-strong), var(--surface));
                box-shadow: inset 0 0 3px rgba(0, 0, 0, .5),
                    inset 1px 2px 5px rgba(255, 255, 255, .15),
                    inset 2px 3px 12px rgba(0, 0, 0, .4),
                    0 3px 10px rgba(0, 0, 0, 0.2);
                border-radius: 50%;
                border: 1px solid var(--card-border);
                display: inline-block;
                height: 96px;
                position: relative;
                width: 96px;
                touch-action: none;
                user-select: none;
                -webkit-user-select: none;
            }

            /* Direction labels with filled icons */
            .joystick-label {
                position: absolute;
                font-size: 6px;
                font-weight: 700;
                text-transform: uppercase;
                letter-spacing: 0.3px;
                opacity: 0.5;
                transition: all 0.12s ease;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0px;
                pointer-events: none;
            }

            .joystick-label svg {
                width: 12px;
                height: 12px;
                fill: none;
                stroke: currentColor;
                stroke-width: 2.5;
            }

            .joystick-label.active {
                opacity: 1;
            }

            .joystick-label-up {
                top: 8px;
                left: 50%;
                transform: translateX(-50%);
                color: #16a34a;
            }

            .joystick-label-down {
                bottom: 8px;
                left: 50%;
                transform: translateX(-50%);
                color: #dc2626;
            }

            .joystick-label-left {
                left: 8px;
                top: 50%;
                transform: translateY(-50%);
                color: #ea580c;
            }

            .joystick-label-right {
                right: 8px;
                top: 50%;
                transform: translateY(-50%);
                color: #2563eb;
            }

            /* The knob (ball) */
            .joystick-knob {
                position: absolute;
                width: 28px;
                height: 28px;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                border-radius: 50%;
                background: radial-gradient(ellipse at 11px 9px, rgba(255, 255, 255, 0.9) 5%, #888 10%, #666 100%);
                box-shadow: inset 2px 2px 10px rgba(255, 255, 255, .4),
                    inset -2px -3px 10px rgba(0, 0, 0, .3),
                    0 3px 8px rgba(0, 0, 0, 0.4);
                transition: transform 0.08s ease-out, background 0.25s ease-in-out;
                z-index: 2;
            }

            /* Color variants based on direction */
            /* Clockwise from bottom: Again (down/red) â†’ Hard (left/orange) â†’ Good (up/green) â†’ Easy (right/blue) */
            .joystick.up .joystick-knob {
                background: radial-gradient(ellipse at 11px 9px, rgba(255, 255, 255, 0.9) 5%, #4ade80 10%, #16a34a 100%);
            }

            .joystick.down .joystick-knob {
                background: radial-gradient(ellipse at 11px 9px, rgba(255, 255, 255, 0.9) 5%, #f87171 10%, #dc2626 100%);
            }

            .joystick.left .joystick-knob {
                background: radial-gradient(ellipse at 11px 9px, rgba(255, 255, 255, 0.9) 5%, #fb923c 10%, #ea580c 100%);
            }

            .joystick.right .joystick-knob {
                background: radial-gradient(ellipse at 11px 9px, rgba(255, 255, 255, 0.9) 5%, #60a5fa 10%, #2563eb 100%);
            }

            /* Knob position based on direction */
            .joystick.up .joystick-knob {
                transform: translate(-50%, -50%) translateY(-18px);
            }

            .joystick.down .joystick-knob {
                transform: translate(-50%, -50%) translateY(18px);
            }

            .joystick.left .joystick-knob {
                transform: translate(-50%, -50%) translateX(-18px);
            }

            .joystick.right .joystick-knob {
                transform: translate(-50%, -50%) translateX(18px);
            }

            html[data-theme="dark"] .joystick-label-up {
                color: #4ade80;
            }

            html[data-theme="dark"] .joystick-label-down {
                color: #f87171;
            }

            html[data-theme="dark"] .joystick-label-left {
                color: #fb923c;
            }

            html[data-theme="dark"] .joystick-label-right {
                color: #60a5fa;
            }
        }

        /* Hide mobile FAB on larger screens */
        @media (min-width: 641px) {
            .mobile-fab-cluster {
                display: none !important;
            }
        }

        /* Card transition animation */
        #cardFront,
        #cardBack {
            transition: opacity 0.15s ease;
        }

        .card-transitioning {
            opacity: 0;
        }

        .bg-oatmeal\/60 {
            background-color: color-mix(in srgb, var(--surface-strong) 70%, transparent) !important;
        }

        .border-oatmeal-dark,
        .border-oatmeal-dark\/60,
        .border-oatmeal-dark\/70 {
            border-color: var(--card-border) !important;
        }

        html[data-theme="dark"] .text-amber-800 {
            color: #ffd8a1 !important;
        }

        body.preinit {
            opacity: 0;
        }

        /* Keep Tailwind's `text-*` colors in sync with theme via CSS variables. */

        /* compact icon toggles */
        .pill-toggle {
            border: 1px solid var(--card-border);
            background: var(--surface);
        }

        .pill-toggle button {
            color: var(--text-sub);
        }

        .pill-toggle button.active {
            background: rgb(var(--dull-purple-rgb));
            color: #fff;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }

        .font-swatch-serif {
            font-family: 'Fraunces', serif !important;
            letter-spacing: 0.01em;
        }

        .font-swatch-mono {
            font-family: 'JetBrains Mono', monospace !important;
            letter-spacing: 0.01em;
        }

        /* Tab navigation */
        .tab-btn {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 0.75rem;
            transition: all 0.2s ease;
            color: var(--text-sub);
            background: transparent;
        }

        .tab-btn:hover {
            background: var(--surface-strong);
        }

        .tab-btn.active {
            background: rgb(var(--dull-purple-rgb));
            color: white;
        }

        .tab-content {
            display: block;
        }

        .tab-content.hidden {
            display: none;
        }

        /* Fix select dropdown positioning on mobile */
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%234A4A4A' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            padding-right: 2rem;
            position: relative;
            z-index: 1;
        }

        html[data-theme="dark"] select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23f4f1ff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
        }

        /* Mobile select touch optimization */
        @media (max-width: 640px) {
            select {
                font-size: 16px;
                /* Prevents iOS zoom on focus */
                min-height: 44px;
                /* Better touch target */
            }
        }
    </style>
</head>

<body class="text-earth-metal font-sans min-h-[100dvh] preinit" data-theme="light" data-font="serif">
    <div class="min-h-[100dvh] flex flex-col">
        <header
            class="flex flex-wrap items-center justify-between gap-2 px-3 sm:px-5 md:px-10 pt-4 sm:pt-6 pb-3 sm:pb-4">
            <div class="flex items-center gap-2 sm:gap-3 min-w-0">
                <div
                    class="w-9 h-9 sm:w-12 sm:h-12 rounded-lg sm:rounded-2xl dash flex items-center justify-center shadow-soft shrink-0">
                    <i data-lucide="sparkles" class="w-5 h-5 sm:w-6 sm:h-6 text-dull-purple"></i>
                </div>
                <div class="min-w-0">
                    <h1 class="font-display text-lg sm:text-2xl text-charcoal tracking-tight truncate">GhostInk</h1>
                    <p class="text-xs sm:text-sm text-earth-metal/70 hidden sm:block">AI-enabled flashcards stored in
                        Notion</p>
                </div>
            </div>
            <div class="flex items-center gap-1 sm:gap-1.5 md:gap-2 shrink-0">
                <div id="connectionBadge"
                    class="px-2 py-1 rounded-full pill text-[10px] sm:text-xs bg-oatmeal border border-oatmeal-dark text-earth-metal hidden md:block">
                    Offline ready</div>
                <!-- Desktop-only options -->
                <div class="hidden sm:flex items-center gap-0.5 sm:gap-1 pill-toggle rounded-full px-1 sm:px-2 py-1">
                    <button class="p-1 rounded-full theme-btn" data-theme="light" data-tip="Light theme"
                        aria-label="Light theme"><i data-lucide="sun" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i></button>
                    <button class="p-1 rounded-full theme-btn" data-theme="dark" data-tip="Dark theme"
                        aria-label="Dark theme"><i data-lucide="moon" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i></button>
                    <button class="p-1 rounded-full theme-btn" data-theme="system" data-tip="System theme"
                        aria-label="System theme"><i data-lucide="laptop" class="w-4 h-4"></i></button>
                </div>
                <div class="hidden md:flex items-center gap-1 pill-toggle rounded-full px-2 py-1">
                    <button class="px-2 py-1 rounded-full font-btn text-xs" data-font="serif" data-tip="Serif font"
                        aria-label="Serif font">
                        <span class="font-swatch-serif inline-block">Aa</span>
                    </button>
                    <button class="px-2 py-1 rounded-full font-btn text-xs" data-font="mono" data-tip="Mono font"
                        aria-label="Monospace font">
                        <span class="font-swatch-mono inline-block">Aa</span>
                    </button>
                </div>
                <div class="hidden sm:flex items-center gap-0.5 sm:gap-1 pill-toggle rounded-full px-1 sm:px-2 py-1">
                    <button id="exportAnkiBtn" class="p-1 rounded-full" title="Export Anki" aria-label="Export to Anki">
                        <i data-lucide="download" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i>
                    </button>
                    <label class="p-1 rounded-full cursor-pointer" title="Import Anki" aria-label="Import from Anki">
                        <i data-lucide="upload-cloud" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i>
                        <input aria-label="Import .apkg" id="ankiImportInput" type="file" accept=".apkg,.json"
                            class="hidden">
                    </label>
                </div>
                <!-- Mobile more button -->
                <button id="mobileMoreBtn"
                    class="sm:hidden p-1.5 rounded-full bg-white-linen border border-oatmeal-dark" title="More options"
                    aria-label="More options">
                    <i data-lucide="more-horizontal" class="w-4 h-4"></i>
                </button>
                <button id="syncNowBtn"
                    class="p-1.5 sm:p-2 rounded-full bg-dull-purple text-white hover:bg-dull-purple-hover transition-all"
                    data-tip="Sync now" title="Sync" aria-label="Sync with Notion">
                    <i data-lucide="refresh-ccw" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i>
                </button>
                <button id="openSettings"
                    class="p-1.5 sm:p-2 rounded-full bg-white-linen border border-oatmeal-dark hover:border-dull-purple transition-all"
                    data-tip="Settings" title="Settings" aria-label="Open settings">
                    <i data-lucide="settings" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i>
                </button>
            </div>
            <!-- Mobile expanded menu -->
            <div id="mobileMoreMenu"
                class="hidden w-full pt-2 pb-1 border-t border-[color:var(--card-border)] mt-2 flex-wrap gap-2 sm:hidden">
                <div class="flex items-center gap-1 pill-toggle rounded-full px-2 py-1">
                    <button class="p-1 rounded-full theme-btn" data-theme="light" aria-label="Light theme"><i
                            data-lucide="sun" class="w-4 h-4"></i></button>
                    <button class="p-1 rounded-full theme-btn" data-theme="dark" aria-label="Dark theme"><i
                            data-lucide="moon" class="w-4 h-4"></i></button>
                    <button class="p-1 rounded-full theme-btn" data-theme="system" aria-label="System theme"><i
                            data-lucide="laptop" class="w-4 h-4"></i></button>
                </div>
                <div class="flex items-center gap-1 pill-toggle rounded-full px-2 py-1">
                    <button class="px-2 py-1 rounded-full font-btn text-xs" data-font="serif"
                        aria-label="Serif font"><span class="font-swatch-serif">Aa</span></button>
                    <button class="px-2 py-1 rounded-full font-btn text-xs" data-font="mono"
                        aria-label="Monospace font"><span class="font-swatch-mono">Aa</span></button>
                </div>
                <div class="flex items-center gap-1 pill-toggle rounded-full px-2 py-1">
                    <button id="exportAnkiBtnMobile" class="p-1 rounded-full" title="Export Anki"
                        aria-label="Export to Anki"><i data-lucide="download" class="w-4 h-4"></i></button>
                    <label class="p-1 rounded-full cursor-pointer" title="Import Anki" aria-label="Import from Anki">
                        <i data-lucide="upload-cloud" class="w-4 h-4"></i>
                        <input aria-label="Import .apkg" id="ankiImportInputMobile" type="file" accept=".apkg,.json"
                            class="hidden">
                    </label>
                </div>
            </div>
        </header>

        <!-- Tab Navigation -->
        <nav id="tabBar"
            class="px-3 sm:px-5 md:px-10 py-2 sm:py-3 flex gap-1.5 sm:gap-2 border-b border-[color:var(--card-border)]">
            <button data-tab="study" class="tab-btn active text-xs sm:text-sm">ðŸ“– Study</button>
            <button data-tab="library" class="tab-btn text-xs sm:text-sm">ðŸ“š Library</button>
        </nav>

        <main class="px-3 sm:px-5 md:px-10 pb-6 sm:pb-10 space-y-4 md:space-y-6">
            <div id="lockedOverlay"
                class="rounded-2xl p-6 bg-[color:var(--surface-strong)] border border-[color:var(--card-border)] flex flex-col gap-5 max-w-3xl mx-auto mt-6 text-center hidden">
                <div class="space-y-3">
                    <p class="font-display text-xl text-charcoal leading-tight">AI-enabled flashcards stored in Notion
                    </p>
                    <p class="text-sm text-earth-metal/70 leading-relaxed">
                        Your cards live in Notion where you can see and edit them. Reveal answers like Anki, or
                        type/speak your answer and let AI check it against the ground truth.
                    </p>
                    <p class="text-[11px] text-earth-metal/60 dark:text-white/60">
                        Built by <a class="underline text-dull-purple dark:text-dull-purple"
                            href="https://mimansajaiswal.github.io" target="_blank" rel="noopener noreferrer">Mimansa
                            Jaiswal</a> Â· In the <a class="underline text-dull-purple dark:text-dull-purple"
                            href="https://mimansajaiswal.github.io/tools/" target="_blank"
                            rel="noopener noreferrer">Tools Made with LLMs</a> Â· Code: <a
                            class="underline text-dull-purple dark:text-dull-purple"
                            href="https://github.com/mimansajaiswal/tools/tree/main/ghostink-flashcards" target="_blank"
                            rel="noopener noreferrer">ghostink-flashcards</a>
                    </p>
                </div>
                <div class="grid md:grid-cols-3 gap-3 text-sm text-left">
                    <div
                        class="rounded-lg bg-[color:var(--surface)] border border-[color:var(--card-border)] p-3 space-y-1">
                        <div class="flex items-center gap-2 text-dull-purple font-semibold"><i data-lucide="link"
                                class="w-4 h-4"></i>Connect</div>
                        <p class="text-earth-metal/70">Add your worker URL and Notion token to sync.</p>
                    </div>
                    <div
                        class="rounded-lg bg-[color:var(--surface)] border border-[color:var(--card-border)] p-3 space-y-1">
                        <div class="flex items-center gap-2 text-dull-purple font-semibold"><i data-lucide="database"
                                class="w-4 h-4"></i>Sources</div>
                        <p class="text-earth-metal/70">Point to your Decks and Cards databases in Notion.</p>
                    </div>
                    <div
                        class="rounded-lg bg-[color:var(--surface)] border border-[color:var(--card-border)] p-3 space-y-1">
                        <div class="flex items-center gap-2 text-dull-purple font-semibold"><i data-lucide="wand-2"
                                class="w-4 h-4"></i>Study</div>
                        <p class="text-earth-metal/70">Reveal answers directly, or use AI mode to check your response.
                        </p>
                    </div>
                </div>
                <div class="flex justify-center">
                    <button id="lockedOpenSettings"
                        class="px-5 py-3 rounded-lg bg-dull-purple text-white text-sm hover:bg-dull-purple-hover transition-all flex items-center gap-2 whitespace-nowrap shadow-soft">
                        <i data-lucide="settings" class="w-4 h-4"></i><span>Open settings</span>
                    </button>
                </div>
            </div>

            <section id="mainContent" class="space-y-6">
                <!-- LIBRARY TAB -->
                <div id="libraryTab" class="tab-content space-y-4 md:space-y-6 hidden">
                    <!-- Decks Section -->
                    <article class="card rounded-2xl p-4 md:p-5 shadow-soft text-[color:var(--text-main)]">
                        <div class="flex items-center justify-between gap-2">
                            <div class="min-w-0">
                                <h2 class="font-display text-base md:text-lg text-charcoal">Decks</h2>
                                <p class="text-xs md:text-sm text-earth-metal/70 hidden sm:block">Click to select a deck
                                    and view its cards.</p>
                            </div>
                            <div class="flex items-center gap-2 shrink-0">
                                <button id="refreshDecksBtn"
                                    class="p-2 rounded-lg border border-oatmeal-dark/60 text-earth-metal hover:bg-oatmeal dark:hover:bg-white/5 flex items-center gap-2"
                                    data-tooltip="Sync with Notion">
                                    <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                                </button>
                                <button id="newDeckBtn"
                                    class="p-2 md:px-3 md:py-2 rounded-lg bg-charcoal dark:bg-white/10 dark:border-white/10 dark:border text-white text-sm hover:bg-earth-metal dark:hover:bg-white/20 flex items-center gap-2"
                                    data-tooltip="New deck">
                                    <i data-lucide="plus" class="w-4 h-4"></i>
                                    <span class="hidden md:inline">New deck</span>
                                </button>
                            </div>
                        </div>
                        <!-- Deck search -->
                        <div class="mt-3">
                            <input id="libraryDeckSearch" type="text" placeholder="Search decks..."
                                class="w-full rounded-lg border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-dull-purple/40">
                        </div>
                        <div id="deckGrid"
                            class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-2 md:gap-3 mt-3 max-h-[400px] sm:max-h-[400px] md:max-h-[240px] lg:max-h-[240px] overflow-y-auto scroll-minimal p-1">
                        </div>
                    </article>

                    <!-- Selected Deck Bar + Cards Section -->
                    <article id="cardsSection"
                        class="card rounded-2xl p-4 md:p-5 shadow-soft text-[color:var(--text-main)]">
                        <div id="selectedDeckBar" class="flex items-center justify-between gap-2">
                            <h2 class="font-display text-base md:text-lg text-charcoal truncate" id="selectedDeckName">
                                Select a deck above</h2>
                            <div class="flex items-center gap-1 md:gap-2 shrink-0">
                                <button id="resetAlgorithmBtn"
                                    class="p-2 md:px-3 md:py-2 rounded-lg border border-red-300 text-red-600 text-sm hover:bg-red-50 dark:border-red-900 dark:text-red-400 dark:hover:bg-red-900/20 flex items-center gap-2 hidden"
                                    data-tooltip="Reset algorithm parameters">
                                    <i data-lucide="rotate-ccw" class="w-4 h-4"></i>
                                    <span class="hidden lg:inline">Reset Algorithm</span>
                                </button>
                                <button id="newCardBtn"
                                    class="p-2 md:px-3 md:py-2 rounded-lg bg-dull-purple text-white text-sm hover:bg-dull-purple-hover transition-all flex items-center gap-2 hidden"
                                    data-tooltip="New card">
                                    <i data-lucide="plus-circle" class="w-4 h-4"></i>
                                    <span class="hidden md:inline">New card</span>
                                </button>
                            </div>
                        </div>
                        <!-- Cards content (hidden until deck selected) -->
                        <div id="cardsContent" class="hidden mt-3 md:mt-4">
                            <!-- Card search -->
                            <div class="mb-3">
                                <input id="cardSearchInput" type="text" placeholder="Search cards by name..."
                                    class="w-full rounded-lg border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-dull-purple/40">
                            </div>
                            <div id="cardsContainer"
                                class="max-h-[350px] md:max-h-[400px] overflow-y-auto scroll-minimal">
                                <table class="w-full text-xs md:text-sm">
                                    <thead class="text-earth-metal/60 sticky top-0 bg-[color:var(--card-bg)]">
                                        <tr class="border-b border-oatmeal-dark/70">
                                            <th class="py-2 text-left">Name</th>
                                            <th class="py-2 text-left hidden sm:table-cell">Type</th>
                                            <th class="py-2 text-left">Due</th>
                                            <th class="py-2 text-left hidden md:table-cell">Tags</th>
                                            <th class="py-2 text-left w-8 md:w-10"></th>
                                        </tr>
                                    </thead>
                                    <tbody id="cardTable" class="divide-y divide-oatmeal-dark/40"></tbody>
                                </table>
                            </div>
                            <div id="noCardsMessage"
                                class="text-center py-6 md:py-8 text-earth-metal/60 text-xs md:text-sm hidden">
                                No cards in this deck yet. Click "New card" to add one.
                            </div>
                        </div>
                    </article>
                </div>

                <!-- STUDY TAB -->
                <div id="studyTab" class="tab-content">
                    <!-- Centered Study Content -->
                    <div class="max-w-2xl mx-auto space-y-4 md:space-y-6">
                        <!-- Session Active Bar (shown when session is active) -->
                        <div id="sessionActiveBar"
                            class="hidden card rounded-2xl p-4 md:p-5 shadow-soft text-[color:var(--text-main)]">
                            <div class="flex items-center justify-between gap-3">
                                <div class="flex items-center gap-2">
                                    <i data-lucide="book-open" class="w-5 h-5 text-dull-purple"></i>
                                    <span id="sessionProgressText"
                                        class="text-sm md:text-base text-charcoal font-medium">Session: 0/0</span>
                                </div>
                                <div id="previewBadge"
                                    class="hidden text-[11px] px-2 py-1 rounded-lg bg-amber-100 text-amber-800 border border-amber-200 dark:bg-amber-900/30 dark:text-amber-100 dark:border-amber-600/60">
                                    Preview mode: no scheduling changes
                                </div>
                                <button id="abandonSessionBtn"
                                    class="flex items-center gap-1.5 px-2 md:px-3 py-1.5 rounded-lg text-xs md:text-sm text-earth-metal/70 hover:text-muted-pink hover:bg-muted-pink/10 border border-oatmeal-dark/60 transition whitespace-nowrap">
                                    <i data-lucide="square" class="w-3 h-3"></i>
                                    <span class="hidden md:inline">Stop Session</span>
                                    <span class="md:hidden">Stop</span>
                                    <kbd id="stopSessionHotkey"
                                        class="hidden md:inline text-[10px] ml-1 px-1.5 py-0.5 rounded bg-dull-purple/10 text-dull-purple font-medium"></kbd>
                                </button>
                            </div>
                        </div>

                        <!-- Study Filters Card -->
                        <article id="studySettingsCard"
                            class="card rounded-2xl p-4 md:p-5 shadow-soft text-[color:var(--text-main)]">
                            <div class="flex items-center justify-between gap-2 mb-3 md:mb-4">
                                <div class="flex items-center gap-2 min-w-0">
                                    <i data-lucide="settings-2" class="w-4 h-4 text-dull-purple shrink-0"></i>
                                    <h2 class="font-display text-base md:text-lg text-charcoal truncate">Study Mode
                                        Settings</h2>
                                </div>
                                <button id="resetFilters"
                                    class="text-xs text-dull-purple hover:underline hidden">Reset</button>
                            </div>

                            <!-- Always visible: Decks + Mode -->
                            <div class="space-y-3">
                                <div>
                                    <label class="text-xs text-earth-metal/70 block mb-2">Study from decks</label>
                                    <div class="relative">
                                        <input id="deckSearchInput" type="text" placeholder="Search decks..."
                                            class="w-full rounded-lg border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-dull-purple/40">
                                        <div id="deckDropdown"
                                            class="hidden absolute left-0 right-0 z-50 w-full mt-1 max-h-48 overflow-y-auto rounded-lg border border-oatmeal-dark/60 bg-[color:var(--card-bg)] shadow-lg">
                                        </div>
                                    </div>
                                    <div id="selectedDecksDisplay" class="flex flex-wrap gap-1.5 mt-2"></div>
                                </div>
                                <div>
                                    <label class="text-xs text-earth-metal/70 block mb-2">Revision mode</label>
                                    <select id="revisionMode"
                                        class="w-full rounded-lg border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm">
                                        <option value="manual">Reveal</option>
                                        <option value="ai">AI</option>
                                    </select>
                                </div>
                                <!-- Session controls -->
                                <div id="sessionControls" class="pt-3">
                                    <button id="startSessionBtn"
                                        class="w-full px-4 py-2.5 rounded-lg bg-dull-purple text-white text-sm hover:bg-dull-purple-hover transition-all transition flex items-center justify-center gap-2">
                                        <i data-lucide="play" class="w-4 h-4"></i>
                                        <span>Start Study Session</span>
                                        <kbd id="startSessionHotkey"
                                            class="hidden md:inline-block text-[10px] px-1.5 py-0.5 rounded bg-white/20 font-medium ml-1 font-sans"></kbd>
                                    </button>
                                </div>
                            </div>

                            <!-- More options divider -->
                            <button id="toggleFilters"
                                class="w-full flex items-center justify-center gap-2 mt-4 py-2 text-xs text-earth-metal/60 hover:text-earth-metal transition-colors">
                                <span class="flex-1 h-px bg-[color:var(--card-border)]"></span>
                                <span class="flex items-center gap-1">
                                    <span id="moreOptionsText">More options</span>
                                    <i data-lucide="chevron-down" id="filtersChevron"
                                        class="w-3 h-3 transition-transform"></i>
                                </span>
                                <span class="flex-1 h-px bg-[color:var(--card-border)]"></span>
                            </button>

                            <div id="filtersContent" class="hidden pt-3 md:pt-4">
                                <div class="grid grid-cols-2 gap-2 md:gap-3 text-xs md:text-sm">
                                    <!-- Card selection mode -->
                                    <div class="col-span-2">
                                        <label class="text-xs text-earth-metal/70 block mb-2">Practice cards</label>
                                        <select id="cardSelectionMode"
                                            class="w-full rounded-lg border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm">
                                            <option value="due">Due cards only</option>
                                            <option value="all">All cards</option>
                                        </select>
                                    </div>
                                    <div id="noScheduleRow" class="col-span-2 hidden">
                                        <label class="flex items-center gap-2 text-xs md:text-sm">
                                            <input id="noScheduleChanges" type="checkbox" class="accent-dull-purple"
                                                checked>
                                            <span>No scheduling changes (preview mode)</span>
                                        </label>
                                        <p class="text-[11px] text-earth-metal/50 dark:text-white/60 mt-1">When on,
                                            ratings wonâ€™t update
                                            due dates or algorithms.</p>
                                    </div>
                                    <label class="flex items-center gap-2">
                                        <input id="filterAgain" type="checkbox" class="accent-dull-purple">
                                        <span>Again recently</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input id="filterHard" type="checkbox" class="accent-dull-purple">
                                        <span>Hard/Again</span>
                                    </label>
                                    <label class="flex items-center gap-2 col-span-2">
                                        <input id="filterAddedToday" type="checkbox" class="accent-dull-purple">
                                        <span>Added today</span>
                                    </label>
                                    <div class="col-span-2">
                                        <label class="text-xs text-earth-metal/70">Tags</label>
                                        <div class="relative">
                                            <input id="filterTagSearch" type="text" placeholder="Search tags"
                                                class="w-full rounded-lg border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm">
                                            <div id="filterTagDropdown"
                                                class="hidden absolute left-0 right-0 z-40 mt-1 max-h-44 overflow-y-auto rounded-lg border border-oatmeal-dark/60 bg-[color:var(--card-bg)] shadow-lg">
                                            </div>
                                        </div>
                                        <div id="filterTagSelected" class="flex flex-wrap gap-1.5 mt-2"></div>
                                    </div>
                                    <label class="flex items-center gap-2">
                                        <input id="filterSuspended" type="checkbox" class="accent-dull-purple">
                                        <span>Hide suspended</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input id="filterLeech" type="checkbox" class="accent-dull-purple">
                                        <span>Hide leeches</span>
                                    </label>
                                    <button id="resetFiltersMobile"
                                        class="col-span-2 sm:hidden text-xs text-dull-purple hover:underline text-center py-2">Reset
                                        all filters</button>
                                </div>
                            </div>
                        </article>
                        <!-- Study Card -->
                        <article id="studyCardSection"
                            class="card rounded-2xl p-4 md:p-5 shadow-soft text-[color:var(--text-main)] hidden">
                            <div class="flex items-center justify-between gap-2">
                                <h2 class="font-display text-base md:text-lg text-charcoal">Study</h2>
                                <div class="flex items-center gap-1">
                                    <button id="addNoteBlock"
                                        class="p-1.5 rounded-lg hover:bg-oatmeal text-dull-purple hidden"
                                        title="Add note to page">
                                        <i data-lucide="file-plus" class="w-4 h-4"></i>
                                    </button>
                                    <button id="copyCardContent"
                                        class="p-1.5 rounded-lg hover:bg-oatmeal text-dull-purple hidden"
                                        title="Copy card content">
                                        <i data-lucide="clipboard" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            <div id="studyCardContent"
                                class="relative mt-3 p-3 md:p-4 rounded-lg bg-[color:var(--surface-strong)] border border-[color:var(--card-border)] space-y-3">
                                <div class="flex items-center justify-between text-xs text-[color:var(--text-sub)]">
                                    <span id="studyDeckLabel" class="truncate">Choose a deck</span>
                                </div>
                                <div id="cardFront"
                                    class="md-content min-h-[100px] md:min-h-[120px] leading-relaxed text-[color:var(--text-main)] max-h-[40vh] md:max-h-[45vh] overflow-y-auto pr-1 scroll-minimal text-sm md:text-base">
                                </div>
                                <div class="space-y-2">
                                    <button id="revealBtn"
                                        class="relative px-3 py-2.5 w-full rounded-lg bg-charcoal dark:bg-white/10 dark:border-white/10 dark:border text-white text-sm hover:bg-earth-metal dark:hover:bg-white/20">
                                        Reveal
                                        <kbd
                                            class="hidden md:inline-block absolute right-3 top-1/2 -translate-y-1/2 text-[10px] px-1.5 py-0.5 rounded bg-white/20 font-medium">â£</kbd>
                                    </button>
                                    <div id="aiControls" class="hidden space-y-2">
                                        <textarea id="aiAnswer" rows="3" placeholder="Type your answer..."
                                            class="w-full rounded-lg border border-[color:var(--card-border)] bg-[color:var(--surface)] px-3 py-2 text-sm"></textarea>
                                        <div class="flex gap-2">
                                            <button id="aiRecord"
                                                class="relative p-2 pr-2 md:pr-8 rounded-lg bg-[color:var(--surface)] border border-[color:var(--card-border)] text-[color:var(--text-main)] text-sm flex flex-1 items-center justify-center"
                                                title="Record">
                                                <i data-lucide="mic" class="w-4 h-4"></i>
                                                <kbd id="micHotkey"
                                                    class="hidden md:inline-block absolute right-2 top-1/2 -translate-y-1/2 text-[10px] px-1 py-0.5 rounded bg-white/20 text-earth-metal/60"></kbd>
                                            </button>
                                            <button id="aiSubmit"
                                                class="px-3 py-2 rounded-lg bg-dull-purple text-white text-sm hover:bg-dull-purple-hover transition-all flex-1">
                                                Send <kbd id="aiSendHotkey"
                                                    class="hidden md:inline-block text-[10px] px-1.5 py-0.5 rounded bg-white/20 font-medium ml-1 font-sans"></kbd>
                                            </button>
                                        </div>
                                        <div id="aiFeedback"
                                            class="md-content hidden text-sm text-earth-metal/80 dark:text-white/70 bg-[var(--surface)] dark:bg-white/5 border border-oatmeal-dark/40 dark:border-white/10 rounded-lg p-2">
                                        </div>
                                    </div>
                                </div>
                                <div id="cardBack"
                                    class="md-content leading-relaxed text-[color:var(--text-sub)] hidden max-h-[40vh] md:max-h-[45vh] overflow-y-auto pr-1 scroll-minimal text-sm md:text-base">
                                </div>
                                <!-- Study controls (hidden when session complete) -->
                                <div id="studyControls">
                                    <div class="grid grid-cols-4 gap-1 md:gap-2">
                                        <button data-rate="Again" aria-label="Rate as Again (1)"
                                            class="rate-btn relative px-1 md:px-2 py-2 rounded-lg bg-red-100 border border-red-300 text-red-700 text-[10px] md:text-xs hover:bg-red-200 dark:bg-red-900/30 dark:border-red-700 dark:text-red-200 dark:hover:bg-red-900/50 flex items-center justify-center gap-1">
                                            <i data-lucide="refresh-cw" class="w-3 h-3"></i>
                                            <span>Again</span>
                                            <kbd
                                                class="hidden md:flex absolute -top-1.5 -right-1.5 w-4 h-4 items-center justify-center text-[8px] rounded bg-red-600 text-white font-medium shadow-sm">1</kbd>
                                        </button>
                                        <button data-rate="Hard" aria-label="Rate as Hard (2)"
                                            class="rate-btn relative px-1 md:px-2 py-2 rounded-lg bg-orange-100 border border-orange-300 text-orange-700 text-[10px] md:text-xs hover:bg-orange-200 dark:bg-orange-900/30 dark:border-orange-700 dark:text-orange-200 dark:hover:bg-orange-900/50 flex items-center justify-center gap-1">
                                            <i data-lucide="alert-triangle" class="w-3 h-3"></i>
                                            <span>Hard</span>
                                            <kbd
                                                class="hidden md:flex absolute -top-1.5 -right-1.5 w-4 h-4 items-center justify-center text-[8px] rounded bg-orange-500 text-white font-medium shadow-sm">2</kbd>
                                        </button>
                                        <button data-rate="Good" aria-label="Rate as Good (3)"
                                            class="rate-btn relative px-1 md:px-2 py-2 rounded-lg bg-green-100 border border-green-300 text-green-700 text-[10px] md:text-xs hover:bg-green-200 dark:bg-green-900/30 dark:border-green-700 dark:text-green-200 dark:hover:bg-green-900/50 flex items-center justify-center gap-1">
                                            <i data-lucide="thumbs-up" class="w-3 h-3"></i>
                                            <span>Good</span>
                                            <kbd
                                                class="hidden md:flex absolute -top-1.5 -right-1.5 w-4 h-4 items-center justify-center text-[8px] rounded bg-green-600 text-white font-medium shadow-sm">3</kbd>
                                        </button>
                                        <button data-rate="Easy" aria-label="Rate as Easy (4)"
                                            class="rate-btn relative px-1 md:px-2 py-2 rounded-lg bg-blue-100 border border-blue-300 text-blue-700 text-[10px] md:text-xs hover:bg-blue-200 dark:bg-blue-900/30 dark:border-blue-700 dark:text-blue-200 dark:hover:bg-blue-900/50 flex items-center justify-center gap-1">
                                            <i data-lucide="zap" class="w-3 h-3"></i>
                                            <span>Easy</span>
                                            <kbd
                                                class="hidden md:flex absolute -top-1.5 -right-1.5 w-4 h-4 items-center justify-center text-[8px] rounded bg-blue-600 text-white font-medium shadow-sm">4</kbd>
                                        </button>
                                    </div>
                                    <div class="text-[10px] md:text-[11px] text-earth-metal/70 flex justify-end mt-2">
                                        <button id="skipCard"
                                            class="px-2 py-1 rounded-lg border border-oatmeal-dark/50 text-dull-purple hover:bg-dull-purple/10 shrink-0 flex items-center gap-1">
                                            <i data-lucide="square-slash" class="w-3 h-3"></i>
                                            <span>Skip</span>
                                            <kbd id="skipHotkey"
                                                class="hidden md:inline text-[9px] ml-0.5 px-1 py-0.5 rounded bg-dull-purple/10 text-dull-purple font-medium">S</kbd>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </article>

                        <!-- Mobile FAB cluster - Joystick and action buttons (only visible on mobile) -->
                        <div id="mobileFabCluster" class="mobile-fab-cluster hidden">
                            <!-- Joystick wrapper with side actions -->
                            <div class="joystick-wrapper">
                                <!-- Arcade-style joystick for rating -->
                                <div id="joystickContainer" class="joystick-container hidden">
                                    <div id="joystick" class="joystick">
                                        <!-- Direction labels with filled icons -->
                                        <!-- Clockwise from bottom: Again (down) â†’ Hard (left) â†’ Good (up) â†’ Easy (right) -->
                                        <div class="joystick-label joystick-label-up">
                                            <i data-lucide="thumbs-up"></i>
                                        </div>
                                        <div class="joystick-label joystick-label-down">
                                            <i data-lucide="refresh-cw"></i>
                                        </div>
                                        <div class="joystick-label joystick-label-left">
                                            <i data-lucide="alert-triangle"></i>
                                        </div>
                                        <div class="joystick-label joystick-label-right">
                                            <i data-lucide="zap"></i>
                                        </div>
                                        <!-- The knob -->
                                        <div class="joystick-knob"></div>
                                    </div>
                                </div>

                                <!-- Side action buttons (next to joystick) -->
                                <div class="joystick-side-actions">
                                    <button id="fabAddNote" class="fab-btn fab-btn-secondary hidden" title="Add note">
                                        <i data-lucide="file-plus"></i>
                                    </button>
                                    <button id="fabCopy" class="fab-btn fab-btn-secondary hidden" title="Copy">
                                        <i data-lucide="clipboard"></i>
                                    </button>
                                    <button id="fabMic" class="fab-btn fab-btn-secondary hidden"
                                        title="Record (AI mode)">
                                        <i data-lucide="mic"></i>
                                    </button>
                                    <button id="fabSend" class="fab-btn fab-btn-secondary hidden"
                                        title="Send (AI mode)">
                                        <i data-lucide="send"></i>
                                    </button>
                                </div>
                            </div>

                            <!-- Pre-reveal actions -->
                            <div id="fabPreRevealActions" class="joystick-side-actions">
                                <button id="fabSkip" class="fab-btn fab-btn-secondary" title="Skip">
                                    <i data-lucide="square-slash"></i>
                                </button>
                                <button id="fabReveal" class="fab-btn fab-btn-primary" title="Reveal">
                                    <i data-lucide="eye"></i>
                                </button>
                            </div>
                        </div>

                        <!-- Notes Preview (below study card, no textarea) -->
                        <div id="notesSection"
                            class="rounded-lg border border-[color:var(--card-border)] p-3 md:p-4 bg-[color:var(--card-bg)] hidden">
                            <div class="flex items-center justify-between mb-2 md:mb-3">
                                <span class="font-semibold text-charcoal text-sm md:text-base">Notes</span>
                                <button id="editNotesBtn" class="p-1.5 rounded-lg hover:bg-oatmeal text-dull-purple"
                                    title="Edit notes">
                                    <i data-lucide="edit-2" class="w-4 h-4"></i>
                                </button>
                            </div>
                            <div id="notesPreview"
                                class="md-content prose prose-sm max-h-60 md:max-h-80 overflow-y-auto text-xs md:text-sm text-[color:var(--text-main)] scroll-minimal">
                                <p class="text-earth-metal/60 text-xs md:text-sm">No notes for this card</p>
                            </div>
                        </div>

                        <!-- Mobile bottom spacer to prevent joystick overlap -->
                        <div class="h-36 md:hidden" aria-hidden="true"></div>
                    </div>
                </div>
            </section>
        </main>
        <footer id="footerAttribution"
            class="hidden px-3 sm:px-5 md:px-10 pb-4 text-[11px] text-earth-metal/60 dark:text-white/60 text-center">
            Built by <a class="underline text-dull-purple dark:text-dull-purple" href="https://mimansajaiswal.github.io"
                target="_blank" rel="noopener noreferrer">Mimansa Jaiswal</a> Â· In the <a
                class="underline text-dull-purple dark:text-dull-purple" href="https://mimansajaiswal.github.io/tools/"
                target="_blank" rel="noopener noreferrer">Tools Made with LLMs</a> Â· Code: <a
                class="underline text-dull-purple dark:text-dull-purple"
                href="https://github.com/mimansajaiswal/tools/tree/main/ghostink-flashcards" target="_blank"
                rel="noopener noreferrer">ghostink-flashcards</a>
        </footer>
    </div>

    <div id="toast" role="status" aria-live="polite"
        class="fixed z-[110] bottom-6 right-6 px-4 py-3 rounded-lg bg-charcoal dark:bg-zinc-800 text-white text-sm shadow-soft hidden opacity-0 transition-opacity duration-300">
    </div>
    <div id="tooltip"
        class="fixed z-[120] px-2.5 py-1.5 rounded-lg text-xs bg-charcoal dark:bg-zinc-800 text-white shadow-soft pointer-events-none hidden">
    </div>

    <!-- Global loading overlay -->
    <div id="loadingOverlay"
        class="fixed inset-0 z-[130] bg-black/40 backdrop-blur-sm hidden items-center justify-center">
        <div class="flex flex-col items-center gap-3 text-white text-center px-6">
            <div class="h-12 w-12 border-4 border-white/30 border-t-white rounded-full animate-spin"></div>
            <p id="loadingMessage" class="text-sm font-medium">Loading...</p>
            <p class="text-xs text-white/80" id="loadingSubtext">Preparing your decks and cards.</p>
            <div id="loadingProgressWrap" class="w-full max-w-xs hidden">
                <div class="w-full h-2 bg-white/20 rounded-full overflow-hidden">
                    <div id="loadingProgressBar" class="h-2 bg-dull-purple w-0 transition-all duration-300"></div>
                </div>
                <p id="loadingProgressText" class="text-[11px] text-white/80 mt-1">0%</p>
            </div>
        </div>
    </div>

    <div id="confirmModal" role="dialog" aria-modal="true" aria-labelledby="confirmModalTitle"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div class="card rounded-2xl p-5 w-full max-w-sm shadow-soft">
            <p id="confirmModalTitle" class="text-charcoal dark:text-white font-display text-lg mb-2">Confirm delete</p>
            <p class="text-sm text-earth-metal/70 dark:text-white/70">This removes it locally and syncs deletion to
                Notion.</p>
            <div class="flex justify-end gap-2 mt-4">
                <button id="cancelDelete"
                    class="px-3 py-2 rounded-lg bg-white-linen border border-oatmeal-dark/70 text-earth-metal dark:text-white text-sm dark:bg-zinc-800 dark:border-white/10 dark:hover:bg-zinc-700">Cancel</button>
                <button id="confirmDelete"
                    class="px-3 py-2 rounded-lg bg-muted-pink text-white text-sm hover:bg-muted-pink-hover transition-all">Delete</button>
            </div>
        </div>
    </div>

    <!-- Reset Algorithm Confirmation Modal -->
    <div id="resetAlgorithmModal" role="dialog" aria-modal="true" aria-labelledby="resetAlgorithmTitle"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4 z-50">
        <div class="card rounded-2xl p-5 w-full max-w-md shadow-soft">
            <div class="flex items-center gap-3 mb-3">
                <div class="p-2 rounded-full bg-red-100 dark:bg-red-900/40">
                    <i data-lucide="alert-triangle" class="w-5 h-5 text-red-600"></i>
                </div>
                <h3 id="resetAlgorithmTitle" class="text-charcoal font-display text-lg">Reset Algorithm Parameters</h3>
            </div>
            <div class="space-y-3 text-sm text-earth-metal/80 dark:text-white/75">
                <p>This will reset <strong>all spaced repetition data</strong> for every card in <span
                        id="resetDeckName" class="font-semibold text-charcoal">this deck</span>:</p>
                <ul class="list-disc list-inside space-y-1 text-earth-metal/70 ml-2">
                    <li>Due dates will be cleared</li>
                    <li>Ease factors, intervals, and stability will reset</li>
                    <li>Review history will be preserved</li>
                    <li>Cards will appear as new again</li>
                </ul>
                <div
                    class="p-3 rounded-lg bg-amber-50 border border-amber-200 dark:bg-amber-900/30 dark:border-amber-600/60 flex items-start gap-2">
                    <i data-lucide="cloud-upload" class="w-4 h-4 text-amber-600 mt-0.5 shrink-0"></i>
                    <p class="text-amber-800 dark:text-amber-100 text-xs">These changes will be synced to Notion. This
                        action cannot be
                        undone.</p>
                </div>
                <div id="resetProgressContainer" class="hidden mt-4 space-y-1">
                    <div class="flex justify-between text-xs text-earth-metal/70 dark:text-white/70">
                        <span id="resetProgressText">Resetting...</span>
                        <span id="resetProgressPercent">0%</span>
                    </div>
                    <div class="h-1.5 bg-oatmeal-dark/30 dark:bg-white/10 rounded-full overflow-hidden">
                        <div id="resetProgressBar" class="h-full bg-red-500 transition-all duration-300"
                            style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="flex justify-end gap-2 mt-5">
                <button id="cancelResetAlgorithm"
                    class="px-4 py-2 rounded-lg bg-white-linen border border-oatmeal-dark/70 text-earth-metal text-sm hover:bg-oatmeal">Cancel</button>
                <button id="confirmResetAlgorithm"
                    class="px-4 py-2 rounded-lg bg-red-600 text-white text-sm hover:bg-red-700 flex items-center gap-2">
                    <i data-lucide="rotate-ccw" class="w-4 h-4"></i>
                    Reset All Cards
                </button>
            </div>
        </div>
    </div>

    <!-- Settings -->
    <div id="settingsModal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div id="settingsCard" class="card rounded-2xl p-5 w-full max-w-3xl shadow-soft max-h-[90vh] overflow-y-auto">
            <div class="sticky top-[-20px] pt-[20px] -mt-[20px] z-20 bg-[color:var(--surface)] pb-2 space-y-3">
                <div class="flex items-center justify-between">
                    <h3 id="settingsTitle" class="font-display text-lg text-charcoal">Settings</h3>
                    <div class="flex items-center gap-2">
                        <button id="saveSettings"
                            class="px-3 py-1.5 rounded-lg bg-dull-purple text-white text-sm hover:bg-dull-purple-hover transition-all disabled:opacity-60 disabled:cursor-not-allowed disabled:hover:bg-dull-purple">Save</button>
                        <button id="closeSettings" aria-label="Close settings"
                            class="text-earth-metal/60 hover:text-charcoal"><i data-lucide="x"
                                class="w-5 h-5"></i></button>
                    </div>
                </div>
                <!-- Combined Sticky Header: Status + Vault -->
                <div class="space-y-3">
                    <!-- Status bar -->
                    <div
                        class="rounded-lg border border-oatmeal-dark/60 dark:border-white/10 p-3 bg-[color:var(--surface-strong)]">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center gap-2">
                                <i data-lucide="shield-check"
                                    class="w-4 h-4 text-dull-purple dark:text-dull-purple"></i>
                                <p class="font-semibold text-charcoal dark:text-white text-sm">Status</p>
                            </div>
                            <div id="q2syncIndicator"
                                class="hidden items-center gap-1.5 px-2 py-0.5 rounded bg-dull-purple/10 border border-dull-purple/20">
                                <span class="relative flex h-1.5 w-1.5">
                                    <span
                                        class="animate-ping absolute inline-flex h-full w-full rounded-full bg-[color:var(--dull-purple)] opacity-75"></span>
                                    <span
                                        class="relative inline-flex rounded-full h-1.5 w-1.5 bg-[color:var(--dull-purple)]"></span>
                                </span>
                                <span class="font-mono text-[10px] font-medium text-dull-purple"><span
                                        id="q2syncCount">0</span> items in q2sync</span>
                            </div>
                        </div>
                        <div class="flex flex-wrap gap-4 text-xs text-earth-metal/80 dark:text-white/70">
                            <span id="statusWorker">Worker: missing</span>
                            <span id="statusAuth">Auth: missing</span>
                            <span id="statusSources">Sources: missing</span>
                        </div>
                    </div>
                    <!-- Offline vault (shown only when setup) -->
                    <div id="vaultStatusSection" class="hidden">
                        <div
                            class="rounded-lg border border-oatmeal-dark/60 dark:border-white/10 p-3 bg-white-linen dark:bg-white/5">
                            <div class="flex items-center gap-2">
                                <i data-lucide="database" class="w-4 h-4 text-dull-purple dark:text-dull-purple"></i>
                                <p class="font-semibold text-charcoal dark:text-white text-sm">Offline vault</p>
                            </div>
                            <div class="mt-3 grid grid-cols-2 gap-3 text-sm">
                                <div class="rounded-lg bg-oatmeal dark:bg-white/10 p-3">
                                    <p
                                        class="text-earth-metal/60 dark:text-white/60 text-[10px] uppercase tracking-wider font-semibold">
                                        Decks cached</p>
                                    <p id="deckCount" class="text-xl font-semibold text-charcoal dark:text-white">0</p>
                                </div>
                                <div class="rounded-lg bg-oatmeal dark:bg-white/10 p-3">
                                    <p
                                        class="text-earth-metal/60 dark:text-white/60 text-[10px] uppercase tracking-wider font-semibold">
                                        Cards cached</p>
                                    <p id="cardCount" class="text-xl font-semibold text-charcoal dark:text-white">0</p>
                                </div>
                                <div
                                    class="rounded-lg bg-white-linen dark:bg-white/10 p-3 border border-oatmeal-dark/40">
                                    <p
                                        class="text-earth-metal/60 dark:text-white/60 text-[10px] uppercase tracking-wider font-semibold">
                                        Pending sync</p>
                                    <p id="queueCount" class="text-xl font-semibold text-charcoal dark:text-white">0</p>
                                </div>
                                <div
                                    class="rounded-lg bg-white-linen dark:bg-white/10 p-3 border border-oatmeal-dark/40">
                                    <p
                                        class="text-earth-metal/60 dark:text-white/60 text-[10px] uppercase tracking-wider font-semibold">
                                        Last sync</p>
                                    <p id="lastSync"
                                        class="text-sm font-semibold text-charcoal dark:text-white truncate mt-1">â€”</p>
                                </div>
                            </div>
                            <p class="mt-3 text-[10px] text-earth-metal/60 dark:text-white/60">IndexedDB holds all
                                decks/cards/FSRS/notes for offline-first use.</p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="grid md:grid-cols-2 gap-6 text-sm mt-4">
                <div class="space-y-4">
                    <div
                        class="rounded-lg border border-oatmeal-dark/60 dark:border-white/10 p-3 bg-white-linen dark:bg-white/5">
                        <div class="flex items-center justify-between">
                            <p class="font-semibold text-charcoal dark:text-white">Worker proxy</p>
                            <button id="openWorkerHelp"
                                class="px-3 py-1.5 rounded-full bg-oatmeal text-earth-metal text-xs border border-oatmeal-dark/70 flex items-center gap-2">
                                <i data-lucide="code" class="w-4 h-4"></i> Worker code
                            </button>
                        </div>
                        <p class="text-xs text-earth-metal/70 dark:text-white/70 mt-1">Add Cloudflare Worker URL even if
                            you plan to sign
                            in with Notion.</p>
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/70">Cloudflare Worker URL</label>
                        <input id="settingWorkerUrl" type="text" placeholder="https://your-proxy.workers.dev"
                            class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/70">Proxy token (optional)</label>
                        <input id="settingProxyToken" type="password" placeholder="ALL_CORS_PROXY_MATCH_TOKEN"
                            class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                    </div>
                    <button id="verifyWorker"
                        class="px-3 py-2 rounded-lg bg-oatmeal text-earth-metal text-sm border border-oatmeal-dark/70 w-full">Verify
                        worker</button>
                    <div>
                        <label class="text-xs text-earth-metal/70">Notion integration secret (instead of OAuth)</label>
                        <input id="settingAuthToken" type="password" placeholder="secret_..."
                            class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 disabled:opacity-60 disabled:cursor-not-allowed">
                    </div>
                    <button id="verifyAuth"
                        class="px-3 py-2 rounded-lg bg-oatmeal text-earth-metal text-sm border border-oatmeal-dark/70 w-full disabled:opacity-60 disabled:cursor-not-allowed">Verify
                        Notion token</button>
                    <button id="oauthBtn"
                        class="w-full px-3 py-2 rounded-lg border border-dull-purple text-dull-purple text-sm hover:bg-oatmeal flex items-center gap-2 justify-center disabled:opacity-60 disabled:cursor-not-allowed">
                        <i data-lucide="log-in" class="w-4 h-4"></i>Sign in with Notion
                    </button>
                    <div>
                        <label class="text-xs text-earth-metal/60">Decks source</label>
                        <select id="deckSourceSelect" disabled
                            class="w-full rounded-lg border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm disabled:opacity-60 disabled:cursor-not-allowed"></select>
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/60">Cards source</label>
                        <select id="cardSourceSelect" disabled
                            class="w-full rounded-lg border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm disabled:opacity-60 disabled:cursor-not-allowed"></select>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2">
                        <button id="scanSources" disabled
                            class="px-3 py-2 rounded-lg bg-charcoal dark:bg-white/10 dark:border-white/10 dark:border text-white text-sm hover:bg-earth-metal dark:hover:bg-white/20 flex-1 min-w-[140px] disabled:opacity-60 disabled:cursor-not-allowed disabled:hover:bg-charcoal">Scan
                            sources</button>
                        <button id="saveSourcesChoice" disabled
                            class="px-3 py-2 rounded-lg bg-dull-purple text-white text-sm hover:bg-dull-purple-hover transition-all flex-1 min-w-[140px] disabled:opacity-60 disabled:cursor-not-allowed">Save
                            sources choice</button>
                    </div>
                    <div class="w-full h-2 bg-oatmeal rounded-full overflow-hidden">
                        <div id="syncProgress" class="h-2 bg-dull-purple w-0 transition-all duration-500"></div>
                    </div>
                </div>
                <div class="space-y-4">
                    <div
                        class="sm:hidden rounded-lg border border-oatmeal-dark/60 dark:border-white/10 p-3 bg-white-linen dark:bg-white/5">
                        <div class="flex items-center justify-between gap-2 mb-2">
                            <div class="flex items-center gap-2">
                                <i data-lucide="smartphone" class="w-4 h-4 text-dull-purple dark:text-dull-purple"></i>
                                <p class="font-semibold text-charcoal dark:text-white">Mobile layout</p>
                            </div>
                        </div>
                        <p class="text-[11px] text-earth-metal/60 dark:text-white/60">Choose where the study
                            joystick/action cluster should appear on mobile screens.</p>
                        <div class="mt-3 space-y-2">
                            <label class="flex items-center gap-2 text-xs text-earth-metal/70 dark:text-white/70">
                                <input id="fabEnabledToggle" type="checkbox" class="accent-dull-purple" checked>
                                <span>Enable mobile FAB controls</span>
                            </label>
                            <div id="fabPosControls" class="space-y-2">
                                <label class="text-xs text-earth-metal/70 dark:text-white/70">FAB position
                                    (grid)</label>
                                <div class="flex items-center gap-2">
                                    <select id="fabPosCellSelect"
                                        class="flex-1 rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm">
                                        <option value="1">1</option>
                                        <option value="2">2</option>
                                        <option value="3">3</option>
                                        <option value="4">4</option>
                                        <option value="5">5</option>
                                        <option value="6">6</option>
                                        <option value="7">7</option>
                                        <option value="8">8</option>
                                        <option value="9">9</option>
                                        <option value="10">10</option>
                                        <option value="11">11</option>
                                        <option value="12">12</option>
                                        <option value="13">13</option>
                                        <option value="14">14</option>
                                        <option value="15">15</option>
                                        <option value="16">16</option>
                                        <option value="17">17</option>
                                        <option value="18">18</option>
                                        <option value="19">19</option>
                                        <option value="20">20</option>
                                        <option value="21">21</option>
                                        <option value="22">22</option>
                                        <option value="23">23</option>
                                        <option value="24">24</option>
                                    </select>
                                    <span
                                        class="text-[10px] text-earth-metal/60 dark:text-white/60 whitespace-nowrap">6Ã—4</span>
                                </div>
                                <pre id="fabGridAscii"
                                    class="font-mono text-[8px] leading-[1.05] text-earth-metal/60 dark:text-white/60 bg-oatmeal/60 dark:bg-white/10 border border-oatmeal-dark/40 dark:border-white/10 rounded-lg p-2 overflow-hidden whitespace-pre"></pre>
                                <p class="text-[10px] text-earth-metal/60 dark:text-white/60">Pick a number from the 6Ã—4
                                    grid
                                    (1 = top-left, 24 = bottom-right). Applies on screens â‰¤ 640px wide.</p>
                            </div>
                        </div>
                    </div>
                    <div
                        class="rounded-lg border border-oatmeal-dark/60 dark:border-white/10 p-3 bg-white-linen dark:bg-white/5">
                        <div class="flex items-center gap-2 mb-2">
                            <i data-lucide="bot" class="w-4 h-4 text-dull-purple dark:text-dull-purple"></i>
                            <p class="font-semibold text-charcoal dark:text-white">AI judge settings</p>
                        </div>
                        <div class="space-y-2">
                            <div>
                                <label class="text-xs text-earth-metal/70">Provider</label>
                                <select id="aiProvider"
                                    class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm">
                                    <option value="">Disabled</option>
                                    <option value="openai">OpenAI</option>
                                    <option value="anthropic">Claude</option>
                                    <option value="gemini">Gemini</option>
                                </select>
                            </div>
                            <div id="aiProviderFields" class="space-y-2 hidden">
                                <div>
                                    <label class="text-xs text-earth-metal/70">Model</label>
                                    <input id="aiModel" type="text"
                                        placeholder="gpt-4o-mini / claude-3-haiku / gemini-1.5-flash"
                                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm">
                                </div>
                                <input id="aiKey" type="password" placeholder="API key (kept locally)"
                                    class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm">
                                <button id="verifyAi" data-tip="Requires internet"
                                    class="px-3 py-2 rounded-lg bg-oatmeal text-earth-metal text-sm border border-oatmeal-dark/70 w-full">Verify
                                    AI settings</button>
                                <p class="text-[11px] text-earth-metal/60">Keys stay on-device (localStorage). AI
                                    judging
                                    only runs if verified.</p>
                            </div>
                        </div>
                    </div>
                    <!-- Speech-to-Text Settings (only shown when AI mode is enabled) -->
                    <div id="sttSettings" class="rounded-lg border border-oatmeal-dark/60 p-3 bg-white-linen hidden">
                        <div class="flex items-center gap-2 mb-2">
                            <i data-lucide="mic" class="w-4 h-4 text-dull-purple"></i>
                            <p class="font-semibold text-charcoal">Speech-to-text</p>
                        </div>
                        <div class="space-y-2">
                            <div>
                                <label class="text-xs text-earth-metal/70">Provider</label>
                                <select id="sttProvider"
                                    class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm">
                                    <option value="">Disabled</option>
                                    <option value="browser">Browser</option>
                                    <option value="openai">OpenAI Whisper</option>
                                    <option value="gemini">Gemini</option>
                                    <option value="groq">Groq Whisper</option>
                                </select>
                            </div>
                            <div id="sttProviderFields" class="space-y-2 hidden">
                                <div>
                                    <label class="text-xs text-earth-metal/70">Model</label>
                                    <input id="sttModel" type="text" placeholder="whisper-1 / gemini-2.0-flash"
                                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm">
                                </div>
                                <input id="sttKey" type="password" placeholder="API key (required for cloud providers)"
                                    class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm">
                                <div>
                                    <label class="text-xs text-earth-metal/70">Starter prompt (optional context)</label>
                                    <input id="sttPrompt" type="text" placeholder="e.g., Technical terms, names..."
                                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm mt-1">
                                </div>
                                <button id="verifyStt" data-tip="Requires internet"
                                    class="px-3 py-2 rounded-lg bg-oatmeal text-earth-metal text-sm border border-oatmeal-dark/70 w-full">Verify
                                    STT settings</button>
                            </div>
                            <p class="text-[11px] text-earth-metal/60">Browser uses free built-in speech recognition.
                                Cloud providers offer better accuracy.</p>
                        </div>
                    </div>
                </div>
                <!-- Danger Zone spanning both columns -->
                <div class="md:col-span-2 mt-4 border-t border-oatmeal-dark/40 dark:border-white/10 pt-4">
                    <button id="toggleDangerZone"
                        class="w-full flex items-center justify-between text-sm text-muted-pink dark:text-muted-pink/80 hover:text-muted-pink/80 transition">
                        <span class="flex items-center gap-2">
                            <i data-lucide="alert-triangle" class="w-4 h-4"></i>
                            <span>Danger Zone</span>
                        </span>
                        <i data-lucide="chevron-down" id="dangerZoneChevron" class="w-4 h-4 transition-transform"></i>
                    </button>
                    <div id="dangerZoneContent"
                        class="hidden mt-3 p-3 rounded-lg bg-muted-pink/10 border border-muted-pink/30 dark:bg-muted-pink/15 dark:border-muted-pink/40">
                        <p class="text-xs text-earth-metal/70 dark:text-white/70 mb-3">This will permanently delete
                            all GhostInk data
                            including decks, cards, settings, and session data. Data synced to Notion will not be
                            affected.</p>
                        <button id="resetApp"
                            class="px-3 py-2 rounded-lg bg-muted-pink text-white text-sm hover:bg-muted-pink-hover transition-all w-full">Reset
                            GhostInk</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Worker helper -->
    <div id="workerHelpModal" class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div class="card rounded-2xl p-5 w-full max-w-3xl shadow-soft h-[80vh] flex flex-col">
            <div class="flex items-center justify-between mb-3">
                <h3 class="font-display text-lg text-charcoal">Cloudflare Worker proxy</h3>
                <button id="closeWorkerHelp" class="text-earth-metal/60 hover:text-charcoal"><i data-lucide="x"
                        class="w-5 h-5"></i></button>
            </div>
            <div class="flex-1 overflow-y-auto space-y-3 text-sm text-earth-metal">
                <p>Deploy this Worker to bypass CORS and forward Notion requests.</p>
                <ol class="list-decimal pl-6 space-y-2">
                    <li>Open <a class="text-dull-purple underline" href="https://workers.cloudflare.com/"
                            target="_blank">Cloudflare Workers</a> and create a new Worker.</li>
                    <li>Replace its contents with the code below, save, and deploy.</li>
                    <li>(Optional) Add variable <code>ALL_CORS_PROXY_MATCH_TOKEN</code> to require a token.</li>
                    <li>Paste the Worker URL into Settings.</li>
                </ol>
                <div class="relative">
                    <button id="copyWorkerCode"
                        class="absolute top-2 right-2 bg-white/80 hover:bg-white px-2 py-1 rounded text-xs shadow text-charcoal font-bold dark:bg-white/10 dark:hover:bg-white/20 dark:text-white">Copy</button>
                    <pre id="workerCodeBlock"
                        class="bg-charcoal text-white-linen p-4 rounded text-xs font-mono overflow-x-auto">
const NOTION_API_END_POINT = "https://api.notion.com/v1";

export default {
  async fetch(request, env) {
    return await handleRequest(request, env);
  }
};

function corsHeaders(request) {
  return {
    "Access-Control-Allow-Origin": request.headers.get("Origin") || "*",
    "Access-Control-Allow-Methods": "GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization, Notion-Version",
  };
}

function handleOptions(request) {
  return new Response(null, { headers: corsHeaders(request) });
}

async function handleRequest(request, env) {
  if (request.method === "OPTIONS") return handleOptions(request);

  const url = new URL(request.url);
  const requiredToken = (env.ALL_CORS_PROXY_MATCH_TOKEN || "").trim();
  if (requiredToken) {
    const provided = url.searchParams.get("token");
    if (provided !== requiredToken) return new Response("Unauthorized", { status: 403 });
    url.searchParams.delete("token");
  }

  const isGeneral = url.searchParams.has("url");
  let targetUrl;
  if (isGeneral) {
    targetUrl = url.searchParams.get("url");
    url.searchParams.delete("url");
    try { targetUrl = new URL(targetUrl).toString(); } catch (err) { return new Response("Invalid target URL", { status: 400 }); }
  } else {
    const secretKey = url.searchParams.get("secret");
    if (!secretKey) return new Response("Missing secret key parameter", { status: 400 });
    url.searchParams.delete("secret");
    const base = NOTION_API_END_POINT.replace(/\/$/, "");
    const path = url.pathname.startsWith("/") ? url.pathname : "/" + url.pathname;
    targetUrl = base + path + url.search;
    request = new Request(targetUrl, request);
    request.headers.set("Authorization", `Bearer ${secretKey}`);
	    request.headers.set("Notion-Version", "2025-09-03");
  }

  const proxied = new Request(targetUrl, request);
  proxied.headers.set("Origin", new URL(targetUrl).origin);

  const response = await fetch(proxied);
  const out = new Response(response.body, response);
  out.headers.set("Access-Control-Allow-Origin", request.headers.get("Origin") || "*");
  out.headers.append("Vary", "Origin");
  return out;
}
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Deck modal -->
    <div id="deckModal" role="dialog" aria-modal="true" aria-labelledby="deckModalTitle"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div class="card rounded-2xl p-5 w-full max-w-md shadow-soft">
            <div class="flex items-center justify-between mb-3">
                <h3 class="font-display text-lg text-charcoal" id="deckModalTitle">New deck</h3>
                <button id="closeDeckModal" aria-label="Close deck modal"
                    class="text-earth-metal/60 hover:text-charcoal"><i data-lucide="x" class="w-5 h-5"></i></button>
            </div>
            <div class="space-y-3 text-sm">
                <input id="deckNameInput" type="text" placeholder="Deck name"
                    class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                <div>
                    <label class="text-xs text-earth-metal/70">Algorithm</label>
                    <select id="deckAlgoInput"
                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                        <option>SM-2</option>
                        <option>FSRS</option>
                    </select>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="text-xs text-earth-metal/70">Daily review limit</label>
                        <input id="deckReviewLimit" type="number"
                            class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"
                            value="50">
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/70">New card limit</label>
                        <input id="deckNewLimit" type="number"
                            class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"
                            value="20">
                    </div>
                </div>
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Order mode</label>
                    <select id="deckOrderMode"
                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                        <option value="none">None (shuffle)</option>
                        <option value="created">Created Time</option>
                        <option value="property">Order Property</option>
                    </select>
                    <p class="text-[11px] text-earth-metal/60">Created time sorts by insertion time; Order property
                        sorts by each cardâ€™s â€œOrderâ€ number.</p>
                </div>
                <label class="flex items-center gap-2 text-sm">
                    <input id="deckReverseInput" type="checkbox" class="accent-dull-purple">
                    <span>Reverse mode enabled</span>
                </label>
                <div>
                    <label class="text-xs text-earth-metal/70">AI revision prompt (optional)</label>
                    <textarea id="deckPromptInput" rows="3"
                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"
                        placeholder="Use {{question}} {{answer}} {{user}} placeholders"></textarea>
                    <div class="flex flex-wrap gap-2 mt-2 text-[11px] text-earth-metal/60 dark:text-white/70">
                        <span
                            class="px-2 py-1 rounded-lg bg-oatmeal-dark/50 dark:bg-white/10 italic text-dull-purple dark:text-dull-purple">{{question}}</span>
                        <span
                            class="px-2 py-1 rounded-lg bg-oatmeal-dark/50 dark:bg-white/10 italic text-dull-purple dark:text-dull-purple">{{answer}}</span>
                        <span
                            class="px-2 py-1 rounded-lg bg-oatmeal-dark/50 dark:bg-white/10 italic text-dull-purple dark:text-dull-purple">{{user}}</span>
                        <span
                            class="px-2 py-1 rounded-lg bg-oatmeal-dark/50 dark:bg-white/10 text-earth-metal/70 dark:text-white/70">Variables
                            replace
                            question, correct answer, and learner answer.</span>
                    </div>
                </div>
                <div id="fsrsParamsField" class="hidden">
                    <div class="grid grid-cols-2 gap-3 items-end">
                        <div>
                            <label class="text-xs text-earth-metal/70">FSRS desired retention</label>
                            <input id="deckFsrsDesiredRetention" type="number" step="0.01" min="0.01" max="0.99"
                                class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-xs font-mono"
                                placeholder="0.90">
                        </div>
                    </div>
                    <label class="text-xs text-earth-metal/70 mt-2 block">FSRS v6 weights (21 numbers)</label>
                    <textarea id="deckFsrsParams" rows="2"
                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-xs font-mono"
                        placeholder="0.212, 1.2931, ..."></textarea>
                    <div class="flex items-center justify-between gap-2 mt-2">
                        <button id="optimizeFsrsBtn"
                            class="px-3 py-2 rounded-lg border border-earth-metal/40 text-earth-metal text-xs hover:bg-oatmeal/50 dark:hover:bg-white/10">
                            Optimize FSRS weights
                        </button>
                        <span class="text-[10px] text-earth-metal/60">Uses this deckâ€™s review history</span>
                    </div>
                    <p class="text-[10px] text-earth-metal/60 mt-1">Leave retention empty to use 0.90. Leave weights
                        empty to use defaults. These also sync via the Notion â€œFSRS Paramsâ€ property (rich_text).</p>
                </div>
            </div>
            <div class="flex justify-end gap-2 mt-4">
                <button id="archiveDeckBtn"
                    class="px-3 py-2 rounded-lg border border-earth-metal/40 text-earth-metal text-sm hidden">Archive
                    deck</button>
                <button id="saveDeckBtn"
                    class="px-4 py-2 rounded-lg bg-dull-purple text-white text-sm hover:bg-dull-purple-hover transition-all">Save</button>
            </div>
        </div>
    </div>

    <!-- Card modal -->
    <div id="cardModal" role="dialog" aria-modal="true" aria-labelledby="cardModalTitle"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4 z-50">
        <div class="card rounded-2xl p-5 w-full max-w-2xl shadow-soft max-h-[90vh] overflow-y-auto">
            <div class="flex items-center justify-between mb-3">
                <h3 class="font-display text-lg text-charcoal" id="cardModalTitle">New card</h3>
                <button id="closeCardModal" aria-label="Close card modal"
                    class="text-earth-metal/60 hover:text-charcoal"><i data-lucide="x" class="w-5 h-5"></i></button>
            </div>
            <p class="text-[10px] text-earth-metal/50 dark:text-white/60 mb-2">Editing Name, Back, or Notes will remove
                Notion text colors
                and highlights on sync</p>
            <div class="grid md:grid-cols-2 gap-4 text-sm">
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Deck</label>
                    <select id="cardDeckInput"
                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"></select>
                </div>
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Card type</label>
                    <select id="cardTypeInput"
                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                        <option value="Front-Back">Front / Back</option>
                        <option value="Cloze">Cloze</option>
                    </select>
                </div>
                <div class="md:col-span-2 space-y-2">
                    <label class="text-xs text-earth-metal/70">Name</label>
                    <textarea id="cardNameInput" rows="3"
                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"></textarea>
                </div>
                <div id="cardBackSection" class="md:col-span-2 space-y-2">
                    <label class="text-xs text-earth-metal/70">Back</label>
                    <textarea id="cardBackInput" rows="4"
                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"></textarea>
                </div>
                <div class="md:col-span-2 space-y-2">
                    <label class="text-xs text-earth-metal/70">Notes (markdown)</label>
                    <textarea id="cardNotesInput" rows="3" placeholder="Add notes for this card..."
                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"></textarea>
                </div>
                <div class="space-y-2">
                    <div class="flex items-center justify-between">
                        <label class="text-xs text-earth-metal/70">Tags</label>
                        <button id="refreshTagOptionsBtn" class="p-1 rounded-lg hover:bg-oatmeal text-dull-purple"
                            title="Refresh tags from Notion">
                            <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                        </button>
                    </div>
                    <div class="relative">
                        <input id="cardTagSearch" type="text" placeholder="Search or add tag"
                            class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm">
                        <div id="cardTagDropdown"
                            class="hidden absolute left-0 right-0 z-40 mt-1 max-h-44 overflow-y-auto rounded-lg border border-oatmeal-dark/60 bg-[color:var(--card-bg)] shadow-lg">
                        </div>
                    </div>
                    <div id="cardTagSelected" class="flex flex-wrap gap-1.5 mt-1"></div>
                </div>
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Order</label>
                    <input id="cardOrderInput" type="number" placeholder="Optional number"
                        class="w-full rounded-lg border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                </div>
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Suspended / Leech</label>
                    <div class="grid grid-cols-2 gap-2">
                        <label class="flex items-center gap-2"><input id="cardSuspendedInput" type="checkbox"
                                class="accent-dull-purple"> Suspended</label>
                        <label class="flex items-center gap-2"><input id="cardLeechInput" type="checkbox"
                                class="accent-dull-purple"> Leech</label>
                    </div>
                </div>
            </div>
            <!-- Review History Section (shown when editing existing card) -->
            <div id="cardReviewHistorySection" class="mt-4 hidden">
                <details class="group">
                    <summary class="text-xs text-earth-metal/70 cursor-pointer select-none flex items-center gap-1">
                        <i data-lucide="chevron-right" class="w-3 h-3 group-open:rotate-90 transition-transform"></i>
                        Review History (<span id="cardReviewHistoryCount">0</span>)
                    </summary>
                    <div id="cardReviewHistoryTable"
                        class="mt-2 max-h-40 overflow-y-auto border border-charcoal/10 rounded-lg"></div>
                </details>
            </div>
            <div class="flex justify-end gap-2 mt-4">
                <button id="deleteCardBtn"
                    class="px-3 py-2 rounded-lg border border-muted-pink text-muted-pink text-sm hidden">Delete
                    card</button>
                <button id="saveCardBtn"
                    class="px-4 py-2 rounded-lg bg-charcoal dark:bg-white/10 dark:border-white/10 dark:border text-white text-sm hover:bg-earth-metal dark:hover:bg-white/20">Save</button>
            </div>
        </div>
    </div>

    <!-- AI Settings Required Modal -->
    <div id="aiSettingsRequiredModal"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4 z-50">
        <div
            class="card rounded-2xl p-5 w-full max-w-md shadow-soft text-center space-y-4 bg-[color:var(--card-bg)] border border-[color:var(--card-border)]">
            <div class="w-12 h-12 rounded-full bg-dull-purple/20 flex items-center justify-center mx-auto">
                <i data-lucide="bot" class="w-6 h-6 text-dull-purple"></i>
            </div>
            <h3 id="aiSettingsModalTitle" class="font-display text-lg text-charcoal dark:text-white">AI not available
            </h3>
            <p id="aiSettingsModalBody" class="text-sm text-earth-metal/70 dark:text-white/70"></p>
            <div id="aiSettingsModalActions" class="flex gap-2 justify-center">
                <button id="closeAiSettingsModal"
                    class="px-4 py-2 rounded-lg border border-oatmeal-dark text-earth-metal dark:text-white dark:border-white/10 text-sm">Close</button>
                <button id="openSettingsFromAiModal"
                    class="px-4 py-2 rounded-lg bg-dull-purple text-white text-sm hover:bg-dull-purple-hover transition-all">Open
                    Settings</button>
            </div>
        </div>
    </div>

    <!-- Notes Edit Modal -->
    <div id="notesModal" role="dialog" aria-modal="true" aria-labelledby="notesModalTitle"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4 z-50">
        <div class="card rounded-2xl p-5 w-full max-w-lg shadow-soft space-y-4 max-h-[90vh] flex flex-col">
            <div class="flex items-center justify-between">
                <h3 id="notesModalTitle" class="font-display text-lg text-charcoal">Edit Notes</h3>
                <button id="closeNotesModal" aria-label="Close notes modal"
                    class="p-1.5 rounded-lg hover:bg-oatmeal text-earth-metal">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            <p class="text-xs text-earth-metal/70 dark:text-white/70">Write notes in Markdown format. They will be
                synced to Notion.</p>
            <textarea id="notesArea" rows="12"
                class="flex-1 w-full rounded-lg border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm font-mono resize-none focus:outline-none focus:ring-2 focus:ring-dull-purple/40"
                placeholder="Add notes for this card..."></textarea>
            <div class="flex items-center justify-between">
                <span id="noteStatus" class="text-xs text-earth-metal/60"></span>
                <div class="flex gap-2">
                    <button id="cancelNotesBtn"
                        class="px-4 py-2 rounded-lg border border-oatmeal-dark text-earth-metal text-sm">Cancel</button>
                    <button id="saveNotesBtn"
                        class="px-4 py-2 rounded-lg bg-dull-purple text-white text-sm hover:bg-dull-purple-hover transition-all">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Reset Confirmation Modal -->
    <div id="resetConfirmModal"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4 z-50">
        <div class="card rounded-2xl p-5 w-full max-w-sm shadow-soft">
            <div class="flex items-center gap-3 mb-3">
                <div class="p-2 rounded-full bg-muted-pink/20">
                    <i data-lucide="alert-triangle" class="w-5 h-5 text-muted-pink"></i>
                </div>
                <h3 class="font-display text-lg text-charcoal">Reset GhostInk?</h3>
            </div>
            <p class="text-sm text-earth-metal/70 dark:text-white/70 mb-4">This will permanently delete all local data
                including decks,
                cards, settings, and study session. This cannot be undone.</p>
            <div class="flex justify-end gap-2">
                <button id="cancelReset"
                    class="px-4 py-2 rounded-lg border border-oatmeal-dark text-earth-metal dark:text-white dark:border-white/10 dark:hover:bg-zinc-800 text-sm">Cancel</button>
                <button id="confirmReset"
                    class="px-4 py-2 rounded-lg bg-muted-pink text-white text-sm hover:bg-muted-pink-hover transition-all">Reset</button>
            </div>
        </div>
    </div>

    <!-- Add Block Note Modal -->
    <div id="addBlockModal"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4 z-50">
        <div class="card rounded-2xl p-5 w-full max-w-lg shadow-soft space-y-4 max-h-[90vh] flex flex-col">
            <div class="flex items-center justify-between">
                <h3 class="font-display text-lg text-charcoal">Add Note to Page</h3>
                <button id="closeAddBlockModal" class="p-1.5 rounded-lg hover:bg-oatmeal text-earth-metal">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            <p class="text-xs text-earth-metal/70 dark:text-white/70">This will be appended as a new paragraph on the
                Notion page with a
                timestamp.</p>
            <textarea id="blockNoteArea" rows="8"
                class="flex-1 w-full rounded-lg border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm font-mono resize-none focus:outline-none focus:ring-2 focus:ring-dull-purple/40"
                placeholder="Write in Markdown..."></textarea>
            <div
                class="rounded-lg border border-[color:var(--card-border)] p-3 bg-[color:var(--surface)] dark:bg-white/5">
                <div class="flex items-center justify-between mb-2">
                    <span class="text-xs font-semibold text-charcoal dark:text-white">Preview</span>
                    <span class="text-[11px] text-earth-metal/60 dark:text-white/60">Timestamp added on save</span>
                </div>
                <div id="blockNotePreview"
                    class="md-content text-xs text-[color:var(--text-main)] max-h-40 overflow-y-auto scroll-minimal">
                    <p class="text-earth-metal/50 dark:text-white/60">Type a note to preview media embeds.</p>
                </div>
            </div>
            <div class="flex items-center justify-end gap-2">
                <button id="cancelAddBlockBtn"
                    class="px-4 py-2 rounded-lg border border-oatmeal-dark text-earth-metal text-sm">Cancel</button>
                <button id="saveAddBlockBtn"
                    class="px-4 py-2 rounded-lg bg-dull-purple text-white text-sm hover:bg-dull-purple-hover transition-all">Add
                    to
                    Page</button>
            </div>
        </div>
    </div>

    <script>
        // Configure marked to open all links in new tab
        const renderer = new marked.Renderer();
        const originalLinkRenderer = renderer.link.bind(renderer);
        renderer.link = (href, title, text) => {
            const html = originalLinkRenderer(href, title, text);
            return html.replace('<a ', '<a target="_blank" rel="noopener noreferrer" ');
        };
        marked.setOptions({ renderer });

        const el = (sel) => document.querySelector(sel);
        const isMac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
        const encodeDataAttr = (value) => encodeURIComponent((value ?? '').toString());
        const decodeDataAttr = (value) => {
            try { return decodeURIComponent((value ?? '').toString()); } catch { return (value ?? '').toString(); }
        };
        const escapeHtml = (str) => {
            if (!str) return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        };

        const MEDIA_IMAGE_EXTS = new Set(['png', 'jpg', 'jpeg', 'gif', 'webp', 'avif', 'svg']);
        const MEDIA_VIDEO_EXTS = new Set(['mp4', 'webm', 'ogg', 'mov', 'm4v']);
        const safeUrl = (raw) => {
            try {
                const u = new URL(raw);
                if (!['http:', 'https:'].includes(u.protocol)) return null;
                return u;
            } catch (_) {
                return null;
            }
        };
        const stripUrlPunctuation = (s) => {
            // Common trailing punctuation when URLs appear at end of sentences.
            return (s || '').replace(/[)\].,!?:;]+$/g, '');
        };
        const getMediaInfo = (rawUrl) => {
            const cleaned = stripUrlPunctuation(rawUrl);
            const u = safeUrl(cleaned);
            if (!u) return null;
            const host = u.hostname.toLowerCase();
            const path = u.pathname || '';
            const ext = (path.split('.').pop() || '').toLowerCase();

            if (MEDIA_IMAGE_EXTS.has(ext)) return { kind: 'image', src: u.toString() };
            if (MEDIA_VIDEO_EXTS.has(ext)) return { kind: 'video', src: u.toString(), ext };

            // YouTube
            if (host === 'youtu.be') {
                const id = path.replace(/^\/+/, '').split('/')[0];
                if (id) return { kind: 'youtube', src: `https://www.youtube.com/embed/${encodeURIComponent(id)}?enablejsapi=1` };
            }
            if (host.includes('youtube.com')) {
                if (path.startsWith('/watch')) {
                    const id = u.searchParams.get('v');
                    if (id) return { kind: 'youtube', src: `https://www.youtube.com/embed/${encodeURIComponent(id)}?enablejsapi=1` };
                }
                if (path.startsWith('/shorts/')) {
                    const id = path.split('/').filter(Boolean)[1];
                    if (id) return { kind: 'youtube', src: `https://www.youtube.com/embed/${encodeURIComponent(id)}?enablejsapi=1` };
                }
                if (path.startsWith('/embed/')) {
                    const id = path.split('/').filter(Boolean)[1];
                    if (id) return { kind: 'youtube', src: `https://www.youtube.com/embed/${encodeURIComponent(id)}?enablejsapi=1` };
                }
            }

            // Vimeo
            if (host === 'vimeo.com') {
                const id = path.replace(/^\/+/, '').split('/')[0];
                if (id && /^\d+$/.test(id)) return { kind: 'vimeo', src: `https://player.vimeo.com/video/${encodeURIComponent(id)}?dnt=1&title=0&byline=0&portrait=0` };
            }

            return null;
        };

        // Initialize GLightbox
        const lightbox = GLightbox({
            selector: '.glightbox',
            touchNavigation: true,
            loop: true,
            autoplayVideos: true,
            zoomable: true,
            draggable: true
        });

        const createMediaFigure = (doc, { kind, src }, label, originalUrl) => {
            const fig = doc.createElement('figure');
            fig.className = 'media-embed';

            const a = doc.createElement('a');
            a.href = src;
            a.className = 'glightbox';
            a.setAttribute('data-description', label || '');

            if (kind === 'image') {
                const img = doc.createElement('img');
                img.src = src;
                img.alt = (label || 'Image').slice(0, 200);
                img.loading = 'lazy';
                img.decoding = 'async';
                img.referrerPolicy = 'no-referrer';
                img.onerror = () => {
                    img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23917FB3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"%3E%3Crect width="18" height="18" x="3" y="3" rx="2" ry="2"/%3E%3Ccircle cx="9" cy="9" r="2"/%3E%3Cpath d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/%3E%3C/svg%3E';
                    img.className += ' opacity-40 p-8 bg-oatmeal';
                };
                a.appendChild(img);
                fig.appendChild(a);
            } else if (kind === 'video') {
                const video = doc.createElement('video');
                video.src = src;
                video.controls = true;
                video.playsInline = true;
                video.preload = 'metadata';
                a.appendChild(video);
                fig.appendChild(a);
            } else if (kind === 'youtube' || kind === 'vimeo') {
                const wrap = doc.createElement('div');
                wrap.className = 'media-embed-frame';
                const iframe = doc.createElement('iframe');
                iframe.src = src;
                iframe.loading = 'lazy';
                iframe.referrerPolicy = 'no-referrer';
                iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
                iframe.allowFullscreen = true;
                wrap.appendChild(iframe);

                // Add an expand overlay for video frames
                const expandBtn = doc.createElement('button');
                expandBtn.className = 'absolute top-2 right-2 p-1.5 rounded-full bg-black/50 text-white opacity-0 group-hover:opacity-100 transition-opacity hover:bg-black/70';
                expandBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 3 6 6-3 3-6-6 3-3Z"/><path d="M9 21 3 15l3-3 6 6-3 3Z"/><path d="M21 3v21H0V3h21ZM3 7v14h14V7H3Z"/></svg>';
                expandBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const lbLink = doc.createElement('a');
                    lbLink.href = src;
                    lbLink.className = 'glightbox hidden';
                    doc.body.appendChild(lbLink);
                    const instance = GLightbox({ elements: [{ href: src, type: 'video', source: kind }] });
                    instance.open();
                };

                wrap.classList.add('group');
                wrap.appendChild(expandBtn);
                fig.appendChild(wrap);
            }

            const cap = doc.createElement('figcaption');
            const sourceLink = doc.createElement('a');
            sourceLink.href = originalUrl || src;
            sourceLink.target = '_blank';
            sourceLink.rel = 'noopener noreferrer';
            sourceLink.className = 'flex items-center gap-1.5 opacity-80 hover:opacity-100 transition';
            sourceLink.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h6v6"/><path d="M10 14 21 3"/><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/></svg> Source`;
            cap.appendChild(sourceLink);
            fig.appendChild(cap);
            return fig;
        };

        const applyMediaEmbeds = (container) => {
            if (!container) return;
            const doc = container.ownerDocument || document;

            // Upgrade raw <img>/<video>/<iframe> styling when users paste HTML.
            container.querySelectorAll('img').forEach(img => {
                img.loading = img.loading || 'lazy';
                img.decoding = img.decoding || 'async';
                img.referrerPolicy = img.referrerPolicy || 'no-referrer';
                if (!img.closest('figure.media-embed')) {
                    const fig = doc.createElement('figure');
                    fig.className = 'media-embed';
                    img.replaceWith(fig);
                    fig.appendChild(img);
                }
                if (!img.parentElement.classList.contains('glightbox')) {
                    const a = doc.createElement('a');
                    a.href = img.src;
                    a.className = 'glightbox';
                    img.replaceWith(a);
                    a.appendChild(img);
                }
            });
            container.querySelectorAll('video').forEach(v => {
                v.controls = true;
                v.playsInline = true;
                v.preload = v.preload || 'metadata';
                if (!v.closest('figure.media-embed')) {
                    const fig = doc.createElement('figure');
                    fig.className = 'media-embed';
                    v.replaceWith(fig);
                    fig.appendChild(v);
                }
                if (!v.parentElement.classList.contains('glightbox')) {
                    const a = doc.createElement('a');
                    a.href = v.src;
                    a.className = 'glightbox';
                    v.replaceWith(a);
                    a.appendChild(v);
                }
            });

            // Replace media links with embeds.
            container.querySelectorAll('a[href]').forEach(a => {
                const href = a.getAttribute('href') || '';
                const info = getMediaInfo(href);
                if (!info) return;
                // Don't nest embeds.
                if (a.closest('figure.media-embed')) return;
                // Don't process glightbox links
                if (a.classList.contains('glightbox')) return;
                const label = (a.textContent || '').trim();
                const fig = createMediaFigure(doc, info, label || href, href);
                a.replaceWith(fig);
            });

            // Embed bare media URLs (not wrapped in markdown links).
            const urlRegex = /https?:\/\/[^\s<>"']+/g;
            const walker = doc.createTreeWalker(container, NodeFilter.SHOW_TEXT, {
                acceptNode(node) {
                    const parent = node.parentElement;
                    if (!parent) return NodeFilter.FILTER_REJECT;
                    const tag = parent.tagName;
                    if (['A', 'CODE', 'PRE', 'SCRIPT', 'STYLE', 'TEXTAREA'].includes(tag)) return NodeFilter.FILTER_REJECT;
                    if (!node.nodeValue || !node.nodeValue.includes('http')) return NodeFilter.FILTER_REJECT;
                    return NodeFilter.FILTER_ACCEPT;
                }
            });
            const toProcess = [];
            while (walker.nextNode()) toProcess.push(walker.currentNode);
            for (const textNode of toProcess) {
                const text = textNode.nodeValue || '';
                urlRegex.lastIndex = 0;
                let match;
                let lastIdx = 0;
                let changed = false;
                const frag = doc.createDocumentFragment();
                while ((match = urlRegex.exec(text)) !== null) {
                    const raw = match[0];
                    const info = getMediaInfo(raw);
                    if (!info) continue;
                    const start = match.index;
                    const end = match.index + raw.length;
                    if (start > lastIdx) frag.appendChild(doc.createTextNode(text.slice(lastIdx, start)));
                    const cleaned = stripUrlPunctuation(raw);
                    frag.appendChild(createMediaFigure(doc, info, cleaned, cleaned));
                    lastIdx = end;
                    changed = true;
                }
                if (!changed) continue;
                if (lastIdx < text.length) frag.appendChild(doc.createTextNode(text.slice(lastIdx)));
                textNode.replaceWith(frag);
            }
            // Refresh GLightbox to pick up new elements
            lightbox.reload();
        };
        let toastTimer = null;
        const toast = (msg) => {
            const t = el('#toast');
            t.textContent = msg;
            t.classList.remove('hidden', 'opacity-0');
            if (toastTimer) clearTimeout(toastTimer);
            toastTimer = setTimeout(() => {
                t.classList.add('opacity-0');
                setTimeout(() => t.classList.add('hidden'), 500);
            }, 3000);
        };
        const toastLong = (msg) => {
            const t = el('#toast');
            t.textContent = msg;
            t.classList.remove('hidden', 'opacity-0');
            if (toastTimer) clearTimeout(toastTimer);
        };
        const toastHide = () => {
            const t = el('#toast');
            t.classList.add('opacity-0');
            if (toastTimer) clearTimeout(toastTimer);
            setTimeout(() => t.classList.add('hidden'), 500);
        };
        const showLoading = (msg = 'Loading...', subtext = '') => {
            const ov = el('#loadingOverlay');
            const lm = el('#loadingMessage');
            const ls = el('#loadingSubtext');
            const pw = el('#loadingProgressWrap');
            const pb = el('#loadingProgressBar');
            const pt = el('#loadingProgressText');
            if (lm) lm.textContent = msg;
            if (ls) ls.textContent = subtext;
            if (pw) pw.classList.add('hidden');
            if (pb) pb.style.width = '0%';
            if (pt) pt.textContent = '0%';
            ov.classList.remove('hidden');
            ov.classList.add('flex');
        };
        const setLoadingProgress = (percent, label = null) => {
            const pw = el('#loadingProgressWrap');
            const pb = el('#loadingProgressBar');
            const pt = el('#loadingProgressText');
            if (pw) pw.classList.remove('hidden');
            const p = Math.min(100, Math.max(0, Number(percent) || 0));
            if (pb) pb.style.width = `${p}%`;
            if (pt) pt.textContent = label != null ? String(label) : `${Math.round(p)}%`;
        };
        const hideLoading = () => {
            const ov = el('#loadingOverlay');
            ov.classList.add('hidden');
            ov.classList.remove('flex');
        };
        const Tooltip = {
            timer: null,
            lastShown: null,
            el: null,
            ensure() { this.el = this.el || document.querySelector('#tooltip'); return this.el; },
            show(target) {
                if (window.innerWidth <= 640) return; // Don't show tooltips on small screens
                const tip = target.dataset.tip;
                if (!tip) return;
                const node = this.ensure();
                node.textContent = tip;
                const rect = target.getBoundingClientRect();
                const pad = 10;
                const x = Math.min(window.innerWidth - pad, Math.max(pad, rect.left + rect.width / 2));
                const preferBelow = rect.top < 100; // near top edge: show below to avoid clipping
                const y = preferBelow ? (rect.bottom + 8) : (rect.top - 8);
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                node.style.transform = preferBelow ? 'translate(-50%, 0)' : 'translate(-50%, -100%)';
                node.classList.remove('hidden');
                this.lastShown = target;
            },
            hide() {
                const node = this.ensure();
                node.classList.add('hidden');
                this.lastShown = null;
            },
            bind() {
                document.addEventListener('mouseover', (e) => {
                    const t = e.target.closest('[data-tip]');
                    if (!t) return;
                    if (this.lastShown) { this.show(t); return; }
                    clearTimeout(this.timer);
                    this.timer = setTimeout(() => this.show(t), 160);
                });
                document.addEventListener('mouseout', (e) => {
                    if (!e.relatedTarget || !e.relatedTarget.closest('[data-tip]')) {
                        clearTimeout(this.timer);
                        this.hide();
                    }
                });
                document.addEventListener('focusin', (e) => {
                    const t = e.target.closest('[data-tip]');
                    if (t) this.show(t);
                });
                document.addEventListener('focusout', () => this.hide());
            }
        };

        const sleep = ms => new Promise(res => setTimeout(res, ms));
        const SYNC_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes background tick
        const MIN_PULL_INTERVAL_MS = 3 * 60 * 1000; // pull at most every 3 minutes
        const MIN_PUSH_INTERVAL_MS = 30 * 1000; // push at most every 30 seconds

        const Storage = {
            db: null,
            settingsKey: 'ghostink_settings_v1',
            sqlReady: null,
            async init() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open('GhostInkDB', 2);
                    req.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('decks')) db.createObjectStore('decks', { keyPath: 'id' });
                        if (!db.objectStoreNames.contains('cards')) db.createObjectStore('cards', { keyPath: 'id' });
                        if (!db.objectStoreNames.contains('meta')) db.createObjectStore('meta', { keyPath: 'key' });
                    };
                    req.onsuccess = (e) => {
                        this.db = e.target.result;
                        // Listen for version change (another tab is resetting/upgrading)
                        this.db.onversionchange = () => {
                            this.db.close();
                            this.db = null;
                            // Reload this tab since the database is being reset
                            location.reload();
                        };
                        resolve();
                    };
                    req.onerror = reject;
                });
            },
            tx(store, mode = 'readonly') {
                return this.db.transaction(store, mode).objectStore(store);
            },
            async getAll(store) {
                return new Promise((resolve, reject) => {
                    const req = this.tx(store).getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = reject;
                });
            },
            async getMeta(key) {
                return new Promise((resolve, reject) => {
                    const req = this.tx('meta').get(key);
                    req.onsuccess = () => resolve(req.result ? req.result.value : null);
                    req.onerror = reject;
                });
            },
            async setMeta(key, value) {
                return new Promise((resolve, reject) => {
                    const req = this.tx('meta', 'readwrite').put({ key, value });
                    req.onsuccess = resolve;
                    req.onerror = reject;
                });
            },
            async put(store, value) {
                return new Promise((resolve, reject) => {
                    const req = this.tx(store, 'readwrite').put(value);
                    req.onsuccess = resolve;
                    req.onerror = reject;
                });
            },
            async delete(store, key) {
                return new Promise((resolve, reject) => {
                    const req = this.tx(store, 'readwrite').delete(key);
                    req.onsuccess = resolve;
                    req.onerror = reject;
                });
            },
            async wipeStore(store) {
                return new Promise((resolve, reject) => {
                    const req = this.tx(store, 'readwrite').clear();
                    req.onsuccess = resolve;
                    req.onerror = reject;
                });
            },
            getSettings() {
                const raw = localStorage.getItem(this.settingsKey);
                if (!raw) {
                    return { workerUrl: '', proxyToken: '', authToken: '', deckSource: '', cardSource: '', aiProvider: '', aiModel: '', aiKey: '', sttProvider: '', sttModel: '', sttKey: '', sttPrompt: '', sttVerified: false, sttPermissionWarmed: false, themeMode: 'system', fontMode: 'serif', fabEnabled: true, workerVerified: false, authVerified: false, sourcesVerified: false, aiVerified: false, sourcesCache: { deckOptions: [], cardOptions: [] } };
                }
                try {
                    return JSON.parse(raw);
                } catch (e) {
                    console.error('Failed to parse settings, resetting to defaults:', e);
                    return { workerUrl: '', proxyToken: '', authToken: '', deckSource: '', cardSource: '', aiProvider: '', aiModel: '', aiKey: '', sttProvider: '', sttModel: '', sttKey: '', sttPrompt: '', sttVerified: false, sttPermissionWarmed: false, themeMode: 'system', fontMode: 'serif', fabEnabled: true, workerVerified: false, authVerified: false, sourcesVerified: false, aiVerified: false, sourcesCache: { deckOptions: [], cardOptions: [] } };
                }
            },
            setSettings(newSettings) {
                localStorage.setItem(this.settingsKey, JSON.stringify(newSettings));
            },
            getSession() {
                const raw = localStorage.getItem('ghostink_session_v1');
                if (!raw) return null;
                try {
                    return JSON.parse(raw);
                } catch (_) {
                    localStorage.removeItem('ghostink_session_v1');
                    return null;
                }
            },
            setSession(session) {
                if (session) {
                    localStorage.setItem('ghostink_session_v1', JSON.stringify(session));
                } else {
                    localStorage.removeItem('ghostink_session_v1');
                }
            },
            async ensureSQL() {
                if (this.sqlReady) return this.sqlReady;
                this.sqlReady = window.initSqlJs({ locateFile: (file) => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.2/${file}` });
                return this.sqlReady;
            }
        };

        const API = {
            async request(method, endpoint, body = null, override = null) {
                const { workerUrl, authToken, proxyToken } = override || Storage.getSettings();
                if (!workerUrl || !authToken) throw new Error('Missing worker URL or Notion token');
                const cleanWorker = workerUrl.trim().replace(/\/$/, '');
                const fetchUrl = new URL(cleanWorker);
                fetchUrl.searchParams.append('url', `https://api.notion.com/v1${endpoint}`);
                if (proxyToken) fetchUrl.searchParams.append('token', proxyToken.trim());
                const headers = { 'Authorization': `Bearer ${authToken.trim()}`, 'Notion-Version': '2025-09-03' };
                let payload = body;
                if (body && !(body instanceof FormData)) {
                    headers['Content-Type'] = 'application/json';
                    payload = JSON.stringify(body);
                }
                const res = await fetch(fetchUrl.toString(), { method, headers, body: payload });
                if (!res.ok) {
                    let txt = await res.text();
                    try {
                        const j = JSON.parse(txt);
                        txt = j.message || txt;
                    } catch (_) { }
                    const error = new Error(txt || `Request failed ${res.status}`);
                    error.status = res.status;
                    throw error;
                }
                return await res.json();
            },
            async listDatabases() {
                const results = [];
                let cursor = null;
                let hasMore = true;
                while (hasMore) {
                    const body = { filter: { value: 'data_source', property: 'object' } };
                    if (cursor) body.start_cursor = cursor;
                    const res = await API.request('POST', '/search', body);
                    results.push(...res.results);
                    hasMore = res.has_more;
                    cursor = res.next_cursor;
                }
                return results;
            },
            async queryDatabase(dbId, filter = null) {
                const rows = [];
                let cursor = null;
                let hasMore = true;
                while (hasMore) {
                    const body = { page_size: 100 }; // Notion max page size
                    if (cursor) body.start_cursor = cursor;
                    if (filter) {
                        body.filter = filter;
                    }
                    const res = await API.request('POST', `/data_sources/${dbId}/query`, body);
                    rows.push(...res.results);
                    hasMore = res.has_more;
                    cursor = res.next_cursor;
                }
                return rows;
            },
            async getDatabase(dbId) {
                return API.request('GET', `/data_sources/${dbId}`);
            },
            async createPage(dbId, properties) {
                return API.request('POST', '/pages', { parent: { data_source_id: dbId }, properties });
            },
            async updatePage(pageId, properties) {
                return API.request('PATCH', `/pages/${pageId}`, { properties });
            },
            async archivePage(pageId) {
                return API.request('PATCH', `/pages/${pageId}`, { archived: true });
            },
            async appendBlocks(pageId, children) {
                return API.request('PATCH', `/blocks/${pageId}/children`, { children });
            }
        };

        /**
         * SRS (Spaced Repetition System) algorithms for flashcard scheduling.
         * Contains implementations of FSRS v4 and SM-2 algorithms.
         */
        const SRS = {
            /**
             * Calculate due date set to 4:00 AM of the target day.
             * Prevents schedule creep by aligning reviews to start-of-day.
             */
            getDueDate(intervalDays) {
                const date = new Date();
                // If interval is 0, set to 4:00 AM today (due immediately)
                // If interval > 0, add days and set to 4:00 AM
                const daysToAdd = Math.round(intervalDays);
                if (daysToAdd > 0) {
                    date.setDate(date.getDate() + daysToAdd);
                }
                date.setHours(4, 0, 0, 0);
                return date.toISOString();
            },

            /**
             * FSRS (Free Spaced Repetition Scheduler) v4 algorithm.
             * Calculates new difficulty, stability, and next review date based on user rating.
             * @param {Object} card - The card being reviewed
             * @param {Object} card.fsrs - FSRS state (difficulty, stability, lastReview, etc.)
             * @param {string} rating - User rating: 'again', 'hard', 'good', or 'easy'
             * @returns {Object} Updated FSRS state with new difficulty, stability, retrievability, dueDate
             */
            fsrs(card, rating, customWeights = null, desiredRetention = DEFAULT_DESIRED_RETENTION) {
                const now = new Date();
                const w = customWeights && customWeights.length === 21 ? customWeights : fsrsW;
                const ratingName = rating;
                const lastD = card.fsrs?.difficulty ?? initDifficulty(w, 'good');
                const lastS = card.fsrs?.stability ?? initStability(w, 'good');
                const lastReview = card.fsrs?.lastReview ? new Date(card.fsrs.lastReview) : null;
                const isNew = !lastReview;
                let newD, newS, retr;
                if (isNew) {
                    newD = initDifficulty(w, ratingName);
                    newS = initStability(w, ratingName);
                    retr = 1;
                } else {
                    const elapsed = Math.max(0.01, (now - lastReview) / 86400000);
                    const r = forgettingCurve(w, elapsed, lastS);
                    newD = nextDifficulty(w, lastD, ratingName);

                    if (ratingName === 'again') {
                        newS = nextForgetStability(w, lastD, lastS, r);
                    } else if (elapsed < 1) {
                        // Use Short-term stability formula for same-day reviews (if not 'again')
                        newS = nextShortTermStability(w, lastS, ratingName);
                    } else {
                        newS = nextRecallStability(w, lastD, lastS, r, ratingName);
                    }
                    retr = Math.max(0, Math.min(1, +r.toFixed(4)));
                }
                const intervalDays = nextInterval(w, newS, desiredRetention);
                return {
                    difficulty: newD,
                    stability: newS,
                    retrievability: retr,
                    lastRating: ratingName,
                    lastReview: now.toISOString(),
                    dueDate: SRS.getDueDate(intervalDays)
                };
            },
            /**
             * SM-2 (SuperMemo 2) algorithm for spaced repetition.
             * Updates ease factor and interval based on user rating.
             * @param {Object} card - The card being reviewed
             * @param {Object} card.sm2 - SM-2 state (easeFactor, interval, repetitions, etc.)
             * @param {string} rating - User rating: 'again', 'hard', 'good', or 'easy'
             * @returns {Object} Updated SM-2 state with new easeFactor, interval, dueDate
             */
            sm2(card, rating) {
                const now = new Date();
                const ease = card.sm2?.easeFactor ?? 2.5;
                const interval = card.sm2?.interval ?? 0;
                const repetitions = card.sm2?.repetitions ?? 0;
                // Map ratings to SM-2 quality grades (0-5 scale)
                // again=0 (complete blackout), hard=3 (correct with difficulty), good=4 (correct), easy=5 (perfect)
                const grade = { again: 0, hard: 3, good: 4, easy: 5 }[rating] ?? 4;

                let newEase, newInterval, newReps;

                // Update ease factor on every review (including failures), then clamp.
                newEase = Math.max(1.3, ease + (0.1 - (5 - grade) * (0.08 + (5 - grade) * 0.02)));

                if (grade < 3) {
                    // Failed recall - reset to beginning
                    newReps = 0;
                    newInterval = 0;
                } else {
                    // Successful recall
                    newReps = repetitions + 1;

                    // Calculate interval based on repetition count
                    if (newReps === 1) {
                        newInterval = 1;
                    } else if (newReps === 2) {
                        newInterval = 6;
                    } else {
                        newInterval = Math.round(interval * newEase);
                    }
                }

                return {
                    easeFactor: newEase,
                    interval: newInterval,
                    repetitions: newReps,
                    dueDate: SRS.getDueDate(newInterval),
                    lastRating: rating,
                    lastReview: now.toISOString()
                };
            }
        };

        const normalizeRating = (name) => name ? name.toLowerCase() : null;
        const displayRating = (name) => name ? name.charAt(0).toUpperCase() + name.slice(1).toLowerCase() : null;
        const detectCardType = (name = '', back = '') => {
            const text = `${name} ${back}`.toLowerCase();
            const hasCloze = /\{\{c\d+::.+?\}\}/i.test(text);
            if (hasCloze) return 'Cloze';
            return 'Front-Back';
        };
        // FSRS v6 constants
        // fsrsW: weight parameters (21 values) - Global Defaults
        const fsrsW = [0.212, 1.2931, 2.3065, 8.2956, 6.4133, 0.8334, 3.0194, 0.001, 1.8722, 0.1666, 0.796, 1.4835, 0.0614, 0.2629, 1.6483, 0.6014, 1.8729, 0.5425, 0.0912, 0.0658, 0.1542];
        const DEFAULT_DESIRED_RETENTION = 0.9;
        const MAX_INTERVAL = 36500;
        const ratingsMap = { again: 1, hard: 2, good: 3, easy: 4 };
        const clamp2 = (n) => +Number.isFinite(n) ? Math.max(0, Math.round(n * 100) / 100) : 0;
        const constrainDifficulty = (d) => Math.min(Math.max(+d.toFixed(2), 1), 10);
        const clampRetention = (r) => {
            const n = Number(r);
            if (!Number.isFinite(n)) return DEFAULT_DESIRED_RETENTION;
            return Math.min(0.99, Math.max(0.01, n));
        };
        const constrainWeights = (w) => {
            const out = (Array.isArray(w) ? w : []).slice(0, 21);
            while (out.length < 21) out.push(fsrsW[out.length]);
            for (let i = 0; i < out.length; i++) {
                const n = Number(out[i]);
                out[i] = Number.isFinite(n) ? n : fsrsW[i];
            }
            // A few guardrails to keep formulas well-behaved
            for (let i = 0; i <= 3; i++) out[i] = Math.max(0.01, out[i]); // initial stabilities
            out[4] = Math.min(10, Math.max(1, out[4])); // baseline difficulty
            out[7] = Math.min(1, Math.max(0, out[7])); // mean reversion weight
            out[20] = Math.min(1, Math.max(0.01, out[20])); // decay (used as -w[20])
            return out;
        };

        // FSRS v6 helpers (Pure functions accepting weights 'w')
        const getDecay = (w) => -w[20];
        const getFactor = (w) => Math.pow(0.9, 1 / getDecay(w)) - 1;
        const meanReversion = (w, init, current) => w[7] * init + (1 - w[7]) * current;

        /** Calculate initial difficulty for a new card based on first rating */
        const initDifficulty = (w, ratingName) => {
            const r = ratingsMap[ratingName] || 3;
            // D0 = w4 - (G-3) * w5
            return constrainDifficulty(w[4] - (r - 3) * w[5]);
        };
        /** Calculate initial stability for a new card based on first rating */
        const initStability = (w, ratingName) => {
            const r = ratingsMap[ratingName] || 3;
            // S0 = w[G-1]
            return +Math.max(w[r - 1], 0.1).toFixed(2);
        };
        /** Calculate probability of recall using the power forgetting curve (v6) */
        const forgettingCurve = (w, elapsedDays, stability) => Math.pow(1 + getFactor(w) * elapsedDays / stability, getDecay(w));

        /** Calculate next review interval in days based on stability */
        const nextInterval = (w, stability, desiredRetention = DEFAULT_DESIRED_RETENTION) => {
            const rr = clampRetention(desiredRetention);
            const newInterval = stability / getFactor(w) * (Math.pow(rr, 1 / getDecay(w)) - 1);
            return Math.min(Math.max(Math.round(newInterval), 0), MAX_INTERVAL);
        };
        /** Update difficulty after a review (applies mean reversion) */
        const nextDifficulty = (w, d, ratingName) => {
            const r = ratingsMap[ratingName] || 3;
            // next_D = D - w6 * (G - 3)
            const next_d = d - w[6] * (r - 3);
            // Mean reversion: w7 * w4 + (1 - w7) * next_D
            return constrainDifficulty(meanReversion(w, w[4], next_d));
        };
        /** Calculate new stability after successful recall */
        const nextRecallStability = (w, d, s, r, ratingName) => {
            const hardPenalty = ratingName === 'hard' ? w[15] : 1;
            const easyBonus = ratingName === 'easy' ? w[16] : 1;
            // S_recall = S * (1 + exp(w8) * (11 - D) * S^(-w9) * (exp((1 - R) * w10) - 1) * hardPenalty * easyBonus)
            const val = s * (1 + Math.exp(w[8]) * (11 - d) * Math.pow(s, -w[9]) * (Math.exp((1 - r) * w[10]) - 1) * hardPenalty * easyBonus);
            return clamp2(val);
        };
        /** Calculate new stability after forgetting (rated 'again') */
        const nextForgetStability = (w, d, s, r) => {
            // S_forget = w11 * D^(-w12) * ((S + 1)^w13 - 1) * exp((1 - R) * w14)
            // Capped at S (stability cannot increase on failure)
            const val = Math.min(
                w[11] * Math.pow(d, -w[12]) * (Math.pow(s + 1, w[13]) - 1) * Math.exp((1 - r) * w[14]),
                s
            );
            return clamp2(val);
        };
        /** Calculate new stability for same-day review (Short-term) */
        const nextShortTermStability = (w, s, ratingName) => {
            const r = ratingsMap[ratingName] || 3;
            // S_new = S * exp(w17 * (G - 3 + w18)) * S^(-w19)
            const val = s * Math.exp(w[17] * (r - 3 + w[18])) * Math.pow(s, -w[19]);
            return clamp2(val);
        };
        const toRichTextChunks = (text) => {
            const str = (text || '').toString();
            if (!str) return [];
            const MAX_CHARS = 2000;
            const MAX_ITEMS = 100;
            const chunks = [];
            for (let i = 0; i < str.length && chunks.length < MAX_ITEMS; i += MAX_CHARS) {
                chunks.push({ text: { content: str.slice(i, i + MAX_CHARS) } });
            }
            return chunks;
        };
        // Compact review history format: "g1702473000,h1702559400,a1702645800"
        // Rating codes: a=again, h=hard, g=good, e=easy
        // Timestamp: Unix epoch seconds
        const compactReviewHistory = (history) => {
            if (!history || !history.length) return '';
            const ratingCodes = { again: 'a', hard: 'h', good: 'g', easy: 'e' };
            return history.map(entry => {
                const code = ratingCodes[entry.rating] || 'g';
                const ms = new Date(entry.at).getTime();
                if (!Number.isFinite(ms)) return null;
                const ts = Math.floor(ms / 1000);
                return `${code}${ts}`;
            }).filter(Boolean).join(',');
        };
        const parseReviewHistory = (compact) => {
            if (!compact || typeof compact !== 'string') return [];
            // Handle legacy JSON format
            if (compact.startsWith('[')) {
                try { return JSON.parse(compact); } catch { return []; }
            }
            const ratingNames = { a: 'again', h: 'hard', g: 'good', e: 'easy' };
            return compact.split(',').filter(Boolean).map(entry => {
                const code = entry[0];
                const ts = parseInt(entry.slice(1), 10);
                if (!Number.isFinite(ts)) return null;
                return {
                    rating: ratingNames[code] || 'good',
                    at: new Date(ts * 1000).toISOString()
                };
            }).filter(Boolean);
        };
        const richToMarkdown = (arr = []) => {
            return (arr || []).map(rt => {
                if (!rt) return '';
                const a = rt.annotations || {};
                let s = '';
                if (rt.type === 'equation' && rt.equation?.expression) {
                    s = `<span class="notion-equation">${rt.equation.expression}</span>`;
                } else {
                    const t = rt.plain_text || '';
                    if (!t) return '';
                    if (rt.href) s = `[${t}](${rt.href})`; else s = t;
                    if (a.code) s = '`' + s + '`';
                    if (a.bold) s = '**' + s + '**';
                    if (a.italic) s = '*' + s + '*';
                    if (a.strikethrough) s = '~~' + s + '~~';
                    if (a.underline) s = '__' + s + '__';
                    if (a.color && a.color !== 'default') {
                        s = `<span class="notion-color-${a.color.replace('_', '-')}">${s}</span>`;
                    }
                }
                return s;
            }).join('');
        };

        // Convert markdown to Notion rich_text using Marked (markdownâ†’HTML) + DOM parsing (HTMLâ†’runs).
        // This avoids regex-recursive parsing (which can cause stack overflows on pathological content).
        // Supported:
        // - bold/italic/strikethrough/code/links
        // - underline (from our exporter: __text__ â†’ <u>text</u>)
        // - Notion colors: <span class="notion-color-...">...</span>
        // - Notion equations: <span class="notion-equation">...</span>
        const markdownToNotionRichText = (markdown) => {
            const raw = (markdown ?? '').toString();
            if (!raw) return [];

            const MAX_INPUT_CHARS = 50000;
            const MAX_ITEMS = 100;
            const MAX_CHARS_PER_ITEM = 2000;

            const safePlain = (input) => {
                const s = (input || '').toString();
                if (!s) return [];
                const cleaned = s.replace(/<[^>]+>/g, '');
                const out = [];
                for (let i = 0; i < cleaned.length && out.length < MAX_ITEMS; i += MAX_CHARS_PER_ITEM) {
                    out.push({ type: 'text', text: { content: cleaned.slice(i, i + MAX_CHARS_PER_ITEM) } });
                }
                return out;
            };

            if (raw.length > MAX_INPUT_CHARS) return safePlain(raw);

            // Treat __text__ as underline (we generate underline using __...__ in richToMarkdown()).
            // This is intentionally different from Markdown strong; we always generate bold with **...**.
            const pre = raw.replace(/__([\s\S]+?)__/g, '<u>$1</u>');

            let html;
            try {
                html = marked.parse(pre, {
                    gfm: true,
                    breaks: true,
                    headerIds: false,
                    mangle: false
                });
            } catch (e) {
                console.error('marked.parse failed; falling back to plain text:', e);
                return safePlain(pre);
            }

            let doc;
            try {
                const parser = new DOMParser();
                doc = parser.parseFromString(`<div id="__rtroot__">${html}</div>`, 'text/html');
            } catch (e) {
                console.error('DOMParser failed; falling back to plain text:', e);
                return safePlain(pre);
            }

            const root = doc.getElementById('__rtroot__');
            if (!root) return safePlain(pre);

            const runs = [];

            const sanitizeLinkUrl = (url) => {
                const s = (url ?? '').toString().trim();
                if (!s) return null;
                // Notion text.link.url must be an absolute URL (or mailto/tel).
                // Drop relative/hash/javascript links to avoid Notion 400s ("Invalid URL for link.").
                if (s.startsWith('#')) return null;
                if (s.toLowerCase().startsWith('javascript:')) return null;
                const candidate = s.startsWith('//') ? `https:${s}` : s;
                try {
                    const u = new URL(candidate);
                    const proto = (u.protocol || '').toLowerCase();
                    // Only keep HTTPS links for Notion properties (everything else is dropped).
                    if (proto !== 'https:') return null;
                    return u.toString();
                } catch (_) {
                    return null;
                }
            };

            const normalizeColor = (cls) => {
                // notion-color-gray-background -> gray_background
                const c = (cls || '').replace(/^notion-color-/, '').trim();
                if (!c) return null;
                return c.replace(/-/g, '_');
            };

            const pushText = (text, annotations, link) => {
                if (!text) return;
                const content = text.toString();
                if (!content) return;
                const item = { type: 'text', text: { content } };
                const cleanLink = sanitizeLinkUrl(link);
                if (cleanLink) item.text.link = { url: cleanLink };
                if (annotations && Object.keys(annotations).length) item.annotations = annotations;
                runs.push(item);
            };

            const pushNewline = (annotations, link) => {
                // Avoid piling up newlines (keeps Notion props cleaner)
                const last = runs[runs.length - 1];
                if (last?.type === 'text' && last.text?.content?.endsWith('\n')) return;
                pushText('\n', annotations, link);
            };

            const mergeAnn = (base, extra) => {
                const out = { ...(base || {}) };
                for (const [k, v] of Object.entries(extra || {})) {
                    if (v !== undefined) out[k] = v;
                }
                return out;
            };

            const walk = (node, state) => {
                if (!node) return;
                const curAnn = state?.annotations || null;
                const curLink = state?.link || null;

                if (runs.length >= 2000) return; // soft safety cap before chunking

                if (node.nodeType === Node.TEXT_NODE) {
                    const val = node.nodeValue || '';
                    // Marked inserts formatting whitespace/newlines between block elements.
                    // We generate our own newlines for blocks, so ignore whitespace-only nodes to avoid double newlines.
                    if (!val || /^\s+$/.test(val)) return;
                    pushText(val, curAnn, curLink);
                    return;
                }
                if (node.nodeType !== Node.ELEMENT_NODE) return;

                const el = node;
                const tag = (el.tagName || '').toUpperCase();

                // Ignore unsafe or irrelevant elements entirely
                if (tag === 'SCRIPT' || tag === 'STYLE' || tag === 'NOSCRIPT') return;

                // Notion equation span
                if (tag === 'SPAN' && el.classList && el.classList.contains('notion-equation')) {
                    const expr = (el.textContent || '').trim();
                    if (expr) runs.push({ type: 'equation', equation: { expression: expr } });
                    return;
                }

                // Notion color span
                if (tag === 'SPAN' && el.classList) {
                    const colorClass = [...el.classList].find(c => c.startsWith('notion-color-'));
                    if (colorClass) {
                        const color = normalizeColor(colorClass);
                        const nextState = { ...state, annotations: mergeAnn(curAnn, { color }) };
                        for (const child of Array.from(el.childNodes)) walk(child, nextState);
                        return;
                    }
                }

                // Annotation tags
                if (tag === 'STRONG' || tag === 'B') {
                    const nextState = { ...state, annotations: mergeAnn(curAnn, { bold: true }) };
                    for (const child of Array.from(el.childNodes)) walk(child, nextState);
                    return;
                }
                if (tag === 'EM' || tag === 'I') {
                    const nextState = { ...state, annotations: mergeAnn(curAnn, { italic: true }) };
                    for (const child of Array.from(el.childNodes)) walk(child, nextState);
                    return;
                }
                if (tag === 'U') {
                    const nextState = { ...state, annotations: mergeAnn(curAnn, { underline: true }) };
                    for (const child of Array.from(el.childNodes)) walk(child, nextState);
                    return;
                }
                if (tag === 'DEL' || tag === 'S') {
                    const nextState = { ...state, annotations: mergeAnn(curAnn, { strikethrough: true }) };
                    for (const child of Array.from(el.childNodes)) walk(child, nextState);
                    return;
                }
                if (tag === 'CODE') {
                    // Treat code as a single literal chunk (no nested parsing)
                    pushText(el.textContent || '', mergeAnn(curAnn, { code: true }), curLink);
                    return;
                }
                if (tag === 'A') {
                    const href = sanitizeLinkUrl(el.getAttribute('href') || curLink);
                    const nextState = { ...state, link: href || null };
                    for (const child of Array.from(el.childNodes)) walk(child, nextState);
                    return;
                }
                if (tag === 'BR') {
                    pushNewline(curAnn, curLink);
                    return;
                }

                // Block-ish elements: preserve line breaks
                const blockTags = new Set(['P', 'DIV', 'LI', 'UL', 'OL', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'BLOCKQUOTE']);
                const isBlock = blockTags.has(tag);

                for (const child of Array.from(el.childNodes)) walk(child, state);
                if (isBlock) pushNewline(curAnn, curLink);
            };

            for (const child of Array.from(root.childNodes)) walk(child, { annotations: null, link: null });

            // Merge adjacent text runs with identical formatting.
            const merged = [];
            const sameAnn = (a, b) => JSON.stringify(a || {}) === JSON.stringify(b || {});
            for (const item of runs) {
                if (!item) continue;
                if (merged.length === 0) { merged.push(item); continue; }
                const prev = merged[merged.length - 1];
                if (item.type === 'text' && prev.type === 'text') {
                    const a1 = prev.annotations || null;
                    const a2 = item.annotations || null;
                    const l1 = prev.text?.link?.url || null;
                    const l2 = item.text?.link?.url || null;
                    if (l1 === l2 && sameAnn(a1, a2)) {
                        prev.text.content = (prev.text.content || '') + (item.text.content || '');
                        continue;
                    }
                }
                merged.push(item);
            }

            // Chunk text items to Notion limits.
            const out = [];
            for (const item of merged) {
                if (out.length >= MAX_ITEMS) break;
                if (item.type === 'equation') {
                    out.push(item);
                    continue;
                }
                const content = item.text?.content || '';
                if (!content) continue;
                if (content.length <= MAX_CHARS_PER_ITEM) {
                    out.push(item);
                    continue;
                }
                for (let i = 0; i < content.length && out.length < MAX_ITEMS; i += MAX_CHARS_PER_ITEM) {
                    out.push({
                        type: 'text',
                        text: {
                            content: content.slice(i, i + MAX_CHARS_PER_ITEM),
                            link: item.text?.link
                        },
                        annotations: item.annotations
                    });
                }
            }

            // Trim trailing whitespace/newlines (avoid Notion properties ending with blank lines).
            while (out.length && out[out.length - 1].type === 'text') {
                const last = out[out.length - 1];
                const content = (last.text?.content || '');
                const trimmedRight = content.replace(/\s+$/g, '');
                if (trimmedRight.length === 0) {
                    out.pop();
                    continue;
                }
                if (trimmedRight !== content) {
                    last.text.content = trimmedRight;
                }
                break;
            }

            return out.slice(0, MAX_ITEMS);
        };

        /**
         * NotionMapper - Bidirectional mapping between app objects and Notion API format.
         * Handles conversion of decks and cards to/from Notion page properties.
         */
        const DEFAULT_AI_PROMPT = 'You are a strict flashcard grader.\nQuestion: {{question}}\nCorrect answer: {{answer}}\nLearner answer: {{user}}\nJudge correctness (short) and give brief feedback.';
        const parseFsrsParamsText = (raw) => {
            const text = (raw || '').toString().trim();
            const out = { desiredRetention: DEFAULT_DESIRED_RETENTION, weights: null };
            if (!text) return out;

            // JSON format (recommended): {"desired_retention":0.9,"weights":[...]}
            if (text.startsWith('{')) {
                try {
                    const obj = JSON.parse(text);
                    const dr = obj.desired_retention ?? obj.desiredRetention ?? obj.request_retention ?? obj.requestRetention;
                    if (dr !== undefined) out.desiredRetention = clampRetention(dr);
                    const w = obj.weights ?? obj.w ?? obj.params;
                    if (Array.isArray(w)) {
                        if (w.length === 21) {
                            out.weights = w.map(n => Number(n));
                        } else if (w.length > 0) {
                            // Recovery: pad with defaults
                            const recovered = w.map(n => Number.isFinite(Number(n)) ? Number(n) : 0);
                            while (recovered.length < 21) {
                                recovered.push(fsrsW[recovered.length]);
                            }
                            out.weights = recovered.slice(0, 21);
                        }
                    }
                    if (out.weights) return out;
                } catch (_) { }
            }

            // Numeric format: either "0.9, w1, w2, ... w21" or just "w1, ... w21"
            const nums = text.split(/[\s,]+/).map(s => parseFloat(s.trim())).filter(n => Number.isFinite(n));

            if (nums.length === 0) return out;

            if (nums.length === 1 && nums[0] > 0 && nums[0] < 1) {
                out.desiredRetention = clampRetention(nums[0]);
                return out;
            }

            // Check if first number looks like retention
            let startIdx = 0;
            if (nums[0] > 0 && nums[0] < 1 && nums.length > 1) {
                out.desiredRetention = clampRetention(nums[0]);
                startIdx = 1;
            }

            // Extract weights and recover if needed
            const rawWeights = nums.slice(startIdx);
            const recovered = [...rawWeights];
            while (recovered.length < 21) {
                recovered.push(fsrsW[recovered.length]);
            }
            out.weights = recovered.slice(0, 21);

            return out;
        };
        const serializeFsrsParamsText = (deck) => {
            if (!deck || deck.algorithm !== 'FSRS') return '';
            const desiredRetention = clampRetention(deck.fsrsDesiredRetention ?? DEFAULT_DESIRED_RETENTION);
            const weights = (Array.isArray(deck.fsrsWeights) && deck.fsrsWeights.length === 21) ? deck.fsrsWeights : fsrsW;
            const obj = { desired_retention: desiredRetention, weights: weights };
            return JSON.stringify(obj);
        };
        const simulateFsrsReviewAt = (state, { at, rating }, w) => {
            const now = new Date(at);
            if (!Number.isFinite(now.getTime())) return null;
            const ratingName = normalizeRating(rating);
            const lastReview = state.lastReview ? new Date(state.lastReview) : null;
            const isNew = !lastReview;

            let newD, newS, retr;
            if (isNew) {
                // Learning/init step: we don't score loss here; just set initial state.
                newD = initDifficulty(w, ratingName || 'good');
                newS = initStability(w, ratingName || 'good');
                retr = 1;
            } else {
                const elapsed = Math.max(0.01, (now - lastReview) / 86400000);
                const r = forgettingCurve(w, elapsed, state.stability);
                newD = nextDifficulty(w, state.difficulty, ratingName);
                if (ratingName === 'again') {
                    newS = nextForgetStability(w, state.difficulty, state.stability, r);
                } else if (elapsed < 1) {
                    newS = nextShortTermStability(w, state.stability, ratingName);
                } else {
                    newS = nextRecallStability(w, state.difficulty, state.stability, r, ratingName);
                }
                retr = Math.max(0, Math.min(1, +r.toFixed(6)));
            }
            return {
                nextState: {
                    difficulty: newD,
                    stability: newS,
                    lastReview: now.toISOString()
                },
                retrievability: retr,
                isNew
            };
        };
        const buildFsrsTrainingSet = (cards, { maxCards = 400 } = {}) => {
            const candidates = (cards || []).filter(c => Array.isArray(c.reviewHistory) && c.reviewHistory.length >= 2);
            if (candidates.length === 0) return [];
            const chosen = candidates.length <= maxCards ? candidates : [...candidates].sort(() => Math.random() - 0.5).slice(0, maxCards);
            return chosen.map(c => ({
                id: c.id,
                history: [...c.reviewHistory]
                    .filter(e => e && e.at && e.rating)
                    .sort((a, b) => new Date(a.at) - new Date(b.at))
            })).filter(x => x.history.length >= 2);
        };
        const fsrsLogLoss = (trainingSet, weights) => {
            const w = constrainWeights(weights);
            const eps = 1e-6;
            let n = 0;
            let loss = 0;
            for (const item of trainingSet) {
                const state = {
                    difficulty: initDifficulty(w, 'good'),
                    stability: initStability(w, 'good'),
                    lastReview: null
                };
                for (const step of item.history) {
                    const sim = simulateFsrsReviewAt(state, step, w);
                    if (!sim) continue;
                    if (!sim.isNew) {
                        const y = normalizeRating(step.rating) === 'again' ? 0 : 1;
                        const p = Math.min(1 - eps, Math.max(eps, sim.retrievability));
                        loss += -(y * Math.log(p) + (1 - y) * Math.log(1 - p));
                        n++;
                    }
                    state.difficulty = sim.nextState.difficulty;
                    state.stability = sim.nextState.stability;
                    state.lastReview = sim.nextState.lastReview;
                }
            }
            if (n === 0) return Number.POSITIVE_INFINITY;
            return loss / n;
        };

        const NotionMapper = {
            /**
             * Convert a Notion page to an app deck object
             * @param {Object} page - Notion page object from API
             * @returns {Object} Deck object for internal use
             */
            deckFrom(page) {
                const props = page.properties || {};
                const title = props['Deck Name']?.title?.map(t => t.plain_text).join('') || 'Untitled deck';
                const rawMode = props['Order Mode']?.select?.name || 'None';
                const orderMap = { 'none': 'none', 'created time': 'created', 'order property': 'property' };
                const fsrsParamsRaw = props['FSRS Params']?.rich_text?.map(t => t.plain_text).join('') || '';
                const fsrsParams = parseFsrsParamsText(fsrsParamsRaw);
                return {
                    id: page.id,
                    notionId: page.id,
                    name: title,
                    algorithm: props['SRS Algorithm']?.select?.name || 'SM-2',
                    orderMode: orderMap[rawMode.toLowerCase()] || 'none',
                    reviewLimit: props['Daily Review Limit']?.number || 50,
                    newLimit: props['New Card Limit']?.number || 20,
                    reverse: props['Reverse Mode Enabled']?.checkbox || false,
                    createdInApp: props['Created In-App']?.checkbox || false,
                    archived: props['Archived?']?.checkbox || false,
                    ankiMetadata: props['Anki Metadata']?.rich_text?.[0]?.plain_text || '',
                    aiPrompt: props['AI Revision Prompt']?.rich_text?.map(t => t.plain_text).join('') || DEFAULT_AI_PROMPT,
                    fsrsDesiredRetention: fsrsParams.desiredRetention,
                    fsrsWeights: fsrsParams.weights,
                    fsrsParamsRaw,
                    updatedInApp: false
                };
            },
            /**
             * Convert an app deck object to Notion page properties
             * @param {Object} deck - App deck object
             * @returns {Object} Notion properties object for API
             */
            deckProps(deck) {
                const orderLabels = { none: 'None', created: 'Created Time', property: 'Order Property' };
                return {
                    'Deck Name': { title: markdownToNotionRichText(deck.name) },
                    'SRS Algorithm': { select: { name: deck.algorithm } },
                    'Order Mode': { select: { name: orderLabels[deck.orderMode] || orderLabels.none } },
                    'Daily Review Limit': { number: deck.reviewLimit },
                    'New Card Limit': { number: deck.newLimit },
                    'Reverse Mode Enabled': { checkbox: !!deck.reverse },
                    'Created In-App': { checkbox: true },
                    'Archived?': { checkbox: !!deck.archived },
                    'Anki Metadata': { rich_text: deck.ankiMetadata ? [{ text: { content: deck.ankiMetadata } }] : [] },
                    'AI Revision Prompt': { rich_text: markdownToNotionRichText(deck.aiPrompt) },
                    'FSRS Params': { rich_text: toRichTextChunks(serializeFsrsParamsText(deck)) }
                };
            },
            /**
             * Convert a Notion page to an app card object
             * @param {Object} page - Notion page object from API
             * @param {Array} decks - Array of deck objects for resolving relations
             * @returns {Object} Card object for internal use
             */
            cardFrom(page, decks) {
                const p = page.properties || {};
                const deckRel = p['Deck']?.relation?.[0]?.id || null;
                const name = richToMarkdown(p['Name']?.title) || 'Card';
                const back = richToMarkdown(p['Back']?.rich_text) || '';
                const tags = p['Tags']?.multi_select?.map(t => ({ name: t.name, color: t.color || 'default' })) || [];
                const lastReview = p['Last Review']?.date?.start || null;
                const fsrs = {
                    difficulty: p['Difficulty']?.number ?? initDifficulty(fsrsW, 'good'),
                    stability: p['Stability']?.number ?? initStability(fsrsW, 'good'),
                    retrievability: p['Retrievability']?.number ?? 0.9,
                    lastRating: normalizeRating(p['Last Rating']?.select?.name) || null,
                    lastReview,
                    dueDate: p['Due Date']?.date?.start || null
                };
                const intervalVal = p['Interval / Box Level']?.number ?? 1;
                const sm2 = {
                    interval: intervalVal,
                    easeFactor: p['Ease Factor']?.number ?? 2.5,
                    // If there's no lastReview, treat as new card (0 reps) to avoid jumping straight to the 6-day step.
                    // Otherwise, infer repetitions from interval: 1 day = 1 rep, 6 days = 2 reps, else 3+.
                    repetitions: !lastReview ? 0 : (intervalVal <= 1 ? 1 : (intervalVal === 6 ? 2 : 3)),
                    dueDate: p['Due Date']?.date?.start || null,
                    lastRating: normalizeRating(p['Last Rating']?.select?.name) || null,
                    lastReview
                };
                return {
                    id: page.id,
                    notionId: page.id,
                    deckId: deckRel,
                    name,
                    back,
                    type: p['Card Type']?.select?.name || detectCardType(name, back),
                    tags,
                    notes: richToMarkdown(p['Notes']?.rich_text) || '',
                    suspended: p['Suspended']?.checkbox || false,
                    leech: p['Leech']?.checkbox || false,
                    fsrs,
                    sm2,
                    syncId: page.id,
                    updatedInApp: p['Updated In-App']?.checkbox || false,
                    order: typeof p['Order']?.number === 'number' ? p['Order'].number : null,
                    reviewHistory: parseReviewHistory(p['Review History']?.rich_text?.[0]?.plain_text || ''),
                    ankiGuid: p['Anki GUID']?.rich_text?.[0]?.plain_text || '',
                    ankiNoteType: p['Anki Note Type']?.select?.name || '',
                    ankiFields: p['Anki Fields JSON']?.rich_text?.[0]?.plain_text || '',
                    clozeIndexes: p['Cloze Indexes']?.rich_text?.[0]?.plain_text || '',
                    createdAt: page.created_time,
                    // Store original Notion rich_text to preserve colors/equations on sync
                    _notionRichText: {
                        name: p['Name']?.title || [],
                        back: p['Back']?.rich_text || [],
                        notes: p['Notes']?.rich_text || []
                    }
                };
            },
            /**
             * Convert an app card object to Notion page properties.
             * Preserves original rich_text (colors, equations) if content unchanged.
             * @param {Object} card - App card object
             * @param {string|null} notionDeckId - Notion page ID for deck relation
             * @returns {Object} Notion properties object for API
             */
            cardProps(card, deck = null) {
                // Only use a real Notion page ID for relations.
                // Local deck IDs (randomUUID) must not be sent to Notion.
                const notionDeckId = deck?.notionId || null;
                const deckAlgorithm = deck?.algorithm || 'SM-2';
                const dueDate = (deckAlgorithm === 'FSRS' ? card.fsrs?.dueDate : card.sm2?.dueDate) || card.fsrs?.dueDate || card.sm2?.dueDate || null;
                const lastReview = (deckAlgorithm === 'FSRS' ? card.fsrs?.lastReview : card.sm2?.lastReview) || card.fsrs?.lastReview || card.sm2?.lastReview || null;
                const lastRating = (deckAlgorithm === 'FSRS' ? card.fsrs?.lastRating : card.sm2?.lastRating) || card.fsrs?.lastRating || card.sm2?.lastRating || null;
                // Helper to get rich_text: use original if content unchanged, else convert markdown
                const getRichText = (field, content, originalRichText) => {
                    // If we have original rich_text and content hasn't been edited in app
                    if (originalRichText && originalRichText.length > 0 && !card.updatedInApp) {
                        // Check if content matches original (convert original back to markdown and compare)
                        const originalMarkdown = richToMarkdown(originalRichText);
                        if (content === originalMarkdown) {
                            // Content unchanged - use original rich_text to preserve colors/equations
                            return originalRichText;
                        }
                    }
                    // Content was changed - convert markdown to rich_text (may lose colors)
                    return markdownToNotionRichText(content);
                };

                const orig = card._notionRichText || {};
                const props = {
                    'Name': { title: getRichText('name', card.name, orig.name) },
                    'Back': { rich_text: getRichText('back', card.back, orig.back) },
                    'Card Type': { select: { name: card.type } },
                    'Tags': { multi_select: card.tags.map(t => ({ name: t.name })) },
                    'Notes': { rich_text: getRichText('notes', card.notes, orig.notes) },
                    'Suspended': { checkbox: !!card.suspended },
                    'Leech': { checkbox: !!card.leech },
                    'Order': { number: typeof card.order === 'number' ? card.order : null },
                    'Difficulty': { number: card.fsrs?.difficulty ?? 4 },
                    'Stability': { number: card.fsrs?.stability ?? 1 },
                    'Retrievability': { number: card.fsrs?.retrievability ?? 0.9 },
                    'Last Rating': lastRating ? { select: { name: displayRating(lastRating) } } : { select: null },
                    'Last Review': { date: lastReview ? { start: lastReview } : null },
                    'Due Date': { date: dueDate ? { start: dueDate } : null },
                    'Interval / Box Level': { number: card.sm2?.interval ?? 1 },
                    'Ease Factor': { number: card.sm2?.easeFactor ?? 2.5 },
                    'Updated In-App': { checkbox: false },
                    'Review History': { rich_text: toRichTextChunks(compactReviewHistory(card.reviewHistory || [])) },
                    'Anki GUID': card.ankiGuid ? { rich_text: [{ type: 'text', text: { content: card.ankiGuid } }] } : { rich_text: [] },
                    'Anki Note Type': card.ankiNoteType ? { select: { name: card.ankiNoteType } } : { select: null },
                    'Anki Fields JSON': card.ankiFields ? { rich_text: [{ type: 'text', text: { content: card.ankiFields } }] } : { rich_text: [] },
                    'Cloze Indexes': card.clozeIndexes ? { rich_text: [{ type: 'text', text: { content: card.clozeIndexes } }] } : { rich_text: [] }
                };
                // Only include Deck if we can safely set it:
                // - If we have a Notion deck page ID, set relation to that.
                // - If the card has no deck, explicitly clear it.
                // - If the card has a deckId but we can't resolve it (missing deck), omit to avoid wiping in Notion.
                if (notionDeckId) props['Deck'] = { relation: [{ id: notionDeckId }] };
                else if (!card.deckId) props['Deck'] = { relation: [] };
                return props;
            }
        };

        const App = {
            state: {
                decks: [],
                cards: [],
                queue: [],
                lastQueueError: null,
                queueLastChangedAt: null,
                selectedDeck: null,
                selectedCard: null,
                filters: { again: false, hard: false, addedToday: false, tags: [], suspended: false, leech: false, studyDecks: [] },
                cardSearch: '',
                deckSearch: '',
                cardLimit: 50,
                cardLimitStep: 50,
                reverse: false,
                lastSync: null,
                lastPull: null,
                lastPush: null,
                activeTab: 'study',
                settings: Storage.getSettings(),
                sourcesCache: { deckOptions: [], cardOptions: [] },
                workerVerified: Storage.getSettings().workerVerified || false,
                authVerified: Storage.getSettings().authVerified || false,
                sourcesVerified: Storage.getSettings().sourcesVerified || false,
                autoSyncTimer: null,
                autoSyncSoonTimer: null,
                syncing: false,
                autoScanPending: false,
                answerRevealed: false,
                aiLocked: false,
                lockAiUntilNextCard: false,
                activeMicButton: null,  // 'inline' | 'fab'
                micPermissionPromise: null,
                cardReversed: false,
                studyNonDue: false,
                session: null,  // Active study session (loaded from localStorage)
                sessionReversed: null,  // Pre-computed reverse decision from session
                lastRating: null,  // For undo feature: { cardId, sm2, fsrs, history, rating, sessionIndex }
                undoToastTimeout: null,
                lastFocusedElement: null,  // For modal focus management
                tagOptions: [],
                tagSelection: [],
                userStoppedMic: false,
                activeAudioStream: null,
                fabSetupMode: false,
                joystickActive: false,
                joystickHandlers: null
            },
            isAiModeSelected() {
                return el('#revisionMode')?.value === 'ai';
            },
            isAiModeUsable() {
                if (!this.isAiModeSelected()) return false;
                if (!navigator.onLine) return false;
                if (!this.state.settings.aiVerified) return false;
                if (!this.state.settings.aiKey) return false;
                return true;
            },
            async init() {
                this.applyTheme();
                this.applyFontMode();
                this.applyFabPosition();

                showLoading('Preparing app...', 'Loading your decks and cards.');
                await Storage.init();
                await this.loadFromDB();
                if (!this.state.tagOptions || this.state.tagOptions.length === 0) {
                    this.state.tagOptions = this.buildLocalTagOptions();
                }
                this.loadSession();  // Load any active study session
                this.captureOAuth();
                this.bind();
                this.seedIfEmpty();
                this.renderAll();
                await this.autoVerifyWorker();
                window.addEventListener('online', () => this.handleOnline());
                window.addEventListener('offline', () => this.renderConnection());
                if (window.matchMedia) {
                    const mq = window.matchMedia('(prefers-color-scheme: dark)');
                    mq.addEventListener('change', () => this.applyTheme());
                }
                Tooltip.bind();
                this.startAutoSync();
                hideLoading();
            },
            loadSession() {
                this.state.session = Storage.getSession();
            },
            saveSession() {
                Storage.setSession(this.state.session);
            },
            setSyncButtonSpinning(on) {
                const btn = el('#syncNowBtn');
                if (!btn) return;
                const icon = btn.querySelector('i');
                btn.disabled = on || !navigator.onLine || this.state.syncing;
                btn.classList.toggle('opacity-70', btn.disabled);
                if (icon) icon.classList.toggle('animate-spin', on);
            },
            async ensureMicPermission() {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return true;
                if (this.state.micPermissionPromise) return this.state.micPermissionPromise;
                this.state.micPermissionPromise = navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        // Immediately stop the tracks: we only want the permission grant, not an always-on mic.
                        // Keeping a live stream makes the browser show "microphone in use" even when not recording.
                        try { stream.getTracks().forEach(t => t.stop()); } catch (_) { }
                        this.state.settings.sttPermissionWarmed = true;
                        Storage.setSettings(this.state.settings);
                        return true;
                    })
                    .finally(() => {
                        this.state.micPermissionPromise = null;
                    });
                return this.state.micPermissionPromise;
            },
            warmMicStreamForAi() {
                // Only warm when explicitly requested elsewhere; avoid auto prompts on load
                if (this.state.micPermissionPromise) return;
                this.ensureMicPermission().catch(() => { /* permission denied handled later */ });
            },
            isSttEnabled() {
                return !!this.state.settings.sttProvider;
            },
            stopMicActivity(hideFeedback = false) {
                const hadActive = this.isMicActive() || !!this.state.activeAudioStream;
                try {
                    if (this.state.activeAudioStream) {
                        this.state.activeAudioStream.getTracks().forEach(t => t.stop());
                        this.state.activeAudioStream = null;
                    }
                } catch (_) { this.state.activeAudioStream = null; }
                try {
                    if (this.state.currentRecorder && typeof this.state.currentRecorder.stop === 'function') {
                        // SpeechRecognition can keep the system mic indicator on until it fully ends;
                        // abort() is the most reliable way to release immediately.
                        if (typeof this.state.currentRecorder.abort === 'function') {
                            try { this.state.currentRecorder.abort(); } catch (_) { }
                        } else {
                            this.state.currentRecorder.stop();
                        }
                    }
                } catch (_) { }
                try {
                    if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                        this.mediaRecorder.stop();
                    }
                } catch (_) { }
                this.state.currentRecorder = null;
                this.mediaRecorder = null;
                // Preserve `userStoppedMic` while async onend/onstop handlers run (cloud STT uses it).
                // If nothing was active, clear it to avoid stale UI state.
                if (!hadActive) this.state.userStoppedMic = false;
                this.state.activeMicButton = null;
                if (hideFeedback) {
                    const feedback = el('#aiFeedback');
                    if (feedback) { feedback.classList.add('hidden'); feedback.innerHTML = ''; }
                }
                this.setMicVisualState(false);
                this.setAiControlsLocked(this.state.aiLocked);
                this.updateMobileFab();
            },
            async getMicStream() {
                // Request a fresh stream for actual recording; do not keep the mic open between actions.
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Error('Microphone unsupported');
                return navigator.mediaDevices.getUserMedia({ audio: true });
            },
            isMicActive() {
                return !!this.state.currentRecorder || (this.mediaRecorder && this.mediaRecorder.state === 'recording');
            },
            toggleMicRecording() {
                const isAiMode = this.isAiModeUsable();
                if (!isAiMode || !this.isSttEnabled() || this.state.answerRevealed || this.state.aiLocked) return;

                if (this.isMicActive()) {
                    const feedback = el('#aiFeedback');
                    if (feedback) {
                        const txt = (feedback.textContent || '').toLowerCase();
                        if (txt.includes('listening') || txt.includes('recording')) {
                            feedback.classList.remove('hidden');
                            feedback.innerHTML = 'Captured. Now send.';
                        }
                    }
                    this.stopMicActivity(false);
                    return;
                }

                this.recordAnswer();
            },
            setMicVisualState(listening) {
                const micBtn = el('#aiRecord');
                const fabMic = el('#fabMic');
                const buttons = [micBtn, fabMic];
                // Reset all
                buttons.forEach(btn => {
                    if (!btn) return;
                    btn.classList.remove('ring', 'ring-dull-purple', 'ring-offset-2', 'animate-pulse', 'bg-dull-purple/20');
                });
                if (!listening) return;
                const target = this.state.activeMicButton === 'fab' ? fabMic : micBtn || fabMic;
                if (!target) return;
                target.classList.add('ring', 'ring-dull-purple', 'ring-offset-2', 'animate-pulse', 'bg-dull-purple/20');
            },
            setAiControlsLocked(locked) {
                if (!locked && this.state.lockAiUntilNextCard && !this.state.answerRevealed) {
                    locked = true;
                }
                this.state.aiLocked = locked;
                const sendBtn = el('#aiSubmit');
                const micBtn = el('#aiRecord');
                const fabMic = el('#fabMic');
                const fabSend = el('#fabSend');
                const isAiMode = this.isAiModeUsable();
                const sttEnabled = this.isSttEnabled();
                const listening = this.isMicActive();
                const answerField = el('#aiAnswer');
                const lockInput = isAiMode && locked;
                if (sendBtn) {
                    sendBtn.disabled = locked || sendBtn.dataset.empty === '1';
                    sendBtn.classList.toggle('opacity-50', sendBtn.disabled);
                    sendBtn.classList.toggle('cursor-not-allowed', sendBtn.disabled);
                    sendBtn.classList.toggle('hidden', isAiMode && locked);
                }
                if (micBtn) {
                    micBtn.disabled = locked;
                    micBtn.classList.toggle('opacity-50', micBtn.disabled);
                    micBtn.classList.toggle('cursor-not-allowed', micBtn.disabled);
                    micBtn.classList.toggle('hidden', isAiMode && (locked || !sttEnabled));
                }
                if (answerField) {
                    answerField.disabled = lockInput;
                    answerField.readOnly = lockInput;
                    answerField.classList.toggle('pointer-events-none', lockInput);
                    answerField.classList.toggle('opacity-60', lockInput);
                }
                if (fabMic) {
                    fabMic.disabled = locked;
                    fabMic.classList.toggle('opacity-50', fabMic.disabled);
                    fabMic.classList.toggle('cursor-not-allowed', fabMic.disabled);
                    fabMic.classList.toggle('hidden', isAiMode && (locked || !sttEnabled));
                }
                if (fabSend) {
                    fabSend.disabled = locked || (sendBtn && sendBtn.dataset.empty === '1');
                    fabSend.classList.toggle('opacity-50', fabSend.disabled);
                    fabSend.classList.toggle('cursor-not-allowed', fabSend.disabled);
                }
                this.setMicVisualState(listening);
                this.updateMobileFab();
            },
            generateCardQueue(deckIds, includeNonDue = false) {
                const selectedDeckIds = (deckIds || []).filter(id => !!this.deckById(id));
                if (selectedDeckIds.length === 0) return [];

                const candidateCards = this.state.cards.filter(c =>
                    selectedDeckIds.includes(c.deckId) &&
                    this.passFilters(c) &&
                    (includeNonDue || this.isDue(c))
                );

                if (candidateCards.length === 0) return [];

                const isNewCard = (card) => {
                    const lastReview = card.fsrs?.lastReview || card.sm2?.lastReview || null;
                    const hasHistory = Array.isArray(card.reviewHistory) && card.reviewHistory.length > 0;
                    const reps = card.sm2?.repetitions ?? 0;
                    return !lastReview && !hasHistory && reps === 0;
                };

                const shuffleInPlace = (arr) => {
                    for (let i = arr.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                };

                const applyOrderForDeck = (arr, deck) => {
                    const mode = deck?.orderMode || 'none';
                    if (mode === 'created') {
                        arr.sort((a, b) => {
                            const aKey = a.createdAt || a.id || '';
                            const bKey = b.createdAt || b.id || '';
                            return aKey.localeCompare(bKey);
                        });
                        return;
                    }
                    if (mode === 'property') {
                        const maxVal = Number.MAX_SAFE_INTEGER;
                        arr.sort((a, b) => {
                            const aOrder = typeof a.order === 'number' ? a.order : maxVal;
                            const bOrder = typeof b.order === 'number' ? b.order : maxVal;
                            if (aOrder === bOrder) {
                                const aKey = a.createdAt || a.id || '';
                                const bKey = b.createdAt || b.id || '';
                                return aKey.localeCompare(bKey);
                            }
                            return aOrder - bOrder;
                        });
                        return;
                    }
                    // Default: shuffle within that deck (so mixed sessions can still interleave).
                    shuffleInPlace(arr);
                };

                // Interleave multiple per-deck sequences while preserving the relative order within each deck.
                // This gives "mixed sessions" where deck-specific ordering is respected but decks are blended.
                const interleavePreservingOrder = (deckToArr) => {
                    const ids = Object.keys(deckToArr || {}).filter(id => Array.isArray(deckToArr[id]) && deckToArr[id].length > 0);
                    if (ids.length === 0) return [];
                    const remaining = new Map(ids.map(id => [id, deckToArr[id].slice()]));
                    const out = [];
                    while (true) {
                        const choices = ids.filter(id => (remaining.get(id) || []).length > 0);
                        if (choices.length === 0) break;
                        let total = 0;
                        for (const id of choices) total += remaining.get(id).length;
                        let r = Math.random() * total;
                        let chosen = choices[0];
                        for (const id of choices) {
                            r -= remaining.get(id).length;
                            if (r <= 0) { chosen = id; break; }
                        }
                        out.push(remaining.get(chosen).shift());
                    }
                    return out;
                };

                const reviewBuckets = {};
                const newBuckets = {};
                const allBuckets = {};

                for (const deckId of selectedDeckIds) {
                    const deck = this.deckById(deckId);
                    const deckCards = candidateCards.filter(c => c.deckId === deckId);
                    if (deckCards.length === 0) continue;

                    if (includeNonDue) {
                        // Practice mode: cap per deck using reviewLimit, preserve deck-specific ordering.
                        const limit = Math.max(0, deck?.reviewLimit ?? 50);
                        const arr = deckCards.slice();
                        applyOrderForDeck(arr, deck);
                        allBuckets[deckId] = arr.slice(0, limit);
                    } else {
                        // Due-only: cap per deck with separate review vs new limits.
                        const reviewLimit = Math.max(0, deck?.reviewLimit ?? 50);
                        const newLimit = Math.max(0, deck?.newLimit ?? 20);
                        const newCards = deckCards.filter(isNewCard);
                        const reviewCards = deckCards.filter(c => !isNewCard(c));
                        applyOrderForDeck(reviewCards, deck);
                        applyOrderForDeck(newCards, deck);
                        reviewBuckets[deckId] = reviewCards.slice(0, reviewLimit);
                        newBuckets[deckId] = newCards.slice(0, newLimit);
                    }
                }

                const chosen = includeNonDue
                    ? interleavePreservingOrder(allBuckets)
                    : [...interleavePreservingOrder(reviewBuckets), ...interleavePreservingOrder(newBuckets)];

                // Pre-compute reverse decisions PER-CARD based on its own deck's settings.
                return chosen.map(card => {
                    const deck = this.deckById(card.deckId);
                    const typeKey = (card.type || '').toLowerCase();
                    const isCloze = typeKey === 'cloze';
                    const isFrontStyle = typeKey.includes('front');
                    // Never reverse cloze cards. Reverse only if the source deck enables it.
                    const shouldReverse = !isCloze && !!deck?.reverse && isFrontStyle && Math.random() < 0.5;
                    return { cardId: card.id, reversed: shouldReverse };
                });
            },
            startSession() {
                // Default to all decks if none selected
                let deckIds = this.state.filters.studyDecks || [];
                if (deckIds.length === 0) {
                    deckIds = this.state.decks.map(d => d.id);
                }
                if (deckIds.length === 0) {
                    toast('No decks available');
                    return;
                }

                // Check card selection mode (due only vs all)
                const cardSelectionMode = el('#cardSelectionMode')?.value || 'due';
                let revisionMode = el('#revisionMode')?.value || 'manual';

                if (revisionMode === 'ai' && !navigator.onLine) {
                    revisionMode = 'manual';
                    toast('Offline: switched to Manual mode');
                }

                const includeNonDue = cardSelectionMode === 'all';
                const noScheduleChanges = includeNonDue
                    ? (el('#noScheduleChanges')?.checked ?? true)
                    : false;

                const cardQueue = this.generateCardQueue(deckIds, includeNonDue);
                if (cardQueue.length === 0) {
                    toast(includeNonDue ? 'No cards in selected decks' : 'No due cards in selected decks');
                    return;
                }

                const deck = this.deckById(deckIds[0]);
                this.state.session = {
                    id: 'session_' + Date.now(),
                    startedAt: new Date().toISOString(),
                    startTime: Date.now(),
                    deckIds: deckIds,
                    algorithm: deck?.algorithm || 'SM-2',
                    settings: {
                        revisionMode: revisionMode,
                        cardSelectionMode: cardSelectionMode,
                        filters: { ...this.state.filters }
                    },
                    cardQueue: cardQueue,
                    currentIndex: 0,
                    completed: [],
                    skipped: [],
                    studyingNonDue: includeNonDue,
                    ratingCounts: { Again: 0, Hard: 0, Good: 0, Easy: 0 },
                    noScheduleChanges
                };

                this.saveSession();
                this.renderStudy();
                toast(`Session started: ${cardQueue.length} cards`);
            },
            abandonSession() {
                this.state.session = null;
                this.saveSession();
                this.renderStudy();
                toast('Session stopped');
                if (this.state.queue.length > 0) this.requestAutoSyncSoon(200, 'session-end');
            },
            getSessionCard() {
                const session = this.state.session;
                if (!session || session.currentIndex >= session.cardQueue.length) {
                    return null;
                }
                const queueItem = session.cardQueue[session.currentIndex];
                return {
                    card: this.cardById(queueItem.cardId),
                    reversed: queueItem.reversed
                };
            },
            advanceSession(wasSkipped = false) {
                const session = this.state.session;
                if (!session) return;

                const queueItem = session.cardQueue[session.currentIndex];
                if (queueItem) {
                    if (wasSkipped) {
                        session.skipped.push(queueItem.cardId);
                    } else {
                        session.completed.push(queueItem.cardId);
                    }
                }

                session.currentIndex++;
                this.saveSession();

                // Add fade transition between cards
                const cardFront = el('#cardFront');
                const cardBack = el('#cardBack');
                if (cardFront) cardFront.classList.add('card-transitioning');
                if (cardBack) cardBack.classList.add('card-transitioning');

                setTimeout(() => {
                    // Check if session is complete
                    if (session.currentIndex >= session.cardQueue.length) {
                        this.renderSessionComplete();
                    } else {
                        this.renderStudy();
                    }
                    if (cardFront) cardFront.classList.remove('card-transitioning');
                    if (cardBack) cardBack.classList.remove('card-transitioning');
                }, 150);
            },
            renderSessionComplete() {
                const session = this.state.session;
                if (!session) return;

                const completedCount = session.completed.length;
                const skippedCount = session.skipped.length;

                // Calculate session statistics
                const durationMs = Date.now() - (session.startTime || Date.now());
                const durationMins = Math.round(durationMs / 60000);
                const cardsPerMin = durationMins > 0 ? (completedCount / durationMins).toFixed(1) : completedCount;
                const ratings = session.ratingCounts || { Again: 0, Hard: 0, Good: 0, Easy: 0 };
                const totalRatings = ratings.Again + ratings.Hard + ratings.Good + ratings.Easy;

                // Update session UI to show completion state
                const activeBar = el('#sessionActiveBar');
                const progressText = el('#sessionProgressText');
                if (activeBar) {
                    progressText.textContent = `Study Session - Complete!`;
                }

                // Hide mobile FAB since session is complete (showing stats)
                this.updateMobileFab();

                // Hide all study controls
                const studyControls = el('#studyControls');
                if (studyControls) studyControls.classList.add('hidden');
                const revealBtn = el('#revealBtn');
                if (revealBtn) revealBtn.classList.add('hidden');
                const addNoteBtn = el('#addNoteBlock');
                if (addNoteBtn) addNoteBtn.classList.add('hidden');
                const copyBtn = el('#copyCardContent');
                if (copyBtn) copyBtn.classList.add('hidden');
                const notesSection = el('#notesSection');
                if (notesSection) notesSection.classList.add('hidden');

                // Calculate percentages for positioning
                const againPct = totalRatings > 0 ? (ratings.Again / totalRatings * 100) : 0;
                const hardPct = totalRatings > 0 ? (ratings.Hard / totalRatings * 100) : 0;
                const goodPct = totalRatings > 0 ? (ratings.Good / totalRatings * 100) : 0;
                const easyPct = totalRatings > 0 ? (ratings.Easy / totalRatings * 100) : 0;

                // Build rating distribution bar with aligned numbers
                const ratingBar = totalRatings > 0 ? `
                    <div class="flex w-full h-2 rounded-full overflow-hidden bg-oatmeal-dark/30 dark:bg-white/10 mt-2">
                        ${ratings.Again > 0 ? `<div class="bg-red-400 dark:bg-red-700" style="width: ${againPct}%"></div>` : ''}
                        ${ratings.Hard > 0 ? `<div class="bg-orange-400 dark:bg-orange-700" style="width: ${hardPct}%"></div>` : ''}
                        ${ratings.Good > 0 ? `<div class="bg-green-400 dark:bg-green-700" style="width: ${goodPct}%"></div>` : ''}
                        ${ratings.Easy > 0 ? `<div class="bg-blue-400 dark:bg-blue-700" style="width: ${easyPct}%"></div>` : ''}
                    </div>
                    <div class="flex w-full text-[10px] mt-1">
                        ${ratings.Again > 0 ? `<span class="text-red-500 dark:text-red-200 text-center" style="width: ${againPct}%">${ratings.Again}</span>` : ''}
                        ${ratings.Hard > 0 ? `<span class="text-orange-500 dark:text-orange-200 text-center" style="width: ${hardPct}%">${ratings.Hard}</span>` : ''}
                        ${ratings.Good > 0 ? `<span class="text-green-500 dark:text-green-200 text-center" style="width: ${goodPct}%">${ratings.Good}</span>` : ''}
                        ${ratings.Easy > 0 ? `<span class="text-blue-500 dark:text-blue-200 text-center" style="width: ${easyPct}%">${ratings.Easy}</span>` : ''}
                    </div>
                ` : '';

                el('#studyDeckLabel').textContent = 'Session Complete';
                el('#cardFront').innerHTML = `
                    <div class="text-center py-4 md:py-6">
                        <h3 class="font-display text-base md:text-lg text-charcoal mb-1">Session Complete</h3>
                        <p class="text-earth-metal/60 text-xs md:text-sm">
                            ${completedCount} card${completedCount !== 1 ? 's' : ''} reviewed${skippedCount > 0 ? `, ${skippedCount} skipped` : ''}
                        </p>
                        <p class="text-earth-metal/50 dark:text-white/60 text-[10px] md:text-xs mb-3">
                            ${durationMins > 0 ? `${durationMins} min` : '<1 min'} Â· ${cardsPerMin} cards/min
                        </p>
                        <div class="max-w-[200px] mx-auto mb-4">
                            ${ratingBar}
                        </div>
                        <div class="flex flex-col gap-3 items-center">
                            <div class="flex flex-col items-center">
                                <button id="restartAllCardsBtn" class="px-4 py-2 bg-dull-purple text-white rounded-lg text-sm hover:bg-dull-purple/90 transition">
                                    Restart
                                </button>
                                <label class="flex items-center gap-2 text-[11px] text-earth-metal/70 mt-2">
                                    <input id="restartNoScheduleChanges" type="checkbox" class="accent-dull-purple" checked>
                                    <span>No scheduling changes</span>
                                </label>
                                <p class="text-[10px] md:text-xs text-earth-metal/50 dark:text-white/60 mt-1">Restart with all cards in selected decks</p>
                            </div>
                            <button id="endSessionBtn" class="px-4 py-2 border border-oatmeal-dark/60 text-earth-metal/70 rounded-lg text-sm hover:bg-oatmeal/50 transition">
                                End Session
                            </button>
                        </div>
                    </div>
                `;
                el('#cardBack').innerHTML = '';
                el('#cardBack').classList.add('hidden');
                this.state.selectedCard = null;
                this.setRatingEnabled(false);

                // Bind completion buttons
                setTimeout(() => {
                    const restartBtn = el('#restartAllCardsBtn');
                    const endBtn = el('#endSessionBtn');
                    if (restartBtn) restartBtn.onclick = () => this.restartWithAllCards();
                    if (endBtn) endBtn.onclick = () => this.abandonSession();
                }, 0);
            },
            restartWithAllCards() {
                const session = this.state.session;
                if (!session) return;

                const previewCheckbox = el('#restartNoScheduleChanges');
                const noScheduleChanges = previewCheckbox ? previewCheckbox.checked : true;
                const cardQueue = this.generateCardQueue(session.deckIds, true);
                if (cardQueue.length === 0) {
                    toast('No cards available');
                    this.abandonSession();
                    return;
                }

                session.cardQueue = cardQueue;
                session.currentIndex = 0;
                session.completed = [];
                session.skipped = [];
                session.studyingNonDue = true;
                session.noScheduleChanges = noScheduleChanges;
                if (session.settings) session.settings.cardSelectionMode = 'all';
                this.saveSession();
                this.renderStudy();
                toast(`Practicing ${cardQueue.length} cards`);
            },
            captureOAuth() {
                const hashParams = new URLSearchParams(location.hash.replace('#', '?'));
                const searchParams = new URLSearchParams(location.search);
                const token = hashParams.get('token') || searchParams.get('token') || searchParams.get('accessToken');
                if (token) {
                    this.state.settings.authToken = token;
                    this.state.authVerified = true;
                    this.state.settings.authVerified = true;
                    Storage.setSettings(this.state.settings);
                    toast('Notion token captured');
                    history.replaceState({}, document.title, location.pathname);
                    this.openSettings();
                    if (this.state.settings.workerUrl) {
                        this.scanSources();
                    } else {
                        toast('Add worker URL then scan sources');
                    }
                }
            },
            async loadFromDB() {
                this.state.decks = (await Storage.getAll('decks')).map(d => ({
                    ...d,
                    orderMode: d.orderMode || (d.ordered ? 'created' : 'none') || 'none',
                    aiPrompt: d.aiPrompt || DEFAULT_AI_PROMPT,
                    fsrsDesiredRetention: clampRetention(d.fsrsDesiredRetention ?? DEFAULT_DESIRED_RETENTION),
                    fsrsWeights: Array.isArray(d.fsrsWeights) && d.fsrsWeights.length === 21 ? d.fsrsWeights : (d.fsrsWeights || null)
                }));
                this.state.cards = await Storage.getAll('cards');
                this.state.queue = (await Storage.getMeta('queue')) || [];
                this.state.lastQueueError = (await Storage.getMeta('lastQueueError')) || null;
                this.state.queueLastChangedAt = (await Storage.getMeta('queueLastChangedAt')) || null;
                const meta = await Storage.getAll('meta');
                const last = meta.find(m => m.key === 'lastSync');
                if (last) this.state.lastSync = last.value;
                const lp = meta.find(m => m.key === 'lastPull');
                if (lp) this.state.lastPull = lp.value;
                const lpush = meta.find(m => m.key === 'lastPush');
                if (lpush) this.state.lastPush = lpush.value;
                const tagMeta = meta.find(m => m.key === 'tagOptions');
                if (tagMeta && Array.isArray(tagMeta.value)) this.state.tagOptions = tagMeta.value;
            },
            async seedIfEmpty() {
                return;
            },
            newDeck(name, algorithm = 'SM-2') {
                return {
                    id: crypto.randomUUID(),
                    notionId: null,
                    name,
                    algorithm,
                    reviewLimit: 50,
                    newLimit: 20,
                    reverse: false,
                    createdInApp: true,
                    updatedInApp: true,
                    aiPrompt: DEFAULT_AI_PROMPT,
                    aiProvider: '',
                    aiModel: '',
                    aiKey: '',
                    orderMode: 'none',
                    fsrsDesiredRetention: DEFAULT_DESIRED_RETENTION,
                    fsrsWeights: null
                };
            },
            newCard(deckId, name, back, type) {
                const now = new Date().toISOString();
                return {
                    id: crypto.randomUUID(),
                    notionId: null,
                    deckId,
                    name,
                    back,
                    type,
                    tags: [],
                    notes: '',
                    suspended: false,
                    leech: false,
                    order: null,
                    fsrs: { difficulty: 4, stability: 1, retrievability: 0.9, lastRating: null, lastReview: null, dueDate: now },
                    sm2: { interval: 1, easeFactor: 2.5, dueDate: now },
                    syncId: crypto.randomUUID(),
                    updatedInApp: true,
                    reviewHistory: [],
                    createdAt: now
                };
            },
            bind() {
                el('#syncNowBtn').onclick = () => this.syncNow();
                // Tab navigation
                document.querySelectorAll('.tab-btn').forEach(btn => btn.onclick = () => this.switchTab(btn.dataset.tab));
                document.querySelectorAll('.theme-btn').forEach(btn => btn.onclick = () => {
                    this.state.settings.themeMode = btn.dataset.theme;
                    Storage.setSettings(this.state.settings);
                    this.applyTheme();
                });
                document.querySelectorAll('.font-btn').forEach(btn => btn.onclick = () => {
                    this.state.settings.fontMode = btn.dataset.font;
                    Storage.setSettings(this.state.settings);
                    this.applyFontMode();
                });
                el('#newDeckBtn').onclick = () => this.openDeckModal();
                el('#refreshDecksBtn').onclick = () => this.manualSync();
                el('#closeDeckModal').onclick = () => this.closeDeckModal();
                el('#saveDeckBtn').onclick = () => this.saveDeckFromModal();
                el('#archiveDeckBtn').onclick = () => this.archiveDeckFromModal();
                el('#deckAlgoInput').onchange = (e) => {
                    const isFsrs = e.target.value === 'FSRS';
                    el('#fsrsParamsField')?.classList.toggle('hidden', !isFsrs);
                };
                el('#newCardBtn').onclick = () => this.openCardModal();
                el('#resetAlgorithmBtn').onclick = () => this.openResetAlgorithmModal();
                el('#cancelResetAlgorithm').onclick = () => this.closeModal('resetAlgorithmModal');
                el('#confirmResetAlgorithm').onclick = () => this.confirmResetAlgorithm();
                el('#resetAlgorithmModal').addEventListener('click', (e) => { if (e.target === el('#resetAlgorithmModal')) this.closeModal('resetAlgorithmModal'); });
                el('#closeCardModal').onclick = () => this.closeCardModal();
                el('#saveCardBtn').onclick = () => this.saveCardFromModal();
                el('#cardTypeInput').onchange = () => this.updateCardBackVisibility();
                el('#deleteCardBtn').onclick = () => this.deleteCardFromModal();
                const cardSelectionMode = el('#cardSelectionMode');
                const noScheduleRow = el('#noScheduleRow');
                const noScheduleChk = el('#noScheduleChanges');
                const toggleNoScheduleUI = () => {
                    const isAll = cardSelectionMode.value === 'all';
                    if (noScheduleRow) {
                        noScheduleRow.classList.toggle('hidden', !isAll);
                        if (isAll && noScheduleChk) noScheduleChk.checked = true;
                        if (!isAll && noScheduleChk) noScheduleChk.checked = false;
                    }
                };
                if (cardSelectionMode) {
                    cardSelectionMode.onchange = toggleNoScheduleUI;
                    toggleNoScheduleUI();
                }
                el('#revealBtn').onclick = () => this.reveal();
                el('#skipCard').onclick = () => this.nextCard();
                el('#copyCardContent').onclick = () => this.copyCardContent();
                el('#addNoteBlock').onclick = () => this.openAddBlockModal();
                el('#closeAddBlockModal').onclick = () => this.closeModal('addBlockModal');
                el('#cancelAddBlockBtn').onclick = () => this.closeModal('addBlockModal');
                el('#saveAddBlockBtn').onclick = () => this.saveBlockNote();
                el('#blockNoteArea')?.addEventListener('input', () => this.renderBlockNotePreview());
                el('#addBlockModal').addEventListener('click', (e) => { if (e.target === el('#addBlockModal')) this.closeModal('addBlockModal'); });
                // Session control buttons
                el('#startSessionBtn').onclick = () => this.startSession();
                el('#abandonSessionBtn').onclick = () => this.abandonSession();
                document.querySelectorAll('.rate-btn').forEach(btn => btn.onclick = (e) => this.rate(e.currentTarget.dataset.rate));
                const tagInput = el('#cardTagSearch');
                const tagDropdown = el('#cardTagDropdown');
                if (tagInput) {
                    tagInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.addTagByName(tagInput.value.trim(), { toSelection: true });
                            tagInput.value = '';
                            this.renderCardTagSelectors();
                        }
                    });
                    tagInput.addEventListener('input', () => {
                        if (tagDropdown) tagDropdown.classList.remove('hidden');
                        this.renderCardTagSelectors();
                    });
                    tagInput.addEventListener('focus', () => {
                        if (tagDropdown) tagDropdown.classList.remove('hidden');
                        this.renderCardTagSelectors();
                    });
                    tagInput.addEventListener('blur', () => {
                        setTimeout(() => {
                            if (tagDropdown && !tagDropdown.matches(':hover')) tagDropdown.classList.add('hidden');
                        }, 150);
                    });
                }
                if (tagDropdown) {
                    tagDropdown.onmouseenter = () => tagDropdown.classList.remove('hidden');
                    tagDropdown.onmouseleave = () => tagDropdown.classList.add('hidden');
                }
                const refreshTagsBtn = el('#refreshTagOptionsBtn');
                if (refreshTagsBtn) refreshTagsBtn.onclick = () => this.refreshTagOptions();
                el('#cardSearchInput').oninput = (e) => { this.state.cardSearch = e.target.value; this.state.cardLimit = 50; this.renderCards(); };
                el('#libraryDeckSearch').oninput = (e) => { this.state.deckSearch = e.target.value; this.renderDecks(); };
                el('#filterAgain').onchange = (e) => { this.state.filters.again = e.target.checked; this.renderCards(); this.updateActiveFiltersCount(); };
                el('#filterHard').onchange = (e) => { this.state.filters.hard = e.target.checked; this.renderCards(); this.updateActiveFiltersCount(); };
                el('#filterAddedToday').onchange = (e) => { this.state.filters.addedToday = e.target.checked; this.renderCards(); this.updateActiveFiltersCount(); };
                // Tag filter handled via renderTagFilter()
                el('#resetFilters').onclick = () => this.resetFilters();
                const resetMobile = el('#resetFiltersMobile');
                if (resetMobile) resetMobile.onclick = () => this.resetFilters();
                const filterTagInput = el('#filterTagSearch');
                const filterTagDropdown = el('#filterTagDropdown');
                if (filterTagInput) {
                    filterTagInput.addEventListener('input', () => {
                        if (filterTagDropdown) filterTagDropdown.classList.remove('hidden');
                        this.renderTagFilter();
                    });
                    filterTagInput.addEventListener('focus', () => {
                        if (filterTagDropdown) filterTagDropdown.classList.remove('hidden');
                        this.renderTagFilter();
                    });
                    filterTagInput.addEventListener('blur', () => {
                        setTimeout(() => {
                            if (filterTagDropdown && !filterTagDropdown.matches(':hover')) filterTagDropdown.classList.add('hidden');
                        }, 150);
                    });
                }
                if (filterTagDropdown) {
                    filterTagDropdown.onmouseenter = () => filterTagDropdown.classList.remove('hidden');
                    filterTagDropdown.onmouseleave = () => filterTagDropdown.classList.add('hidden');
                }
                el('#filterSuspended').onchange = (e) => { this.state.filters.suspended = e.target.checked; this.renderCards(); this.updateActiveFiltersCount(); };
                el('#filterLeech').onchange = (e) => { this.state.filters.leech = e.target.checked; this.renderCards(); this.updateActiveFiltersCount(); };
                // Toggle filters panel
                el('#toggleFilters').onclick = () => this.toggleFiltersPanel();
                el('#ankiImportInput').onchange = (e) => this.handleAnkiImport(e.target.files[0]);
                el('#exportAnkiBtn').onclick = () => this.exportAnki();
                // Mobile menu toggle and duplicate handlers
                el('#mobileMoreBtn').onclick = () => {
                    const menu = el('#mobileMoreMenu');
                    menu.classList.toggle('hidden');
                    menu.classList.toggle('flex');
                };
                const exportMobile = el('#exportAnkiBtnMobile');
                if (exportMobile) exportMobile.onclick = () => this.exportAnki();
                const importMobile = el('#ankiImportInputMobile');
                if (importMobile) importMobile.onchange = (e) => this.handleAnkiImport(e.target.files[0]);
                this.initMobileFab();
                this.bindDeckSearch();
                // Keyboard shortcuts for study
                // Use capture to ensure we can intercept combo hotkeys even when textarea is focused.
                document.addEventListener('keydown', (e) => {
                    // Undo shortcut (Ctrl+Z or Cmd+Z) - works globally during study
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && this.state.lastRating) {
                        e.preventDefault();
                        this.undoLastRating();
                        return;
                    }
                    // Stop session via Ctrl/Cmd+. (works even when focused in textarea)
                    if ((e.ctrlKey || e.metaKey) && e.key === '.' && this.state.session) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        this.abandonSession();
                        return;
                    }
                    // Start session via Cmd/Ctrl+Enter (desktop)
                    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && !this.state.session && this.state.activeTab === 'study') {
                        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                        e.preventDefault();
                        this.startSession();
                        return;
                    }
                    if (!this.state.session || !this.state.selectedCard) return;

                    const isAiMode = this.isAiModeUsable();
                    const aiAnswer = el('#aiAnswer');
                    const hasAiText = (aiAnswer?.value || '').trim().length > 0;
                    // Option/Alt+Shift+S can produce a different printable character on macOS, so prefer physical key detection.
                    const isSkipCombo = !!(e.altKey && e.shiftKey && (
                        (e.code === 'KeyS') ||
                        ((e.key || '').toLowerCase() === 's') ||
                        e.keyCode === 83 ||
                        e.which === 83
                    ));

                    if (isSkipCombo) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        this.nextCard();
                        return;
                    }

                    // Global send in AI mode (Cmd/Ctrl+Enter) even inside textarea
                    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                        if (isAiMode && hasAiText && !this.state.aiLocked) {
                            e.preventDefault();
                            this.submitToAI();
                            return;
                        }
                        // In non-AI mode, allow reveal via Cmd/Ctrl+Enter
                        if (!this.isAiModeSelected() && !this.state.answerRevealed) {
                            e.preventDefault();
                            this.reveal();
                            return;
                        }
                    }

                    // Mic toggle via Cmd/Ctrl+E even when focused in textarea
                    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'e' && isAiMode && this.isSttEnabled() && !this.state.answerRevealed && !this.state.aiLocked) {
                        e.preventDefault();
                        this.toggleMicRecording();
                        return;
                    }

                    if (e.key === 'Escape' && this.isMicActive()) {
                        e.preventDefault();
                        this.stopMicActivity(false);
                    }

                    if ((e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') && e.key !== 'Escape') return;

                    // Space key logic
                    if (e.key === ' ' && !this.state.answerRevealed) {
                        e.preventDefault();
                        if (this.isAiModeUsable()) {
                            const btn = el('#aiSubmit');
                            // If text area has content (button enabled), Send. Otherwise do nothing.
                            if (!btn.disabled && !this.state.aiLocked) this.submitToAI();
                        } else {
                            this.reveal();
                        }
                    }

                    // Toggle Mic with Alt/Option+M in AI mode
                    if (e.altKey && e.key.toLowerCase() === 'm' && this.isAiModeUsable() && this.isSttEnabled() && !this.state.answerRevealed && !this.state.aiLocked) {
                        e.preventDefault();
                        this.toggleMicRecording();
                    }
                    if (this.state.answerRevealed) {
                        const ratings = { '1': 'Again', '2': 'Hard', '3': 'Good', '4': 'Easy' };
                        if (ratings[e.key]) this.rate(ratings[e.key]);
                    }
                    if (e.key.toLowerCase() === 's') this.nextCard();
                }, true);
                document.addEventListener('click', (e) => {
                    // Handle edit deck button click
                    const editDeckBtn = e.target.closest('.edit-deck-btn');
                    if (editDeckBtn) {
                        e.stopPropagation();
                        const deckId = editDeckBtn.dataset.deckId;
                        this.editDeck(deckId);
                        return;
                    }
                    // Handle deck selection (click on deck card)
                    const deckCard = e.target.closest('[data-deck-id]');
                    if (deckCard && !e.target.closest('.edit-card-btn') && !e.target.closest('.info-card-btn') && !e.target.closest('.edit-deck-btn') && !e.target.closest('.deck-option') && !e.target.closest('.selected-deck-pill')) {
                        this.selectDeck(deckCard.dataset.deckId);
                        return;
                    }
                    // Handle edit card button click
                    const editCardBtn = e.target.closest('.edit-card-btn');
                    if (editCardBtn) {
                        e.stopPropagation();
                        const cardId = editCardBtn.dataset.cardId;
                        this.editCard(cardId);
                        return;
                    }
                    // Handle info card button click (show review history popover)
                    const infoCardBtn = e.target.closest('.info-card-btn');
                    if (infoCardBtn) {
                        e.stopPropagation();
                        const cardId = infoCardBtn.dataset.cardId;
                        this.showReviewHistoryPopover(infoCardBtn, cardId);
                        return;
                    }
                });
                el('#openSettings').onclick = () => this.openSettings();
                el('#closeSettings').onclick = () => this.closeSettings();
                el('#saveSettings').onclick = () => this.saveSettings();
                el('#verifyWorker').onclick = () => this.verifyWorker();
                el('#verifyAuth').onclick = () => this.verifyAuth();
                el('#oauthBtn').onclick = () => { if (this.state.settings.workerUrl) this.startOAuth(); else toast('Add worker URL first'); };
                el('#scanSources').onclick = () => this.scanSources();
                el('#saveSourcesChoice').onclick = () => {
                    this.state.settings.deckSource = el('#deckSourceSelect').value;
                    this.state.settings.cardSource = el('#cardSourceSelect').value;
                    this.state.sourcesVerified = !!(this.state.settings.deckSource && this.state.settings.cardSource);
                    this.state.settings.sourcesVerified = this.state.sourcesVerified;
                    Storage.setSettings(this.state.settings);
                    this.renderStatus();
                    toast('Sources choice saved. Syncing...');
                    this.syncNow();
                };
                // Mobile FAB position picker (grid-based)
                this.bindFabPositionPicker();
                el('#openWorkerHelp').onclick = () => this.openModal('workerHelpModal');
                el('#closeWorkerHelp').onclick = () => this.closeModal('workerHelpModal');
                el('#copyWorkerCode').onclick = () => this.copyWorkerCode();
                el('#lockedOpenSettings').onclick = () => this.openSettings();
                el('#resetApp').onclick = () => this.openModal('resetConfirmModal');
                el('#cancelReset').onclick = () => this.closeModal('resetConfirmModal');
                el('#confirmReset').onclick = () => this.resetApp();
                el('#toggleDangerZone').onclick = () => this.toggleDangerZone();
                el('#resetConfirmModal').addEventListener('click', (e) => { if (e.target === el('#resetConfirmModal')) this.closeModal('resetConfirmModal'); });
                this.updateSettingsButtons();
                window.addEventListener('keydown', (e) => { if (e.key === 'Escape') { this.closeSettings(); this.closeModal('workerHelpModal'); this.closeDeckModal(); this.closeCardModal(); this.closeModal('confirmModal'); this.closeModal('aiSettingsRequiredModal'); this.closeModal('notesModal'); this.closeModal('addBlockModal'); } });
                el('#settingsModal').addEventListener('click', (e) => { if (e.target === el('#settingsModal')) this.closeSettings(); });
                el('#workerHelpModal').addEventListener('click', (e) => { if (e.target === el('#workerHelpModal')) this.closeModal('workerHelpModal'); });
                el('#revisionMode').onchange = (e) => {
                    if (e.target.value === 'ai') {
                        if (!navigator.onLine) {
                            e.target.value = 'manual';
                            this.showAiBlockedModal('offline');
                            return;
                        }
                        if (!this.state.settings.aiVerified) {
                            e.target.value = 'manual';
                            this.showAiBlockedModal('unverified');
                            return;
                        }
                        if (!this.state.settings.aiKey) {
                            e.target.value = 'manual';
                            this.showAiBlockedModal('unverified');
                            return;
                        }
                    }
                    const on = this.isAiModeUsable();
                    el('#aiControls').classList.toggle('hidden', !on);
                    this.updateSkipHotkeyLabel(on);
                    this.updateMobileFab();
                    this.renderStudy();
                };
                el('#closeAiSettingsModal').onclick = () => this.closeModal('aiSettingsRequiredModal');
                el('#openSettingsFromAiModal').onclick = () => { this.closeModal('aiSettingsRequiredModal'); this.openSettings(); };
                el('#aiSettingsRequiredModal').addEventListener('click', (e) => { if (e.target === el('#aiSettingsRequiredModal')) this.closeModal('aiSettingsRequiredModal'); });
                // Notes modal bindings
                el('#editNotesBtn').onclick = () => this.openNotesModal();
                el('#closeNotesModal').onclick = () => this.closeModal('notesModal');
                el('#cancelNotesBtn').onclick = () => this.closeModal('notesModal');
                el('#saveNotesBtn').onclick = () => this.saveNotes();
                el('#notesModal').addEventListener('click', (e) => { if (e.target === el('#notesModal')) this.closeModal('notesModal'); });
                el('#verifyAi').onclick = () => this.verifyAiSettings();
                el('#verifyStt').onclick = () => this.verifySttSettings();
                el('#aiSubmit').onclick = () => this.submitToAI();
                el('#aiAnswer').oninput = (e) => {
                    const btn = el('#aiSubmit');
                    const hasText = e.target.value.trim().length > 0;
                    btn.dataset.empty = hasText ? '0' : '1';
                    this.setAiControlsLocked(this.state.aiLocked);
                };
                el('#aiRecord').onclick = () => {
                    if (!this.isAiModeUsable() || !this.isSttEnabled() || this.state.answerRevealed || this.state.aiLocked) return;
                    this.state.activeMicButton = 'inline';
                    this.toggleMicRecording();
                };
                const fabMic = el('#fabMic');
                const fabSend = el('#fabSend');
                if (fabMic) fabMic.onclick = () => {
                    if (!this.isAiModeUsable() || !this.isSttEnabled() || this.state.answerRevealed || this.state.aiLocked) return;
                    this.state.activeMicButton = 'fab';
                    this.toggleMicRecording();
                };
                if (fabSend) fabSend.onclick = () => { if (!this.state.aiLocked) this.submitToAI(); };
                el('#confirmDelete').onclick = () => this.performDelete();
                el('#cancelDelete').onclick = () => this.closeModal('confirmModal');
                el('#confirmModal').addEventListener('click', (e) => { if (e.target === el('#confirmModal')) this.closeModal('confirmModal'); });
                el('#deckModal').addEventListener('click', (e) => { if (e.target === el('#deckModal')) this.closeDeckModal(); });
                el('#cardModal').addEventListener('click', (e) => { if (e.target === el('#cardModal')) this.closeCardModal(); });
            },
            renderAll() {
                this.renderDecks();
                this.renderCards();
                this.renderConnection();
                this.renderStudy();
                this.renderStudyDeckSelection();
                this.renderTagFilter();
                this.updateCounts();
                this.populateSourceSelects();
                this.renderGate();
                this.renderStatus();
                this.renderSelectedDeckBar();
                this.updateActiveFiltersCount();
                lucide.createIcons();
                this.loadAISettings();
                // Show/hide STT settings based on whether AI is verified
                const isAiVerified = this.state.settings?.aiVerified;
                el('#sttSettings')?.classList.toggle('hidden', !isAiVerified);
                // Update hotkey labels based on platform
                const sendHotkey = el('#aiSendHotkey');
                const ctrlSymbol = isMac ? 'âŒ˜' : 'âŒƒ';
                const enterSymbol = 'â†µ';
                if (sendHotkey) sendHotkey.textContent = `${ctrlSymbol} ${enterSymbol}`;
                const micHotkey = el('#micHotkey');
                if (micHotkey) micHotkey.textContent = `${ctrlSymbol} E`;
                const startHotkey = el('#startSessionHotkey');
                if (startHotkey) startHotkey.textContent = `${ctrlSymbol} ${enterSymbol}`;
                const stopHotkey = el('#stopSessionHotkey');
                if (stopHotkey) stopHotkey.textContent = `${ctrlSymbol} .`;
            },
            // Tab switching
            switchTab(tab) {
                // Block library access during active study session
                if (tab === 'library' && this.state.session) {
                    toast('Please stop your study session first to access the library');
                    return;
                }
                document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                const tabEl = el(`#${tab}Tab`);
                if (tabEl) tabEl.classList.remove('hidden');
                const btnEl = el(`[data-tab="${tab}"]`);
                if (btnEl) btnEl.classList.add('active');
                this.state.activeTab = tab;
                lucide.createIcons();
            },
            // Toggle filters panel
            toggleFiltersPanel() {
                const content = el('#filtersContent');
                const chevron = el('#filtersChevron');
                const text = el('#moreOptionsText');
                const isHidden = content && content.classList.contains('hidden');
                if (content) content.classList.toggle('hidden');
                if (chevron) chevron.style.transform = isHidden ? 'rotate(180deg)' : '';
                if (text) text.textContent = isHidden ? 'Less options' : 'More options';
            },
            // Update active filters count (for reset button visibility)
            updateActiveFiltersCount() {
                const f = this.state.filters;
                let count = 0;
                if (f.again) count++;
                if (f.hard) count++;
                if (f.addedToday) count++;
                if (f.tags && f.tags.length > 0) count++;
                if (f.suspended) count++;
                if (f.leech) count++;
                if (f.studyDecks && f.studyDecks.length > 0) count++;
                // Show reset button if any filters are active
                const resetBtn = el('#resetFilters');
                if (resetBtn) {
                    resetBtn.classList.toggle('hidden', count === 0);
                }
            },
            // Render selected deck bar
            renderSelectedDeckBar() {
                const deck = this.state.selectedDeck;
                const nameEl = el('#selectedDeckName');
                const newCardBtn = el('#newCardBtn');
                const resetBtn = el('#resetAlgorithmBtn');
                const cardsContent = el('#cardsContent');
                const footer = el('#footerAttribution');
                if (deck) {
                    if (nameEl) nameEl.textContent = deck.name;
                    if (newCardBtn) newCardBtn.classList.remove('hidden');
                    if (resetBtn) resetBtn.classList.remove('hidden');
                    if (cardsContent) cardsContent.classList.remove('hidden');
                    if (footer) footer.classList.remove('hidden');
                } else {
                    if (nameEl) nameEl.textContent = 'Select a deck above';
                    if (newCardBtn) newCardBtn.classList.add('hidden');
                    if (resetBtn) resetBtn.classList.add('hidden');
                    if (cardsContent) cardsContent.classList.add('hidden');
                    if (footer) footer.classList.add('hidden');
                }
            },
            renderGate() {
                const ready = this.isReady();
                el('#mainContent').style.display = ready ? 'block' : 'none';
                el('#lockedOverlay').classList.toggle('hidden', ready);
                const oauth = el('#oauthBtn');
                const verifyAuthBtn = el('#verifyAuth');
                const tokenInput = el('#settingAuthToken');
                if (oauth) oauth.disabled = !this.state.settings.workerUrl;
                if (verifyAuthBtn) verifyAuthBtn.disabled = !this.state.settings.workerUrl;
                if (tokenInput) tokenInput.disabled = !this.state.settings.workerUrl;
                this.updateSettingsButtons();
            },
            renderConnection() {
                const badge = el('#connectionBadge');
                const online = navigator.onLine;
                const hasWorkerUrl = !!this.state.settings.workerUrl;
                const workerOk = hasWorkerUrl && this.state.workerVerified;
                const hasToken = !!this.state.settings.authToken;
                const authOk = workerOk && hasToken;
                const ready = online && workerOk && authOk;

                const q2count = (this.state.queue || []).length;
                const pendingSpan = q2count > 0
                    ? ` <span class="ml-1 font-mono text-[10px] sm:text-[11px] text-dull-purple/80 dark:text-dull-purple/90">(${q2count})</span>`
                    : '';
                const q2ind = el('#q2syncIndicator');
                const q2val = el('#q2syncCount');
                if (q2ind && q2val) {
                    q2val.textContent = String(q2count);
                    q2ind.classList.toggle('hidden', q2count === 0);
                }

                // Tooltip/diagnostics for stuck queues (best-effort).
                const ageMs = this.state.queueLastChangedAt ? (Date.now() - new Date(this.state.queueLastChangedAt).getTime()) : 0;
                const staleMinutes = ageMs > 0 ? Math.floor(ageMs / 60000) : 0;
                const errorMsg = this.state.lastQueueError?.message || '';
                const errorAt = this.state.lastQueueError?.at ? new Date(this.state.lastQueueError.at).toLocaleString() : '';
                badge.title = '';
                if (q2count > 0) {
                    const parts = [];
                    if (staleMinutes >= 2) parts.push(`Queue unchanged for ~${staleMinutes} min`);
                    if (errorMsg) parts.push(`Last sync error${errorAt ? ` (${errorAt})` : ''}: ${errorMsg}`);
                    if (parts.length) badge.title = parts.join('\n');
                }

                if (!online) {
                    badge.innerHTML = `Offline${pendingSpan}`;
                    badge.className = 'px-3 py-1 rounded-full pill text-xs bg-oatmeal border border-oatmeal-dark text-earth-metal';
                    this.updateSyncButtonState();
                    return;
                }

                if (!hasWorkerUrl) {
                    badge.innerHTML = `Online Â· add worker URL${pendingSpan}`;
                } else if (!workerOk) {
                    badge.innerHTML = `Online Â· verify worker${pendingSpan}`;
                } else if (!hasToken) {
                    badge.innerHTML = `Online Â· set token${pendingSpan}`;
                } else if (!authOk) {
                    badge.innerHTML = `Online Â· verify token${pendingSpan}`;
                } else {
                    badge.innerHTML = q2count > 0 ? `Online${pendingSpan}` : 'Online Â· Notion ready';
                }
                badge.className = ready
                    ? 'px-3 py-1 rounded-full pill text-xs bg-white-linen border border-oatmeal-dark text-earth-metal'
                    : 'px-3 py-1 rounded-full pill text-xs bg-oatmeal border border-oatmeal-dark text-earth-metal';
                this.updateSyncButtonState();
            },
            renderDecks() {
                const grid = el('#deckGrid');
                const theme = document.body.getAttribute('data-theme') || 'light';
                const selectedId = this.state.selectedDeck?.id;
                const searchQuery = (this.state.deckSearch || '').toLowerCase().trim();
                let decks = this.state.decks;
                if (searchQuery) {
                    decks = decks.filter(d => d.name.toLowerCase().includes(searchQuery));
                }
                if (decks.length === 0) {
                    grid.innerHTML = `<p class="text-earth-metal/60 text-sm col-span-full text-center py-4">${searchQuery ? 'No decks match your search.' : 'No decks yet. Click "New deck" to create one.'}</p>`;
                    return;
                }
                grid.innerHTML = decks.map(d => {
                    const isSelected = d.id === selectedId;
                    const selectedClass = isSelected ? 'ring-2 ring-dull-purple' : '';
                    return `
                    <article class="rounded-2xl border border-[color:var(--card-border)] p-3 bg-[color:var(--surface)] text-[color:var(--text-main)] flex flex-col gap-2 hover:bg-[color:var(--surface-strong)] transition cursor-pointer ${selectedClass}" data-deck-id="${d.id}">
                        <div class="flex items-center justify-between">
                            <p class="font-semibold text-[color:var(--text-main)] truncate flex-1">${escapeHtml(d.name)}</p>
                            <div class="flex items-center gap-1.5">
                                <button class="edit-deck-btn p-1 rounded hover:bg-dull-purple/20 text-dull-purple" data-deck-id="${d.id}" title="Edit deck">
                                    <i data-lucide="edit-2" class="w-3.5 h-3.5 pointer-events-none"></i>
                                </button>
                                <span class="text-[11px] px-2 py-1 rounded-full bg-[color:var(--surface-strong)] text-[color:var(--text-main)] border border-[color:var(--card-border)]">${d.algorithm}</span>
                            </div>
                        </div>
                        <div class="flex items-center gap-3 text-xs text-[color:var(--text-sub)]">
                            <span>${this.cardsForDeck(d.id).filter(c => this.isDue(c)).length} due</span>
                            <span>${this.cardsForDeck(d.id).length} cards</span>
                        </div>
                        <div class="flex items-center gap-2 text-[11px] text-[color:var(--text-sub)]">
                            <i data-lucide="refresh-cw" class="w-3 h-3"></i>
                            <span>Reverse ${d.reverse ? 'on' : 'off'}</span>
                        </div>
                        <div class="flex items-center gap-2 text-[11px] text-[color:var(--text-sub)]">
                            <i data-lucide="list-ordered" class="w-3 h-3"></i>
                            <span>Order: ${(d.orderMode === 'created' && 'Created Time') || (d.orderMode === 'property' && 'Order Property') || 'None'}</span>
                        </div>
                    </article>
                `}).join('');
                lucide.createIcons();
            },
            renderCards() {
                const tbody = el('#cardTable');
                const noCardsMsg = el('#noCardsMessage');
                const container = el('#cardsContainer');

                // If no deck selected, show message and hide table
                if (!this.state.selectedDeck) {
                    tbody.innerHTML = '';
                    if (container) container.classList.add('hidden');
                    if (noCardsMsg) {
                        noCardsMsg.textContent = 'Select a deck above to view its cards';
                        noCardsMsg.classList.remove('hidden');
                    }
                    this.updateCounts();
                    return;
                }

                let cards = this.cardsForDeck(this.state.selectedDeck.id);
                cards = cards.filter(c => this.passFilters(c));

                // Sort by due date (overdue/upcoming first, new cards at end)
                cards.sort((a, b) => {
                    const dueA = (a.fsrs?.dueDate || a.sm2?.dueDate);
                    const dueB = (b.fsrs?.dueDate || b.sm2?.dueDate);
                    if (!dueA && !dueB) return 0;
                    if (!dueA) return 1;
                    if (!dueB) return -1;
                    return new Date(dueA) - new Date(dueB);
                });

                // Apply card name search filter
                const searchQuery = (this.state.cardSearch || '').toLowerCase().trim();
                if (searchQuery) {
                    cards = cards.filter(c => {
                        const plainName = (c.name || '').replace(/<[^>]*>/g, '').replace(/\{\{c\d+::(.*?)\}\}/g, '$1').toLowerCase();
                        return plainName.includes(searchQuery);
                    });
                }

                if (cards.length === 0) {
                    tbody.innerHTML = '';
                    if (container) container.classList.add('hidden');
                    if (noCardsMsg) {
                        noCardsMsg.textContent = searchQuery ? 'No cards match your search.' : 'No cards in this deck yet. Click "New card" to add one.';
                        noCardsMsg.classList.remove('hidden');
                    }
                } else {
                    if (container) container.classList.remove('hidden');
                    if (noCardsMsg) noCardsMsg.classList.add('hidden');

                    const limit = this.state.cardLimit || 50;
                    const visibleCards = cards.slice(0, limit);
                    const hasMore = cards.length > limit;

                    tbody.innerHTML = visibleCards.map(c => {
                        // Strip HTML tags and cloze syntax for display, then escape for safety
                        const plainName = (c.name || '').replace(/<[^>]*>/g, '').replace(/\{\{c\d+::(.*?)\}\}/g, '$1');
                        const nameText = escapeHtml(plainName.slice(0, 50));
                        const tagPills = c.tags.slice(0, 2).map(t => `<span class="notion-color-${t.color.replace('_', '-')}-background px-1.5 py-0.5 rounded text-[10px]">${escapeHtml(t.name)}</span>`).join(' ');
                        // Get due date
                        const dueDate = c.fsrs?.dueDate || c.sm2?.dueDate;
                        const dueDisplay = dueDate ? new Date(dueDate).toLocaleDateString() : 'â€”';
                        return `
                        <tr class="hover:bg-oatmeal/50 dark:hover:bg-white/5" data-card-id="${c.id}">
                            <td class="py-2 pr-2 text-charcoal"><div class="truncate max-w-[150px] sm:max-w-[250px] md:max-w-[350px] lg:max-w-[450px]">${nameText}</div></td>
                            <td class="py-2 pr-2 capitalize hidden sm:table-cell">${c.type}</td>
                            <td class="py-2 pr-2 text-earth-metal/70 text-xs whitespace-nowrap">${dueDisplay}</td>
                            <td class="py-2 pr-2 hidden md:table-cell text-xs"><div class="flex gap-1 flex-wrap">${tagPills}${c.tags.length > 2 ? '<span class="text-earth-metal/50 dark:text-white/60">...</span>' : ''}</div></td>
                            <td class="py-2 flex gap-1">
                                <button class="info-card-btn p-1 rounded hover:bg-dull-purple/20 text-earth-metal/60 relative" data-card-id="${c.id}" title="Review history">
                                    <i data-lucide="info" class="w-4 h-4 pointer-events-none"></i>
                                </button>
                                <button class="edit-card-btn p-1 rounded hover:bg-dull-purple/20 text-dull-purple" data-card-id="${c.id}" title="Edit card">
                                    <i data-lucide="edit-2" class="w-4 h-4 pointer-events-none"></i>
                                </button>
                            </td>
                        </tr>`;
                    }).join('');

                    if (hasMore) {
                        tbody.innerHTML += `
                         <tr>
                            <td colspan="5" class="py-3 text-center">
                                <button id="showMoreCardsBtn" class="text-xs text-dull-purple hover:underline bg-oatmeal/50 dark:bg-white/10 px-4 py-2 rounded-lg">
                                    Show ${cards.length - limit} more cards
                                </button>
                            </td>
                         </tr>
                         `;
                        setTimeout(() => {
                            const btn = el('#showMoreCardsBtn');
                            if (btn) btn.onclick = () => {
                                this.state.cardLimit += (this.state.cardLimitStep || 50);
                                this.renderCards();
                            };
                        }, 0);
                    }
                    lucide.createIcons();
                }
                this.updateCounts();
            },
            renderStudy() {
                // Ensure we never keep the mic open across cards/screens.
                if (this.isMicActive() || this.state.activeAudioStream) {
                    this.stopMicActivity(true);
                }
                // Update session UI controls
                const session = this.state.session;
                const revisionSelect = el('#revisionMode');
                if (session?.settings?.revisionMode && revisionSelect) {
                    revisionSelect.value = session.settings.revisionMode;
                }
                const activeBar = el('#sessionActiveBar');
                const progressText = el('#sessionProgressText');
                const studySettingsCard = el('#studySettingsCard');
                const studyCardSection = el('#studyCardSection');
                const notesSection = el('#notesSection');

                // Show/hide sections based on session state
                if (session) {
                    // Session is active - hide settings, show session bar and study card
                    // Notes are hidden until answer is revealed
                    if (studySettingsCard) studySettingsCard.classList.add('hidden');
                    if (studyCardSection) studyCardSection.classList.remove('hidden');
                    if (notesSection) notesSection.classList.add('hidden'); // Hidden until reveal
                    if (activeBar) {
                        activeBar.classList.remove('hidden');
                        const current = session.currentIndex + 1;
                        const total = session.cardQueue.length;
                        progressText.textContent = `Study Session (${current}/${total})`;
                        const previewBadge = el('#previewBadge');
                        if (previewBadge) previewBadge.classList.toggle('hidden', !session.noScheduleChanges);
                    }
                    lucide.createIcons();
                } else {
                    // No session - show settings, hide session bar, study card, and notes
                    if (studySettingsCard) studySettingsCard.classList.remove('hidden');
                    if (studyCardSection) studyCardSection.classList.add('hidden');
                    if (notesSection) notesSection.classList.add('hidden');
                    if (activeBar) activeBar.classList.add('hidden');
                }

                const card = this.pickCard();
                const deck = card ? this.deckById(card.deckId) : null;
                const isCloze = card && (card.type || '').toLowerCase() === 'cloze';

                // Check if no cards are due but decks are selected
                const f = this.state.filters;
                const hasSelectedDecks = f.studyDecks && f.studyDecks.length > 0;
                const allCards = hasSelectedDecks
                    ? this.state.cards.filter(c => f.studyDecks.includes(c.deckId))
                    : this.state.cards;
                const dueCards = allCards.filter(c => this.passFilters(c) && this.isDue(c));
                const nonDueCards = allCards.filter(c => this.passFilters(c) && !this.isDue(c));

                if (!card && hasSelectedDecks && nonDueCards.length > 0 && !session) {
                    // No due cards but there are non-due cards available (only show when no session)
                    el('#studyDeckLabel').textContent = 'No cards due';
                    el('#cardFront').innerHTML = `
                        <div class="text-center py-4">
                            <p class="text-earth-metal/70 text-sm mb-3">No cards are due for review right now.</p>
                            <p class="text-earth-metal/60 text-xs mb-4">${nonDueCards.length} card${nonDueCards.length === 1 ? '' : 's'} available for extra practice.</p>
                            <button id="studyNonDueBtn" class="px-4 py-2 bg-dull-purple text-white rounded-lg text-sm hover:bg-dull-purple/90 transition">
                                Practice non-due cards
                            </button>
                        </div>
                    `;
                    el('#cardBack').innerHTML = '';
                    el('#cardBack').classList.add('hidden');
                    el('#aiControls').classList.add('hidden');
                    this.state.answerRevealed = false;
                    this.setRatingEnabled(false);
                    this.updateMobileFab();
                    this.state.selectedCard = null;
                    // Bind the button
                    setTimeout(() => {
                        const btn = el('#studyNonDueBtn');
                        if (btn) btn.onclick = () => this.enableNonDueStudy();
                    }, 0);
                    return;
                }

                el('#studyDeckLabel').textContent = deck ? deck.name : 'Choose a deck';
                // Clear cardFront before setting new content to force fresh DOM
                el('#cardFront').innerHTML = '';
                const front = card ? this.renderCardFront(card, deck) : '<p class="text-earth-metal/70 text-sm">No card selected</p>';
                el('#cardFront').innerHTML = front;
                applyMediaEmbeds(el('#cardFront'));
                // Show opposite side based on whether card was reversed
                const backContent = card ? (this.state.cardReversed ? card.name : card.back) : '';
                el('#cardBack').innerHTML = card ? marked.parse(backContent || '') : '';
                applyMediaEmbeds(el('#cardBack'));
                this.renderMath(el('#cardFront'));
                this.renderMath(el('#cardBack'));
                // Ensure cloze blanks are NOT revealed on new card (must be after renderMath)
                document.querySelectorAll('#cardFront .cloze-blank').forEach(span => span.classList.remove('revealed'));
                el('#cardBack').classList.add('hidden');
                el('#aiControls').classList.add('hidden');
                // Show study controls (may have been hidden by session complete)
                const studyControls = el('#studyControls');
                if (studyControls) studyControls.classList.remove('hidden');

                this.state.activeMicButton = null;
                this.state.lockAiUntilNextCard = false;
                const isAiMode = this.isAiModeUsable();
                const revealBtn = el('#revealBtn');

                this.updateSkipHotkeyLabel(isAiMode);
                this.setAiControlsLocked(false);
                if (revealBtn) {
                    revealBtn.disabled = false;
                    revealBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }

                if (isAiMode) {
                    if (revealBtn) revealBtn.classList.add('hidden');
                    el('#aiControls').classList.remove('hidden');
                    const submitBtn = el('#aiSubmit');
                    submitBtn.dataset.empty = '1';
                    const feedback = el('#aiFeedback');
                    if (feedback) { feedback.classList.add('hidden'); feedback.innerHTML = ''; }
                    this.setAiControlsLocked(false);
                    setTimeout(() => el('#aiAnswer').focus(), 50);
                } else {
                    if (revealBtn) revealBtn.classList.remove('hidden');
                    el('#aiControls').classList.add('hidden');
                }

                // Hide copy button until reveal (shows answer content)
                const copyBtn = el('#copyCardContent');
                if (copyBtn) copyBtn.classList.add('hidden');
                // Hide add note button until reveal
                const addNoteBtn = el('#addNoteBlock');
                if (addNoteBtn) addNoteBtn.classList.add('hidden');
                // Reset answer revealed state and disable rating buttons
                this.state.answerRevealed = false;
                this.setRatingEnabled(false);
                this.updateMobileFab();
                this.state.selectedCard = card || null;
                this.renderNotes();
                this.renderFsrsMeta();
                el('#aiAnswer').value = '';
                el('#aiFeedback').innerHTML = '';
                el('#aiFeedback').classList.add('hidden');
                lucide.createIcons();
            },
            renderNotes() {
                const notes = this.state.selectedCard?.notes ?? '';
                el('#notesPreview').innerHTML = notes ? marked.parse(notes) : '<p class="text-earth-metal/60 text-sm">No notes for this card</p>';
                applyMediaEmbeds(el('#notesPreview'));
                this.renderMath(el('#notesPreview'));
            },
            renderFsrsMeta() {
                // Stats display removed - internal calculation only
            },
            renderTagFilter() {
                const input = el('#filterTagSearch');
                const dropdown = el('#filterTagDropdown');
                const selectedWrap = el('#filterTagSelected');
                if (!input || !dropdown || !selectedWrap) return;

                const tagMap = new Map();
                this.state.cards.forEach(c => {
                    (c.tags || []).forEach(t => {
                        if (!tagMap.has(t.name)) tagMap.set(t.name, t.color || 'default');
                    });
                });
                const allTags = Array.from(tagMap.keys()).sort((a, b) => a.localeCompare(b));
                const selected = new Set(this.state.filters.tags || []);
                const query = (input.value || '').toLowerCase();
                const options = allTags.filter(name => name.toLowerCase().includes(query));

                dropdown.innerHTML = options.length
                    ? options.map(name => {
                        const isSelected = selected.has(name);
                        return `<button class="tag-option w-full text-left px-3 py-2 text-sm flex items-center gap-2 ${isSelected ? 'bg-dull-purple/10 border-lime-200' : 'hover:bg-oatmeal/60'}" data-tag="${encodeDataAttr(name)}">
                            <span class="flex-1">${escapeHtml(name)}</span>
                            ${isSelected ? '<span class="text-[11px] text-dull-purple">Selected</span>' : ''}
                        </button>`;
                    }).join('')
                    : `<div class="px-3 py-2 text-sm text-earth-metal/60 dark:text-white/60">No tags found</div>`;

                dropdown.querySelectorAll('.tag-option').forEach(btn => {
                    btn.onclick = () => {
                        const tag = decodeDataAttr(btn.dataset.tag);
                        if (selected.has(tag)) selected.delete(tag); else selected.add(tag);
                        this.state.filters.tags = Array.from(selected);
                        this.renderTagFilter();
                        this.renderCards();
                        this.updateActiveFiltersCount();
                    };
                });

                selectedWrap.innerHTML = selected.size
                    ? Array.from(selected).map(tag => `
                        <span class="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-oatmeal text-earth-metal text-xs border border-oatmeal-dark/60">
                            ${escapeHtml(tag)}
                            <button class="remove-tag text-earth-metal/70" data-tag="${encodeDataAttr(tag)}">&times;</button>
                        </span>
                    `).join('')
                    : '<span class="text-earth-metal/50 dark:text-white/60 text-xs">All tags included</span>';

                selectedWrap.querySelectorAll('.remove-tag').forEach(btn => {
                    btn.onclick = () => {
                        const tag = decodeDataAttr(btn.dataset.tag);
                        this.state.filters.tags = this.state.filters.tags.filter(t => t !== tag);
                        this.renderTagFilter();
                        this.renderCards();
                        this.updateActiveFiltersCount();
                    };
                });
            },
            buildLocalTagOptions() {
                const tagMap = new Map();
                this.state.cards.forEach(c => {
                    (c.tags || []).forEach(t => {
                        if (!tagMap.has(t.name)) tagMap.set(t.name, t.color || 'default');
                    });
                });
                return Array.from(tagMap.entries()).map(([name, color]) => ({ name, color }));
            },
            collectTagOptions() {
                const tagMap = new Map();
                (this.state.tagOptions || []).forEach(t => { if (t?.name) tagMap.set(t.name, t.color || 'default'); });
                this.buildLocalTagOptions().forEach(t => { if (!tagMap.has(t.name)) tagMap.set(t.name, t.color || 'default'); });
                return Array.from(tagMap.entries())
                    .map(([name, color]) => ({ name, color }))
                    .sort((a, b) => a.name.localeCompare(b.name));
            },
            renderCardTagSelectors() {
                const input = el('#cardTagSearch');
                const dropdown = el('#cardTagDropdown');
                const selectedWrap = el('#cardTagSelected');
                if (!input || !dropdown || !selectedWrap) return;

                const selected = new Set(this.state.tagSelection || []);
                const allOptions = this.collectTagOptions();
                const query = (input.value || '').toLowerCase();
                const options = allOptions.filter(opt => opt.name.toLowerCase().includes(query));
                const canAdd = query && !allOptions.some(opt => opt.name.toLowerCase() === query);

                dropdown.innerHTML = `
                    ${canAdd ? `<button class="tag-add-option w-full text-left px-3 py-2 text-sm text-dull-purple hover:bg-dull-purple/10" data-add="${encodeDataAttr(input.value.trim())}">+ Add "${escapeHtml(input.value.trim())}"</button>` : ''}
                    ${options.map(opt => {
                    const active = selected.has(opt.name);
                    return `<button class="tag-option w-full text-left px-3 py-2 text-sm flex items-center gap-2 ${active ? 'bg-dull-purple/10 border-lime-200' : 'hover:bg-oatmeal/60'}" data-tag="${encodeDataAttr(opt.name)}">
                            <span class="flex-1">${escapeHtml(opt.name)}</span>
                            ${active ? '<span class="text-[11px] text-dull-purple">Selected</span>' : ''}
                        </button>`;
                }).join('')}
                `;

                dropdown.querySelectorAll('.tag-option').forEach(btn => {
                    btn.onclick = () => {
                        const tag = decodeDataAttr(btn.dataset.tag);
                        if (selected.has(tag)) selected.delete(tag); else selected.add(tag);
                        this.state.tagSelection = Array.from(selected);
                        this.renderCardTagSelectors();
                    };
                });
                dropdown.querySelectorAll('.tag-add-option').forEach(btn => {
                    btn.onclick = () => {
                        const name = decodeDataAttr(btn.dataset.add);
                        this.addTagByName(name, { toSelection: true });
                        if (input) input.value = '';
                    };
                });

                selectedWrap.innerHTML = selected.size
                    ? Array.from(selected).map(tag => `
                        <span class="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-oatmeal text-earth-metal text-xs border border-oatmeal-dark/60">
                            ${escapeHtml(tag)}
                            <button class="remove-tag text-earth-metal/70" data-tag="${encodeDataAttr(tag)}">&times;</button>
                        </span>
                    `).join('')
                    : '<span class="text-earth-metal/50 dark:text-white/60 text-xs">No tags selected</span>';

                selectedWrap.querySelectorAll('.remove-tag').forEach(btn => {
                    btn.onclick = () => {
                        const tag = decodeDataAttr(btn.dataset.tag);
                        this.state.tagSelection = this.state.tagSelection.filter(t => t !== tag);
                        this.renderCardTagSelectors();
                    };
                });
            },
            addTagByName(name, { toSelection = false } = {}) {
                if (!name) return;
                const exists = this.state.tagOptions.some(t => t.name.toLowerCase() === name.toLowerCase());
                if (!exists) {
                    this.state.tagOptions.push({ name, color: 'default' });
                    Storage.setMeta('tagOptions', this.state.tagOptions).catch(() => { });
                }
                if (toSelection && !this.state.tagSelection.includes(name)) {
                    this.state.tagSelection.push(name);
                }
                this.renderCardTagSelectors();
                this.renderTagFilter();
            },
            async refreshTagOptions() {
                const btn = el('#refreshTagOptionsBtn');
                if (btn) btn.disabled = true;
                try {
                    if (!this.isReady()) {
                        this.state.tagOptions = this.buildLocalTagOptions();
                        this.renderCardTagSelectors();
                        toast('Offline: using local tags');
                        return;
                    }
                    const { cardSource } = this.state.settings;
                    if (!cardSource) throw new Error('Missing card source');
                    const db = await API.getDatabase(cardSource);
                    const opts = db?.properties?.['Tags']?.multi_select?.options || [];
                    this.state.tagOptions = opts.map(o => ({ name: o.name, color: o.color || 'default' }));
                    await Storage.setMeta('tagOptions', this.state.tagOptions);
                    this.renderCardTagSelectors();
                    this.renderTagFilter();
                    toast('Tags refreshed');
                } catch (e) {
                    console.error('Refresh tags failed', e);
                    toast('Could not refresh tags');
                } finally {
                    if (btn) btn.disabled = false;
                }
            },
            renderStudyDeckSelection() {
                const dropdown = el('#deckDropdown');
                const display = el('#selectedDecksDisplay');
                const input = el('#deckSearchInput');
                if (!dropdown || !display || !input) return;

                const selected = this.state.filters.studyDecks || [];
                const query = (input.value || '').toLowerCase();

                // Render dropdown options
                const filtered = this.state.decks.filter(d => d.name.toLowerCase().includes(query));
                dropdown.innerHTML = filtered.map(d => {
                    const isSelected = selected.includes(d.id);
                    const dueCount = this.cardsForDeck(d.id).filter(c => this.isDue(c)).length;
                    return `<div class="deck-option flex items-center justify-between px-3 py-2 cursor-pointer hover:bg-oatmeal/50 ${isSelected ? 'bg-dull-purple/10' : ''}" data-deck-id="${d.id}">
                        <span class="flex items-center gap-2">
                            ${isSelected ? '<i data-lucide="check" class="w-3 h-3 text-dull-purple"></i>' : '<span class="w-3"></span>'}
                            <span class="text-sm">${escapeHtml(d.name)}</span>
                        </span>
                        <span class="text-xs text-earth-metal/60">${dueCount} due</span>
                    </div>`;
                }).join('');
                if (filtered.length === 0) {
                    dropdown.innerHTML = '<div class="px-3 py-2 text-sm text-earth-metal/60 dark:text-white/60 italic">No decks found</div>';
                }

                // Render selected deck pills
                display.innerHTML = selected.map(id => {
                    const d = this.deckById(id);
                    if (!d) return '';
                    return `<span class="selected-deck-pill inline-flex items-center gap-1 px-2 py-1 rounded-full bg-dull-purple text-white text-xs" data-deck-id="${id}">
                        ${escapeHtml(d.name)}
                        <button class="remove-deck-btn hover:bg-white/20 rounded-full p-0.5" data-deck-id="${id}">
                            <i data-lucide="x" class="w-3 h-3 pointer-events-none"></i>
                        </button>
                    </span>`;
                }).join('');
                if (selected.length === 0) {
                    const totalDue = this.state.cards.filter(c => this.isDue(c)).length;
                    display.innerHTML = `<span class="text-dull-purple/80 text-xs italic">All decks (${totalDue} due)</span>`;
                }
                lucide.createIcons();
            },
            bindDeckSearch() {
                const input = el('#deckSearchInput');
                const dropdown = el('#deckDropdown');
                if (!input || !dropdown) return;

                input.onfocus = () => {
                    dropdown.classList.remove('hidden');
                    this.renderStudyDeckSelection();
                };
                input.oninput = () => this.renderStudyDeckSelection();
                input.onblur = (e) => {
                    // Delay hiding to allow click on dropdown
                    setTimeout(() => {
                        if (!dropdown.contains(document.activeElement)) {
                            dropdown.classList.add('hidden');
                        }
                    }, 150);
                };

                dropdown.onmousedown = (e) => {
                    e.preventDefault(); // Prevent blur
                    const option = e.target.closest('.deck-option');
                    if (option) {
                        const deckId = option.dataset.deckId;
                        const idx = this.state.filters.studyDecks.indexOf(deckId);
                        if (idx >= 0) {
                            this.state.filters.studyDecks.splice(idx, 1);
                        } else {
                            this.state.filters.studyDecks.push(deckId);
                        }
                        // Reset non-due study mode when decks change
                        this.state.studyNonDue = false;
                        this.renderStudyDeckSelection();
                        this.renderStudy();
                        this.updateActiveFiltersCount();
                    }
                };

                el('#selectedDecksDisplay').onclick = (e) => {
                    const btn = e.target.closest('.remove-deck-btn');
                    if (btn) {
                        const deckId = btn.dataset.deckId;
                        const idx = this.state.filters.studyDecks.indexOf(deckId);
                        if (idx >= 0) {
                            this.state.filters.studyDecks.splice(idx, 1);
                            // Reset non-due study mode when decks change
                            this.state.studyNonDue = false;
                            this.renderStudyDeckSelection();
                            this.renderStudy();
                            this.updateActiveFiltersCount();
                        }
                    }
                };
            },
            openDeckModal(deck) {
                if (!this.isReady()) { this.openSettings(); return; }
                this.state.editingDeck = deck || null;
                el('#deckModalTitle').textContent = deck ? 'Edit deck' : 'New deck';
                el('#deckNameInput').value = deck?.name ?? '';
                const algo = deck?.algorithm ?? 'SM-2';
                el('#deckAlgoInput').value = algo;
                el('#deckReviewLimit').value = deck?.reviewLimit ?? 50;
                el('#deckNewLimit').value = deck?.newLimit ?? 20;
                el('#deckOrderMode').value = deck?.orderMode ?? 'none';
                el('#deckReverseInput').checked = deck?.reverse ?? false;
                el('#deckPromptInput').value = deck?.aiPrompt ?? DEFAULT_AI_PROMPT;

                // Populate FSRS params
                const paramsField = el('#fsrsParamsField');
                const paramsInput = el('#deckFsrsParams');
                const retentionInput = el('#deckFsrsDesiredRetention');
                const optimizeBtn = el('#optimizeFsrsBtn');
                if (paramsInput) {
                    paramsInput.value = (deck?.fsrsWeights || fsrsW).join(', ');
                }
                if (retentionInput) {
                    retentionInput.value = (deck?.fsrsDesiredRetention ?? DEFAULT_DESIRED_RETENTION).toFixed(2);
                }
                if (optimizeBtn) {
                    optimizeBtn.onclick = async () => {
                        const current = this.state.editingDeck;
                        if (!current || current.algorithm !== 'FSRS') return toast('Switch to FSRS first');
                        if (!current.id) return toast('Save the deck first');
                        await this.optimizeFsrsWeightsForDeck(current);
                    };
                }
                if (paramsField) {
                    paramsField.classList.toggle('hidden', algo !== 'FSRS');
                }

                el('#archiveDeckBtn').classList.toggle('hidden', !deck);
                el('#deckModal').classList.remove('hidden');
                el('#deckModal').classList.add('flex');
            },
            async optimizeFsrsWeightsForDeck(deck) {
                const cards = this.cardsForDeck(deck.id);
                const trainingSet = buildFsrsTrainingSet(cards);
                const totalEvents = trainingSet.reduce((acc, x) => acc + x.history.length, 0);
                if (trainingSet.length < 10 || totalEvents < 50) {
                    toast('Not enough review history to optimize (need ~50+ reviews)');
                    return;
                }
                if (!confirm(`Optimize FSRS weights for "${deck.name}"?\n\nThis uses your review history for this deck and can take ~10â€“60 seconds.`)) {
                    return;
                }

                const optimizeBtn = el('#optimizeFsrsBtn');
                if (optimizeBtn) optimizeBtn.disabled = true;
                try {
                    const start = constrainWeights(Array.isArray(deck.fsrsWeights) && deck.fsrsWeights.length === 21 ? deck.fsrsWeights : fsrsW);
                    showLoading('Optimizing FSRS weights...', `Using ${trainingSet.length} cards (~${totalEvents} reviews)`);
                    setLoadingProgress(0, `0% â€¢ iter 0/220`);
                    await new Promise(r => setTimeout(r, 0));

                    const alpha = 0.602;
                    const gamma = 0.101;
                    const a0 = 0.12;
                    const c0 = 0.06;
                    const iters = 220;

                    let w = start.slice();
                    let bestW = w.slice();
                    let bestLoss = fsrsLogLoss(trainingSet, bestW);

                    for (let k = 0; k < iters; k++) {
                        const ak = a0 / Math.pow(k + 1, alpha);
                        const ck = c0 / Math.pow(k + 1, gamma);
                        const delta = new Array(21);
                        const scale = new Array(21);
                        for (let i = 0; i < 21; i++) {
                            delta[i] = Math.random() < 0.5 ? -1 : 1;
                            scale[i] = Math.abs(w[i]) + 1;
                        }
                        const wPlus = w.map((v, i) => v + ck * delta[i] * scale[i]);
                        const wMinus = w.map((v, i) => v - ck * delta[i] * scale[i]);
                        const lossPlus = fsrsLogLoss(trainingSet, wPlus);
                        const lossMinus = fsrsLogLoss(trainingSet, wMinus);
                        if (!Number.isFinite(lossPlus) || !Number.isFinite(lossMinus)) {
                            // If we wandered into invalid space, reset toward best.
                            w = bestW.slice();
                            continue;
                        }
                        const gHat = new Array(21);
                        for (let i = 0; i < 21; i++) {
                            const denom = 2 * ck * delta[i] * scale[i];
                            gHat[i] = (lossPlus - lossMinus) / denom;
                        }

                        // Gradient step
                        w = constrainWeights(w.map((v, i) => v - ak * gHat[i]));
                        const curLoss = fsrsLogLoss(trainingSet, w);
                        if (curLoss < bestLoss) {
                            bestLoss = curLoss;
                            bestW = w.slice();
                        }

                        if (k % 10 === 0) {
                            showLoading('Optimizing FSRS weights...', `Iter ${k + 1}/${iters} â€¢ best logloss ${bestLoss.toFixed(4)}`);
                            setLoadingProgress(((k + 1) / iters) * 100, `${Math.round(((k + 1) / iters) * 100)}% â€¢ iter ${k + 1}/${iters}`);
                            await new Promise(r => setTimeout(r, 0));
                        }
                    }
                    setLoadingProgress(100, `100% â€¢ iter ${iters}/${iters}`);

                    const rounded = bestW.map(n => +n.toFixed(4));
                    // Update modal fields (user still presses Save to persist/sync).
                    deck.fsrsWeights = rounded;
                    const paramsInput = el('#deckFsrsParams');
                    if (paramsInput) paramsInput.value = rounded.join(', ');
                    toast(`Optimized FSRS weights loaded (best logloss ${bestLoss.toFixed(4)}). Press Save to apply.`);
                } finally {
                    hideLoading();
                    if (optimizeBtn) optimizeBtn.disabled = false;
                }
            },
            editDeck(deckId) {
                const deck = this.state.decks.find(d => d.id === deckId);
                if (deck) this.openDeckModal(deck);
            },
            closeDeckModal() {
                el('#deckModal').classList.add('hidden');
                el('#deckModal').classList.remove('flex');
            },
            async saveDeckFromModal() {
                const d = this.state.editingDeck || this.newDeck('', 'SM-2');
                d.name = el('#deckNameInput').value || d.name || 'Untitled deck';
                d.algorithm = el('#deckAlgoInput').value;
                d.reviewLimit = Number(el('#deckReviewLimit').value) || 50;
                d.newLimit = Number(el('#deckNewLimit').value) || 20;
                d.orderMode = el('#deckOrderMode').value || 'none';
                d.reverse = el('#deckReverseInput').checked;
                d.aiPrompt = el('#deckPromptInput').value || '';

                // Save FSRS params if present
                if (d.algorithm === 'FSRS') {
                    const rawRetention = el('#deckFsrsDesiredRetention')?.value?.trim() || '';
                    const rawParams = el('#deckFsrsParams')?.value?.trim() || '';

                    // Use parseFsrsParamsText to handle recovery and various formats
                    const parsed = parseFsrsParamsText(rawParams || rawRetention);

                    // If the user explicitly provided a retention value in the numeric field, prioritize it
                    if (rawRetention) {
                        d.fsrsDesiredRetention = clampRetention(parseFloat(rawRetention)) || DEFAULT_DESIRED_RETENTION;
                    } else {
                        d.fsrsDesiredRetention = parsed.desiredRetention;
                    }

                    // Always ensure we have 21 weights if it's FSRS
                    d.fsrsWeights = parsed.weights || [...fsrsW];
                } else {
                    d.fsrsWeights = null;
                    d.fsrsDesiredRetention = DEFAULT_DESIRED_RETENTION;
                }

                if (!this.state.editingDeck) this.state.decks.push(d);
                d.updatedInApp = true;
                await Storage.put('decks', d);
                this.queueOp({ type: 'deck-upsert', payload: d });
                this.closeDeckModal();
                this.renderDecks();
                this.renderStudy();
                toast('Deck saved');
            },
            async archiveDeckFromModal() {
                const deck = this.state.editingDeck;
                if (!deck) return;
                // Check if this was the selected deck
                const wasSelected = this.state.selectedDeck?.id === deck.id;
                // Remove from study deck filters if it was there
                if (this.state.filters.studyDecks) {
                    this.state.filters.studyDecks = this.state.filters.studyDecks.filter(id => id !== deck.id);
                }

                // Mark as archived
                deck.archived = true;

                // Remove deck and its cards from local storage view (deletion logic remains for UX)
                // But we queue the upsert with archived=true FIRST so it syncs correctly
                await Storage.put('decks', deck);
                this.queueOp({ type: 'deck-upsert', payload: deck });

                const cards = this.cardsForDeck(deck.id);
                for (const card of cards) {
                    const idx = this.state.cards.findIndex(c => c.id === card.id);
                    if (idx >= 0) this.state.cards.splice(idx, 1);
                    await Storage.delete('cards', card.id);
                }
                const deckIdx = this.state.decks.findIndex(d => d.id === deck.id);
                if (deckIdx >= 0) this.state.decks.splice(deckIdx, 1);
                await Storage.delete('decks', deck.id);

                // Clear selection if this was the selected deck
                if (wasSelected) {
                    this.state.selectedDeck = null;
                }
                this.closeDeckModal();
                this.renderDecks();
                this.renderCards();
                this.renderSelectedDeckBar();
                this.renderStudyDeckSelection();
                this.renderStudy();
                toast('Deck archived');
            },
            openResetAlgorithmModal() {
                const deck = this.state.selectedDeck;
                if (!deck) {
                    toast('Select a deck first');
                    return;
                }
                el('#resetDeckName').textContent = deck.name;
                this.openModal('resetAlgorithmModal');
            },
            async confirmResetAlgorithm() {
                const deck = this.state.selectedDeck;
                if (!deck) return;
                const cards = this.cardsForDeck(deck.id);
                if (cards.length === 0) {
                    toast('No cards in this deck');
                    this.closeModal('resetAlgorithmModal');
                    return;
                }

                // Show progress UI
                const container = el('#resetProgressContainer');
                const bar = el('#resetProgressBar');
                const percent = el('#resetProgressPercent');
                const confirmBtn = el('#confirmResetAlgorithm');
                const cancelBtn = el('#cancelResetAlgorithm');

                if (container) container.classList.remove('hidden');
                if (confirmBtn) confirmBtn.classList.add('hidden');
                if (cancelBtn) cancelBtn.classList.add('hidden');

                // Reset algorithm parameters for all cards in the deck
                let resetCount = 0;
                const total = cards.length;
                const CHUNK_SIZE = 20;
                const weights = deck.fsrsWeights || fsrsW;

                for (let i = 0; i < total; i += CHUNK_SIZE) {
                    const chunk = cards.slice(i, i + CHUNK_SIZE);

                    // Update UI
                    if (percent) percent.textContent = Math.round((i / total) * 100) + '%';
                    if (bar) bar.style.width = ((i / total) * 100) + '%';

                    // Allow UI to breathe
                    await new Promise(resolve => setTimeout(resolve, 0));

                    for (const card of chunk) {
                        // Reset SM-2 parameters
                        card.sm2 = {
                            easeFactor: 2.5,
                            interval: 1,
                            repetitions: 0,
                            dueDate: null,
                            lastRating: null,
                            lastReview: null
                        };
                        // Reset FSRS parameters with proper initial values
                        card.fsrs = {
                            stability: initStability(weights, 'good'),
                            difficulty: initDifficulty(weights, 'good'),
                            dueDate: null,
                            lastReview: null,
                            lastRating: null,
                            retrievability: 0.9
                        };
                        // Save locally
                        await Storage.put('cards', card);
                        // Queue for sync to Notion
                        this.queueOp({ type: 'card-upsert', payload: card });
                        resetCount++;
                    }
                }

                // Update in-memory state
                this.state.cards = this.state.cards.map(c => {
                    const updated = cards.find(uc => uc.id === c.id);
                    return updated || c;
                });

                this.closeModal('resetAlgorithmModal');

                // Reset UI for next time
                if (container) container.classList.add('hidden');
                if (confirmBtn) confirmBtn.classList.remove('hidden');
                if (cancelBtn) cancelBtn.classList.remove('hidden');
                if (bar) bar.style.width = '0%';

                // Re-render all views that show due counts
                this.renderCards();
                this.renderDecks();
                this.renderStudyDeckSelection();
                this.renderStudy();
                toast(`Reset ${resetCount} card${resetCount !== 1 ? 's' : ''} â€” syncing to Notion`);
            },
            openCardModal(card) {
                if (!this.isReady()) { this.openSettings(); return; }
                this.state.editingCard = card || null;
                el('#cardModalTitle').textContent = card ? 'Edit card' : 'New card';
                const deckSelect = el('#cardDeckInput');
                deckSelect.innerHTML = this.state.decks.map(d => `<option value="${d.id}">${d.name}</option>`).join('');
                deckSelect.value = card?.deckId || this.state.selectedDeck?.id || this.state.decks[0]?.id;
                el('#cardTypeInput').value = card?.type ?? 'Front-Back';
                el('#cardNameInput').value = card?.name ?? '';
                el('#cardBackInput').value = card?.back ?? '';
                el('#cardNotesInput').value = card?.notes ?? '';
                // Initialize tag selection for modal
                this.state.tagSelection = card?.tags?.map(t => t.name) || [];
                const tagSearch = el('#cardTagSearch');
                if (tagSearch) tagSearch.value = '';
                this.renderCardTagSelectors();
                el('#cardOrderInput').value = (typeof card?.order === 'number') ? card.order : '';
                el('#cardSuspendedInput').checked = card?.suspended ?? false;
                el('#cardLeechInput').checked = card?.leech ?? false;
                el('#deleteCardBtn').classList.toggle('hidden', !card);
                // Show/hide back section based on card type
                this.updateCardBackVisibility();
                // Populate review history section
                this.renderCardModalReviewHistory(card);
                el('#cardModal').classList.remove('hidden');
                el('#cardModal').classList.add('flex');
                lucide.createIcons();
            },
            renderCardModalReviewHistory(card) {
                const section = el('#cardReviewHistorySection');
                const countEl = el('#cardReviewHistoryCount');
                const tableEl = el('#cardReviewHistoryTable');

                if (!card || !card.reviewHistory || card.reviewHistory.length === 0) {
                    section.classList.add('hidden');
                    return;
                }

                section.classList.remove('hidden');
                const history = card.reviewHistory;
                countEl.textContent = history.length;

                const ratingColors = { again: 'text-red-500', hard: 'text-orange-500', good: 'text-green-500', easy: 'text-blue-500' };
                // Show all reviews (most recent first)
                const sortedHistory = [...history].reverse();
                tableEl.innerHTML = `
                    <table class="w-full text-xs">
                        <thead class="sticky top-0 bg-oatmeal dark:bg-white/5"><tr class="text-earth-metal/50 dark:text-white/60 border-b border-charcoal/10"><th class="text-left py-1.5 px-2">Rating</th><th class="text-left py-1.5 px-2">Date</th><th class="text-left py-1.5 px-2">Time</th></tr></thead>
                        <tbody>
                            ${sortedHistory.map(h => `
                                <tr class="border-b border-charcoal/5 last:border-0">
                                    <td class="py-1 px-2 capitalize ${ratingColors[h.rating] || ''}">${h.rating}</td>
                                    <td class="py-1 px-2 text-earth-metal/70">${new Date(h.at).toLocaleDateString()}</td>
                                    <td class="py-1 px-2 text-earth-metal/70">${new Date(h.at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            },
            updateCardBackVisibility() {
                const isCloze = el('#cardTypeInput').value === 'Cloze';
                const backSection = el('#cardBackSection');
                if (backSection) backSection.classList.toggle('hidden', isCloze);
            },
            closeCardModal() {
                el('#cardModal').classList.add('hidden');
                el('#cardModal').classList.remove('flex');
            },
            async saveCardFromModal() {
                let card = this.state.editingCard || this.newCard('', '', '', 'Front-Back');
                const oldName = card.name;
                const oldBack = card.back;
                const oldNotes = card.notes;
                card.deckId = el('#cardDeckInput').value;
                card.type = el('#cardTypeInput').value;
                card.name = el('#cardNameInput').value || 'Untitled';
                card.back = el('#cardBackInput').value || '';
                card.notes = el('#cardNotesInput').value || '';
                if (!this.state.editingCard) {
                    const autoType = detectCardType(card.name, card.back);
                    if (card.type === 'Front-Back' && autoType === 'Cloze') card.type = 'Cloze';
                }
                const selectedTags = this.state.tagSelection || [];
                const optionMap = new Map(this.collectTagOptions().map(t => [t.name, t.color || 'default']));
                const existingColors = new Map((this.state.editingCard?.tags || []).map(t => [t.name, t.color || 'default']));
                card.tags = selectedTags.map(name => ({ name, color: optionMap.get(name) || existingColors.get(name) || 'default' }));
                const orderVal = el('#cardOrderInput').value;
                card.order = orderVal === '' ? null : Number(orderVal);
                card.suspended = el('#cardSuspendedInput').checked;
                card.leech = el('#cardLeechInput').checked;
                // Only set updatedInApp if name/back/notes changed (affects rich_text preservation)
                // Note: Editing Name, Back, or Notes will cause text colors and highlights to be lost on sync
                if (card.name !== oldName || card.back !== oldBack || card.notes !== oldNotes) {
                    card.updatedInApp = true;
                }
                // Ensure selected tags are stored for future modal suggestions
                selectedTags.forEach(name => {
                    if (!this.state.tagOptions.some(t => t.name === name)) {
                        this.state.tagOptions.push({ name, color: optionMap.get(name) || 'default' });
                    }
                });
                Storage.setMeta('tagOptions', this.state.tagOptions).catch(() => { });
                if (!this.state.editingCard) this.state.cards.push(card);
                await Storage.put('cards', card);
                this.queueOp({ type: 'card-upsert', payload: card });
                this.closeCardModal();
                this.renderCards();
                toast('Card saved');
            },
            async deleteCardFromModal() {
                const card = this.state.editingCard;
                if (!card) return;
                this.pendingDelete = { type: 'card', id: card.id, notionId: card.notionId };
                this.openModal('confirmModal');
            },
            async syncNow() {
                if (!navigator.onLine) {
                    toast('Offline: sync will resume when you reconnect');
                    return;
                }
                if (!this.isReady()) return toast('Complete settings first');
                if (this.state.syncing) { toast('Sync already in progress'); return; }
                this.state.syncing = true;
                this.updateSyncButtonState();
                this.setSyncButtonSpinning(true);
                const loadingMsg = el('#loadingMessage');
                el('#syncProgress').style.width = '10%';
                try {
                    // Push first to save local changes
                    if (loadingMsg && !el('#loadingOverlay').classList.contains('hidden')) {
                        loadingMsg.textContent = 'Pushing local changes...';
                    }
                    await this.pushQueue();
                    el('#syncProgress').style.width = '50%';

                    // Then pull to get updates
                    if (loadingMsg && !el('#loadingOverlay').classList.contains('hidden')) {
                        loadingMsg.textContent = 'Fetching decks...';
                    }
                    await this.pullFromNotion();
                    el('#syncProgress').style.width = '100%';

                    if (loadingMsg && !el('#loadingOverlay').classList.contains('hidden')) {
                        loadingMsg.textContent = 'Preparing your library...';
                    }
                    const nowIso = new Date().toISOString();
                    this.state.lastPull = nowIso;
                    this.state.lastPush = nowIso;
                    this.state.lastSync = nowIso;
                    await Storage.put('meta', { key: 'lastPull', value: nowIso });
                    await Storage.put('meta', { key: 'lastPush', value: nowIso });
                    await Storage.put('meta', { key: 'lastSync', value: nowIso });
                    toast('Synced with Notion');
                } catch (e) {
                    console.error('Sync failed', e);
                    toast('Sync failed - check connection');
                } finally {
                    this.setSyncButtonSpinning(false);
                    setTimeout(() => el('#syncProgress').style.width = '0%', 700);
                    this.state.syncing = false;
                    this.updateSyncButtonState();
                    if (this.state.queue.length > 0) {
                        this.requestAutoSyncSoon(MIN_PUSH_INTERVAL_MS + 100);
                    }
                }
            },
            async pullFromNotion() {
                const { deckSource, cardSource } = this.state.settings;
                if (!deckSource || !cardSource) return;
                const since = this.state.lastPull;

                // Deck visibility:
                // - Custom deck property "Archived?" means "hide deck + cards from app".
                // - Notion page-level `archived: true` means deleted in Notion (remove locally).
                // For incremental pulls, we must fetch both archived/unarchived to detect newly hidden decks.
                let deckFilter = { property: 'Archived?', checkbox: { equals: false } };
                if (since) {
                    deckFilter = { timestamp: 'last_edited_time', last_edited_time: { on_or_after: since } };
                }

                // Query non-archived decks first
                const decks = await API.queryDatabase(deckSource, deckFilter);
                const deckPages = decks || [];
                const isHiddenDeck = (p) => !!p?.properties?.['Archived?']?.checkbox;
                // Notion page-level deletion sets `archived: true`. Remove those locally.
                const deletedDeckNotionIds = new Set(deckPages.filter(p => p?.archived).map(p => p.id));
                // Custom "Archived?" decks should not exist locally at all.
                const hiddenDeckNotionIds = new Set(deckPages.filter(p => !p?.archived && isHiddenDeck(p)).map(p => p.id));
                // Optional safety: fetch all hidden decks to ensure we never show them even if they were archived
                // before `since` (e.g., after upgrading from older versions).
                if (since) {
                    try {
                        const hiddenAll = await API.queryDatabase(deckSource, { property: 'Archived?', checkbox: { equals: true } });
                        for (const p of (hiddenAll || [])) {
                            if (p?.id) hiddenDeckNotionIds.add(p.id);
                        }
                    } catch (_) { /* best-effort */ }
                }

                const mappedDecks = deckPages
                    .filter(p => !p?.archived && !isHiddenDeck(p))
                    .map(d => NotionMapper.deckFrom(d));

                // Identify decks that are new (not in local state) - need to fetch their cards
                const existingActiveDeckNotionIds = new Set(
                    this.state.decks.filter(d => d.notionId && !d.archived).map(d => d.notionId)
                );
                const newDeckIds = mappedDecks.filter(d => !existingActiveDeckNotionIds.has(d.notionId)).map(d => d.notionId);

                // Active deck ids for card filtering (local active + newly pulled active), excluding hidden/deleted.
                const activeDeckNotionIds = new Set([...existingActiveDeckNotionIds, ...mappedDecks.map(d => d.notionId)]);
                for (const id of hiddenDeckNotionIds) activeDeckNotionIds.delete(id);
                for (const id of deletedDeckNotionIds) activeDeckNotionIds.delete(id);

                // Query cards (with timestamp if incremental), then filter client-side
                let cardFilter = null;
                if (since) {
                    cardFilter = { timestamp: 'last_edited_time', last_edited_time: { on_or_after: since } };
                }
                const cards = await API.queryDatabase(cardSource, cardFilter);
                const deletedCardNotionIds = new Set((cards || []).filter(p => p?.archived).map(p => p.id));
                let mappedCards = (cards || []).filter(p => !p?.archived).map(c => NotionMapper.cardFrom(c, mappedDecks));

                // If we have new decks, fetch their cards separately (they may not have been edited recently)
                if (since && newDeckIds.length > 0) {
                    for (const deckId of newDeckIds) {
                        const deckCards = await API.queryDatabase(cardSource, {
                            property: 'Deck',
                            relation: { contains: deckId }
                        });
                        const newCards = (deckCards || []).filter(p => !p?.archived).map(c => NotionMapper.cardFrom(c, mappedDecks));
                        // Add cards we don't already have
                        for (const nc of newCards) {
                            if (!mappedCards.find(c => c.notionId === nc.notionId)) {
                                mappedCards.push(nc);
                            }
                        }
                    }
                }

                // Filter out cards that belong to hidden/deleted decks
                const filteredCards = mappedCards.filter(c => {
                    // If card has no deck relation, include it
                    if (!c.deckId) return true;
                    // Include only if deck is in our non-archived list
                    return activeDeckNotionIds.has(c.deckId);
                });

                if (!since) {
                    await Storage.wipeStore('decks');
                    await Storage.wipeStore('cards');
                    this.state.decks = [];
                    this.state.cards = [];
                }

                // Apply deletions (Notion page-level archive/delete) on incremental pulls.
                // Deck deletions also remove their cards locally.
                if (since) {
                    if (deletedCardNotionIds.size > 0) {
                        for (const nid of deletedCardNotionIds) {
                            const local = this.state.cards.find(c => c.notionId === nid);
                            if (!local) continue;
                            await Storage.delete('cards', local.id);
                        }
                        this.state.cards = this.state.cards.filter(c => !deletedCardNotionIds.has(c.notionId));
                    }
                    if (hiddenDeckNotionIds.size > 0) {
                        const toHideDecks = this.state.decks.filter(d => d.notionId && hiddenDeckNotionIds.has(d.notionId));
                        // Remove from local DB/state entirely.
                        for (const d of toHideDecks) {
                            await Storage.delete('decks', d.id);
                        }
                        const hideDeckKeys = new Set([
                            ...toHideDecks.map(d => d.id),
                            ...toHideDecks.map(d => d.notionId).filter(Boolean),
                            ...hiddenDeckNotionIds
                        ]);
                        const cardsToHide = this.state.cards.filter(c => hideDeckKeys.has(c.deckId));
                        for (const c of cardsToHide) {
                            await Storage.delete('cards', c.id);
                        }
                        this.state.cards = this.state.cards.filter(c => !hideDeckKeys.has(c.deckId));
                        this.state.decks = this.state.decks.filter(d => !(d.notionId && hiddenDeckNotionIds.has(d.notionId)));
                        // Remove hidden decks from selection/filter state
                        if (this.state.filters?.studyDecks?.length) {
                            const hiddenIds = new Set(toHideDecks.map(d => d.id));
                            this.state.filters.studyDecks = this.state.filters.studyDecks.filter(id => !hiddenIds.has(id));
                        }
                        if (this.state.selectedDeck && this.state.selectedDeck.notionId && hiddenDeckNotionIds.has(this.state.selectedDeck.notionId)) {
                            this.state.selectedDeck = null;
                        }
                    }
                    if (deletedDeckNotionIds.size > 0) {
                        const toDeleteDecks = this.state.decks.filter(d => deletedDeckNotionIds.has(d.notionId));
                        for (const d of toDeleteDecks) {
                            await Storage.delete('decks', d.id);
                        }
                        const deletedDeckKeys = new Set([
                            ...toDeleteDecks.map(d => d.id),
                            ...toDeleteDecks.map(d => d.notionId).filter(Boolean),
                            ...deletedDeckNotionIds
                        ]);
                        // Remove cards in deleted decks (by either local id or Notion id).
                        const cardsToDelete = this.state.cards.filter(c => deletedDeckKeys.has(c.deckId));
                        for (const c of cardsToDelete) {
                            await Storage.delete('cards', c.id);
                        }
                        this.state.decks = this.state.decks.filter(d => !deletedDeckNotionIds.has(d.notionId));
                        this.state.cards = this.state.cards.filter(c => !deletedDeckKeys.has(c.deckId));
                    }
                }

                const upsertDeck = (deck) => {
                    const idx = this.state.decks.findIndex(d => d.notionId === deck.notionId);
                    if (idx >= 0) this.state.decks[idx] = { ...this.state.decks[idx], ...deck };
                    else this.state.decks.push(deck);
                };
                const upsertCard = (card) => {
                    const idx = this.state.cards.findIndex(c => c.notionId === card.notionId);
                    if (idx >= 0) this.state.cards[idx] = { ...this.state.cards[idx], ...card };
                    else this.state.cards.push(card);
                };

                for (const d of mappedDecks) { upsertDeck(d); await Storage.put('decks', d); }
                for (const c of filteredCards) { upsertCard(c); await Storage.put('cards', c); }
                this.renderAll();
            },
            async pushQueue() {
                const { deckSource, cardSource } = this.state.settings;
                // Process deck operations before card operations to satisfy Notion relation dependencies.
                const queue = [...this.state.queue]
                    .map((op, idx) => ({ op, idx }))
                    .sort((a, b) => {
                        const prio = (t) => ({ 'deck-upsert': 1, 'deck-delete': 2, 'card-upsert': 3, 'card-delete': 4, 'block-append': 5 }[t] || 99);
                        const dp = prio(a.op.type) - prio(b.op.type);
                        return dp !== 0 ? dp : a.idx - b.idx; // stable within the same type
                    })
                    .map(x => x.op);
                const hadQueue = queue.length > 0;
                this.state.queue = [];
                el('#queueCount').textContent = '0';
                const failed = [];
                for (let i = 0; i < queue.length; i++) {
                    const op = queue[i];
                    if (i > 0) await sleep(350); // Pace requests to ~3 per second
                    try {
                        if (op.type === 'deck-upsert') {
                            const props = NotionMapper.deckProps(op.payload);
                            if (op.payload.notionId) await API.updatePage(op.payload.notionId, props);
                            else {
                                const res = await API.createPage(deckSource, props);
                                op.payload.notionId = res.id;
                                op.payload.id = op.payload.id || res.id;
                                await Storage.put('decks', op.payload);
                                // If the queue was rehydrated from storage, op.payload may not be the same object
                                // instance as the deck in memory. Ensure we update in-memory state so subsequent
                                // card upserts in this same run can resolve `deck.notionId`.
                                const deckIdx = this.state.decks.findIndex(d => d.id === op.payload.id);
                                if (deckIdx >= 0) {
                                    this.state.decks[deckIdx] = { ...this.state.decks[deckIdx], ...op.payload };
                                }
                            }
                        }
                        if (op.type === 'deck-delete' && op.payload.notionId) await API.archivePage(op.payload.notionId);
                        if (op.type === 'card-upsert') {
                            const deck = this.deckById(op.payload.deckId);
                            if (!op.payload.notionId && op.payload.deckId && (!deck || !deck.notionId)) {
                                throw new Error('Deck not yet synced');
                            }
                            const props = NotionMapper.cardProps(op.payload, deck);
                            if (op.payload.notionId) await API.updatePage(op.payload.notionId, props);
                            else {
                                const res = await API.createPage(cardSource, props);
                                op.payload.notionId = res.id;
                                op.payload.id = op.payload.id || res.id;
                                op.payload.syncId = res.id;
                            }
                            // After successful push, reset updatedInApp and update _notionRichText
                            // so subsequent pushes (e.g., SRS updates) preserve the rich_text we just sent
                            op.payload.updatedInApp = false;
                            op.payload._notionRichText = {
                                name: props['Name'].title,
                                back: props['Back'].rich_text,
                                notes: props['Notes'].rich_text
                            };
                            // Update local state
                            const cardIdx = this.state.cards.findIndex(c => c.notionId === op.payload.notionId || c.id === op.payload.id);
                            if (cardIdx >= 0) {
                                this.state.cards[cardIdx] = { ...this.state.cards[cardIdx], ...op.payload };
                            }
                            await Storage.put('cards', op.payload);
                        }
                        if (op.type === 'card-delete' && op.payload.notionId) await API.archivePage(op.payload.notionId);
                        if (op.type === 'block-append' && op.payload.pageId) {
                            await API.appendBlocks(op.payload.pageId, op.payload.blocks);
                        }
                    } catch (e) {
                        console.error(`Queue op failed: ${op.type}`, e);
                        // Store last error so the header badge can explain why the queue may look "stuck".
                        this.state.lastQueueError = {
                            at: new Date().toISOString(),
                            type: op.type,
                            message: e?.message || String(e)
                        };
                        Storage.setMeta('lastQueueError', this.state.lastQueueError).catch(() => { });
                        op.retryCount = (op.retryCount || 0) + 1;
                        if (op.retryCount <= 5) {
                            failed.push(op);
                        } else {
                            toast(`Sync dropped item after 5 attempts: ${e.message}`);
                        }
                    }
                }
                // Re-queue failed operations at the back of the queue
                if (failed.length > 0) {
                    this.state.queue = [...this.state.queue, ...failed];
                    el('#queueCount').textContent = String(this.state.queue.length);
                    toast(`${failed.length} sync operation(s) failed, will retry`);
                    this.state.queueLastChangedAt = new Date().toISOString();
                    Storage.setMeta('queueLastChangedAt', this.state.queueLastChangedAt).catch(() => { });
                } else if (hadQueue) {
                    // Queue fully drained: clear the last error to avoid stale "stuck" tooltips.
                    this.state.lastQueueError = null;
                    Storage.setMeta('lastQueueError', null).catch(() => { });
                    this.state.queueLastChangedAt = new Date().toISOString();
                    Storage.setMeta('queueLastChangedAt', this.state.queueLastChangedAt).catch(() => { });
                }
                await Storage.setMeta('queue', this.state.queue);
                this.renderConnection();
            },
            queueOp(op, reason = 'generic') {
                op.reason = reason;
                this.state.queue.push(op);
                el('#queueCount').textContent = String(this.state.queue.length);
                Storage.setMeta('queue', this.state.queue).catch(() => { });
                this.state.queueLastChangedAt = new Date().toISOString();
                Storage.setMeta('queueLastChangedAt', this.state.queueLastChangedAt).catch(() => { });
                this.updateSyncButtonState();
                this.renderConnection();
                const delay = (reason === 'rating') ? (5 * 60 * 1000) : 1500;
                this.requestAutoSyncSoon(delay, reason);
            },
            updateSyncButtonState() {
                const btn = el('#syncNowBtn');
                if (!btn) return;
                const pendingOffline = this.state.queue.length > 0 && !navigator.onLine;
                const offline = !navigator.onLine;
                btn.disabled = pendingOffline || this.state.syncing || offline;
                btn.classList.toggle('opacity-70', btn.disabled);
            },
            async manualSync() {
                if (!navigator.onLine) {
                    toast('Offline: sync will run when you are online');
                    return;
                }
                if (!this.isReady()) { toast('Complete setup first'); return; }
                if (this.state.syncing) { toast('Sync already in progress'); return; }

                this.state.syncing = true;
                const btn = el('#refreshDecksBtn');
                const svg = btn?.querySelector('svg');
                if (svg) svg.classList.add('animate-spin');

                try {
                    // Always push first to save local progress
                    if (this.state.queue.length > 0) {
                        await this.pushQueue();
                        this.state.lastPush = new Date().toISOString();
                        await Storage.put('meta', { key: 'lastPush', value: this.state.lastPush });
                    }
                    // Then pull to get updates
                    await this.pullFromNotion();
                    this.state.lastPull = new Date().toISOString();
                    await Storage.put('meta', { key: 'lastPull', value: this.state.lastPull });

                    this.state.lastSync = new Date().toISOString();
                    await Storage.put('meta', { key: 'lastSync', value: this.state.lastSync });
                    this.renderConnection();
                    toast('Synced with Notion');
                } catch (e) {
                    console.error('Manual sync failed', e);
                    toast('Sync failed - check connection');
                } finally {
                    this.state.syncing = false;
                    if (svg) svg.classList.remove('animate-spin');
                    if (this.state.queue.length > 0) {
                        this.requestAutoSyncSoon(MIN_PUSH_INTERVAL_MS + 100);
                    }
                }
            },
            startAutoSync() {
                if (this.state.autoSyncTimer) clearInterval(this.state.autoSyncTimer);
                this.state.autoSyncTimer = setInterval(() => this.autoSyncTick(), SYNC_INTERVAL_MS);
                this.autoSyncTick(); // kick off once on load
                this.updateSyncButtonState();
            },
            requestAutoSyncSoon(delayMs = 1500, reason = 'generic') {
                if (this.state.autoSyncSoonTimer) {
                    if (reason !== 'rating') {
                        clearTimeout(this.state.autoSyncSoonTimer);
                        this.state.autoSyncSoonTimer = null;
                    } else {
                        return;
                    }
                }
                if (!navigator.onLine) return;
                if (!this.isReady()) return;
                const ms = Math.max(200, Number(delayMs) || 0);
                this.state.autoSyncSoonTimer = setTimeout(() => {
                    this.state.autoSyncSoonTimer = null;
                    this.autoSyncTick();
                }, ms);
            },
            async autoSyncTick() {
                if (this.state.syncing) return;
                if (!navigator.onLine) {
                    this.updateSyncButtonState();
                    return;
                }
                if (!this.isReady()) return;
                const now = Date.now();
                const lastPullMs = this.state.lastPull ? new Date(this.state.lastPull).getTime() : 0;
                const lastPushMs = this.state.lastPush ? new Date(this.state.lastPush).getTime() : 0;
                // Don't pull during a study session; keep focus on local flow.
                const wantsPull = !this.state.session && (now - lastPullMs > MIN_PULL_INTERVAL_MS);
                // Never pull while there are pending local mutations; a pull can overwrite local edits or
                // break deck/card references before the queue finishes pushing.
                const wantsPush = this.state.queue.length > 0;
                const canPushNow = wantsPush && (this.state.lastPush == null || (now - lastPushMs > MIN_PUSH_INTERVAL_MS));
                if (!wantsPull && !wantsPush) return;
                // If we have pending work but are within the push cooldown, schedule another tick close to the allowed time.
                if (wantsPush && !canPushNow) {
                    const remaining = MIN_PUSH_INTERVAL_MS - (now - lastPushMs);
                    this.requestAutoSyncSoon(remaining + 100);
                    return;
                }
                this.state.syncing = true;
                try {
                    let didWork = false;
                    // Always push first to avoid overwriting local changes with stale Notion data
                    if (canPushNow) {
                        await this.pushQueue();
                        this.state.lastPush = new Date().toISOString();
                        await Storage.put('meta', { key: 'lastPush', value: this.state.lastPush });
                        didWork = true;
                    }
                    // Only pull when the queue is empty after any push attempt.
                    if (wantsPull && this.state.queue.length === 0) {
                        await this.pullFromNotion();
                        this.state.lastPull = new Date().toISOString();
                        await Storage.put('meta', { key: 'lastPull', value: this.state.lastPull });
                        didWork = true;
                    }
                    if (didWork) {
                        this.state.lastSync = new Date().toISOString();
                        await Storage.put('meta', { key: 'lastSync', value: this.state.lastSync });
                        this.renderConnection();
                    }
                } catch (e) {
                    console.error('Auto sync failed', e);
                } finally {
                    this.state.syncing = false;
                    this.updateSyncButtonState();
                    // If more work was added to the queue during sync, schedule another tick.
                    if (this.state.queue.length > 0) {
                        this.requestAutoSyncSoon(MIN_PUSH_INTERVAL_MS + 100);
                    }
                }
            },
            handleOnline() {
                this.renderConnection();
                this.requestAutoSyncSoon(250);
            },
            selectDeck(id) {
                const deck = this.deckById(id);
                this.state.selectedDeck = deck;
                this.state.cardLimit = 50; // Reset limit
                this.renderDecks(); // Re-render to show selection highlight
                this.renderCards();
                this.renderStudy();
                this.renderSelectedDeckBar();
                // Scroll to cards section
                const cardsSection = el('#cardsSection');
                if (cardsSection) cardsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            },
            selectCard(id) {
                const card = this.cardById(id);
                this.state.selectedCard = card;
                this.renderStudy();
                this.openCardModal(card);
            },
            editCard(id) {
                const card = this.cardById(id);
                if (!card) return;
                this.state.selectedCard = card;
                this.openCardModal(card);
            },
            showReviewHistoryPopover(btn, cardId) {
                // Close any existing popover
                const existing = document.querySelector('.review-history-popover');
                if (existing) existing.remove();

                const card = this.cardById(cardId);
                if (!card) return;

                const history = card.reviewHistory || [];
                const ratingColors = { again: 'text-red-500', hard: 'text-orange-500', good: 'text-green-500', easy: 'text-blue-500' };

                // Create popover content
                let content;
                if (history.length === 0) {
                    content = '<p class="text-earth-metal/50 dark:text-white/60 text-center py-2">No reviews yet</p>';
                } else {
                    // Show last 10 reviews (most recent first)
                    const recentHistory = [...history].reverse().slice(0, 10);
                    content = `
                        <table class="w-full text-xs">
                            <thead><tr class="text-earth-metal/50 dark:text-white/60 border-b border-charcoal/10 dark:border-white/10"><th class="text-left py-1">Rating</th><th class="text-left py-1">Date</th></tr></thead>
                            <tbody>
                                ${recentHistory.map(h => `
                                    <tr class="border-b border-charcoal/5 dark:border-white/5 last:border-0">
                                        <td class="py-1 capitalize ${ratingColors[h.rating] || ''}">${h.rating}</td>
                                        <td class="py-1 text-earth-metal/70 dark:text-white/70">${new Date(h.at).toLocaleDateString()} ${new Date(h.at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                        ${history.length > 10 ? `<p class="text-earth-metal/50 dark:text-white/60 text-xs text-center mt-1">+${history.length - 10} more</p>` : ''}
                    `;
                }

                // Create and position popover
                const popover = document.createElement('div');
                popover.className = 'review-history-popover fixed z-50 bg-oatmeal dark:bg-zinc-800 border border-charcoal/20 dark:border-white/10 rounded-lg shadow-lg p-3 min-w-[200px] max-w-[280px]';
                popover.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-medium text-sm text-charcoal dark:text-white">Review History</span>
                        <button class="close-popover text-earth-metal/50 dark:text-white/60 hover:text-earth-metal dark:hover:text-white p-0.5"><i data-lucide="x" class="w-4 h-4"></i></button>
                    </div>
                    ${content}
                `;

                // Position popover near button
                document.body.appendChild(popover);
                const btnRect = btn.getBoundingClientRect();
                const popRect = popover.getBoundingClientRect();

                // Position to the left of button, or right if not enough space
                let left = btnRect.left - popRect.width - 8;
                if (left < 8) left = Math.min(window.innerWidth - popRect.width - 8, btnRect.right + 8);
                let top = btnRect.top;
                if (top + popRect.height > window.innerHeight - 8) top = window.innerHeight - popRect.height - 8;

                popover.style.left = `${left}px`;
                popover.style.top = `${top}px`;

                lucide.createIcons({ nodes: [popover] });

                // Close handlers
                popover.querySelector('.close-popover').onclick = () => popover.remove();
                const closeOnClickOutside = (e) => {
                    if (!popover.contains(e.target) && !btn.contains(e.target)) {
                        popover.remove();
                        document.removeEventListener('click', closeOnClickOutside);
                    }
                };
                setTimeout(() => document.addEventListener('click', closeOnClickOutside), 0);
            },
            passFilters(card) {
                const f = this.state.filters;
                const now = new Date();
                const deck = this.deckById(card.deckId);
                const alg = deck?.algorithm || 'SM-2';
                const lastRating = (alg === 'FSRS' ? card.fsrs?.lastRating : card.sm2?.lastRating) || card.fsrs?.lastRating || card.sm2?.lastRating;
                if (f.again && lastRating !== 'again') return false;
                if (f.hard && !['again', 'hard'].includes(lastRating)) return false;
                if (f.addedToday && card.createdAt && new Date(card.createdAt).toDateString() !== now.toDateString()) return false;
                if (f.tags.length && !f.tags.some(t => card.tags.some(ct => ct.name === t))) return false;
                if (f.suspended && card.suspended) return false;
                if (f.leech && card.leech) return false;
                return true;
            },
            isDue(card) {
                const deck = this.deckById(card.deckId);
                const alg = deck?.algorithm || 'SM-2';
                const duePrimary = alg === 'FSRS' ? card.fsrs?.dueDate : card.sm2?.dueDate;
                const dueFallback = alg === 'FSRS' ? card.sm2?.dueDate : card.fsrs?.dueDate;
                const due = duePrimary || dueFallback;
                return due ? new Date(due) <= new Date() : true;
            },
            pickCard() {
                // If session is active, return the session's current card
                if (this.state.session) {
                    const sessionData = this.getSessionCard();
                    if (sessionData && sessionData.card) {
                        // Store the pre-computed reverse decision from session
                        this.state.sessionReversed = sessionData.reversed;
                        return sessionData.card;
                    }
                    // Session complete or no more cards
                    return null;
                }

                const f = this.state.filters;
                // If studyNonDue is enabled, include all cards regardless of due date
                let pool = this.state.studyNonDue
                    ? this.state.cards.filter(c => this.passFilters(c))
                    : this.state.cards.filter(c => this.passFilters(c) && this.isDue(c));
                // Filter by selected study decks
                if (f.studyDecks && f.studyDecks.length > 0) {
                    pool = pool.filter(c => f.studyDecks.includes(c.deckId));
                }
                if (pool.length === 0) return null;

                // Sort by due date (most overdue first, new cards at the end)
                pool.sort((a, b) => {
                    const dueA = (a.fsrs?.dueDate || a.sm2?.dueDate);
                    const dueB = (b.fsrs?.dueDate || b.sm2?.dueDate);
                    if (!dueA && !dueB) return 0;
                    if (!dueA) return 1;
                    if (!dueB) return -1;
                    return new Date(dueA) - new Date(dueB);
                });

                return pool[0] || null;
            },
            renderCardFront(card, deck) {
                const typeKey = (card.type || '').toLowerCase();
                const isCloze = typeKey === 'cloze';
                const isFrontStyle = typeKey.includes('front');
                // Use session's pre-computed reverse decision if active, otherwise random
                let shouldReverse;
                if (this.state.session && typeof this.state.sessionReversed === 'boolean') {
                    shouldReverse = !isCloze && this.state.sessionReversed;
                } else {
                    shouldReverse = !isCloze && deck?.reverse && isFrontStyle && Math.random() < 0.5;
                }
                // Store reverse state for reveal
                this.state.cardReversed = shouldReverse;
                let prompt = shouldReverse ? card.back : card.name;
                if (isCloze) {
                    // Cloze content may be stored in either Name or Back; prefer the field that contains cloze markup.
                    const hasClozeInName = /\{\{c\d+::.+?\}\}/i.test(card.name || '');
                    const hasClozeInBack = /\{\{c\d+::.+?\}\}/i.test(card.back || '');
                    if (!hasClozeInName && hasClozeInBack) {
                        prompt = card.back;
                    }
                    // Create cloze blanks with hidden answer and visible placeholder
                    const processed = prompt.replace(/\{\{c\d+::(.*?)\}\}/g, (match, answer) => {
                        return `<span class="cloze-blank"><span class="cloze-placeholder">[...]</span><span class="cloze-answer">${answer}</span></span>`;
                    });
                    return marked.parse(processed);
                }
                return marked.parse(prompt);
            },
            setRatingEnabled(enabled) {
                document.querySelectorAll('.rate-btn').forEach(btn => {
                    btn.disabled = !enabled;
                    btn.classList.toggle('opacity-30', !enabled);
                    btn.classList.toggle('cursor-not-allowed', !enabled);
                    btn.classList.toggle('pointer-events-none', !enabled);
                });
            },
            reveal() {
                const card = this.state.selectedCard;
                const isCloze = card && (card.type || '').toLowerCase() === 'cloze';
                if (this.state.answerRevealed) return;

                // Only show cardBack for non-cloze cards
                if (!isCloze) {
                    el('#cardBack').classList.remove('hidden');
                }

                // Show notes section after reveal (no longer a hint)
                const notesSection = el('#notesSection');
                if (notesSection) notesSection.classList.remove('hidden');

                // Show add note button after reveal
                const addNoteBtn = el('#addNoteBlock');
                if (addNoteBtn) addNoteBtn.classList.remove('hidden');

                // Show copy button after reveal
                const copyBtn = el('#copyCardContent');
                if (copyBtn) copyBtn.classList.remove('hidden');

                // Reveal cloze blanks
                document.querySelectorAll('#cardFront .cloze-blank').forEach(span => span.classList.add('revealed'));

                // Enable rating (in both Manual and AI modes, reveal() signifies answer is now visible)
                this.state.answerRevealed = true;
                this.setRatingEnabled(true);
                this.updateMobileFab();
                const revealBtn = el('#revealBtn');
                if (revealBtn) {
                    revealBtn.classList.add('hidden');
                }
                this.state.activeMicButton = null;
                this.state.lockAiUntilNextCard = true;
            },
            async rate(rating) {
                const card = this.state.selectedCard;
                if (!card) return;
                if (!this.state.answerRevealed) {
                    const mode = el('#revisionMode').value;
                    toast(mode === 'ai' ? 'Judge the answer first' : 'Reveal the answer first');
                    return;
                }
                if (this.isAiModeSelected() && navigator.onLine && !this.state.settings.aiKey) {
                    toast('Add an AI key or switch to Reveal mode');
                    return;
                }
                const ratingKey = normalizeRating(rating);
                const ratingLabel = displayRating(ratingKey) || 'Good';
                // Save previous state for undo
                const previousState = {
                    cardId: card.id,
                    sm2: JSON.parse(JSON.stringify(card.sm2 || {})),
                    fsrs: JSON.parse(JSON.stringify(card.fsrs || {})),
                    history: [...card.reviewHistory],
                    rating: ratingLabel,
                    sessionIndex: this.state.session ? this.state.session.currentIndex : null,
                    ratingCounts: this.state.session?.ratingCounts ? { ...this.state.session.ratingCounts } : null
                };
                // Preview mode: never modify scheduling (independent of due/all selection).
                const previewMode = !!this.state.session?.noScheduleChanges;
                // Track rating in session statistics
                if (this.state.session && this.state.session.ratingCounts) {
                    this.state.session.ratingCounts[ratingLabel] = (this.state.session.ratingCounts[ratingLabel] || 0) + 1;
                }
                if (previewMode) {
                    this.state.lastRating = null;
                    this.setRatingEnabled(false);
                    this.advanceSession(false);
                    toast('Preview mode: scheduling unchanged');
                    return;
                }
                const deck = this.deckById(card.deckId);
                const alg = deck?.algorithm || 'SM-2';
                if (alg === 'FSRS') card.fsrs = SRS.fsrs(card, ratingKey, deck?.fsrsWeights, deck?.fsrsDesiredRetention);
                else card.sm2 = SRS.sm2(card, ratingKey);  // SM-2 is default
                card.fsrs = card.fsrs || {};
                if (alg === 'FSRS') card.fsrs.lastRating = ratingKey;
                else {
                    card.sm2 = card.sm2 || {};
                    card.sm2.lastRating = ratingKey;
                }
                card.reviewHistory.push({ rating: ratingKey, at: new Date().toISOString() });
                await Storage.put('cards', card);
                this.queueOp({ type: 'card-upsert', payload: card }, 'rating');
                // Show undo toast
                this.showUndoToast(previousState);
                // If session is active, advance the session; otherwise just render next card
                if (this.state.session) {
                    this.advanceSession(false);
                } else {
                    this.nextCard();
                }
            },
            nextCard() {
                if (this.state.session) {
                    this.advanceSession(true); // wasSkipped = true
                } else {
                    this.renderStudy();
                }
            },
            showUndoToast(previousState) {
                // Clear any existing undo toast timeout
                if (this.state.undoToastTimeout) {
                    clearTimeout(this.state.undoToastTimeout);
                }
                this.state.lastRating = previousState;
                const t = el('#toast');
                t.innerHTML = `Rated "${previousState.rating}" <button id="undoBtn" class="ml-2 underline font-medium hover:text-ghost-dark">Undo</button>`;
                t.classList.remove('hidden', 'opacity-0');
                el('#undoBtn').onclick = () => this.undoLastRating();
                this.state.undoToastTimeout = setTimeout(() => {
                    this.state.lastRating = null;
                    t.classList.add('opacity-0');
                    setTimeout(() => {
                        t.classList.add('hidden');
                        t.innerHTML = '';
                    }, 300);
                }, 4000);
            },
            async undoLastRating() {
                const prev = this.state.lastRating;
                if (!prev) {
                    toast('Nothing to undo');
                    return;
                }
                // Clear the undo toast timeout
                if (this.state.undoToastTimeout) {
                    clearTimeout(this.state.undoToastTimeout);
                    this.state.undoToastTimeout = null;
                }
                // Find the card and restore its state
                const card = this.cardById(prev.cardId);
                if (!card) {
                    toast('Card not found');
                    this.state.lastRating = null;
                    return;
                }
                // Restore SRS state
                card.sm2 = prev.sm2;
                card.fsrs = prev.fsrs;
                card.reviewHistory = prev.history;
                // Save restored card
                await Storage.put('cards', card);
                // Ensure undo is propagated to Notion on next sync.
                this.queueOp({ type: 'card-upsert', payload: card });
                // Also update in memory
                const cardIndex = this.state.cards.findIndex(c => c.id === card.id);
                if (cardIndex !== -1) {
                    this.state.cards[cardIndex] = card;
                }
                // Restore session state if applicable
                if (this.state.session && prev.sessionIndex !== null) {
                    this.state.session.currentIndex = prev.sessionIndex;
                    // Remove from completed array if it was added
                    const completedIdx = this.state.session.completed.indexOf(prev.cardId);
                    if (completedIdx !== -1) {
                        this.state.session.completed.splice(completedIdx, 1);
                    }
                    // Restore rating counts
                    if (prev.ratingCounts) {
                        this.state.session.ratingCounts = prev.ratingCounts;
                    }
                    this.saveSession();
                }
                this.state.lastRating = null;
                // Hide the undo toast
                const t = el('#toast');
                t.classList.add('hidden', 'opacity-0');
                t.innerHTML = '';
                // Re-render study view to show the card again
                this.renderStudy();
                toast('Rating undone');
            },
            enableNonDueStudy() {
                // Temporarily ignore due dates for this study session
                this.state.studyNonDue = true;
                this.renderStudy();
            },
            cardsForDeck(deckId) {
                return this.state.cards.filter(c => c.deckId === deckId);
            },
            deckById(id) {
                return this.state.decks.find(d => d.id === id);
            },
            cardById(id) {
                return this.state.cards.find(c => c.id === id);
            },
            deckName(id) {
                return this.deckById(id)?.name ?? 'â€”';
            },
            getDeckLabel(deckIds) {
                if (!deckIds || deckIds.length === 0) return 'No decks';
                const allDeckIds = this.state.decks.map(d => d.id);
                const isAllDecks = deckIds.length === allDeckIds.length &&
                    deckIds.every(id => allDeckIds.includes(id));
                if (isAllDecks) return 'All decks';
                if (deckIds.length === 1) return this.deckById(deckIds[0])?.name || 'Unknown';
                return `${deckIds.length} decks`;
            },
            resetFilters() {
                this.state.filters = { again: false, hard: false, addedToday: false, tags: [], suspended: false, leech: false, studyDecks: [] };
                el('#filterAgain').checked = false;
                el('#filterHard').checked = false;
                el('#filterAddedToday').checked = false;
                el('#filterSuspended').checked = false;
                el('#filterLeech').checked = false;
                this.renderStudyDeckSelection();
                this.renderTagFilter();
                this.renderStudy();
                this.renderCards();
            },
            openNotesModal() {
                const card = this.state.selectedCard;
                if (!card) return toast('No card selected');
                el('#notesArea').value = card.notes || '';
                el('#noteStatus').textContent = '';
                this.openModal('notesModal');
            },
            async saveNotes() {
                const card = this.state.selectedCard;
                if (!card) return;
                card.notes = el('#notesArea').value;
                await Storage.put('cards', card);
                this.queueOp({ type: 'card-upsert', payload: card });
                el('#noteStatus').textContent = 'Saved';
                el('#notesPreview').innerHTML = card.notes ? marked.parse(card.notes) : '<p class="text-earth-metal/60 text-sm">No notes yet.</p>';
                applyMediaEmbeds(el('#notesPreview'));
                this.renderMath(el('#notesPreview'));
                this.closeModal('notesModal');
                toast('Notes saved');
            },
            openAddBlockModal() {
                const card = this.state.selectedCard;
                if (!card) return toast('No card selected');
                if (!card.notionId) return toast('Card not synced to Notion yet');
                el('#blockNoteArea').value = '';
                this.renderBlockNotePreview();
                this.openModal('addBlockModal');
            },
            renderBlockNotePreview() {
                const area = el('#blockNoteArea');
                const preview = el('#blockNotePreview');
                if (!area || !preview) return;
                const md = (area.value || '').trim();
                if (!md) {
                    preview.innerHTML = '<p class="text-earth-metal/50 dark:text-white/60">Type a note to preview media embeds.</p>';
                    return;
                }
                preview.innerHTML = marked.parse(md);
                applyMediaEmbeds(preview);
                this.renderMath(preview);
            },
            async saveBlockNote() {
                const card = this.state.selectedCard;
                if (!card || !card.notionId) return toast('Card not synced to Notion');
                const content = el('#blockNoteArea').value.trim();
                if (!content) return toast('Please enter some text');

                // Add timestamp prefix
                const timestamp = new Date().toLocaleString();
                const fullContent = `[${timestamp}] ${content}`;

                // Create Notion paragraph block (no 'object' property needed for children)
                const block = {
                    type: 'paragraph',
                    paragraph: {
                        rich_text: markdownToNotionRichText(fullContent)
                    }
                };

                // Queue the block append operation
                this.queueOp({
                    type: 'block-append',
                    payload: {
                        pageId: card.notionId,
                        blocks: [block]
                    }
                });

                this.closeModal('addBlockModal');
                toast('Note queued for sync');
            },
            async copyCardContent() {
                const card = this.state.selectedCard;
                if (!card) return toast('No card selected');
                const deck = this.deckById(card.deckId);
                const isCloze = (card.type || '').toLowerCase() === 'cloze';
                let content = `## ${card.name}\n\n`;
                if (!isCloze && card.back) {
                    content += `**Answer:**\n${card.back}\n\n`;
                }
                if (card.notes) {
                    content += `**Notes:**\n${card.notes}\n\n`;
                }
                content += `Deck: ${deck?.name ?? 'â€”'}`;
                try {
                    await navigator.clipboard.writeText(content);
                    toast('Copied to clipboard');
                } catch (_) {
                    toast('Copy failed');
                }
            },
            async handleAnkiImport(file) {
                if (!file) return;
                if (file.size > 100 * 1024 * 1024) return toast('File too large (max 100MB)');
                const ext = file.name.split('.').pop().toLowerCase();
                if (ext === 'apkg' || ext === 'zip') {
                    await this.importApkg(file);
                    return;
                }
                const text = await file.text();
                let payload;
                try { payload = JSON.parse(text); } catch { payload = null; }
                if (!payload?.cards?.length) return toast('Unsupported file');

                const deckName = file.name.replace('.apkg', '').replace('.json', '');
                let deck = this.state.decks.find(d => d.name === deckName);
                if (!deck) {
                    deck = this.newDeck(deckName, 'SM-2');
                    this.state.decks.push(deck);
                    await Storage.put('decks', deck);
                    this.queueOp({ type: 'deck-upsert', payload: deck });
                }

                let importedCount = 0;
                const existingGuids = new Set(this.state.cards.map(c => c.ankiGuid).filter(Boolean));
                for (const raw of payload.cards) {
                    const guid = raw.guid || raw.id || null;
                    if (guid && existingGuids.has(guid)) continue;

                    const card = this.newCard(deck.id, raw.name || raw.front || 'Imported', raw.back || '', raw.type || 'Front-Back');
                    card.tags = (raw.tags || []).map(t => typeof t === 'string' ? { name: t, color: 'default' } : t);
                    card.notes = raw.notes || '';
                    card.ankiGuid = guid || crypto.randomUUID();
                    existingGuids.add(card.ankiGuid);
                    this.state.cards.push(card);
                    await Storage.put('cards', card);
                    this.queueOp({ type: 'card-upsert', payload: card });
                    importedCount++;
                }
                this.renderAll();
                toast(`Imported ${importedCount} cards from JSON`);
            },
            async importApkg(file) {
                try {
                    const buf = await file.arrayBuffer();
                    const zip = await JSZip.loadAsync(buf);
                    const collectionFile = zip.file('collection.anki2');
                    if (!collectionFile) {
                        toast('Invalid .apkg file: missing collection.anki2');
                        return;
                    }
                    const collection = await collectionFile.async('uint8array');
                    const SQL = await Storage.ensureSQL();
                    const db = new SQL.Database(collection);
                    const colRow = db.exec("SELECT * FROM col LIMIT 1")[0];
                    const row = colRow?.values?.[0] || [];
                    const models = JSON.parse(row[9] || '{}');
                    const decksJson = JSON.parse(row[10] || '{}');
                    const decksMap = {};
                    Object.values(decksJson).forEach(d => { decksMap[d.id] = d.name; });
                    const notes = db.exec("SELECT id,guid,mid,mod,usn,tags,flds,sfld,csum,flags,data FROM notes")[0]?.values || [];
                    const cards = db.exec("SELECT id,nid,did,ord,mod,usn,type,queue,due,ivl,factor,reps,lapses,left,odue,odid,flags,data FROM cards")[0]?.values || [];

                    const deckCache = {};
                    const notesById = new Map(notes.map(n => [n[0], n]));
                    const existingGuids = new Set(this.state.cards.map(c => c.ankiGuid).filter(Boolean));
                    let importedCount = 0;

                    for (const cardRow of cards) {
                        const [cid, nid, did, ord] = cardRow;
                        const note = notesById.get(nid);
                        if (!note) continue;
                        const [_, guid, mid, mod, usn, tags, flds] = note;

                        // Check if card with this GUID already exists
                        if (guid && existingGuids.has(guid)) continue;

                        const deckId = did;
                        // Use existing deck if available, or create/cache new one
                        if (!deckCache[deckId]) {
                            const deckName = decksMap[deckId] || file.name.replace('.apkg', '');
                            let deck = this.state.decks.find(d => d.name === deckName);
                            if (!deck) {
                                deck = this.newDeck(deckName, 'SM-2');
                                this.state.decks.push(deck);
                                await Storage.put('decks', deck);
                                this.queueOp({ type: 'deck-upsert', payload: deck });
                            }
                            deckCache[deckId] = deck;
                        }

                        const model = models[mid];
                        const fields = (flds || '').split('\u001f');
                        const front = fields[0] || 'Imported';
                        const back = fields[1] || '';
                        const isCloze = model?.type === 1;
                        const type = isCloze ? 'Cloze' : 'Front-Back';
                        const card = this.newCard(deckCache[deckId].id, front, isCloze ? back || front : back, type);
                        card.tags = (tags || '').trim().split(' ').filter(Boolean).map(t => ({ name: t.replace(/^\s*/, '').replace(/\s*$/, ''), color: 'default' }));
                        card.ankiGuid = guid;
                        if (guid) existingGuids.add(guid);
                        card.ankiNoteType = model?.name || '';
                        card.ankiFields = JSON.stringify(fields);
                        card.clozeIndexes = isCloze ? 'auto' : '';
                        this.state.cards.push(card);
                        await Storage.put('cards', card);
                        this.queueOp({ type: 'card-upsert', payload: card });
                        importedCount++;
                    }
                    this.renderAll();
                    toast(`Imported ${importedCount} cards from .apkg`);
                } catch (e) {
                    console.error(e);
                    toast('Import failed');
                }
            },
            async exportAnki() {
                const deck = this.state.selectedDeck || this.state.decks[0];
                if (!deck) return toast('No deck to export');
                const cards = this.cardsForDeck(deck.id);
                try {
                    const dbBytes = await this.buildApkgSql(deck, cards);
                    const zip = new JSZip();
                    zip.file('collection.anki2', dbBytes);
                    zip.file('media', JSON.stringify({}));
                    const blob = await zip.generateAsync({ type: 'blob' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const safeName = (deck.name || 'deck')
                        .toString()
                        .replace(/[\\/:*?"<>|]+/g, '-')
                        .replace(/\s+/g, ' ')
                        .trim()
                        .slice(0, 120) || 'deck';
                    a.download = `${safeName}.apkg`;
                    a.click();
                    URL.revokeObjectURL(url);
                    toast('Exported .apkg');
                } catch (e) {
                    toast('Export failed');
                    console.error(e);
                }
            },
            async buildApkgSql(deck, cards) {
                const SQL = await Storage.ensureSQL();
                const db = new SQL.Database();
                db.run(`CREATE TABLE col (id integer primary key, crt integer, mod integer, scm integer, ver integer, dty integer, usn integer, ls integer, conf text, models text, decks text, dconf text, tags text);`);
                db.run(`CREATE TABLE notes (id integer primary key, guid text, mid integer, mod integer, usn integer, tags text, flds text, sfld text, csum integer, flags integer, data text);`);
                db.run(`CREATE TABLE cards (id integer primary key, nid integer, did integer, ord integer, mod integer, usn integer, type integer, queue integer, due integer, ivl integer, factor integer, reps integer, lapses integer, left integer, odue integer, odid integer, flags integer, data text);`);
                db.run(`CREATE TABLE revlog (id integer primary key, cid integer, usn integer, ease integer, ivl integer, lastIvl integer, factor integer, time integer, type integer);`);
                db.run(`CREATE TABLE graves (id integer primary key, oid integer, type integer, usn integer);`);

                const nowMs = Date.now();
                const now = Math.floor(nowMs / 1000);
                const dayStart = Math.floor(now / 86400);
                const deckId = Math.abs(this.hash(deck.name));
                const modelBasicId = deckId + 1;
                const modelClozeId = deckId + 2;

                const conf = { nextPos: 1, estTimes: true, activeDecks: [deckId], sortType: "noteFld", sortBackwards: false, newSpread: 0, dueCounts: true, curDeck: deckId, timeLim: 0 };
                const models = {};
                models[modelBasicId] = {
                    id: modelBasicId,
                    name: "Basic",
                    type: 0,
                    mod: now,
                    usn: 0,
                    sortf: 0,
                    did: deckId,
                    latexPre: "\\documentclass{article}\\begin{document}",
                    latexPost: "\\end{document}",
                    flds: [
                        { name: "Front", ord: 0, sticky: false, rtl: false, font: "Arial", size: 20, media: [] },
                        { name: "Back", ord: 1, sticky: false, rtl: false, font: "Arial", size: 20, media: [] }
                    ],
                    tmpls: [
                        { name: "Card 1", ord: 0, qfmt: "{{Front}}", afmt: "{{FrontSide}}<hr id=answer>{{Back}}", did: null, bqfmt: "", bafmt: "" }
                    ],
                    css: ".card { font-family: Arial; font-size: 20px; }"
                };
                models[modelClozeId] = {
                    id: modelClozeId,
                    name: "Cloze",
                    type: 1,
                    mod: now,
                    usn: 0,
                    sortf: 0,
                    did: deckId,
                    flds: [
                        { name: "Text", ord: 0, sticky: false, rtl: false, font: "Arial", size: 20, media: [] },
                        { name: "Back Extra", ord: 1, sticky: false, rtl: false, font: "Arial", size: 20, media: [] }
                    ],
                    tmpls: [{ name: "Cloze", ord: 0, qfmt: "{{cloze:Text}}", afmt: "{{cloze:Text}}<br>{{Back Extra}}", did: null }],
                    css: ".card { font-family: Arial; font-size: 20px; }"
                };

                const decks = {};
                decks[deckId] = { id: deckId, name: deck.name, mod: now, usn: 0, desc: "", dyn: 0, extendNew: 0, extendRev: 0, conf: 1, collapsed: false, browserCollapsed: false, newToday: [dayStart, 0], revToday: [dayStart, 0], lrnToday: [dayStart, 0], timeToday: [dayStart, 0] };
                const dconf = { 1: { id: 1, name: "Default", new: { perDay: 20 }, rev: { perDay: 200 }, lapse: { delays: [10], mult: 0 }, dyn: false, maxTaken: 60, timer: 0 } };
                const tags = {};
                const colRow = db.prepare("INSERT INTO col VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)");
                colRow.run([nowMs, dayStart, now, now, 11, 0, 0, 0, JSON.stringify(conf), JSON.stringify(models), JSON.stringify(decks), JSON.stringify(dconf), JSON.stringify(tags)]);

                let nidCounter = nowMs;
                let cidCounter = nowMs + 500;
                const noteStmt = db.prepare("INSERT INTO notes VALUES (?,?,?,?,?,?,?,?,?,?,?)");
                const cardStmt = db.prepare("INSERT INTO cards VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");

                cards.forEach((card, idx) => {
                    const isCloze = (card.type || '').toLowerCase() === 'cloze';
                    const mid = isCloze ? modelClozeId : modelBasicId;
                    const nid = ++nidCounter;

                    const fields = isCloze ? [card.name, card.back] : [card.name, card.back];
                    const flds = fields.join('\u001f');
                    const tagStr = card.tags.length ? card.tags.map(t => t.name.trim()).join(' ') + ' ' : '';
                    const sfld = fields[0];
                    const csum = Math.abs(this.hash(flds)) >>> 0;
                    noteStmt.run([nid, card.ankiGuid || crypto.randomUUID(), mid, now, 0, tagStr, flds, sfld, csum, 0, ""]);

                    let ordinals = [0];
                    if (isCloze) {
                        const matches = [...card.name.matchAll(/{{\s*c(\d+)::/g)];
                        if (matches.length > 0) {
                            const indices = new Set(matches.map(m => parseInt(m[1], 10) - 1));
                            ordinals = Array.from(indices).sort((a, b) => a - b);
                        }
                    }

                    ordinals.forEach((ord) => {
                        const cid = ++cidCounter;
                        // Export as new cards: type=0, queue=0, due=integer order
                        const type = 0;
                        const queue = 0;
                        const due = idx + 1; // Or some global counter, but idx is fine for new cards order
                        const ivl = 0;
                        const factor = 0;

                        cardStmt.run([cid, nid, deckId, ord, now, 0, type, queue, due, ivl, factor, 0, 0, 0, 0, 0, 0, ""]);
                    });
                });

                return new Uint8Array(db.export());
            },
            hash(str) {
                let h = 0;
                for (let i = 0; i < str.length; i++) {
                    h = Math.imul(31, h) + str.charCodeAt(i) | 0;
                }
                return h;
            },
            updateCounts() {
                el('#deckCount').textContent = String(this.state.decks.length);
                el('#cardCount').textContent = String(this.state.cards.length);
                el('#queueCount').textContent = String(this.state.queue.length);
                el('#lastSync').textContent = this.state.lastSync ? new Date(this.state.lastSync).toLocaleString() : 'â€”';
            },
            openSettings() {
                this.state.lastFocusedElement = document.activeElement;
                const s = this.state.settings;
                el('#settingWorkerUrl').value = s.workerUrl;
                el('#settingProxyToken').value = s.proxyToken;
                el('#settingAuthToken').value = s.authToken.startsWith('secret_') ? s.authToken : s.authToken;
                el('#settingsModal').classList.remove('hidden');
                el('#settingsModal').classList.add('flex');
                this.renderStatus();
                this.updateSettingsButtons();
                setTimeout(() => { el('#settingWorkerUrl').focus(); }, 50);
            },
            closeSettings() {
                el('#settingsModal').classList.add('hidden');
                el('#settingsModal').classList.remove('flex');
                if (this.state.lastFocusedElement) {
                    this.state.lastFocusedElement.focus();
                    this.state.lastFocusedElement = null;
                }
            },
            showAiBlockedModal(reason) {
                const modal = el('#aiSettingsRequiredModal');
                const title = el('#aiSettingsModalTitle');
                const body = el('#aiSettingsModalBody');
                const actions = el('#aiSettingsModalActions');
                const closeBtn = el('#closeAiSettingsModal');
                const openSettingsBtn = el('#openSettingsFromAiModal');
                if (!modal || !title || !body || !actions) return;

                if (reason === 'offline') {
                    title.textContent = 'AI not available offline';
                    body.textContent = 'Reconnect to use AI mode. We switched you back to Reveal.';
                    if (openSettingsBtn) openSettingsBtn.classList.add('hidden');
                    if (closeBtn) closeBtn.textContent = 'OK';
                    closeBtn.onclick = () => {
                        this.closeModal('aiSettingsRequiredModal');
                        const revisionSelect = el('#revisionMode');
                        if (revisionSelect) revisionSelect.value = 'manual';
                        el('#aiControls')?.classList.add('hidden');
                    };
                } else {
                    title.textContent = 'AI settings required';
                    body.textContent = 'Set and verify your AI provider in Settings to enable AI mode.';
                    if (openSettingsBtn) openSettingsBtn.classList.remove('hidden');
                    if (closeBtn) closeBtn.textContent = 'Cancel';
                    closeBtn.onclick = () => this.closeModal('aiSettingsRequiredModal');
                }

                modal.classList.remove('hidden');
                modal.classList.add('flex');
            },
            async saveSettings() {
                const prevWorkerUrl = this.state.settings.workerUrl;
                const prevProxyToken = this.state.settings.proxyToken;
                const prevAiProvider = this.state.settings.aiProvider || '';
                const prevAiModel = this.state.settings.aiModel || '';
                const prevAiKey = this.state.settings.aiKey || '';
                this.state.settings.workerUrl = el('#settingWorkerUrl').value.trim();
                this.state.settings.proxyToken = el('#settingProxyToken').value.trim();
                if (this.state.settings.workerUrl !== prevWorkerUrl || this.state.settings.proxyToken !== prevProxyToken) {
                    this.state.workerVerified = false;
                    this.state.settings.workerVerified = false;
                }
                const authVal = el('#settingAuthToken').value.trim();
                const prevAuth = this.state.settings.authToken;
                if (authVal) {
                    this.state.settings.authToken = authVal;
                    if (authVal !== prevAuth) {
                        this.state.authVerified = false;
                        this.state.settings.authVerified = false;
                    }
                } else {
                    this.state.settings.authToken = '';
                    this.state.authVerified = false;
                    this.state.settings.authVerified = false;
                }
                // Save AI settings
                const aiProvider = el('#aiProvider').value;
                const aiModel = el('#aiModel').value.trim();
                const aiKey = el('#aiKey').value.trim();
                this.state.settings.aiProvider = aiProvider;
                this.state.settings.aiModel = aiModel;
                this.state.settings.aiKey = aiKey;
                const aiKeyChanged = !!(aiKey !== prevAiKey);
                const aiChanged = (aiProvider || '') !== prevAiProvider || (aiModel || '') !== prevAiModel || aiKeyChanged;
                if (!aiProvider || aiChanged) {
                    this.state.settings.aiVerified = false;
                }

                // Save STT settings
                const prevSttProvider = this.state.settings.sttProvider;
                const prevSttModel = this.state.settings.sttModel || '';
                const prevSttKey = this.state.settings.sttKey || '';
                const sttProvider = el('#sttProvider').value;
                const sttModel = el('#sttModel').value.trim();
                const sttKey = el('#sttKey').value.trim();
                const sttPrompt = el('#sttPrompt').value.trim();
                this.state.settings.sttProvider = sttProvider;
                this.state.settings.sttModel = sttModel;
                this.state.settings.sttKey = sttKey;
                this.state.settings.sttPrompt = sttPrompt;
                const sttKeyChanged = !!(sttKey !== prevSttKey);
                const sttChanged = (sttProvider || '') !== (prevSttProvider || '') || (sttModel || '') !== prevSttModel || sttKeyChanged;
                if (!sttProvider) {
                    this.state.settings.sttVerified = false;
                } else if (sttProvider === 'browser') {
                    this.state.settings.sttVerified = true;
                } else if (sttChanged) {
                    this.state.settings.sttVerified = false;
                }

                Storage.setSettings(this.state.settings);
                this.renderStatus();
                this.applyTheme();
                this.applyFontMode();
                this.renderGate();
                this.applySttChangeEffects(!sttProvider || sttChanged);
                // If AI became unverified, force the UI out of AI mode to avoid a broken study flow.
                if (!this.state.settings.aiVerified) {
                    const revisionSelect = el('#revisionMode');
                    if (revisionSelect && revisionSelect.value === 'ai') revisionSelect.value = 'manual';
                    el('#aiControls')?.classList.add('hidden');
                    el('#sttSettings')?.classList.add('hidden');
                    this.updateSkipHotkeyLabel(false);
                    this.updateMobileFab();
                }

                // Check if this is first sync (no decks/cards loaded yet)
                const isFirstSync = this.state.decks.length === 0 && this.state.cards.length === 0;

                if (isFirstSync && this.isReady()) {
                    // Close settings and show sync loading overlay
                    this.closeSettings();
                    showLoading('Syncing your content...', 'Fetching decks and cards from Notion.');

                    try {
                        await this.syncNow();
                        toast('Initial sync complete');
                    } catch (err) {
                        console.error('First sync error:', err);
                        toast('Sync error - please try again');
                    } finally {
                        hideLoading();
                        this.renderAll();
                    }
                } else {
                    this.closeSettings();
                    this.renderConnection();
                    toast('Settings saved');
                }
            },
            async verifyWorker() {
                if (!navigator.onLine) {
                    toast('Offline: connect to verify worker');
                    return;
                }
                const workerUrl = el('#settingWorkerUrl').value.trim();
                const proxyToken = el('#settingProxyToken').value.trim();
                if (!workerUrl) return toast('Add worker URL');
                try {
                    const url = new URL(workerUrl.replace(/\/$/, ''));
                    url.searchParams.append('url', 'https://api.notion.com/v1/users/me');
                    if (proxyToken) url.searchParams.append('token', proxyToken);
                    const res = await fetch(url.toString());
                    if (res.ok || res.status === 401) {
                        toast('Worker reachable');
                        this.state.settings.workerUrl = workerUrl;
                        this.state.settings.proxyToken = proxyToken;
                        this.state.workerVerified = true;
                        this.state.settings.workerVerified = true;
                        Storage.setSettings(this.state.settings);
                        this.renderStatus();
                        this.renderGate();
                    } else throw new Error(res.status);
                } catch (e) {
                    toast('Worker check failed');
                    this.state.workerVerified = false;
                    this.state.settings.workerVerified = false;
                    Storage.setSettings(this.state.settings);
                    this.renderStatus();
                }
            },
            async verifyAuth() {
                if (!navigator.onLine) {
                    toast('Offline: connect to verify Notion token');
                    return;
                }
                if (!this.state.settings.workerUrl) { this.updateSettingsButtons(); return toast('Add worker URL first'); }
                const workerUrl = (el('#settingWorkerUrl').value.trim()) || this.state.settings.workerUrl;
                const proxyToken = (el('#settingProxyToken').value.trim()) || this.state.settings.proxyToken;
                const authVal = (el('#settingAuthToken').value.trim()) || this.state.settings.authToken;
                if (!authVal) return toast('Add Notion token');
                this.state.settings.workerUrl = workerUrl;
                this.state.settings.proxyToken = proxyToken;
                this.state.settings.authToken = authVal;
                this.state.authVerified = true;
                this.state.settings.authVerified = true;
                Storage.setSettings(this.state.settings);
                toast('Token saved');
                this.renderStatus();
                this.renderGate();
                await this.scanSources();
            },
            async verifyAiSettings() {
                if (!navigator.onLine) {
                    toast('Offline: connect to verify AI settings');
                    return;
                }
                const provider = el('#aiProvider').value;
                const model = el('#aiModel').value.trim();
                const key = el('#aiKey').value.trim();
                if (!provider) return toast('Select an AI provider');
                if (!model) return toast('Enter a model name');
                if (!key) return toast('Enter an API key');
                try {
                    showLoading('Verifying AI settings...', 'Testing connection to AI provider.');
                    let endpoint, headers, body;
                    if (provider === 'openai') {
                        endpoint = 'https://api.openai.com/v1/models';
                        headers = { 'Authorization': `Bearer ${key}` };
                    } else if (provider === 'anthropic') {
                        endpoint = 'https://api.anthropic.com/v1/messages';
                        headers = { 'x-api-key': key, 'anthropic-version': '2023-06-01', 'Content-Type': 'application/json' };
                        body = JSON.stringify({ model, max_tokens: 1, messages: [{ role: 'user', content: 'Hi' }] });
                    } else if (provider === 'gemini') {
                        endpoint = `https://generativelanguage.googleapis.com/v1beta/models?key=${key}`;
                        headers = {};
                    }
                    const res = await fetch(endpoint, { method: body ? 'POST' : 'GET', headers, body });
                    if (res.ok || res.status === 400) {
                        this.state.settings.aiProvider = provider;
                        this.state.settings.aiModel = model;
                        this.state.settings.aiKey = key;
                        this.state.settings.aiVerified = true;
                        Storage.setSettings(this.state.settings);
                        // Show STT settings now that AI is verified
                        el('#sttSettings')?.classList.remove('hidden');
                        toast('AI settings verified');
                    } else {
                        throw new Error(`API returned ${res.status}`);
                    }
                } catch (e) {
                    this.state.settings.aiVerified = false;
                    Storage.setSettings(this.state.settings);
                    // Hide STT settings since AI is not verified
                    el('#sttSettings')?.classList.add('hidden');
                    toast('AI verification failed: ' + e.message);
                } finally {
                    hideLoading();
                }
            },
            async verifySttSettings() {
                if (!navigator.onLine) {
                    toast('Offline: connect to verify speech settings');
                    return;
                }
                const provider = el('#sttProvider').value;
                const model = el('#sttModel').value.trim();
                const key = el('#sttKey').value.trim();
                const prompt = el('#sttPrompt').value.trim();
                const inAiMode = el('#revisionMode').value === 'ai';

                if (!provider) {
                    this.state.settings.sttProvider = '';
                    this.state.settings.sttModel = '';
                    this.state.settings.sttKey = '';
                    this.state.settings.sttPrompt = prompt;
                    this.state.settings.sttVerified = false;
                    this.state.settings.sttPermissionWarmed = false;
                    Storage.setSettings(this.state.settings);
                    this.state.sttProvider = '';
                    this.state.sttVerified = false;
                    this.state.sttKey = '';
                    this.stopMicActivity(true);
                    this.applySttChangeEffects(true);
                    toast('Speech-to-text disabled');
                    return;
                }

                if (provider === 'browser') {
                    this.state.settings.sttProvider = 'browser';
                    this.state.settings.sttModel = '';
                    this.state.settings.sttKey = '';
                    this.state.settings.sttPrompt = prompt;
                    this.state.settings.sttVerified = true;
                    Storage.setSettings(this.state.settings);
                    this.state.sttProvider = 'browser';
                    this.state.sttModel = '';
                    this.state.sttKey = '';
                    this.state.sttPrompt = prompt;
                    this.state.sttVerified = true;
                    this.applySttChangeEffects(false);
                    if (inAiMode) el('#aiControls')?.classList.remove('hidden');
                    toast('Using browser speech recognition');
                    return;
                }

                if (!key) return toast('Enter an API key for cloud provider');

                try {
                    showLoading('Verifying STT settings...', 'Testing connection to speech provider.');
                    let endpoint, headers;

                    if (provider === 'openai') {
                        // Verify OpenAI key by checking models endpoint
                        endpoint = 'https://api.openai.com/v1/models';
                        headers = { 'Authorization': `Bearer ${key}` };
                    } else if (provider === 'groq') {
                        // Verify Groq key by checking models endpoint
                        endpoint = 'https://api.groq.com/openai/v1/models';
                        headers = { 'Authorization': `Bearer ${key}` };
                    } else if (provider === 'gemini') {
                        // Verify Gemini key by listing models
                        endpoint = `https://generativelanguage.googleapis.com/v1beta/models?key=${key}`;
                        headers = {};
                    }

                    const res = await fetch(endpoint, { method: 'GET', headers });
                    if (res.ok) {
                        this.state.settings.sttProvider = provider;
                        this.state.settings.sttModel = model || this.getDefaultSttModel(provider);
                        this.state.settings.sttKey = key;
                        this.state.settings.sttPrompt = prompt;
                        this.state.settings.sttVerified = true;
                        Storage.setSettings(this.state.settings);
                        this.applySttChangeEffects(false);
                        if (inAiMode) el('#aiControls')?.classList.remove('hidden');
                        toast('STT settings verified');
                    } else {
                        throw new Error(`API returned ${res.status}`);
                    }
                } catch (e) {
                    this.state.settings.sttVerified = false;
                    Storage.setSettings(this.state.settings);
                    toast('STT verification failed: ' + e.message);
                } finally {
                    hideLoading();
                }
            },
            getDefaultSttModel(provider) {
                if (provider === 'openai') return 'whisper-1';
                if (provider === 'groq') return 'whisper-large-v3';
                if (provider === 'gemini') return 'gemini-2.0-flash';
                return '';
            },
            startOAuth() {
                if (!this.state.settings.workerUrl) return toast('Add worker URL first');
                this.saveSettings();
                showLoading('Starting Notion sign-in...', 'Redirecting to Notion authorization.');
                const here = encodeURIComponent(window.location.href);
                window.location.href = `https://notion-oauth-handler.mimansa-jaiswal.workers.dev/auth/login?from=${here}`;
            },
            async scanSources() {
                if (!navigator.onLine) {
                    toast('Offline: cannot scan databases');
                    return;
                }
                if (!this.state.settings.workerUrl || !this.state.settings.authToken) return toast('Add worker URL and token first');
                try {
                    showLoading('Scanning databases...', 'Finding valid deck and card sources.');
                    toastLong('Scanning data sources...');
                    const dbs = await API.listDatabases();
                    const deckOptions = [];
                    const cardOptions = [];
                    for (const d of dbs) {
                        const id = d.id;
                        const title = d.title?.[0]?.plain_text || id;
                        if (await this.validateDb(d, 'deck')) deckOptions.push({ id, title });
                        if (await this.validateDb(d, 'card')) cardOptions.push({ id, title });
                    }
                    this.state.sourcesCache = { deckOptions, cardOptions };
                    this.state.settings.sourcesCache = { deckOptions, cardOptions };
                    el('#deckSourceSelect').innerHTML = `<option value=\"\">Select deck source</option>` + deckOptions.map(o => `<option value=\"${o.id}\">${o.title}</option>`).join('');
                    el('#cardSourceSelect').innerHTML = `<option value=\"\">Select card source</option>` + cardOptions.map(o => `<option value=\"${o.id}\">${o.title}</option>`).join('');
                    if (deckOptions.length === 1) this.state.settings.deckSource = deckOptions[0].id;
                    if (cardOptions.length === 1) this.state.settings.cardSource = cardOptions[0].id;
                    Storage.setSettings(this.state.settings);
                    if (this.state.settings.deckSource) el('#deckSourceSelect').value = this.state.settings.deckSource;
                    if (this.state.settings.cardSource) el('#cardSourceSelect').value = this.state.settings.cardSource;
                    this.state.sourcesVerified = !!(this.state.settings.deckSource && this.state.settings.cardSource);
                    this.state.settings.sourcesVerified = this.state.sourcesVerified;
                    Storage.setSettings(this.state.settings);
                    this.renderStatus();
                    this.renderGate();
                    toast('Sources loaded');
                } catch (e) {
                    toast(e.message);
                } finally {
                    hideLoading();
                    toastHide();
                }
            },
            populateSourceSelects() {
                const cache = this.state.settings.sourcesCache || { deckOptions: [], cardOptions: [] };
                const deckOptions = cache.deckOptions || [];
                const cardOptions = cache.cardOptions || [];
                this.state.sourcesCache = { deckOptions, cardOptions };
                el('#deckSourceSelect').innerHTML = `<option value="">Select deck source</option>` + deckOptions.map(o => `<option value="${o.id}">${o.title}</option>`).join('');
                el('#cardSourceSelect').innerHTML = `<option value="">Select card source</option>` + cardOptions.map(o => `<option value="${o.id}">${o.title}</option>`).join('');
                if (this.state.settings.deckSource) el('#deckSourceSelect').value = this.state.settings.deckSource;
                if (this.state.settings.cardSource) el('#cardSourceSelect').value = this.state.settings.cardSource;
                el('#deckSourceSelect').onchange = (e) => { this.state.settings.deckSource = e.target.value; this.state.sourcesVerified = !!(this.state.settings.deckSource && this.state.settings.cardSource); this.state.settings.sourcesVerified = this.state.sourcesVerified; Storage.setSettings(this.state.settings); this.renderStatus(); this.renderGate(); };
                el('#cardSourceSelect').onchange = (e) => { this.state.settings.cardSource = e.target.value; this.state.sourcesVerified = !!(this.state.settings.deckSource && this.state.settings.cardSource); this.state.settings.sourcesVerified = this.state.sourcesVerified; Storage.setSettings(this.state.settings); this.renderStatus(); this.renderGate(); };
            },
            openModal(id) {
                const m = el('#' + id);
                // Store the element that triggered the modal
                this.state.lastFocusedElement = document.activeElement;
                m.classList.remove('hidden');
                m.classList.add('flex');
                // Focus the first focusable element in the modal
                setTimeout(() => {
                    const focusable = m.querySelector('button, input, select, textarea, [tabindex]:not([tabindex="-1"])');
                    if (focusable) focusable.focus();
                }, 50);
            },
            closeModal(id) {
                const m = el('#' + id);
                m.classList.add('hidden');
                m.classList.remove('flex');
                // Return focus to the element that triggered the modal
                if (this.state.lastFocusedElement) {
                    this.state.lastFocusedElement.focus();
                    this.state.lastFocusedElement = null;
                }
            },
            async copyWorkerCode() {
                const code = el('#workerCodeBlock').innerText;
                try {
                    await navigator.clipboard.writeText(code);
                    toast('Worker code copied');
                } catch (e) {
                    console.error('Clipboard write failed:', e);
                    toast('Failed to copy - please select and copy manually');
                }
            },
            toggleDangerZone() {
                const content = el('#dangerZoneContent');
                const chevron = el('#dangerZoneChevron');
                content.classList.toggle('hidden');
                chevron.classList.toggle('rotate-180');
            },
            async resetApp() {
                this.closeModal('resetConfirmModal');
                showLoading('Resetting GhostInk...', 'Clearing all local data.');
                // Clear IndexedDB stores
                await Storage.wipeStore('decks');
                await Storage.wipeStore('cards');
                await Storage.wipeStore('meta');
                // Clear all GhostInk-specific localStorage keys
                localStorage.removeItem(Storage.settingsKey);
                localStorage.removeItem('ghostink_session_v1');
                // Close the database connection before deleting
                if (Storage.db) {
                    Storage.db.close();
                    Storage.db = null;
                }
                // Delete the entire database and wait for it to complete
                await new Promise((resolve, reject) => {
                    const req = indexedDB.deleteDatabase('GhostInkDB');
                    req.onsuccess = resolve;
                    req.onerror = reject;
                    req.onblocked = () => {
                        console.warn('Database delete blocked, reloading anyway');
                        resolve();
                    };
                });
                // Clear caches used by this app only
                if (typeof caches !== 'undefined') {
                    try {
                        const keys = await caches.keys();
                        await Promise.all(keys.filter(k => k.startsWith('ghostink-cache-')).map(k => caches.delete(k)));
                    } catch (e) {
                        console.warn('Cache clear failed', e);
                    }
                }
                // Unregister only this app's service worker (scope limited to current path)
                if (navigator.serviceWorker) {
                    try {
                        const regs = await navigator.serviceWorker.getRegistrations();
                        await Promise.all(regs.filter(r => r.scope.includes('ghostink-flashcards')).map(r => r.unregister()));
                    } catch (e) {
                        console.warn('SW unregister failed', e);
                    }
                }
                location.reload();
            },
            renderStatus() {
                const hasWorkerUrl = !!this.state.settings.workerUrl;
                const workerOk = hasWorkerUrl && (this.state.workerVerified || this.state.settings.workerVerified);
                const hasToken = !!this.state.settings.authToken;
                const authOk = workerOk && hasToken && (this.state.authVerified || this.state.settings.authVerified);
                const hasSources = !!(this.state.settings.deckSource && this.state.settings.cardSource && this.state.sourcesVerified);

                el('#statusWorker').textContent = `Worker: ${workerOk ? 'verified' : hasWorkerUrl ? 'unverified' : 'missing'}`;
                el('#statusAuth').textContent = `Auth: ${authOk ? 'verified' : workerOk ? (hasToken ? 'unverified' : 'missing') : 'blocked (verify worker)'}`;
                el('#statusSources').textContent = `Sources: ${hasSources ? 'verified' : 'missing'}`;

                const vaultSection = el('#vaultStatusSection');
                if (vaultSection) vaultSection.classList.toggle('hidden', !hasSources);

                this.updateSettingsButtons();
                this.renderConnection();
            },
            async validateDb(dbOrId, type) {
                try {
                    const meta = typeof dbOrId === 'string' ? await API.getDatabase(dbOrId) : dbOrId;
                    const props = meta?.properties || {};
                    const has = (name, kind) => props[name]?.type === kind;
                    if (type === 'deck') {
                        const required = [
                            ['Deck Name', 'title'],
                            ['SRS Algorithm', 'select'],
                            ['Order Mode', 'select'],
                            ['Daily Review Limit', 'number'],
                            ['New Card Limit', 'number'],
                            ['Reverse Mode Enabled', 'checkbox'],
                            ['Created In-App', 'checkbox'],
                            ['Archived?', 'checkbox']
                        ];
                        const missing = required.filter(([n, k]) => !has(n, k));
                        if (missing.length) return false;
                        // FSRS configuration storage
                        if (!has('FSRS Params', 'rich_text')) return false;
                        return true;
                    }
                    if (type === 'card') {
                        const required = [
                            ['Name', 'title'],
                            ['Back', 'rich_text'],
                            ['Card Type', 'select'],
                            ['Deck', 'relation'],
                            ['Tags', 'multi_select'],
                            ['Suspended', 'checkbox'],
                            ['Leech', 'checkbox'],
                            ['Order', 'number'],
                            ['Difficulty', 'number'],
                            ['Stability', 'number'],
                            ['Retrievability', 'number'],
                            ['Last Rating', 'select'],
                            ['Last Review', 'date'],
                            ['Due Date', 'date'],
                            ['Interval / Box Level', 'number'],
                            ['Ease Factor', 'number'],
                            ['Updated In-App', 'checkbox']
                        ];
                        const missing = required.filter(([n, k]) => !has(n, k));
                        if (missing.length) return false;
                        return true;
                    }
                } catch (e) {
                    // Validation failed - database doesn't match expected schema
                }
                return false;
            },
            updateSettingsButtons() {
                const s = this.state.settings;
                // Block scan/save/sources until both worker AND Notion auth are verified
                const workerOk = s.workerVerified || this.state.workerVerified;
                const notionOk = s.authVerified || this.state.authVerified;
                const blockScanSave = !(workerOk && notionOk);
                const online = navigator.onLine;

                ['scanSources', 'saveSourcesChoice', 'saveSettings', 'deckSourceSelect', 'cardSourceSelect'].forEach(id => {
                    const elem = el('#' + id);
                    if (!elem) return;
                    elem.disabled = blockScanSave;
                });
                const oa = el('#oauthBtn');
                const va = el('#verifyAuth');
                const tokenInput = el('#settingAuthToken');
                const blockAuth = !this.state.settings.workerUrl;
                if (oa) { oa.disabled = blockAuth; oa.classList.toggle('opacity-60', blockAuth); oa.classList.toggle('cursor-not-allowed', blockAuth); }
                if (va) { va.disabled = blockAuth; va.classList.toggle('opacity-60', blockAuth); va.classList.toggle('cursor-not-allowed', blockAuth); }
                if (tokenInput) tokenInput.disabled = blockAuth;

                // Disable AI/STT verification buttons when offline
                ['verifyAi', 'verifyStt'].forEach(id => {
                    const btn = el('#' + id);
                    if (!btn) return;
                    btn.disabled = !online;
                    btn.classList.toggle('opacity-60', !online);
                    btn.classList.toggle('cursor-not-allowed', !online);
                });
            },
            async autoVerifyWorker() {
                const s = this.state.settings;
                // If already verified from storage, just re-render gate
                if (s.workerUrl && this.state.workerVerified && s.authToken && this.state.sourcesVerified) {
                    this.renderGate();
                    return;
                }
                // Otherwise, silently verify worker using stored settings (not input fields)
                if (!s.workerUrl) return;
                try {
                    const url = new URL(s.workerUrl.replace(/\/$/, ''));
                    url.searchParams.append('url', 'https://api.notion.com/v1/users/me');
                    if (s.proxyToken) url.searchParams.append('token', s.proxyToken);
                    const res = await fetch(url.toString());
                    if (res.ok || res.status === 401) {
                        this.state.workerVerified = true;
                        this.state.settings.workerVerified = true;
                        Storage.setSettings(this.state.settings);
                    }
                } catch (_) { /* silent fail - user can manually verify */ }
                this.renderGate();
                this.renderConnection();
            },
            applyTheme() {
                const mode = this.state.settings.themeMode || 'system';
                const systemPrefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                const theme = mode === 'system' ? (systemPrefersDark ? 'dark' : 'light') : mode;
                document.body.setAttribute('data-theme', theme);
                document.documentElement.setAttribute('data-theme', theme);
                document.documentElement.style.colorScheme = theme === 'dark' ? 'dark' : 'light';
                document.querySelectorAll('.theme-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.theme === mode);
                });
            },
            applyFabPosition() {
                const fab = el('#mobileFabCluster');
                if (!fab) return;
                if (this.state.settings.fabEnabled === false) {
                    fab.style.left = '';
                    fab.style.bottom = '';
                    fab.style.top = '';
                    fab.style.right = '';
                    fab.style.transform = '';
                    return;
                }
                const pos = this.state.settings.fabPos;
                // Legacy format: { bottom: px, left: px } anchored to bottom-left of the cluster.
                if (pos && typeof pos === 'object' && pos.mode !== 'grid' && (pos.bottom != null || pos.left != null)) {
                    fab.style.transform = 'none';
                    fab.style.bottom = (pos.bottom ?? 12) + 'px';
                    fab.style.left = (pos.left ?? 12) + 'px';
                    fab.style.top = 'auto';
                    fab.style.right = 'auto';
                    return;
                }

                // Grid format: { mode:'grid', rows, cols, cell } anchored to the *center* of the cluster.
                const grid = pos && typeof pos === 'object' && pos.mode === 'grid' ? pos : null;
                const rows = Math.max(2, Math.min(10, Number(grid?.rows) || 6));
                const cols = Math.max(2, Math.min(10, Number(grid?.cols) || 4));
                const cellMax = rows * cols;
                const cell = Math.max(1, Math.min(cellMax, Number(grid?.cell) || 21)); // default near bottom-left
                const colIdx = (cell - 1) % cols;
                const rowIdx = Math.floor((cell - 1) / cols);

                const vw = window.innerWidth || document.documentElement.clientWidth || 360;
                const vh = window.innerHeight || document.documentElement.clientHeight || 640;
                const centerX = ((colIdx + 0.5) / cols) * vw;
                const centerY = ((rowIdx + 0.5) / rows) * vh;

                // Clamp a bit away from edges so the cluster stays usable.
                const pad = 48;
                const clampedX = Math.min(vw - pad, Math.max(pad, centerX));
                const clampedY = Math.min(vh - pad, Math.max(pad, centerY));

                fab.style.transform = 'translate(-50%, 50%)';
                fab.style.left = clampedX + 'px';
                fab.style.bottom = (vh - clampedY) + 'px';
                fab.style.top = 'auto';
                fab.style.right = 'auto';
            },
            bindFabPositionPicker() {
                const select = el('#fabPosCellSelect');
                const ascii = el('#fabGridAscii');
                const enabledToggle = el('#fabEnabledToggle');
                const posControls = el('#fabPosControls');
                if (!select) return;

                const rows = 6;
                const cols = 4;
                const total = rows * cols;

                const getSavedCell = () => {
                    const pos = this.state.settings.fabPos;
                    if (pos && typeof pos === 'object' && pos.mode === 'grid') {
                        const c = Number(pos.cell);
                        if (Number.isFinite(c) && c >= 1 && c <= total) return c;
                    }
                    return 21; // near bottom-left by default
                };

                const renderAscii = (activeCell) => {
                    if (!ascii) return;
                    const pad2 = (n) => String(n).padStart(2, '0');
                    let out = '';
                    let cell = 1;
                    for (let r = 0; r < rows; r++) {
                        const row = [];
                        for (let c = 0; c < cols; c++) {
                            const label = pad2(cell);
                            if (cell === activeCell) {
                                row.push(`<span class="text-dull-purple font-semibold">${label}</span>`);
                            } else {
                                row.push(label);
                            }
                            cell++;
                        }
                        out += row.join(' ') + (r < rows - 1 ? '\n' : '');
                    }
                    ascii.innerHTML = out;
                };

                const applyCell = (cell) => {
                    const n = Math.max(1, Math.min(total, Number(cell) || 1));
                    this.state.settings.fabPos = { mode: 'grid', rows, cols, cell: n };
                    Storage.setSettings(this.state.settings);
                    this.applyFabPosition();
                    renderAscii(n);
                    toast('Mobile FAB position saved');
                };

                const initial = getSavedCell();
                select.value = String(initial);
                renderAscii(initial);
                select.onchange = () => applyCell(select.value);

                const applyEnabled = (enabled) => {
                    const on = !!enabled;
                    this.state.settings.fabEnabled = on;
                    Storage.setSettings(this.state.settings);
                    if (posControls) posControls.classList.toggle('hidden', !on);
                    this.applyFabPosition();
                    this.updateMobileFab();
                };

                if (enabledToggle) {
                    const savedEnabled = this.state.settings.fabEnabled;
                    enabledToggle.checked = savedEnabled !== false;
                    if (posControls) posControls.classList.toggle('hidden', enabledToggle.checked === false);
                    enabledToggle.onchange = () => applyEnabled(enabledToggle.checked);
                } else {
                    // No toggle in DOM; ensure controls are visible if present.
                    if (posControls) posControls.classList.remove('hidden');
                }
            },
            applyFontMode() {
                const mode = this.state.settings.fontMode || 'serif';
                const fontMode = mode === 'mono' ? 'mono' : 'serif';
                document.body.setAttribute('data-font', fontMode);
                document.documentElement.setAttribute('data-font', fontMode);
                document.querySelectorAll('.font-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.font === mode);
                });
            },
            isReady() {
                const s = this.state.settings;
                const hasSettings = !!(s.workerUrl && s.authToken && s.deckSource && s.cardSource);
                // If offline, trust the stored settings (assume they were verified before)
                if (!navigator.onLine && hasSettings) return true;
                // If online, require full verification
                return hasSettings && s.workerVerified && (s.authVerified || this.state.authVerified) && s.sourcesVerified;
            },
            loadAISettings() {
                const s = Storage.getSettings();
                if (s.aiProvider) el('#aiProvider').value = s.aiProvider;
                if (s.aiModel) el('#aiModel').value = s.aiModel;
                if (s.aiKey) el('#aiKey').value = s.aiKey;

                // Load STT settings
                if (s.sttProvider) el('#sttProvider').value = s.sttProvider;
                if (s.sttModel) el('#sttModel').value = s.sttModel;
                if (s.sttKey) el('#sttKey').value = s.sttKey;
                if (s.sttPrompt) el('#sttPrompt').value = s.sttPrompt;

                this.state.settings.sttVerified = s.sttVerified || false;
                this.state.settings.sttPermissionWarmed = s.sttPermissionWarmed || false;
                if (s.themeMode) this.state.settings.themeMode = s.themeMode;
                if (s.fontMode) this.state.settings.fontMode = s.fontMode;
                this.applyTheme();
                this.applyFontMode();
                this.updateSkipHotkeyLabel(el('#revisionMode')?.value === 'ai');
                // Toggle provider field visibility based on current selection
                this.toggleAiProviderFields();
                this.toggleSttProviderFields();
                // On file:// we still need to proactively ask once to enable mic; HTTPS will reuse prior grant
                if (location.protocol === 'file:' && s.sttProvider && s.sttPermissionWarmed) {
                    this.warmMicStreamForAi();
                }
                // Add change listeners for provider dropdowns
                el('#aiProvider').onchange = () => this.toggleAiProviderFields();
                el('#sttProvider').onchange = () => {
                    this.toggleSttProviderFields();
                    const provider = el('#sttProvider')?.value || '';
                    this.persistSttSettingsFromUI({ requestPermission: !!provider });
                };
            },
            persistSttSettingsFromUI({ requestPermission = false } = {}) {
                const prevProvider = this.state.settings.sttProvider || '';
                const provider = (el('#sttProvider')?.value || '').trim();
                const model = (el('#sttModel')?.value || '').trim();
                const key = (el('#sttKey')?.value || '').trim();
                const prompt = (el('#sttPrompt')?.value || '').trim();

                this.state.settings.sttProvider = provider;
                this.state.settings.sttModel = model;
                this.state.settings.sttPrompt = prompt;
                if (key) this.state.settings.sttKey = key;
                // Browser STT doesn't require verification. Disabled clears verification.
                if (!provider) {
                    this.state.settings.sttVerified = false;
                    this.state.settings.sttPermissionWarmed = false;
                    this.state.settings.sttModel = '';
                    this.state.settings.sttKey = '';
                } else if (provider === 'browser') {
                    this.state.settings.sttVerified = true;
                    this.state.settings.sttModel = '';
                    this.state.settings.sttKey = '';
                } else if (provider !== prevProvider) {
                    // If provider changed, require re-verify to avoid using stale creds with a new endpoint.
                    this.state.settings.sttVerified = false;
                }

                Storage.setSettings(this.state.settings);
                this.applySttChangeEffects(!provider);

                if (prevProvider && provider && provider !== prevProvider) {
                    toast(provider === 'browser' ? 'Using browser speech recognition' : 'STT provider changed â€” verify STT settings');
                }

                // Only request mic permission when transitioning from disabled -> enabled.
                const shouldRequest = !!(requestPermission && !prevProvider && provider);
                if (!shouldRequest) return;
                this.ensureMicPermission()
                    .then(() => {
                        this.state.settings.sttPermissionWarmed = true;
                        Storage.setSettings(this.state.settings);
                    })
                    .catch(() => {
                        this.state.settings.sttPermissionWarmed = false;
                        Storage.setSettings(this.state.settings);
                        toast('Microphone access denied');
                    });
            },
            toggleAiProviderFields() {
                const provider = el('#aiProvider').value;
                const fields = el('#aiProviderFields');
                if (fields) {
                    if (provider) {
                        fields.classList.remove('hidden');
                    } else {
                        fields.classList.add('hidden');
                    }
                }
            },
            toggleSttProviderFields() {
                const provider = el('#sttProvider').value;
                const fields = el('#sttProviderFields');
                if (fields) {
                    if (provider && provider !== 'browser') {
                        fields.classList.remove('hidden');
                    } else {
                        fields.classList.add('hidden');
                    }
                }
                // Avoid auto-triggering mic prompts on simple provider toggles; recording will request when needed
            },
            updateSkipHotkeyLabel(isAiMode) {
                const skipKbd = el('#skipHotkey');
                if (!skipKbd) return;
                if (isAiMode) {
                    // Use symbols for both platforms (âŽ‡ = Alt, â‡§ = Shift)
                    skipKbd.textContent = isMac ? 'âŒ¥ â‡§ S' : 'âŽ‡ â‡§ S';
                } else {
                    skipKbd.textContent = 'S';
                }
            },
            applySttChangeEffects(disabled = false) {
                if (disabled || !this.isSttEnabled()) {
                    this.stopMicActivity(true);
                } else {
                    const feedback = el('#aiFeedback');
                    if (feedback) feedback.classList.add('hidden');
                    if (location.protocol === 'file:' && this.state.settings.sttPermissionWarmed) {
                        // Prompt once on local files so mic shows up immediately
                        this.warmMicStreamForAi();
                    }
                }
                this.setAiControlsLocked(this.state.aiLocked);
                this.updateMobileFab();
            },
            async submitToAI() {
                if (this.state.aiLocked) return;
                if (!this.state.selectedCard) return;
                if (this.state.answerRevealed) {
                    toast('Answer already reviewed. Go to the next card.');
                    return;
                }
                // Stop any ongoing mic recording before sending
                if (this.isMicActive()) this.stopMicActivity(true);
                const ans = el('#aiAnswer').value.trim();
                if (!ans) { toast('Enter or record an answer first'); return; }
                if (!navigator.onLine) {
                    toast('Offline: AI mode needs internet');
                    return;
                }
                if (!this.state.settings.aiVerified) {
                    toast('Verify AI settings in Settings first');
                    return;
                }
                if (!this.state.settings.aiKey) { toast('Add an AI key in Settings'); return; }
                const deck = this.deckById(this.state.selectedCard.deckId);
                const promptTemplate = deck?.aiPrompt || DEFAULT_AI_PROMPT;
                // Swap question and answer if card is reversed
                const isReversed = this.state.cardReversed;
                const question = isReversed ? this.state.selectedCard.back : this.state.selectedCard.name;
                const answer = isReversed ? this.state.selectedCard.name : this.state.selectedCard.back;
                const applyTemplate = (tpl, vars) => {
                    let out = String(tpl || '');
                    for (const [key, value] of Object.entries(vars)) {
                        out = out.split(`{{${key}}}`).join(String(value ?? ''));
                    }
                    return out;
                };
                const prompt = applyTemplate(promptTemplate, { question, answer, user: ans });
                const provider = this.state.settings.aiProvider || 'openai';
                const model = this.state.settings.aiModel || (provider === 'anthropic' ? 'claude-3-haiku-20240307' : provider === 'gemini' ? 'gemini-1.5-flash-latest' : 'gpt-4o-mini');
                try {
                    this.state.lockAiUntilNextCard = true;
                    this.setAiControlsLocked(true);
                    this.updateMobileFab();
                    el('#aiFeedback').classList.remove('hidden');
                    el('#aiFeedback').innerHTML = 'Thinking...';
                    const res = await this.callAI(provider, model, prompt, this.state.settings.aiKey);
                    el('#aiFeedback').innerHTML = marked.parse(res);
                    applyMediaEmbeds(el('#aiFeedback'));
                    this.renderMath(el('#aiFeedback'));
                    this.reveal();
                } catch (e) {
                    el('#aiFeedback').innerHTML = '';
                    toast('AI error: ' + e.message);
                    this.state.lockAiUntilNextCard = false;
                    this.setAiControlsLocked(false);
                    this.updateMobileFab();
                }
            },
            async callAI(provider, model, prompt, key) {
                if (provider === 'anthropic') {
                    const resp = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json',
                            'x-api-key': key,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify({ model, max_tokens: 256, messages: [{ role: 'user', content: prompt }] })
                    });
                    if (!resp.ok) throw new Error('Claude returned ' + resp.status);
                    const json = await resp.json();
                    return json.content?.[0]?.text || 'No response';
                }
                if (provider === 'gemini') {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${encodeURIComponent(key)}`;
                    const resp = await fetch(url, {
                        method: 'POST',
                        headers: { 'content-type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });
                    if (!resp.ok) throw new Error('Gemini returned ' + resp.status);
                    const json = await resp.json();
                    return json.candidates?.[0]?.content?.parts?.map(p => p.text).join('\n') || 'No response';
                }
                const resp = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'content-type': 'application/json', 'authorization': 'Bearer ' + key },
                    body: JSON.stringify({ model, messages: [{ role: 'user', content: prompt }], max_tokens: 256 })
                });
                if (!resp.ok) throw new Error('OpenAI returned ' + resp.status);
                const json = await resp.json();
                return json.choices?.[0]?.message?.content || 'No response';
            },
            initMobileFab() {
                const cluster = el('#mobileFabCluster');
                if (!cluster) return;

                // Bind action buttons (always bind, visibility controlled by updateMobileFab)
                el('#fabReveal')?.addEventListener('click', () => this.reveal());
                el('#fabSkip')?.addEventListener('click', () => this.nextCard());
                el('#fabCopy')?.addEventListener('click', () => this.copyCardContent());
                el('#fabAddNote')?.addEventListener('click', () => this.openAddBlockModal());

                // Initialize joystick with Hammer.js
                this.initJoystick();

                // Listen for window resize to show/hide FAB cluster
                window.addEventListener('resize', () => this.updateMobileFab());
            },
            initJoystick() {
                const isSmallDevice = window.matchMedia('(max-width: 640px)').matches;
                const inSession = !!this.state.session;
                const fabEnabled = this.state.settings.fabEnabled !== false;
                const shouldBeActive = isSmallDevice && inSession && fabEnabled;

                if (!shouldBeActive) {
                    if (this.state.joystickActive) {
                        this.cleanupJoystick();
                    }
                    return;
                }

                if (this.state.joystickActive) return;

                const joystick = el('#joystick');
                if (!joystick) return;

                const THRESHOLD = 15;
                let startX = 0;
                let startY = 0;
                let currentDirection = null;

                const getDirection = (dx, dy) => {
                    const absX = Math.abs(dx);
                    const absY = Math.abs(dy);
                    if (absX < THRESHOLD && absY < THRESHOLD) return null;
                    if (absX > absY) {
                        return dx > 0 ? 'right' : 'left';
                    } else {
                        return dy > 0 ? 'down' : 'up';
                    }
                };

                const updateJoystick = (direction) => {
                    joystick.classList.remove('up', 'down', 'left', 'right');
                    joystick.querySelectorAll('.joystick-label').forEach(l => l.classList.remove('active'));
                    if (direction) {
                        joystick.classList.add(direction);
                        joystick.querySelector(`.joystick-label-${direction}`)?.classList.add('active');
                    }
                };

                const onPointerDown = (e) => {
                    startX = e.clientX;
                    startY = e.clientY;
                    joystick.setPointerCapture(e.pointerId);
                };

                const onPointerMove = (e) => {
                    if (!startX && !startY) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    currentDirection = getDirection(dx, dy);
                    updateJoystick(currentDirection);
                };

                const onPointerUp = (e) => {
                    if (currentDirection) {
                        const ratings = { up: 'Good', down: 'Again', left: 'Hard', right: 'Easy' };
                        this.rate(ratings[currentDirection]);
                    }
                    startX = 0;
                    startY = 0;
                    currentDirection = null;
                    updateJoystick(null);
                };

                joystick.addEventListener('pointerdown', onPointerDown);
                joystick.addEventListener('pointermove', onPointerMove);
                joystick.addEventListener('pointerup', onPointerUp);
                joystick.addEventListener('pointercancel', onPointerUp);

                this.state.joystickActive = true;
                this.state.joystickHandlers = { onPointerDown, onPointerMove, onPointerUp };
            },
            cleanupJoystick() {
                const joystick = el('#joystick');
                if (joystick && this.state.joystickHandlers) {
                    const { onPointerDown, onPointerMove, onPointerUp } = this.state.joystickHandlers;
                    joystick.removeEventListener('pointerdown', onPointerDown);
                    joystick.removeEventListener('pointermove', onPointerMove);
                    joystick.removeEventListener('pointerup', onPointerUp);
                    joystick.removeEventListener('pointercancel', onPointerUp);
                    joystick.classList.remove('up', 'down', 'left', 'right');
                    joystick.querySelectorAll('.joystick-label').forEach(l => l.classList.remove('active'));
                }
                this.state.joystickActive = false;
                this.state.joystickHandlers = null;
            },

            updateMobileFab() {
                const isSmallDevice = window.matchMedia('(max-width: 640px)').matches;
                const cluster = el('#mobileFabCluster');

                // Try to init joystick if needed
                this.initJoystick();

                // Hide FAB on large screens
                if (!isSmallDevice) {
                    if (cluster) cluster.classList.add('hidden');
                    return;
                }
                // Hard-disable FAB entirely if user turned it off.
                if (this.state.settings.fabEnabled === false) {
                    if (cluster) cluster.classList.add('hidden');
                    return;
                }

                const hasCard = !!this.state.selectedCard;
                const inSession = !!this.state.session;
                const revealed = this.state.answerRevealed;
                const revisionMode = el('#revisionMode')?.value || 'manual';
                const isAiMode = revisionMode === 'ai';
                const sttEnabled = this.isSttEnabled();
                // Check if the actual reveal button in the card is visible (not hidden)
                const revealBtnVisible = el('#revealBtn') && !el('#revealBtn').classList.contains('hidden');

                const joystickContainer = el('#joystickContainer');
                const fabPreRevealActions = el('#fabPreRevealActions');
                const fabCopy = el('#fabCopy');
                const fabAddNote = el('#fabAddNote');
                const fabMic = el('#fabMic');
                const fabSend = el('#fabSend');

                // Only show FAB cluster when there's an active card with reveal button visible or already revealed
                const showFab = hasCard && inSession && (revealBtnVisible || revealed || isAiMode);
                if (cluster) cluster.classList.toggle('hidden', !showFab);

                // Show joystick only when answer is revealed
                if (joystickContainer) joystickContainer.classList.toggle('hidden', !revealed);
                // Show pre-reveal actions (skip + reveal) only when not revealed and reveal button is visible
                if (fabPreRevealActions) fabPreRevealActions.classList.toggle('hidden', revealed || !revealBtnVisible);
                // Show copy and add note only when revealed
                if (fabCopy) fabCopy.classList.toggle('hidden', !revealed);
                if (fabAddNote) fabAddNote.classList.toggle('hidden', !revealed);
                const hideFabMic = !hasCard || !inSession || this.state.answerRevealed || !isAiMode || this.state.aiLocked || !sttEnabled;
                const hideFabSend = !hasCard || !inSession || this.state.answerRevealed || !isAiMode || this.state.aiLocked;
                if (fabMic) fabMic.classList.toggle('hidden', hideFabMic);
                if (fabSend) fabSend.classList.toggle('hidden', hideFabSend);

                // Re-init lucide icons for the joystick
                if (revealed) {
                    setTimeout(() => lucide.createIcons(), 0);
                }
            },
            renderMath(container) {
                if (!container || typeof katex === 'undefined') return;
                container.querySelectorAll('.notion-equation').forEach(span => {
                    try {
                        const expr = span.textContent || '';
                        span.innerHTML = katex.renderToString(expr, { throwOnError: false });
                    } catch (e) { console.error(e); }
                });
            },
            async recordAnswer() {
                const isAiMode = el('#revisionMode')?.value === 'ai';
                if (!isAiMode) {
                    toast('Mic is available in AI mode only.');
                    return;
                }
                if (!this.isSttEnabled()) {
                    toast('Enable speech-to-text in Settings first.');
                    return;
                }
                if (this.state.answerRevealed) {
                    toast('Already judged. Go to the next card.');
                    return;
                }
                this.state.userStoppedMic = false;
                if (!this.state.activeMicButton) this.state.activeMicButton = 'inline';
                const provider = this.state.settings.sttProvider;
                const isCloudProvider = provider && provider !== 'browser';

                // If cloud provider is configured and verified, use it
                if (isCloudProvider) {
                    if (!this.state.settings.sttKey) {
                        toast('Add and verify your STT API key in Settings.');
                        return;
                    }
                    if (!this.state.settings.sttVerified) {
                        toast('Verify STT settings in Settings first.');
                        return;
                    }
                    await this.recordWithCloudSTT();
                    return;
                }

                // Fall back to browser speech recognition
                if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
                    toast('Speech recognition not supported. Configure a cloud provider in settings.');
                    return;
                }
                const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
                const rec = new SR();
                rec.lang = 'en-US';
                rec.interimResults = true;
                rec.continuous = true;
                rec.maxAlternatives = 1;
                el('#aiFeedback').classList.remove('hidden');
                el('#aiFeedback').innerHTML = 'Listening...';

                let finalTranscript = el('#aiAnswer').value;
                if (finalTranscript) finalTranscript += ' ';

                rec.onresult = (e) => {
                    let interim = '';
                    for (let i = e.resultIndex; i < e.results.length; ++i) {
                        if (e.results[i].isFinal) {
                            finalTranscript += e.results[i][0].transcript;
                        } else {
                            interim += e.results[i][0].transcript;
                        }
                    }
                    el('#aiAnswer').value = finalTranscript + interim;
                    // Trigger input event to update Send button state
                    el('#aiAnswer').dispatchEvent(new Event('input'));
                };

                // Store recorder instance to allow stopping it
                this.state.currentRecorder = rec;
                this.setAiControlsLocked(false);

                rec.onerror = (e) => {
                    if (e.error !== 'aborted') {
                        el('#aiFeedback').innerHTML = '';
                        toast('Mic error: ' + e.error);
                    }
                    this.state.currentRecorder = null;
                    this.state.userStoppedMic = false;
                    this.state.activeMicButton = null;
                    this.setAiControlsLocked(this.state.aiLocked);
                };
                rec.onend = () => {
                    if (el('#aiFeedback').innerHTML.includes('Listening') && this.state.userStoppedMic) {
                        el('#aiFeedback').innerHTML = 'Captured. Now send.';
                    } else if (el('#aiFeedback').innerHTML.includes('Listening')) {
                        el('#aiFeedback').innerHTML = '';
                    }
                    this.state.currentRecorder = null;
                    this.state.userStoppedMic = false;
                    this.state.activeMicButton = null;
                    this.setAiControlsLocked(this.state.aiLocked);
                };
                rec.start();
            },
            async recordWithCloudSTT() {
                const provider = this.state.settings.sttProvider;
                const model = this.state.settings.sttModel || this.getDefaultSttModel(provider);
                const key = this.state.settings.sttKey;
                const prompt = this.state.settings.sttPrompt || '';

                el('#aiFeedback').classList.remove('hidden');
                el('#aiFeedback').innerHTML = 'Recording... Click again to stop.';

                // If already recording, stop
                if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                    this.state.userStoppedMic = true;
                    this.mediaRecorder.stop();
                    return;
                }
                this.state.userStoppedMic = false;
                if (!this.state.activeMicButton) this.state.activeMicButton = 'inline';

                try {
                    const stream = await this.getMicStream();
                    if (!stream) throw new Error('Microphone unavailable');
                    this.state.activeAudioStream = stream;
                    const chunks = [];
                    this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });

                    this.mediaRecorder.ondataavailable = (e) => chunks.push(e.data);

                    this.mediaRecorder.onstop = async () => {
                        // Stop the mic as soon as recording ends so the browser doesn't show "mic in use".
                        try { stream.getTracks().forEach(t => t.stop()); } catch (_) { }
                        if (this.state.activeAudioStream === stream) this.state.activeAudioStream = null;
                        el('#aiFeedback').innerHTML = 'Transcribing...';
                        this.state.currentRecorder = null;
                        this.setAiControlsLocked(this.state.aiLocked);

                        try {
                            const audioBlob = new Blob(chunks, { type: 'audio/webm' });
                            let transcript = '';

                            if (provider === 'openai' || provider === 'groq') {
                                transcript = await this.transcribeWithWhisper(audioBlob, provider, model, key, prompt);
                            } else if (provider === 'gemini') {
                                transcript = await this.transcribeWithGemini(audioBlob, model, key, prompt);
                            }

                            if (transcript) {
                                const current = el('#aiAnswer').value.trim();
                                el('#aiAnswer').value = current ? `${current} ${transcript}` : transcript;
                                // Trigger input event to update Send button state
                                el('#aiAnswer').dispatchEvent(new Event('input'));
                            }
                            el('#aiFeedback').innerHTML = this.state.userStoppedMic ? 'Captured. Now send.' : '';
                            this.mediaRecorder = null;
                            this.state.userStoppedMic = false;
                            this.state.activeMicButton = null;
                            this.setAiControlsLocked(false);
                        } catch (e) {
                            el('#aiFeedback').innerHTML = '';
                            toast('Transcription failed: ' + e.message);
                            this.mediaRecorder = null;
                            this.state.userStoppedMic = false;
                            this.state.activeMicButton = null;
                        }
                    };

                    this.mediaRecorder.onerror = () => {
                        try { stream.getTracks().forEach(t => t.stop()); } catch (_) { }
                        if (this.state.activeAudioStream === stream) this.state.activeAudioStream = null;
                        el('#aiFeedback').innerHTML = '';
                        toast('Recording error');
                        this.state.currentRecorder = null;
                        this.mediaRecorder = null;
                        this.state.userStoppedMic = false;
                        this.state.activeMicButton = null;
                        this.setAiControlsLocked(this.state.aiLocked);
                    };

                    this.state.currentRecorder = {
                        stop: () => {
                            if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                                this.state.userStoppedMic = true;
                                this.mediaRecorder.stop();
                            }
                        }
                    };
                    this.setAiControlsLocked(false);
                    this.mediaRecorder.start();
                    const activeRecorder = this.mediaRecorder;

                    // Auto-stop after 60 seconds
                    setTimeout(() => {
                        if (this.mediaRecorder === activeRecorder && activeRecorder && activeRecorder.state === 'recording') {
                            activeRecorder.stop();
                        }
                    }, 60000);

                } catch (e) {
                    el('#aiFeedback').innerHTML = '';
                    toast('Microphone access denied');
                    this.state.currentRecorder = null;
                    this.mediaRecorder = null;
                    this.setAiControlsLocked(this.state.aiLocked);
                }
            },
            async transcribeWithWhisper(audioBlob, provider, model, key, prompt) {
                const endpoint = provider === 'openai'
                    ? 'https://api.openai.com/v1/audio/transcriptions'
                    : 'https://api.groq.com/openai/v1/audio/transcriptions';

                const formData = new FormData();
                formData.append('file', audioBlob, 'audio.webm');
                formData.append('model', model);
                if (prompt) formData.append('prompt', prompt);

                const res = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${key}` },
                    body: formData
                });

                if (!res.ok) throw new Error(`API returned ${res.status}`);
                const data = await res.json();
                return data.text || '';
            },
            async transcribeWithGemini(audioBlob, model, key, prompt) {
                // Use FileReader for efficient non-blocking Base64 conversion
                const base64Audio = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(audioBlob);
                });

                const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`;

                const systemPrompt = prompt
                    ? `Transcribe this audio. Context: ${prompt}. Return only the transcription, no other text.`
                    : 'Transcribe this audio. Return only the transcription, no other text.';

                const res = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [
                                { text: systemPrompt },
                                { inline_data: { mime_type: 'audio/webm', data: base64Audio } }
                            ]
                        }]
                    })
                });

                if (!res.ok) throw new Error(`API returned ${res.status}`);
                const data = await res.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
            },
            async performDelete() {
                this.closeModal('confirmModal');
                const target = this.pendingDelete;
                if (!target) return;
                if (target.type === 'card') {
                    await Storage.delete('cards', target.id);
                    this.state.cards = this.state.cards.filter(c => c.id !== target.id);
                    this.queueOp({ type: 'card-delete', payload: { id: target.id, notionId: target.notionId } });
                    this.renderCards();
                    toast('Card deleted');
                }
                this.pendingDelete = null;
            }
        };

        document.addEventListener('DOMContentLoaded', async () => {
            document.body.classList.remove('preinit');
            try {
                await App.init();
            } catch (e) {
                console.error('Failed to initialize GhostInk', e);
                toast('Startup failed â€“ see console for details');
            }
        });
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(() => { });
            });
        }
    </script>
</body>

</html>