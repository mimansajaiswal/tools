<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GhostInk Flashcards</title>
    <meta name="theme-color" content="#917FB3">
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">

    <!-- Tailwind (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Hammer.js for touch gestures -->
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>

    <!-- Markdown renderer -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.2/sql-wasm.js"></script>
    <!-- KaTeX for equations -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>

    <!-- Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Fraunces:wght@600;700&family=Sora:wght@400;500;600&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        oatmeal: '#F3F0E6',
                        'oatmeal-dark': '#E6E2D6',
                        'earth-metal': '#4A4A4A',
                        charcoal: '#1F1F1F',
                        'white-linen': '#FAF9F6',
                        'dull-purple': '#917FB3',
                        'muted-pink': '#D8A7B1',
                        'muted-pink-dim': '#C696A0'
                    },
                    fontFamily: {
                        display: ['var(--font-display, "Fraunces")', 'serif'],
                        sans: ['var(--font-sans, "Sora")', 'system-ui', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        :root {
            --oatmeal: #F3F0E6;
            --oatmeal-dark: #E6E2D6;
            --earth-metal: #4A4A4A;
            --charcoal: #1F1F1F;
            --linen: #FAF9F6;
            --dull-purple: #917FB3;
            --muted-pink: #D8A7B1;
            --card-bg: rgba(250, 249, 246, 0.9);
            --card-border: rgba(26, 26, 26, 0.06);
            --text-main: #1F1F1F;
            --text-sub: rgba(31, 31, 31, 0.7);
            --surface: #faf9f6;
            --surface-strong: #f3f0e6;
            --border-weak: rgba(26, 26, 26, 0.06);
            --bg: #f6f3eb;
        }

        body {
            background: var(--bg);
            color: var(--text-main);
            font-family: var(--font-sans, "Manrope"), system-ui, sans-serif;
        }

        body[data-font="mono"] {
            --font-display: "JetBrains Mono";
            --font-sans: "JetBrains Mono";
            font-family: "JetBrains Mono", monospace;
        }

        body:not([data-font="mono"]) {
            --font-display: "Fraunces";
            --font-sans: "Sora";
        }

        body[data-theme="dark"] {
            --oatmeal: #1f1c2b;
            --oatmeal-dark: #252335;
            --linen: #1b1917;
            --card-bg: #201d1b;
            --card-border: rgba(255, 255, 255, 0.08);
            --text-main: #f4f1ff;
            --text-sub: rgba(244, 241, 255, 0.7);
            --surface: #1f1c1a;
            --surface-strong: #1b1917;
            --border-weak: rgba(255, 255, 255, 0.08);
            --bg: #1b1917;
        }

        .card {
            border: 1px solid var(--card-border);
            background: var(--card-bg);
            backdrop-filter: blur(12px);
        }

        .dash {
            background: repeating-linear-gradient(-45deg,
                    rgba(145, 127, 179, 0.08),
                    rgba(145, 127, 179, 0.08) 12px,
                    transparent 12px,
                    transparent 24px);
        }

        .pill {
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .glass {
            background: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .shadow-soft {
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.08);
        }

        body[data-theme="dark"] .shadow-soft {
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
        }

        /* Notion color helpers */
        .notion-color-default {
            color: inherit;
        }

        .notion-color-gray {
            color: #9b9a97;
        }

        .notion-color-brown {
            color: #64473a;
        }

        .notion-color-orange {
            color: #d9730d;
        }

        .notion-color-yellow {
            color: #e0a30b;
        }

        .notion-color-green {
            color: #0f7b6c;
        }

        .notion-color-blue {
            color: #0b6ae6;
        }

        .notion-color-purple {
            color: #6940a5;
        }

        .notion-color-pink {
            color: #ad1a72;
        }

        .notion-color-red {
            color: #e03e3e;
        }

        .notion-color-gray-background {
            background: #ebeced;
        }

        .notion-color-brown-background {
            background: #ede4de;
        }

        .notion-color-orange-background {
            background: #faebdd;
        }

        .notion-color-yellow-background {
            background: #fbf3db;
        }

        .notion-color-green-background {
            background: #ddebea;
        }

        .notion-color-blue-background {
            background: #e7f3f8;
        }

        .notion-color-purple-background {
            background: #f1ecf9;
        }

        .notion-color-pink-background {
            background: #f6e0e9;
        }

        .notion-color-red-background {
            background: #fdebec;
        }

        body[data-theme="dark"] .notion-color-gray {
            color: #868686;
        }

        body[data-theme="dark"] .notion-color-brown {
            color: #b0937c;
        }

        body[data-theme="dark"] .notion-color-orange {
            color: #ffb45b;
        }

        body[data-theme="dark"] .notion-color-yellow {
            color: #f7cd46;
        }

        body[data-theme="dark"] .notion-color-green {
            color: #5bc0a7;
        }

        body[data-theme="dark"] .notion-color-blue {
            color: #6ab7ff;
        }

        body[data-theme="dark"] .notion-color-purple {
            color: #b18cff;
        }

        body[data-theme="dark"] .notion-color-pink {
            color: #ff8fb1;
        }

        body[data-theme="dark"] .notion-color-red {
            color: #ff7b73;
        }

        body[data-theme="dark"] .notion-color-gray-background {
            background: #2f3134;
        }

        body[data-theme="dark"] .notion-color-brown-background {
            background: #352922;
        }

        body[data-theme="dark"] .notion-color-orange-background {
            background: #422a15;
        }

        body[data-theme="dark"] .notion-color-yellow-background {
            background: #443716;
        }

        body[data-theme="dark"] .notion-color-green-background {
            background: #183a33;
        }

        body[data-theme="dark"] .notion-color-blue-background {
            background: #152f4d;
        }

        body[data-theme="dark"] .notion-color-purple-background {
            background: #2b2340;
        }

        body[data-theme="dark"] .notion-color-pink-background {
            background: #3b2431;
        }

        body[data-theme="dark"] .notion-color-red-background {
            background: #442022;
        }

        .cloze-blank {
            padding: 2px 6px;
            border-bottom: 1px dashed #917FB3;
            color: transparent;
            background: linear-gradient(90deg, rgba(145, 127, 179, 0.14), rgba(216, 167, 177, 0.14));
            border-radius: 6px;
        }

        .scroll-minimal::-webkit-scrollbar {
            width: 8px;
        }

        .scroll-minimal::-webkit-scrollbar-thumb {
            background: rgba(73, 73, 73, 0.25);
            border-radius: 10px;
        }

        /* swipe hint badges */
        .swipe-hints {
            pointer-events: none;
        }

        .swipe-hints span {
            opacity: 0;
            transition: opacity 0.15s ease, transform 0.15s ease;
        }

        .swipe-hints .hint-active {
            opacity: 0.8;
            transform: translateY(-2px);
        }

        /* theme utility overrides so light/dark stay consistent */
        .bg-white-linen {
            background-color: var(--surface) !important;
        }

        .bg-oatmeal {
            background-color: var(--surface-strong) !important;
        }

        .bg-oatmeal\/60 {
            background-color: color-mix(in srgb, var(--surface-strong) 70%, transparent) !important;
        }

        .bg-oatmeal/60 {
            background-color: color-mix(in srgb, var(--surface-strong) 70%, transparent) !important;
        }

        .border-oatmeal-dark,
        .border-oatmeal-dark\/60,
        .border-oatmeal-dark\/70 {
            border-color: var(--card-border) !important;
        }

        .text-earth-metal,
        .text-earth-metal\/70,
        .text-earth-metal\/60 {
            color: var(--text-sub) !important;
        }

        .text-charcoal {
            color: var(--text-main) !important;
        }

        /* compact icon toggles */
        .pill-toggle {
            border: 1px solid var(--card-border);
            background: var(--surface);
        }

        .pill-toggle button {
            color: var(--text-sub);
        }

        .pill-toggle button.active {
            background: var(--dull-purple);
            color: #fff;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }

        .font-swatch-serif {
            font-family: 'Fraunces', serif !important;
            letter-spacing: 0.01em;
        }

        .font-swatch-mono {
            font-family: 'JetBrains Mono', monospace !important;
            letter-spacing: 0.01em;
        }
    </style>
</head>

<body class="text-earth-metal font-sans min-h-[100dvh]">
    <div class="min-h-[100dvh] flex flex-col">
        <header class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between px-5 sm:px-10 pt-6 pb-4">
            <div class="flex items-center gap-3">
                <div class="w-12 h-12 rounded-2xl dash flex items-center justify-center shadow-soft">
                    <i data-lucide="sparkles" class="w-6 h-6 text-dull-purple"></i>
                </div>
                <div>
                    <h1 class="font-display text-2xl text-charcoal tracking-tight">GhostInk</h1>
                    <p class="text-sm text-earth-metal/70">Offline-first flashcards with Notion & FSRS</p>
                </div>
            </div>
            <div class="flex flex-wrap gap-2 items-center justify-start sm:justify-end">
                <div id="connectionBadge"
                    class="px-3 py-1 rounded-full pill text-xs bg-oatmeal border border-oatmeal-dark text-earth-metal">
                    Offline ready</div>
                <div class="flex items-center gap-2 pill-toggle rounded-full px-2 py-1">
                    <button class="p-1 rounded-full theme-btn" data-theme="light" data-tip="Light theme"><i
                            data-lucide="sun" class="w-4 h-4"></i></button>
                    <button class="p-1 rounded-full theme-btn" data-theme="dark" data-tip="Dark theme"><i
                            data-lucide="moon" class="w-4 h-4"></i></button>
                    <button class="p-1 rounded-full theme-btn" data-theme="system" data-tip="System theme"><i
                            data-lucide="laptop" class="w-4 h-4"></i></button>
                </div>
                <div class="flex items-center gap-2 pill-toggle rounded-full px-2 py-1">
                    <button class="px-2 py-1 rounded-full font-btn text-xs" data-font="serif"
                        data-tip="Serif font (Playfair/Manrope)">
                        <span class="font-swatch-serif inline-block">Aa</span>
                    </button>
                    <button class="px-2 py-1 rounded-full font-btn text-xs" data-font="mono"
                        data-tip="Monospace (Plex Mono)">
                        <span class="font-swatch-mono inline-block">Aa</span>
                    </button>
                </div>
                <div class="flex items-center gap-2 pill-toggle rounded-full px-2 py-1" data-tip="Anki import/export">
                    <span class="text-[11px] text-[color:var(--text-sub)]">Anki</span>
                    <button id="exportAnkiBtn" class="p-1 rounded-full">
                        <i data-lucide="download" class="w-4 h-4"></i>
                    </button>
                    <label class="p-1 rounded-full cursor-pointer">
                        <i data-lucide="upload-cloud" class="w-4 h-4"></i>
                        <input aria-label="Import .apkg" id="ankiImportInput" type="file" accept=".apkg,.json"
                            class="hidden">
                    </label>
                </div>
                <button id="syncNowBtn"
                    class="p-2 rounded-full bg-dull-purple text-white hover:bg-[#7d6aa1] transition-all flex items-center gap-1"
                    data-tip="Sync now">
                    <i data-lucide="refresh-ccw" class="w-4 h-4"></i>
                </button>
                <button id="openSettings"
                    class="p-2 rounded-full bg-white-linen border border-oatmeal-dark hover:border-dull-purple transition-all flex items-center gap-1"
                    data-tip="Settings">
                    <i data-lucide="settings" class="w-4 h-4"></i>
                </button>
            </div>
        </header>

        <main class="px-5 sm:px-10 pb-10 space-y-6">
            <div id="lockedOverlay"
                class="rounded-2xl p-6 bg-[color:var(--surface-strong)] border border-[color:var(--card-border)] flex flex-col gap-5 max-w-3xl mx-auto mt-6 text-center hidden">
                <div class="space-y-3">
                    <p class="font-display text-xl text-charcoal leading-tight">Connect and start studying</p>
                    <p class="text-sm text-earth-metal/70 leading-relaxed">
                        Keep decks and cards in Notion, import/export Anki, and get AI judging on your answers. Set your
                        theme, connect once, and go offline when you need.
                    </p>
                </div>
                <div class="grid md:grid-cols-3 gap-3 text-sm text-left">
                    <div
                        class="rounded-xl bg-[color:var(--surface)] border border-[color:var(--card-border)] p-3 space-y-1">
                        <div class="flex items-center gap-2 text-dull-purple font-semibold"><i data-lucide="link"
                                class="w-4 h-4"></i>Connect</div>
                        <p class="text-earth-metal/70">Add Worker URL + token, verify, then sign in with Notion or paste
                            a secret.</p>
                    </div>
                    <div
                        class="rounded-xl bg-[color:var(--surface)] border border-[color:var(--card-border)] p-3 space-y-1">
                        <div class="flex items-center gap-2 text-dull-purple font-semibold"><i data-lucide="database"
                                class="w-4 h-4"></i>Sources</div>
                        <p class="text-earth-metal/70">Choose your Decks and Cards databases for sync.</p>
                    </div>
                    <div
                        class="rounded-xl bg-[color:var(--surface)] border border-[color:var(--card-border)] p-3 space-y-1">
                        <div class="flex items-center gap-2 text-dull-purple font-semibold"><i data-lucide="wand-2"
                                class="w-4 h-4"></i>Study</div>
                        <p class="text-earth-metal/70">Review with AI judge, spaced repetition, Anki import/export.</p>
                    </div>
                </div>
                <div class="flex justify-center">
                    <button id="lockedOpenSettings"
                        class="px-5 py-3 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1] flex items-center gap-2 whitespace-nowrap shadow-soft">
                        <i data-lucide="settings" class="w-4 h-4"></i><span>Open settings</span>
                    </button>
                </div>
            </div>

            <section id="mainContent" class="space-y-6">
                <section class="grid lg:grid-cols-3 gap-4 min-w-0">
                    <article class="card rounded-2xl p-5 shadow-soft text-[color:var(--text-main)]">
                        <div class="flex items-center justify-between">
                            <h2 class="font-display text-lg text-charcoal">Study filters</h2>
                            <button id="resetFilters" class="text-xs text-dull-purple hover:underline">Reset</button>
                        </div>
                        <div class="grid grid-cols-2 gap-3 mt-3 text-sm">
                            <label class="flex items-center gap-2">
                                <input id="filterAgain" type="checkbox" class="accent-dull-purple">
                                <span>Again recently</span>
                            </label>
                            <label class="flex items-center gap-2">
                                <input id="filterHard" type="checkbox" class="accent-dull-purple">
                                <span>Hard/Again only</span>
                            </label>
                            <label class="flex items-center gap-2 col-span-2">
                                <input id="filterAddedToday" type="checkbox" class="accent-dull-purple">
                                <span>Added today</span>
                            </label>
                            <div class="col-span-2">
                                <label class="text-xs text-earth-metal/70">Stability below</label>
                                <input id="filterStability" type="range" min="0" max="50" step="1"
                                    class="w-full accent-dull-purple">
                                <div class="flex justify-between text-xs text-earth-metal/60">
                                    <span>0</span><span id="stabilityValue">25</span><span>50</span>
                                </div>
                            </div>
                            <div class="col-span-2">
                                <label class="text-xs text-earth-metal/70">Tags (comma)</label>
                                <input id="filterTags" type="text" placeholder="biology, spaced"
                                    class="w-full rounded-xl border border-oatmeal-dark/60 bg-white-linen px-3 py-2 text-sm">
                            </div>
                            <div class="col-span-2">
                                <label class="text-xs text-earth-metal/70">Manual pick</label>
                                <div id="manualSelection" class="flex flex-wrap gap-2 mt-2 text-xs"></div>
                            </div>
                        </div>
                    </article>
                </section>

                <section class="grid xl:grid-cols-3 gap-6 min-w-0">
                    <div class="xl:col-span-2 space-y-6">
                        <article class="card rounded-2xl p-5 shadow-soft text-[color:var(--text-main)]">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h2 class="font-display text-lg text-charcoal">Decks</h2>
                                    <p class="text-sm text-earth-metal/70">Rename, recolor, select algorithm, delete, or
                                        add new.</p>
                                </div>
                                <button id="newDeckBtn"
                                    class="px-3 py-2 rounded-xl bg-charcoal text-white text-sm hover:bg-earth-metal flex items-center gap-2">
                                    <i data-lucide="plus" class="w-4 h-4"></i>
                                    New deck
                                </button>
                            </div>
                            <div id="deckGrid" class="grid md:grid-cols-2 xl:grid-cols-3 gap-3 mt-4"></div>
                        </article>

                        <article class="card rounded-2xl p-5 shadow-soft text-[color:var(--text-main)]">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h2 class="font-display text-lg text-charcoal">Cards in deck</h2>
                                    <p class="text-sm text-earth-metal/70">Markdown everywhere. Reverse mode honored.
                                    </p>
                                </div>
                                <button id="newCardBtn"
                                    class="px-3 py-2 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1] flex items-center gap-2">
                                    <i data-lucide="plus-circle" class="w-4 h-4"></i>
                                    New card
                                </button>
                            </div>
                            <div class="overflow-auto scroll-minimal mt-4">
                                <table class="w-full text-xs md:text-sm">
                                    <thead class="text-earth-metal/60">
                                        <tr class="border-b border-oatmeal-dark/70">
                                            <th class="py-2 text-left">Name</th>
                                            <th class="py-2 text-left">Type</th>
                                            <th class="py-2 text-left">Deck</th>
                                            <th class="py-2 text-left">Due</th>
                                            <th class="py-2 text-left">Alg</th>
                                            <th class="py-2 text-left">Tags</th>
                                        </tr>
                                    </thead>
                                    <tbody id="cardTable" class="divide-y divide-oatmeal-dark/40"></tbody>
                                </table>
                            </div>
                        </article>
                    </div>

                    <div class="space-y-6">
                        <article class="card rounded-2xl p-5 shadow-soft text-[color:var(--text-main)]">
                            <div class="flex items-center justify-between">
                                <h2 class="font-display text-lg text-charcoal">Study session</h2>
                                <div class="flex items-center gap-2 text-xs">
                                    <select id="revisionMode"
                                        class="rounded-lg border border-oatmeal-dark/60 bg-white-linen px-2 py-1">
                                        <option value="manual">Reveal</option>
                                        <option value="ai">AI judge</option>
                                    </select>
                                    <button id="toggleReverse"
                                        class="text-xs text-dull-purple hover:underline">Reverse</button>
                                </div>
                            </div>
                            <div
                                class="mt-3 p-4 rounded-xl bg-[color:var(--surface-strong)] border border-[color:var(--card-border)] space-y-3">
                                <div class="flex items-center justify-between text-xs text-[color:var(--text-sub)]">
                                    <span id="studyDeckLabel">Choose a deck</span>
                                    <span id="algorithmLabel"
                                        class="px-2 py-1 rounded-full bg-[color:var(--surface)] border border-[color:var(--card-border)] text-[color:var(--text-main)]">‚Äî</span>
                                </div>
                                <div id="cardFront"
                                    class="min-h-[120px] leading-relaxed text-[color:var(--text-main)] max-h-[45vh] overflow-y-auto pr-1 scroll-minimal">
                                </div>
                                <div class="space-y-2">
                                    <button id="revealBtn"
                                        class="px-3 py-2 w-full rounded-xl bg-charcoal text-white text-sm hover:bg-earth-metal">Reveal</button>
                                    <div
                                        class="grid grid-cols-4 gap-1 text-[11px] text-[color:var(--text-sub)] swipe-hints">
                                        <span id="hintUp" class="text-center">‚Üë Easy</span>
                                        <span id="hintLeft" class="text-center">‚Üê Hard</span>
                                        <span id="hintRight" class="text-center">‚Üí Good</span>
                                        <span id="hintDown" class="text-center">‚Üì Again</span>
                                    </div>
                                    <div id="aiControls" class="hidden space-y-2">
                                        <textarea id="aiAnswer" rows="3"
                                            placeholder="Type your answer for AI to judge..."
                                            class="w-full rounded-xl border border-[color:var(--card-border)] bg-[color:var(--surface)] px-3 py-2 text-sm"></textarea>
                                        <div class="flex gap-2">
                                            <button id="aiRecord"
                                                class="px-3 py-2 rounded-xl bg-[color:var(--surface)] border border-[color:var(--card-border)] text-[color:var(--text-main)] text-sm flex-1">üéôÔ∏è
                                                Record</button>
                                            <button id="aiSubmit"
                                                class="px-3 py-2 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1] flex-1">Send
                                                to AI</button>
                                        </div>
                                        <div id="aiFeedback"
                                            class="text-sm text-earth-metal/80 bg-white-linen border border-oatmeal-dark/40 rounded-xl p-2">
                                        </div>
                                    </div>
                                </div>
                                <div id="cardBack"
                                    class="min-h-[120px] leading-relaxed text-[color:var(--text-sub)] hidden max-h-[45vh] overflow-y-auto pr-1 scroll-minimal">
                                </div>
                                <div class="grid grid-cols-4 gap-2">
                                    <button data-rate="again"
                                        class="rate-btn px-2 py-2 rounded-lg bg-white-linen border border-oatmeal-dark text-xs hover:border-dull-purple">Again</button>
                                    <button data-rate="hard"
                                        class="rate-btn px-2 py-2 rounded-lg bg-white-linen border border-oatmeal-dark text-xs hover:border-dull-purple">Hard</button>
                                    <button data-rate="good"
                                        class="rate-btn px-2 py-2 rounded-lg bg-dull-purple text-white text-xs hover:bg-[#7d6aa1]">Good</button>
                                    <button data-rate="easy"
                                        class="rate-btn px-2 py-2 rounded-lg bg-muted-pink text-white text-xs hover:bg-muted-pink-dim">Easy</button>
                                </div>
                                <div class="text-[11px] text-earth-metal/70 flex justify-between">
                                    <span id="fsrsMeta">FSRS fields ready</span>
                                    <button id="skipCard" class="text-dull-purple hover:underline">Skip</button>
                                </div>
                            </div>
                        </article>

                        <article class="card rounded-2xl p-5 shadow-soft text-[color:var(--text-main)]">
                            <div class="flex items-center justify-between">
                                <h2 class="font-display text-lg text-charcoal">Card notes</h2>
                                <button id="copyMarkdown"
                                    class="text-xs text-dull-purple hover:underline flex items-center gap-1">
                                    <i data-lucide="clipboard" class="w-3 h-3"></i> Copy markdown
                                </button>
                            </div>
                            <textarea id="notesArea" rows="6" placeholder="Markdown notes that autosave locally..."
                                class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2 text-sm mt-3 max-h-60 overflow-y-auto"></textarea>
                            <div class="mt-2 text-xs text-earth-metal/60 flex justify-between items-center">
                                <span id="noteStatus">Autosaves offline. Not pushed to Notion; meant for LLM
                                    copy.</span>
                                <span class="text-earth-metal/50">Scroll supported</span>
                            </div>
                            <div class="mt-3 text-xs text-earth-metal/70">Preview</div>
                            <div id="notesPreview"
                                class="rounded-xl border border-oatmeal-dark/60 bg-white-linen px-3 py-2 text-sm max-h-60 overflow-y-auto">
                            </div>
                        </article>

                        <article class="card rounded-2xl p-5 shadow-soft text-[color:var(--text-main)]">
                            <div class="flex items-center gap-2">
                                <i data-lucide="filter" class="w-4 h-4 text-dull-purple"></i>
                                <h3 class="font-display text-lg text-charcoal">Session subsets</h3>
                            </div>
                            <p class="text-sm text-earth-metal/70 mt-2">Pick any subset: tags, selected cards, stability
                                threshold, added today, suspended, leeches.</p>
                            <div class="mt-3 space-y-2 text-sm">
                                <label class="flex items-center gap-2">
                                    <input id="filterSuspended" type="checkbox" class="accent-dull-purple">
                                    <span>Hide suspended</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input id="filterLeech" type="checkbox" class="accent-dull-purple">
                                    <span>Hide leeches</span>
                                </label>
                            </div>
                        </article>
                    </div>
                </section>
            </section>
        </main>
    </div>

    <div id="toast"
        class="fixed z-[110] bottom-6 right-6 px-4 py-3 rounded-xl bg-charcoal text-white text-sm shadow-soft hidden">
    </div>
    <div id="tooltip"
        class="fixed z-[120] px-2.5 py-1.5 rounded-lg text-xs bg-charcoal text-white shadow-soft pointer-events-none hidden">
    </div>

    <div id="confirmModal" class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div class="card rounded-2xl p-5 w-full max-w-sm shadow-soft">
            <p class="text-charcoal font-display text-lg mb-2">Confirm delete</p>
            <p class="text-sm text-earth-metal/70">This removes it locally and syncs deletion to Notion.</p>
            <div class="flex justify-end gap-2 mt-4">
                <button id="cancelDelete"
                    class="px-3 py-2 rounded-xl bg-white-linen border border-oatmeal-dark/70 text-earth-metal text-sm">Cancel</button>
                <button id="confirmDelete" class="px-3 py-2 rounded-xl bg-muted-pink text-white text-sm">Delete</button>
            </div>
        </div>
    </div>

    <!-- Settings -->
    <div id="settingsModal" class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div id="settingsCard" class="card rounded-2xl p-5 w-full max-w-3xl shadow-soft max-h-[90vh] overflow-y-auto">
            <div class="flex items-center justify-between mb-3">
                <h3 class="font-display text-lg text-charcoal">Connection</h3>
                <button id="closeSettings" class="text-earth-metal/60 hover:text-charcoal"><i data-lucide="x"
                        class="w-5 h-5"></i></button>
            </div>
            <div class="grid md:grid-cols-2 gap-6 text-sm">
                <div class="space-y-4">
                    <div class="rounded-xl border border-oatmeal-dark/60 p-3 bg-white-linen">
                        <div class="flex items-center justify-between">
                            <p class="font-semibold text-charcoal">Worker proxy</p>
                            <button id="openWorkerHelp"
                                class="px-3 py-1.5 rounded-full bg-oatmeal text-earth-metal text-xs border border-oatmeal-dark/70 flex items-center gap-2">
                                <i data-lucide="code" class="w-4 h-4"></i> Worker code
                            </button>
                        </div>
                        <p class="text-xs text-earth-metal/70 mt-1">Add Cloudflare Worker URL even if you plan to sign
                            in with Notion.</p>
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/70">Cloudflare Worker URL</label>
                        <input id="settingWorkerUrl" type="text" placeholder="https://your-proxy.workers.dev"
                            class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2">
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/70">Proxy token (optional)</label>
                        <input id="settingProxyToken" type="text" placeholder="ALL_CORS_PROXY_MATCH_TOKEN"
                            class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2">
                    </div>
                    <button id="verifyWorker"
                        class="px-3 py-2 rounded-xl bg-oatmeal text-earth-metal text-sm border border-oatmeal-dark/70 w-full">Verify
                        worker</button>
                    <div>
                        <label class="text-xs text-earth-metal/70">Notion token (secret alternative)</label>
                        <input id="settingAuthToken" type="password" placeholder="secret_..."
                            class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2 disabled:opacity-60 disabled:cursor-not-allowed">
                    </div>
                    <button id="verifyAuth"
                        class="px-3 py-2 rounded-xl bg-oatmeal text-earth-metal text-sm border border-oatmeal-dark/70 w-full disabled:opacity-60 disabled:cursor-not-allowed">Verify
                        Notion token</button>
                    <button id="oauthBtn"
                        class="w-full px-3 py-2 rounded-xl border border-dull-purple text-dull-purple text-sm hover:bg-oatmeal flex items-center gap-2 justify-center disabled:opacity-60 disabled:cursor-not-allowed">
                        <i data-lucide="log-in" class="w-4 h-4"></i>Sign in with Notion
                    </button>
                    <div>
                        <label class="text-xs text-earth-metal/60">Decks source</label>
                        <select id="deckSourceSelect"
                            class="w-full rounded-xl border border-oatmeal-dark/60 bg-white-linen px-2 py-2 text-sm"></select>
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/60">Cards source</label>
                        <select id="cardSourceSelect"
                            class="w-full rounded-xl border border-oatmeal-dark/60 bg-white-linen px-2 py-2 text-sm"></select>
                    </div>
                    <div class="flex gap-2 flex-wrap">
                        <button id="scanSources"
                            class="px-3 py-2 rounded-xl bg-charcoal text-white text-sm hover:bg-earth-metal flex-1 min-w-[140px]">Scan
                            sources</button>
                        <button id="saveSettings"
                            class="px-3 py-2 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1] flex-1 min-w-[140px]">Save</button>
                    </div>
                    <div class="w-full h-2 bg-oatmeal rounded-full overflow-hidden">
                        <div id="syncProgress" class="h-2 bg-dull-purple w-0 transition-all duration-500"></div>
                    </div>
                    <div class="text-xs text-earth-metal/70">
                        <p id="snapshotStatus">Not yet synced</p>
                    </div>
                </div>
                <div class="space-y-4">
                    <div class="rounded-xl border border-oatmeal-dark/60 p-3 bg-white-linen">
                        <div class="flex items-center gap-2">
                            <i data-lucide="database" class="w-4 h-4 text-dull-purple"></i>
                            <p class="font-semibold text-charcoal">Offline vault</p>
                        </div>
                        <div class="mt-3 grid grid-cols-2 gap-3 text-sm">
                            <div class="rounded-xl bg-oatmeal p-3">
                                <p class="text-earth-metal/60">Decks cached</p>
                                <p id="deckCount" class="text-xl font-semibold text-charcoal">0</p>
                            </div>
                            <div class="rounded-xl bg-oatmeal p-3">
                                <p class="text-earth-metal/60">Cards cached</p>
                                <p id="cardCount" class="text-xl font-semibold text-charcoal">0</p>
                            </div>
                            <div class="rounded-xl bg-white-linen p-3">
                                <p class="text-earth-metal/60">Pending sync</p>
                                <p id="queueCount" class="text-xl font-semibold text-charcoal">0</p>
                            </div>
                            <div class="rounded-xl bg-white-linen p-3">
                                <p class="text-earth-metal/60">Last sync</p>
                                <p id="lastSync" class="text-xl font-semibold text-charcoal">‚Äî</p>
                            </div>
                        </div>
                        <p class="mt-3 text-xs text-earth-metal/70">IndexedDB holds all decks/cards/FSRS/notes for
                            offline-first use.</p>
                    </div>
                    <div class="rounded-xl border border-oatmeal-dark/60 p-3 bg-oatmeal/60">
                        <div class="flex items-center gap-2">
                            <i data-lucide="shield-check" class="w-4 h-4 text-dull-purple"></i>
                            <p class="font-semibold text-charcoal">Status</p>
                        </div>
                        <ul class="text-xs text-earth-metal/80 mt-2 space-y-1">
                            <li id="statusWorker">Worker: missing</li>
                            <li id="statusAuth">Auth: missing</li>
                            <li id="statusSources">Sources: missing</li>
                        </ul>
                    </div>
                    <div class="rounded-xl border border-oatmeal-dark/60 p-3 bg-white-linen">
                        <div class="flex items-center gap-2 mb-2">
                            <i data-lucide="bot" class="w-4 h-4 text-dull-purple"></i>
                            <p class="font-semibold text-charcoal">AI judge settings</p>
                        </div>
                        <div class="space-y-2">
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="text-xs text-earth-metal/70">Provider</label>
                                    <select id="aiProvider"
                                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-2 py-2 text-sm">
                                        <option value="">Disabled</option>
                                        <option value="openai">OpenAI</option>
                                        <option value="anthropic">Claude</option>
                                        <option value="gemini">Gemini</option>
                                    </select>
                                </div>
                                <div>
                                    <label class="text-xs text-earth-metal/70">Model</label>
                                    <input id="aiModel" type="text"
                                        placeholder="gpt-4o-mini / claude-3-haiku / gemini-1.5-flash"
                                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-2 py-2 text-sm">
                                </div>
                            </div>
                            <input id="aiKey" type="password" placeholder="API key (kept locally)"
                                class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2 text-sm">
                            <p class="text-[11px] text-earth-metal/60">Keys stay on-device (localStorage). AI judging
                                only runs if a key is set.</p>
                        </div>
                    </div>
                    <button id="resetApp"
                        class="px-3 py-2 rounded-xl bg-white-linen text-earth-metal text-sm border border-oatmeal-dark/70 hover:border-muted-pink w-full">Reset
                        (clear cache)</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Worker helper -->
    <div id="workerHelpModal" class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div class="card rounded-2xl p-5 w-full max-w-3xl shadow-soft h-[80vh] flex flex-col">
            <div class="flex items-center justify-between mb-3">
                <h3 class="font-display text-lg text-charcoal">Cloudflare Worker proxy</h3>
                <button id="closeWorkerHelp" class="text-earth-metal/60 hover:text-charcoal"><i data-lucide="x"
                        class="w-5 h-5"></i></button>
            </div>
            <div class="flex-1 overflow-y-auto space-y-3 text-sm text-earth-metal">
                <p>Deploy this Worker to bypass CORS and forward Notion requests.</p>
                <ol class="list-decimal pl-5 space-y-2">
                    <li>Open <a class="text-dull-purple underline" href="https://workers.cloudflare.com/"
                            target="_blank">Cloudflare Workers</a> and create a new Worker.</li>
                    <li>Replace its contents with the code below, save, and deploy.</li>
                    <li>(Optional) Add variable <code>ALL_CORS_PROXY_MATCH_TOKEN</code> to require a token.</li>
                    <li>Paste the Worker URL into Settings.</li>
                </ol>
                <div class="relative">
                    <button id="copyWorkerCode"
                        class="absolute top-2 right-2 bg-white/80 hover:bg-white px-2 py-1 rounded text-xs shadow text-charcoal font-bold">Copy</button>
                    <pre id="workerCodeBlock"
                        class="bg-charcoal text-white-linen p-4 rounded text-xs font-mono overflow-x-auto">
const NOTION_API_END_POINT = "https://api.notion.com/v1";

export default {
  async fetch(request, env) {
    return await handleRequest(request, env);
  }
};

function corsHeaders(request) {
  return {
    "Access-Control-Allow-Origin": request.headers.get("Origin") || "*",
    "Access-Control-Allow-Methods": "GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization, Notion-Version",
  };
}

function handleOptions(request) {
  return new Response(null, { headers: corsHeaders(request) });
}

async function handleRequest(request, env) {
  if (request.method === "OPTIONS") return handleOptions(request);

  const url = new URL(request.url);
  const requiredToken = (env.ALL_CORS_PROXY_MATCH_TOKEN || "").trim();
  if (requiredToken) {
    const provided = url.searchParams.get("token");
    if (provided !== requiredToken) return new Response("Unauthorized", { status: 403 });
    url.searchParams.delete("token");
  }

  const isGeneral = url.searchParams.has("url");
  let targetUrl;
  if (isGeneral) {
    targetUrl = url.searchParams.get("url");
    url.searchParams.delete("url");
    try { targetUrl = new URL(targetUrl).toString(); } catch (err) { return new Response("Invalid target URL", { status: 400 }); }
  } else {
    const secretKey = url.searchParams.get("secret");
    if (!secretKey) return new Response("Missing secret key parameter", { status: 400 });
    url.searchParams.delete("secret");
    const base = NOTION_API_END_POINT.replace(/\/$/, "");
    const path = url.pathname.startsWith("/") ? url.pathname : "/" + url.pathname;
    targetUrl = base + path + url.search;
    request = new Request(targetUrl, request);
    request.headers.set("Authorization", `Bearer ${secretKey}`);
    request.headers.set("Notion-Version", "2022-06-28");
  }

  const proxied = new Request(targetUrl, request);
  proxied.headers.set("Origin", new URL(targetUrl).origin);

  const response = await fetch(proxied);
  const out = new Response(response.body, response);
  out.headers.set("Access-Control-Allow-Origin", request.headers.get("Origin") || "*");
  out.headers.append("Vary", "Origin");
  return out;
}
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Deck modal -->
    <div id="deckModal" class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div class="card rounded-2xl p-5 w-full max-w-md shadow-soft">
            <div class="flex items-center justify-between mb-3">
                <h3 class="font-display text-lg text-charcoal" id="deckModalTitle">New deck</h3>
                <button id="closeDeckModal" class="text-earth-metal/60 hover:text-charcoal"><i data-lucide="x"
                        class="w-5 h-5"></i></button>
            </div>
            <div class="space-y-3 text-sm">
                <input id="deckNameInput" type="text" placeholder="Deck name"
                    class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2">
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="text-xs text-earth-metal/70">Color</label>
                        <input id="deckColorInput" type="color"
                            class="w-full h-10 rounded-xl border border-oatmeal-dark/70">
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/70">Algorithm</label>
                        <select id="deckAlgoInput"
                            class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2">
                            <option>FSRS</option>
                            <option>SM-2</option>
                            <option>Leitner</option>
                            <option>Random</option>
                            <option>Custom</option>
                        </select>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="text-xs text-earth-metal/70">Daily review limit</label>
                        <input id="deckReviewLimit" type="number"
                            class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2" value="50">
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/70">New card limit</label>
                        <input id="deckNewLimit" type="number"
                            class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2" value="20">
                    </div>
                </div>
                <label class="flex items-center gap-2 text-sm">
                    <input id="deckReverseInput" type="checkbox" class="accent-dull-purple">
                    <span>Reverse mode enabled</span>
                </label>
                <div>
                    <label class="text-xs text-earth-metal/70">AI revision prompt (optional)</label>
                    <textarea id="deckPromptInput" rows="3"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2"
                        placeholder="Use {{question}} and {{answer}} placeholders"></textarea>
                </div>
            </div>
            <div class="flex justify-end gap-2 mt-4">
                <button id="deleteDeckBtn"
                    class="px-3 py-2 rounded-xl border border-muted-pink text-muted-pink text-sm hidden">Delete
                    deck</button>
                <button id="saveDeckBtn"
                    class="px-4 py-2 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1]">Save</button>
            </div>
        </div>
    </div>

    <!-- Card modal -->
    <div id="cardModal" class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div class="card rounded-2xl p-5 w-full max-w-2xl shadow-soft">
            <div class="flex items-center justify-between mb-3">
                <h3 class="font-display text-lg text-charcoal" id="cardModalTitle">New card</h3>
                <button id="closeCardModal" class="text-earth-metal/60 hover:text-charcoal"><i data-lucide="x"
                        class="w-5 h-5"></i></button>
            </div>
            <div class="grid md:grid-cols-2 gap-4 text-sm">
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Deck</label>
                    <select id="cardDeckInput"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2"></select>
                </div>
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Card type</label>
                    <select id="cardTypeInput"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2">
                        <option value="Front-Back">Front / Back</option>
                        <option value="Cloze">Cloze</option>
                    </select>
                </div>
                <div class="md:col-span-2 space-y-2">
                    <label class="text-xs text-earth-metal/70">Name (front / cloze prompt / blanks)</label>
                    <textarea id="cardNameInput" rows="3"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2"></textarea>
                </div>
                <div class="md:col-span-2 space-y-2">
                    <label class="text-xs text-earth-metal/70">Back (answer / full text)</label>
                    <textarea id="cardBackInput" rows="4"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2"></textarea>
                </div>
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Tags (comma)</label>
                    <input id="cardTagsInput" type="text"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-white-linen px-3 py-2">
                </div>
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Suspended / Leech</label>
                    <div class="flex gap-4">
                        <label class="flex items-center gap-2"><input id="cardSuspendedInput" type="checkbox"
                                class="accent-dull-purple"> Suspended</label>
                        <label class="flex items-center gap-2"><input id="cardLeechInput" type="checkbox"
                                class="accent-dull-purple"> Leech</label>
                    </div>
                </div>
            </div>
            <div class="flex justify-end gap-2 mt-4">
                <button id="deleteCardBtn"
                    class="px-3 py-2 rounded-xl border border-muted-pink text-muted-pink text-sm hidden">Delete
                    card</button>
                <button id="saveCardBtn"
                    class="px-4 py-2 rounded-xl bg-charcoal text-white text-sm hover:bg-earth-metal">Save</button>
            </div>
        </div>
    </div>

    <script>
        const el = (sel) => document.querySelector(sel);
        const toast = (msg) => {
            const t = el('#toast');
            t.textContent = msg;
            t.classList.remove('hidden', 'opacity-0');
            setTimeout(() => t.classList.add('opacity-0'), 2500);
            setTimeout(() => t.classList.add('hidden'), 3000);
        };
        const Tooltip = {
            timer: null,
            lastShown: null,
            el: null,
            ensure() { this.el = this.el || document.querySelector('#tooltip'); return this.el; },
            show(target) {
                const tip = target.dataset.tip;
                if (!tip) return;
                const node = this.ensure();
                node.textContent = tip;
                const rect = target.getBoundingClientRect();
                const x = rect.left + rect.width / 2;
                const y = rect.top - 8;
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                node.style.transform = 'translate(-50%, -100%)';
                node.classList.remove('hidden');
                this.lastShown = target;
            },
            hide() {
                const node = this.ensure();
                node.classList.add('hidden');
                this.lastShown = null;
            },
            bind() {
                document.addEventListener('mouseover', (e) => {
                    const t = e.target.closest('[data-tip]');
                    if (!t) return;
                    if (this.lastShown) { this.show(t); return; }
                    clearTimeout(this.timer);
                    this.timer = setTimeout(() => this.show(t), 160);
                });
                document.addEventListener('mouseout', (e) => {
                    if (!e.relatedTarget || !e.relatedTarget.closest('[data-tip]')) {
                        clearTimeout(this.timer);
                        this.hide();
                    }
                });
                document.addEventListener('focusin', (e) => {
                    const t = e.target.closest('[data-tip]');
                    if (t) this.show(t);
                });
                document.addEventListener('focusout', () => this.hide());
            }
        };

        const SYNC_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes background tick
        const MIN_PULL_INTERVAL_MS = 3 * 60 * 1000; // pull at most every 3 minutes
        const MIN_PUSH_INTERVAL_MS = 60 * 1000; // push at most every minute

        const Storage = {
            db: null,
            settingsKey: 'ghostink_settings_v1',
            sqlReady: null,
            async init() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open('GhostInkDB', 2);
                    req.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('decks')) db.createObjectStore('decks', { keyPath: 'id' });
                        if (!db.objectStoreNames.contains('cards')) db.createObjectStore('cards', { keyPath: 'id' });
                        if (!db.objectStoreNames.contains('meta')) db.createObjectStore('meta', { keyPath: 'key' });
                    };
                    req.onsuccess = (e) => {
                        this.db = e.target.result;
                        resolve();
                    };
                    req.onerror = reject;
                });
            },
            tx(store, mode = 'readonly') {
                return this.db.transaction(store, mode).objectStore(store);
            },
            async getAll(store) {
                return new Promise((resolve, reject) => {
                    const req = this.tx(store).getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = reject;
                });
            },
            async put(store, value) {
                return new Promise((resolve, reject) => {
                    const req = this.tx(store, 'readwrite').put(value);
                    req.onsuccess = resolve;
                    req.onerror = reject;
                });
            },
            async delete(store, key) {
                return new Promise((resolve, reject) => {
                    const req = this.tx(store, 'readwrite').delete(key);
                    req.onsuccess = resolve;
                    req.onerror = reject;
                });
            },
            async wipeStore(store) {
                return new Promise((resolve, reject) => {
                    const req = this.tx(store, 'readwrite').clear();
                    req.onsuccess = resolve;
                    req.onerror = reject;
                });
            },
            getSettings() {
                const raw = localStorage.getItem(this.settingsKey);
                return raw ? JSON.parse(raw) : { workerUrl: '', proxyToken: '', authToken: '', deckSource: '', cardSource: '', aiProvider: '', aiModel: '', aiKey: '', themeMode: 'system', fontMode: 'serif', workerVerified: false, authVerified: false };
            },
            setSettings(newSettings) {
                localStorage.setItem(this.settingsKey, JSON.stringify(newSettings));
            },
            async ensureSQL() {
                if (this.sqlReady) return this.sqlReady;
                this.sqlReady = window.initSqlJs({ locateFile: (file) => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.2/${file}` });
                return this.sqlReady;
            }
        };

        const API = {
            async request(method, endpoint, body = null, override = null) {
                const { workerUrl, authToken, proxyToken } = override || Storage.getSettings();
                if (!workerUrl || !authToken) throw new Error('Missing worker URL or Notion token');
                const cleanWorker = workerUrl.trim().replace(/\/$/, '');
                const fetchUrl = new URL(cleanWorker);
                fetchUrl.searchParams.append('url', `https://api.notion.com/v1${endpoint}`);
                if (proxyToken) fetchUrl.searchParams.append('token', proxyToken.trim());
                const headers = { 'Authorization': `Bearer ${authToken.trim()}`, 'Notion-Version': '2022-06-28' };
                let payload = body;
                if (body && !(body instanceof FormData)) {
                    headers['Content-Type'] = 'application/json';
                    payload = JSON.stringify(body);
                }
                const res = await fetch(fetchUrl.toString(), { method, headers, body: payload });
                if (!res.ok) {
                    let txt = await res.text();
                    try {
                        const j = JSON.parse(txt);
                        txt = j.message || txt;
                    } catch (_) { }
                    throw new Error(txt || `Request failed ${res.status}`);
                }
                return await res.json();
            },
            async listDatabases() {
                const results = [];
                let cursor = null;
                let hasMore = true;
                while (hasMore) {
                    const body = { filter: { value: 'database', property: 'object' }, page_size: 50 };
                    if (cursor) body.start_cursor = cursor;
                    const res = await API.request('POST', '/search', body);
                    results.push(...res.results);
                    hasMore = res.has_more;
                    cursor = res.next_cursor;
                }
                return results;
            },
            async queryDatabase(dbId, since = null) {
                const rows = [];
                let cursor = null;
                let hasMore = true;
                while (hasMore) {
                    const body = { page_size: 100 }; // Notion max page size
                    if (cursor) body.start_cursor = cursor;
                    if (since) {
                        body.filter = {
                            timestamp: 'last_edited_time',
                            last_edited_time: { on_or_after: since }
                        };
                    }
                    const res = await API.request('POST', `/databases/${dbId}/query`, body);
                    rows.push(...res.results);
                    hasMore = res.has_more;
                    cursor = res.next_cursor;
                }
                return rows;
            },
            async getDatabase(dbId) {
                return API.request('GET', `/databases/${dbId}`);
            },
            async createPage(dbId, properties) {
                return API.request('POST', '/pages', { parent: { database_id: dbId }, properties });
            },
            async updatePage(pageId, properties) {
                return API.request('PATCH', `/pages/${pageId}`, { properties });
            },
            async archivePage(pageId) {
                return API.request('PATCH', `/pages/${pageId}`, { archived: true });
            }
        };

        const SRS = {
            fsrs(card, rating) {
                const now = new Date();
                const ratingName = rating;
                const lastD = card.fsrs?.difficulty ?? initDifficulty('good');
                const lastS = card.fsrs?.stability ?? initStability('good');
                const lastReview = card.fsrs?.lastReview ? new Date(card.fsrs.lastReview) : null;
                const isNew = !lastReview;
                let newD, newS, retr;
                if (isNew) {
                    newD = initDifficulty(ratingName);
                    newS = initStability(ratingName);
                    retr = REQUEST_RETENTION;
                } else {
                    const elapsed = Math.max(0.01, (now - lastReview) / 86400000);
                    const r = forgettingCurve(elapsed, lastS);
                    newD = nextDifficulty(lastD, ratingName);
                    if (ratingName === 'again') newS = nextForgetStability(lastD, lastS, r);
                    else newS = nextRecallStability(newD, lastS, r, ratingName);
                    retr = REQUEST_RETENTION;
                }
                const intervalDays = nextInterval(newS);
                return {
                    difficulty: newD,
                    stability: newS,
                    retrievability: retr,
                    lastRating: ratingName,
                    lastReview: now.toISOString(),
                    dueDate: new Date(now.getTime() + intervalDays * 86400000).toISOString()
                };
            },
            sm2(card, rating) {
                const now = new Date();
                const ease = card.sm2?.easeFactor ?? 2.5;
                const interval = card.sm2?.interval ?? 1;
                const grade = { again: 1, hard: 3, good: 4, easy: 5 }[rating] ?? 3;
                const newEase = Math.max(1.3, ease + (0.1 - (5 - grade) * (0.08 + (5 - grade) * 0.02)));
                const newInterval = grade < 3 ? 1 : interval < 1 ? 1 : Math.round(interval * newEase);
                return {
                    easeFactor: newEase,
                    interval: newInterval,
                    dueDate: new Date(now.getTime() + newInterval * 86400000).toISOString(),
                    lastRating: rating,
                    lastReview: now.toISOString()
                };
            },
            leitner(card, rating) {
                const now = new Date();
                const box = card.leitner?.box ?? 1;
                const delta = { again: -1, hard: 0, good: 1, easy: 2 }[rating] ?? 0;
                const nextBox = Math.max(1, box + delta);
                const interval = nextBox;
                return {
                    box: nextBox,
                    dueDate: new Date(now.getTime() + interval * 86400000).toISOString(),
                    lastRating: rating,
                    lastReview: now.toISOString()
                };
            },
            random() {
                const now = new Date();
                return { dueDate: new Date(now.getTime() + Math.random() * 5 * 86400000).toISOString() };
            }
        };

        const normalizeRating = (name) => name ? name.toLowerCase() : null;
        const displayRating = (name) => name ? name.charAt(0).toUpperCase() + name.slice(1).toLowerCase() : null;
        const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
        const hexToRgb = (hex) => {
            const h = hex.replace('#', '');
            if (h.length === 3) return { r: parseInt(h[0] + h[0], 16), g: parseInt(h[1] + h[1], 16), b: parseInt(h[2] + h[2], 16) };
            return { r: parseInt(h.slice(0, 2), 16), g: parseInt(h.slice(2, 4), 16), b: parseInt(h.slice(4, 6), 16) };
        };
        const rgbToHex = ({ r, g, b }) => '#' + [r, g, b].map(x => clamp(Math.round(x), 0, 255).toString(16).padStart(2, '0')).join('');
        const mix = (c1, c2, t) => {
            const a = hexToRgb(c1);
            const b = hexToRgb(c2);
            return rgbToHex({ r: a.r + (b.r - a.r) * t, g: a.g + (b.g - a.g) * t, b: a.b + (b.b - a.b) * t });
        };
        const adjustedDeckColor = (color, theme) => {
            const base = color || '#917FB3';
            if (theme === 'dark') return mix(base, '#000000', 0.55);
            return mix(base, '#ffffff', 0.7);
        };
        const detectCardType = (name = '', back = '') => {
            const text = `${name} ${back}`.toLowerCase();
            const hasCloze = /\{\{c\d+::.+?\}\}/i.test(text);
            if (hasCloze) return 'Cloze';
            return 'Front-Back';
        };
        // FSRS constants (v4.11 defaults)
        const fsrsW = [0.4, 0.6, 2.4, 5.8, 4.93, 0.94, 0.86, 0.01, 1.49, 0.14, 0.94, 2.18, 0.05, 0.34, 1.26, 0.29, 2.61];
        const DECAY = -0.5;
        const FACTOR = Math.pow(0.9, 1 / DECAY) - 1; // derived from requestRetention 0.9
        const REQUEST_RETENTION = 0.9;
        const MAX_INTERVAL = 36500;
        const ratingsMap = { again: 1, hard: 2, good: 3, easy: 4 };
        const clamp2 = (n) => +Number.isFinite(n) ? Math.max(0, Math.round(n * 100) / 100) : 0;
        const constrainDifficulty = (d) => Math.min(Math.max(+d.toFixed(2), 1), 10);
        const meanReversion = (init, current) => fsrsW[7] * init + (1 - fsrsW[7]) * current;
        const initDifficulty = (ratingName) => {
            const r = ratingsMap[ratingName] || 3;
            return constrainDifficulty(fsrsW[4] - fsrsW[5] * (r - 3));
        };
        const initStability = (ratingName) => {
            const r = ratingsMap[ratingName] || 3;
            return +Math.max(fsrsW[r - 1], 0.1).toFixed(2);
        };
        const forgettingCurve = (elapsedDays, stability) => Math.pow(1 + FACTOR * elapsedDays / stability, DECAY);
        const nextInterval = (stability) => {
            const raw = stability / FACTOR * (Math.pow(REQUEST_RETENTION, 1 / DECAY) - 1);
            const rounded = Math.min(Math.max(Math.round(raw), 1), MAX_INTERVAL);
            return rounded;
        };
        const nextDifficulty = (d, ratingName) => {
            const r = ratingsMap[ratingName] || 3;
            const next_d = d - fsrsW[6] * (r - 3);
            return constrainDifficulty(meanReversion(fsrsW[4], next_d));
        };
        const nextRecallStability = (d, s, r, ratingName) => {
            const hardPenalty = ratingName === 'hard' ? fsrsW[15] : 1;
            const easyBonus = ratingName === 'easy' ? fsrsW[16] : 1;
            const val = s * (1 + Math.exp(fsrsW[8]) * (11 - d) * Math.pow(s, -fsrsW[9]) * (Math.exp((1 - r) * fsrsW[10]) - 1) * hardPenalty * easyBonus);
            return clamp2(val);
        };
        const nextForgetStability = (d, s, r) => {
            const val = Math.min(
                fsrsW[11] * Math.pow(d, -fsrsW[12]) * (Math.pow(s + 1, fsrsW[13]) - 1) * Math.exp((1 - r) * fsrsW[14]),
                s
            );
            return clamp2(val);
        };
        const toRichTextChunks = (text) => {
            const str = (text || '').toString();
            if (!str) return [];
            const MAX_CHARS = 2000;
            const MAX_ITEMS = 100;
            const chunks = [];
            for (let i = 0; i < str.length && chunks.length < MAX_ITEMS; i += MAX_CHARS) {
                chunks.push({ text: { content: str.slice(i, i + MAX_CHARS) } });
            }
            return chunks;
        };
        const richToMarkdown = (arr = []) => {
            return (arr || []).map(rt => {
                if (!rt) return '';
                const a = rt.annotations || {};
                let s = '';
                if (rt.type === 'equation' && rt.equation?.expression) {
                    s = `<span class="notion-equation">${rt.equation.expression}</span>`;
                } else {
                    const t = rt.plain_text || '';
                    if (!t) return '';
                    if (rt.href) s = `[${t}](${rt.href})`; else s = t;
                    if (a.code) s = '`' + s + '`';
                    if (a.bold) s = '**' + s + '**';
                    if (a.italic) s = '*' + s + '*';
                    if (a.strikethrough) s = '~~' + s + '~~';
                    if (a.underline) s = '__' + s + '__';
                    if (a.color && a.color !== 'default') {
                        s = `<span class="notion-color-${a.color.replace('_', '-')}">${s}</span>`;
                    }
                }
                return s;
            }).join('');
        };

        const NotionMapper = {
            deckFrom(page) {
                const props = page.properties || {};
                const title = props['Deck Name']?.title?.map(t => t.plain_text).join('') || 'Untitled deck';
                return {
                    id: page.id,
                    notionId: page.id,
                    name: title,
                    color: props['Deck Color']?.rich_text?.[0]?.plain_text || '#917FB3',
                    algorithm: props['Default SRS Algorithm']?.select?.name || 'FSRS',
                    reviewLimit: props['Daily Review Limit']?.number || 50,
                    newLimit: props['New Card Limit']?.number || 20,
                    reverse: props['Reverse Mode Enabled']?.checkbox || false,
                    createdInApp: props['Created In-App']?.checkbox || false,
                    ankiMetadata: props['Anki Metadata']?.rich_text?.[0]?.plain_text || '',
                    aiPrompt: props['AI Revision Prompt']?.rich_text?.map(t => t.plain_text).join('') || '',
                    updatedInApp: false
                };
            },
            deckProps(deck) {
                return {
                    'Deck Name': { title: [{ text: { content: deck.name } }] },
                    'Deck Color': { rich_text: deck.color ? [{ text: { content: deck.color } }] : [] },
                    'Default SRS Algorithm': { select: { name: deck.algorithm } },
                    'Daily Review Limit': { number: deck.reviewLimit },
                    'New Card Limit': { number: deck.newLimit },
                    'Reverse Mode Enabled': { checkbox: !!deck.reverse },
                    'Created In-App': { checkbox: true },
                    'Anki Metadata': { rich_text: deck.ankiMetadata ? [{ text: { content: deck.ankiMetadata } }] : [] },
                    'AI Revision Prompt': { rich_text: deck.aiPrompt ? [{ text: { content: deck.aiPrompt } }] : [] }
                };
            },
            cardFrom(page, decks) {
                const p = page.properties || {};
                const deckRel = p['Deck']?.relation?.[0]?.id || null;
                const name = richToMarkdown(p['Name']?.title) || 'Card';
                const back = richToMarkdown(p['Back']?.rich_text) || '';
                const tags = p['Tags']?.multi_select?.map(t => t.name) || [];
                const fsrs = {
                    difficulty: p['Difficulty']?.number ?? initDifficulty('good'),
                    stability: p['Stability']?.number ?? initStability('good'),
                    retrievability: p['Retrievability']?.number ?? 0.9,
                    lastRating: normalizeRating(p['Last Rating']?.select?.name) || null,
                    lastReview: p['Last Review']?.date?.start || null,
                    dueDate: p['Due Date']?.date?.start || null
                };
                const sm2 = {
                    interval: p['Interval / Box Level']?.number ?? 1,
                    easeFactor: p['Ease Factor']?.number ?? 2.5,
                    dueDate: p['Due Date']?.date?.start || null,
                    lastRating: normalizeRating(p['Last Rating']?.select?.name) || null,
                    lastReview: p['Last Review']?.date?.start || null
                };
                return {
                    id: page.id,
                    notionId: page.id,
                    deckId: deckRel,
                    name,
                    back,
                    type: p['Card Type']?.select?.name || detectCardType(name, back),
                    tags,
                    notes: richToMarkdown(p['Notes']?.rich_text) || '',
                    suspended: p['Suspended']?.checkbox || false,
                    leech: p['Leech']?.checkbox || false,
                    fsrs,
                    sm2,
                    leitner: { box: p['Interval / Box Level']?.number || 1, dueDate: p['Due Date']?.date?.start || null },
                    syncId: page.id,
                    updatedInApp: p['Updated In-App']?.checkbox || false,
                    reviewHistory: JSON.parse(p['Review History']?.rich_text?.[0]?.plain_text || '[]'),
                    ankiGuid: p['Anki GUID']?.rich_text?.[0]?.plain_text || '',
                    ankiNoteType: p['Anki Note Type']?.select?.name || '',
                    ankiFields: p['Anki Fields JSON']?.rich_text?.[0]?.plain_text || '',
                    clozeIndexes: p['Cloze Indexes']?.rich_text?.[0]?.plain_text || '',
                    createdAt: page.created_time
                };
            },
            cardProps(card, notionDeckId = null) {
                return {
                    'Name': { title: [{ text: { content: card.name } }] },
                    'Back': { rich_text: [{ text: { content: card.back } }] },
                    'Card Type': { select: { name: card.type } },
                    'Deck': notionDeckId ? { relation: [{ id: notionDeckId }] } : { relation: [] },
                    'Tags': { multi_select: card.tags.map(t => ({ name: t })) },
                    // Only chunk Notes and Review History; other fields are expected to stay short.
                    'Notes': { rich_text: toRichTextChunks(card.notes) },
                    'Suspended': { checkbox: !!card.suspended },
                    'Leech': { checkbox: !!card.leech },
                    'Difficulty': { number: card.fsrs?.difficulty ?? 4 },
                    'Stability': { number: card.fsrs?.stability ?? 1 },
                    'Retrievability': { number: card.fsrs?.retrievability ?? 0.9 },
                    'Last Rating': card.fsrs?.lastRating ? { select: { name: displayRating(card.fsrs.lastRating) } } : { select: null },
                    'Last Review': { date: card.fsrs?.lastReview ? { start: card.fsrs.lastReview } : null },
                    'Due Date': { date: card.fsrs?.dueDate ? { start: card.fsrs.dueDate } : null },
                    'Interval / Box Level': { number: card.leitner?.box ?? card.sm2?.interval ?? 1 },
                    'Ease Factor': { number: card.sm2?.easeFactor ?? 2.5 },
                    'Updated In-App': { checkbox: true },
                    'Review History': { rich_text: toRichTextChunks(JSON.stringify(card.reviewHistory || [])) },
                    'Anki GUID': card.ankiGuid ? { rich_text: [{ text: { content: card.ankiGuid } }] } : { rich_text: [] },
                    'Anki Note Type': card.ankiNoteType ? { select: { name: card.ankiNoteType } } : { select: null },
                    'Anki Fields JSON': card.ankiFields ? { rich_text: [{ text: { content: card.ankiFields } }] } : { rich_text: [] },
                    'Cloze Indexes': card.clozeIndexes ? { rich_text: [{ text: { content: card.clozeIndexes } }] } : { rich_text: [] }
                };
            }
        };

        const App = {
            state: {
                decks: [],
                cards: [],
                queue: [],
                selectedDeck: null,
                selectedCard: null,
                filters: { again: false, hard: false, addedToday: false, stability: 25, tags: [], suspended: false, leech: false, manual: [] },
                reverse: false,
                lastSync: null,
                lastPull: null,
                lastPush: null,
                settings: Storage.getSettings(),
                sourcesCache: [],
                workerVerified: Storage.getSettings().workerVerified || false,
                authVerified: Storage.getSettings().authVerified || false,
                sourcesVerified: false,
                autoSyncTimer: null,
                syncing: false,
                autoScanPending: false
            },
            async init() {
                await Storage.init();
                await this.loadFromDB();
                this.captureOAuth();
                this.bind();
                this.seedIfEmpty();
                this.renderAll();
                await this.autoVerifyWorker();
                window.addEventListener('online', () => this.handleOnline());
                window.addEventListener('offline', () => this.renderConnection());
                this.applyTheme();
                this.applyFontMode();
                if (window.matchMedia) {
                    const mq = window.matchMedia('(prefers-color-scheme: dark)');
                    mq.addEventListener('change', () => this.applyTheme());
                }
                Tooltip.bind();
                this.startAutoSync();
            },
            captureOAuth() {
                const hashParams = new URLSearchParams(location.hash.replace('#', '?'));
                const searchParams = new URLSearchParams(location.search);
                const token = hashParams.get('token') || searchParams.get('token') || searchParams.get('accessToken');
                if (token) {
                    this.state.settings.authToken = token;
                    Storage.setSettings(this.state.settings);
                    toast('Notion token captured');
                    history.replaceState({}, document.title, location.pathname);
                    this.pendingAuthVerify = true;
                    this.openSettings();
                    this.state.autoScanPending = true;
                }
            },
            async loadFromDB() {
                this.state.decks = await Storage.getAll('decks');
                this.state.cards = await Storage.getAll('cards');
                const meta = await Storage.getAll('meta');
                const last = meta.find(m => m.key === 'lastSync');
                if (last) this.state.lastSync = last.value;
                const lp = meta.find(m => m.key === 'lastPull');
                if (lp) this.state.lastPull = lp.value;
                const lpush = meta.find(m => m.key === 'lastPush');
                if (lpush) this.state.lastPush = lpush.value;
            },
            async seedIfEmpty() {
                return;
            },
            newDeck(name, color, algorithm) {
                return {
                    id: crypto.randomUUID(),
                    notionId: null,
                    name,
                    color,
                    algorithm,
                    reviewLimit: 50,
                    newLimit: 20,
                    reverse: false,
                    createdInApp: true,
                    updatedInApp: true,
                    aiPrompt: '',
                    aiProvider: '',
                    aiModel: '',
                    aiKey: ''
                };
            },
            newCard(deckId, name, back, type) {
                const now = new Date().toISOString();
                return {
                    id: crypto.randomUUID(),
                    notionId: null,
                    deckId,
                    name,
                    back,
                    type,
                    tags: [],
                    notes: '',
                    suspended: false,
                    leech: false,
                    fsrs: { difficulty: 4, stability: 1, retrievability: 0.9, lastRating: null, lastReview: null, dueDate: now },
                    sm2: { interval: 1, easeFactor: 2.5, dueDate: now },
                    leitner: { box: 1, dueDate: now },
                    syncId: crypto.randomUUID(),
                    updatedInApp: true,
                    reviewHistory: [],
                    createdAt: now
                };
            },
            bind() {
                el('#syncNowBtn').onclick = () => this.syncNow();
                document.querySelectorAll('.theme-btn').forEach(btn => btn.onclick = () => {
                    this.state.settings.themeMode = btn.dataset.theme;
                    Storage.setSettings(this.state.settings);
                    this.applyTheme();
                });
                document.querySelectorAll('.font-btn').forEach(btn => btn.onclick = () => {
                    this.state.settings.fontMode = btn.dataset.font;
                    Storage.setSettings(this.state.settings);
                    this.applyFontMode();
                });
                el('#newDeckBtn').onclick = () => this.openDeckModal();
                el('#closeDeckModal').onclick = () => this.closeDeckModal();
                el('#saveDeckBtn').onclick = () => this.saveDeckFromModal();
                el('#deleteDeckBtn').onclick = () => this.deleteDeckFromModal();
                el('#newCardBtn').onclick = () => this.openCardModal();
                el('#closeCardModal').onclick = () => this.closeCardModal();
                el('#saveCardBtn').onclick = () => this.saveCardFromModal();
                el('#deleteCardBtn').onclick = () => this.deleteCardFromModal();
                el('#revealBtn').onclick = () => this.reveal();
                el('#skipCard').onclick = () => this.nextCard();
                el('#toggleReverse').onclick = () => { this.state.reverse = !this.state.reverse; this.renderStudy(); };
                el('#notesArea').addEventListener('input', () => this.saveNotes());
                el('#copyMarkdown').onclick = () => this.copyMarkdown();
                document.querySelectorAll('.rate-btn').forEach(btn => btn.onclick = (e) => this.rate(e.target.dataset.rate));
                el('#filterAgain').onchange = (e) => { this.state.filters.again = e.target.checked; this.renderCards(); };
                el('#filterHard').onchange = (e) => { this.state.filters.hard = e.target.checked; this.renderCards(); };
                el('#filterAddedToday').onchange = (e) => { this.state.filters.addedToday = e.target.checked; this.renderCards(); };
                el('#filterStability').oninput = (e) => { this.state.filters.stability = Number(e.target.value); el('#stabilityValue').textContent = e.target.value; this.renderCards(); };
                el('#filterTags').oninput = (e) => { this.state.filters.tags = e.target.value.split(',').map(t => t.trim()).filter(Boolean); this.renderCards(); };
                el('#resetFilters').onclick = () => this.resetFilters();
                el('#filterSuspended').onchange = (e) => { this.state.filters.suspended = e.target.checked; this.renderCards(); };
                el('#filterLeech').onchange = (e) => { this.state.filters.leech = e.target.checked; this.renderCards(); };
                el('#ankiImportInput').onchange = (e) => this.handleAnkiImport(e.target.files[0]);
                el('#exportAnkiBtn').onclick = () => this.exportAnki();
                this.attachSwipe();
                document.addEventListener('click', (e) => {
                    if (e.target.dataset.deckId) this.selectDeck(e.target.dataset.deckId);
                    if (e.target.dataset.cardId) this.selectCard(e.target.dataset.cardId);
                });
                el('#openSettings').onclick = () => this.openSettings();
                el('#closeSettings').onclick = () => this.closeSettings();
                el('#saveSettings').onclick = () => this.saveSettings();
                el('#verifyWorker').onclick = () => this.verifyWorker();
                el('#verifyAuth').onclick = () => this.verifyAuth();
                el('#oauthBtn').onclick = () => { if (this.state.workerVerified) this.startOAuth(); else toast('Verify worker first'); };
                el('#scanSources').onclick = () => this.scanSources();
                el('#openWorkerHelp').onclick = () => this.openModal('workerHelpModal');
                el('#closeWorkerHelp').onclick = () => this.closeModal('workerHelpModal');
                el('#copyWorkerCode').onclick = () => this.copyWorkerCode();
                el('#lockedOpenSettings').onclick = () => this.openSettings();
                el('#resetApp').onclick = () => this.resetApp();
                this.updateSettingsButtons();
                window.addEventListener('keydown', (e) => { if (e.key === 'Escape') { this.closeSettings(); this.closeModal('workerHelpModal'); this.closeDeckModal(); this.closeCardModal(); } });
                el('#settingsModal').addEventListener('click', (e) => { if (e.target === el('#settingsModal')) this.closeSettings(); });
                el('#workerHelpModal').addEventListener('click', (e) => { if (e.target === el('#workerHelpModal')) this.closeModal('workerHelpModal'); });
                el('#revisionMode').onchange = (e) => { const on = e.target.value === 'ai'; el('#aiControls').classList.toggle('hidden', !on); };
                el('#aiSubmit').onclick = () => this.submitToAI();
                el('#aiRecord').onclick = () => this.recordAnswer();
                el('#confirmDelete').onclick = () => this.performDelete();
                el('#cancelDelete').onclick = () => this.closeModal('confirmModal');
                el('#confirmModal').addEventListener('click', (e) => { if (e.target === el('#confirmModal')) this.closeModal('confirmModal'); });
            },
            renderAll() {
                this.renderDecks();
                this.renderCards();
                this.renderConnection();
                this.renderStudy();
                this.updateCounts();
                this.populateSourceSelects();
                this.renderGate();
                this.renderStatus();
                lucide.createIcons();
                this.loadAISettings();
                this.updateResetState();
            },
            renderGate() {
                const ready = this.isReady();
                el('#mainContent').style.display = ready ? 'block' : 'none';
                el('#lockedOverlay').classList.toggle('hidden', ready);
                const oauth = el('#oauthBtn');
                const verifyAuthBtn = el('#verifyAuth');
                const tokenInput = el('#settingAuthToken');
                if (oauth) oauth.disabled = !this.state.workerVerified;
                if (verifyAuthBtn) verifyAuthBtn.disabled = !this.state.workerVerified;
                if (tokenInput) tokenInput.disabled = !this.state.workerVerified;
                this.updateSettingsButtons();
            },
            renderConnection() {
                const badge = el('#connectionBadge');
                const online = navigator.onLine;
                const hasWorkerUrl = !!this.state.settings.workerUrl;
                const workerOk = hasWorkerUrl && this.state.workerVerified;
                const hasToken = !!this.state.settings.authToken;
                const authOk = workerOk && this.state.authVerified && hasToken;
                const ready = online && workerOk && authOk;

                if (!online) {
                    badge.textContent = 'Offline';
                    badge.className = 'px-3 py-1 rounded-full pill text-xs bg-oatmeal border border-oatmeal-dark text-earth-metal';
                    return;
                }

                if (!hasWorkerUrl) {
                    badge.textContent = 'Online ¬∑ add worker URL';
                } else if (!workerOk) {
                    badge.textContent = 'Online ¬∑ verify worker';
                } else if (!hasToken) {
                    badge.textContent = 'Online ¬∑ set token';
                } else if (!authOk) {
                    badge.textContent = 'Online ¬∑ verify token';
                } else {
                    badge.textContent = 'Online ¬∑ Notion ready';
                }
                badge.className = ready
                    ? 'px-3 py-1 rounded-full pill text-xs bg-white-linen border border-oatmeal-dark text-earth-metal'
                    : 'px-3 py-1 rounded-full pill text-xs bg-oatmeal border border-oatmeal-dark text-earth-metal';
            },
            renderDecks() {
                const grid = el('#deckGrid');
                const theme = document.body.getAttribute('data-theme') || 'light';
                grid.innerHTML = this.state.decks.map(d => `
                    <article class="rounded-2xl border border-[color:var(--card-border)] p-3 bg-[color:var(--surface)] text-[color:var(--text-main)] flex flex-col gap-2 hover:-translate-y-0.5 transition cursor-pointer" data-deck-id="${d.id}">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center gap-2">
                                <span class="w-3 h-3 rounded-full" style="background:${adjustedDeckColor(d.color, theme)}"></span>
                                <p class="font-semibold text-[color:var(--text-main)]">${d.name}</p>
                            </div>
                            <span class="text-[11px] px-2 py-1 rounded-full bg-[color:var(--surface-strong)] text-[color:var(--text-main)] border border-[color:var(--card-border)]">${d.algorithm}</span>
                        </div>
                        <div class="flex items-center gap-3 text-xs text-[color:var(--text-sub)]">
                            <span>${this.cardsForDeck(d.id).filter(c => this.isDue(c)).length} due</span>
                            <span>${this.cardsForDeck(d.id).length} cards</span>
                        </div>
                        <div class="flex items-center gap-2 text-[11px] text-[color:var(--text-sub)]">
                            <i data-lucide="refresh-cw" class="w-3 h-3"></i>
                            <span>Reverse ${d.reverse ? 'on' : 'off'}</span>
                        </div>
                    </article>
                `).join('');
            },
            renderCards() {
                const tbody = el('#cardTable');
                let cards = this.state.selectedDeck ? this.cardsForDeck(this.state.selectedDeck.id) : this.state.cards;
                cards = cards.filter(c => this.passFilters(c));
                tbody.innerHTML = cards.map(c => `
                    <tr class="hover:bg-oatmeal/50 cursor-pointer" data-card-id="${c.id}">
                        <td class="py-2 pr-2 text-charcoal">${c.name.slice(0, 60)}</td>
                        <td class="py-2 pr-2 capitalize">${c.type}</td>
                        <td class="py-2 pr-2">${this.deckName(c.deckId)}</td>
                        <td class="py-2 pr-2 text-earth-metal/70">${c.fsrs?.dueDate ? new Date(c.fsrs.dueDate).toLocaleDateString() : '‚Äî'}</td>
                        <td class="py-2 pr-2 text-earth-metal/70">${this.deckById(c.deckId)?.algorithm ?? 'FSRS'}</td>
                        <td class="py-2 pr-2 text-earth-metal/70">${c.tags.join(', ')}</td>
                    </tr>
                `).join('');
                this.renderManualSelection();
                this.updateCounts();
            },
            renderStudy() {
                const card = this.pickCard();
                const deck = card ? this.deckById(card.deckId) : null;
                el('#studyDeckLabel').textContent = deck ? deck.name : 'Choose a deck';
                el('#algorithmLabel').textContent = deck ? deck.algorithm : '‚Äî';
                const front = card ? this.renderCardFront(card, deck) : '<p class="text-earth-metal/70 text-sm">No card selected</p>';
                el('#cardFront').innerHTML = front;
                el('#cardBack').innerHTML = card ? marked.parse(card.back || '') : '';
                this.renderMath(el('#cardFront'));
                this.renderMath(el('#cardBack'));
                el('#cardBack').classList.add('hidden');
                if (deck && deck.reverse) el('#toggleReverse').classList.add('text-charcoal');
                else el('#toggleReverse').classList.remove('text-charcoal');
                this.state.selectedCard = card || null;
                this.renderNotes();
                this.renderFsrsMeta();
                el('#aiAnswer').value = '';
                el('#aiFeedback').innerHTML = '';
                this.resetSwipeHints();
            },
            renderNotes() {
                const notes = this.state.selectedCard?.notes ?? '';
                el('#notesArea').value = notes;
                el('#notesPreview').innerHTML = notes ? marked.parse(notes) : '<p class="text-earth-metal/60 text-sm">No notes yet.</p>';
                this.renderMath(el('#notesPreview'));
            },
            renderFsrsMeta() {
                const card = this.state.selectedCard;
                if (!card) { el('#fsrsMeta').textContent = 'FSRS fields ready'; return; }
                const f = card.fsrs;
                el('#fsrsMeta').textContent = `Diff ${f?.difficulty?.toFixed(1) ?? '-'} ¬∑ Stability ${f?.stability?.toFixed(1) ?? '-'} ¬∑ Due ${f?.dueDate ? new Date(f.dueDate).toLocaleDateString() : '‚Äî'}`;
            },
            renderManualSelection() {
                const wrap = el('#manualSelection');
                wrap.innerHTML = this.state.filters.manual.map(id => {
                    const c = this.cardById(id);
                    return c ? `<span class="px-2 py-1 rounded-full bg-oatmeal text-earth-metal text-xs">${c.name.slice(0, 20)}</span>` : '';
                }).join('');
            },
            openDeckModal(deck) {
                if (!this.isReady()) { this.openSettings(); return; }
                this.state.editingDeck = deck || null;
                el('#deckModalTitle').textContent = deck ? 'Edit deck' : 'New deck';
                el('#deckNameInput').value = deck?.name ?? '';
                el('#deckColorInput').value = deck?.color ?? '#917FB3';
                el('#deckAlgoInput').value = deck?.algorithm ?? 'FSRS';
                el('#deckReviewLimit').value = deck?.reviewLimit ?? 50;
                el('#deckNewLimit').value = deck?.newLimit ?? 20;
                el('#deckReverseInput').checked = deck?.reverse ?? false;
                el('#deckPromptInput').value = deck?.aiPrompt ?? '';
                el('#deleteDeckBtn').classList.toggle('hidden', !deck);
                el('#deckModal').classList.remove('hidden');
                el('#deckModal').classList.add('flex');
            },
            closeDeckModal() {
                el('#deckModal').classList.add('hidden');
                el('#deckModal').classList.remove('flex');
            },
            async saveDeckFromModal() {
                const d = this.state.editingDeck || this.newDeck('', '#917FB3', 'FSRS');
                d.name = el('#deckNameInput').value || d.name || 'Untitled deck';
                d.color = el('#deckColorInput').value;
                d.algorithm = el('#deckAlgoInput').value;
                d.reviewLimit = Number(el('#deckReviewLimit').value) || 50;
                d.newLimit = Number(el('#deckNewLimit').value) || 20;
                d.reverse = el('#deckReverseInput').checked;
                d.aiPrompt = el('#deckPromptInput').value || '';
                if (!this.state.editingDeck) this.state.decks.push(d);
                d.updatedInApp = true;
                await Storage.put('decks', d);
                this.queueOp({ type: 'deck-upsert', payload: d });
                this.closeDeckModal();
                this.renderDecks();
                this.renderStudy();
                toast('Deck saved');
            },
            async deleteDeckFromModal() {
                const deck = this.state.editingDeck;
                if (!deck) return;
                this.pendingDelete = { type: 'deck', id: deck.id, notionId: deck.notionId };
                this.openModal('confirmModal');
            },
            openCardModal(card) {
                if (!this.isReady()) { this.openSettings(); return; }
                this.state.editingCard = card || null;
                el('#cardModalTitle').textContent = card ? 'Edit card' : 'New card';
                const deckSelect = el('#cardDeckInput');
                deckSelect.innerHTML = this.state.decks.map(d => `<option value="${d.id}">${d.name}</option>`).join('');
                deckSelect.value = card?.deckId || this.state.selectedDeck?.id || this.state.decks[0]?.id;
                el('#cardTypeInput').value = card?.type ?? 'Front-Back';
                el('#cardNameInput').value = card?.name ?? '';
                el('#cardBackInput').value = card?.back ?? '';
                el('#cardTagsInput').value = card?.tags?.join(', ') ?? '';
                el('#cardSuspendedInput').checked = card?.suspended ?? false;
                el('#cardLeechInput').checked = card?.leech ?? false;
                el('#deleteCardBtn').classList.toggle('hidden', !card);
                el('#cardModal').classList.remove('hidden');
                el('#cardModal').classList.add('flex');
            },
            closeCardModal() {
                el('#cardModal').classList.add('hidden');
                el('#cardModal').classList.remove('flex');
            },
            async saveCardFromModal() {
                let card = this.state.editingCard || this.newCard('', '', '', 'Front-Back');
                card.deckId = el('#cardDeckInput').value;
                card.type = el('#cardTypeInput').value;
                card.name = el('#cardNameInput').value || 'Untitled';
                card.back = el('#cardBackInput').value || '';
                if (!this.state.editingCard) {
                    const autoType = detectCardType(card.name, card.back);
                    if (card.type === 'Front-Back' && autoType === 'Cloze') card.type = 'Cloze';
                }
                card.tags = el('#cardTagsInput').value.split(',').map(t => t.trim()).filter(Boolean);
                card.suspended = el('#cardSuspendedInput').checked;
                card.leech = el('#cardLeechInput').checked;
                card.updatedInApp = true;
                if (!this.state.editingCard) this.state.cards.push(card);
                await Storage.put('cards', card);
                this.queueOp({ type: 'card-upsert', payload: card });
                this.closeCardModal();
                this.renderCards();
                toast('Card saved');
            },
            async deleteCardFromModal() {
                const card = this.state.editingCard;
                if (!card) return;
                this.pendingDelete = { type: 'card', id: card.id, notionId: card.notionId };
                this.openModal('confirmModal');
            },
            async syncNow() {
                if (!this.isReady()) return toast('Complete settings first');
                el('#syncProgress').style.width = '10%';
                await this.pullFromNotion();
                el('#syncProgress').style.width = '50%';
                await this.pushQueue();
                el('#syncProgress').style.width = '100%';
                const nowIso = new Date().toISOString();
                this.state.lastPull = nowIso;
                this.state.lastPush = nowIso;
                this.state.lastSync = nowIso;
                await Storage.put('meta', { key: 'lastPull', value: nowIso });
                await Storage.put('meta', { key: 'lastPush', value: nowIso });
                await Storage.put('meta', { key: 'lastSync', value: nowIso });
                el('#snapshotStatus').textContent = 'Up to date';
                setTimeout(() => el('#syncProgress').style.width = '0%', 700);
                toast('Synced with Notion');
            },
            async pullFromNotion() {
                const { deckSource, cardSource } = this.state.settings;
                if (!deckSource || !cardSource) return;
                const since = this.state.lastPull;
                const decks = await API.queryDatabase(deckSource, since);
                const cards = await API.queryDatabase(cardSource, since);
                const mappedDecks = decks.map(d => NotionMapper.deckFrom(d));
                const mappedCards = cards.map(c => NotionMapper.cardFrom(c, mappedDecks));

                if (!since) {
                    await Storage.wipeStore('decks');
                    await Storage.wipeStore('cards');
                    this.state.decks = [];
                    this.state.cards = [];
                }

                const upsertDeck = (deck) => {
                    const idx = this.state.decks.findIndex(d => d.notionId === deck.notionId);
                    if (idx >= 0) this.state.decks[idx] = { ...this.state.decks[idx], ...deck };
                    else this.state.decks.push(deck);
                };
                const upsertCard = (card) => {
                    const idx = this.state.cards.findIndex(c => c.notionId === card.notionId);
                    if (idx >= 0) this.state.cards[idx] = { ...this.state.cards[idx], ...card };
                    else this.state.cards.push(card);
                };

                for (const d of mappedDecks) { upsertDeck(d); await Storage.put('decks', d); }
                for (const c of mappedCards) { upsertCard(c); await Storage.put('cards', c); }
                this.renderAll();
            },
            async pushQueue() {
                const { deckSource, cardSource } = this.state.settings;
                const queue = [...this.state.queue];
                this.state.queue = [];
                el('#queueCount').textContent = '0';
                for (const op of queue) {
                    if (op.type === 'deck-upsert') {
                        const props = NotionMapper.deckProps(op.payload);
                        if (op.payload.notionId) await API.updatePage(op.payload.notionId, props);
                        else {
                            const res = await API.createPage(deckSource, props);
                            op.payload.notionId = res.id;
                            op.payload.id = op.payload.id || res.id;
                            await Storage.put('decks', op.payload);
                        }
                    }
                    if (op.type === 'deck-delete' && op.payload.notionId) await API.archivePage(op.payload.notionId);
                    if (op.type === 'card-upsert') {
                        const deck = this.deckById(op.payload.deckId);
                        const props = NotionMapper.cardProps(op.payload, deck?.notionId || deck?.id || null);
                        if (op.payload.notionId) await API.updatePage(op.payload.notionId, props);
                        else {
                            const res = await API.createPage(cardSource, props);
                            op.payload.notionId = res.id;
                            op.payload.id = op.payload.id || res.id;
                            op.payload.syncId = res.id;
                            await Storage.put('cards', op.payload);
                        }
                    }
                    if (op.type === 'card-delete' && op.payload.notionId) await API.archivePage(op.payload.notionId);
                }
            },
            queueOp(op) {
                this.state.queue.push(op);
                el('#queueCount').textContent = String(this.state.queue.length);
            },
            startAutoSync() {
                if (this.state.autoSyncTimer) clearInterval(this.state.autoSyncTimer);
                this.state.autoSyncTimer = setInterval(() => this.autoSyncTick(), SYNC_INTERVAL_MS);
                this.autoSyncTick(); // kick off once on load
            },
            async autoSyncTick() {
                if (this.state.syncing) return;
                if (!navigator.onLine) return;
                if (!this.isReady()) return;
                const now = Date.now();
                const lastPullMs = this.state.lastPull ? new Date(this.state.lastPull).getTime() : 0;
                const lastPushMs = this.state.lastPush ? new Date(this.state.lastPush).getTime() : 0;
                const shouldPull = now - lastPullMs > MIN_PULL_INTERVAL_MS;
                const shouldPush = this.state.queue.length > 0 && (now - lastPushMs > MIN_PUSH_INTERVAL_MS);
                if (!shouldPull && !shouldPush) return;
                this.state.syncing = true;
                try {
                    if (shouldPull) {
                        await this.pullFromNotion();
                        this.state.lastPull = new Date().toISOString();
                        await Storage.put('meta', { key: 'lastPull', value: this.state.lastPull });
                    }
                    if (shouldPush) {
                        await this.pushQueue();
                        this.state.lastPush = new Date().toISOString();
                        await Storage.put('meta', { key: 'lastPush', value: this.state.lastPush });
                    }
                    this.state.lastSync = new Date().toISOString();
                    await Storage.put('meta', { key: 'lastSync', value: this.state.lastSync });
                    this.renderConnection();
                } catch (e) {
                    console.error('Auto sync failed', e);
                } finally {
                    this.state.syncing = false;
                }
            },
            handleOnline() {
                this.renderConnection();
                this.autoSyncTick();
            },
            selectDeck(id) {
                const deck = this.deckById(id);
                this.state.selectedDeck = deck;
                this.renderCards();
                this.renderStudy();
                this.openDeckModal(deck);
            },
            selectCard(id) {
                const card = this.cardById(id);
                this.state.selectedCard = card;
                if (!this.state.filters.manual.includes(id)) this.state.filters.manual.push(id);
                this.renderManualSelection();
                this.renderStudy();
                this.openCardModal(card);
            },
            passFilters(card) {
                const f = this.state.filters;
                const now = new Date();
                if (f.again && card.fsrs?.lastRating !== 'again') return false;
                if (f.hard && !['again', 'hard'].includes(card.fsrs?.lastRating)) return false;
                if (f.addedToday && card.createdAt && new Date(card.createdAt).toDateString() !== now.toDateString()) return false;
                if (card.fsrs?.stability && card.fsrs.stability > f.stability) return false;
                if (f.tags.length && !f.tags.some(t => card.tags.includes(t))) return false;
                if (f.suspended && card.suspended) return false;
                if (f.leech && card.leech) return false;
                if (f.manual.length && !f.manual.includes(card.id)) return false;
                return true;
            },
            isDue(card) {
                const due = card.fsrs?.dueDate || card.sm2?.dueDate || card.leitner?.dueDate;
                return due ? new Date(due) <= new Date() : true;
            },
            pickCard() {
                const pool = this.state.cards.filter(c => this.passFilters(c) && this.isDue(c));
                return pool[0] || null;
            },
            renderCardFront(card, deck) {
                const typeKey = (card.type || '').toLowerCase();
                const isFrontStyle = typeKey.includes('front');
                const prompt = this.state.reverse || (deck?.reverse && isFrontStyle) ? card.back : card.name;
                if (typeKey === 'cloze') {
                    return marked.parse(prompt.replace(/\{\{c\d+::(.*?)\}\}/g, '<span class="cloze-blank">$1</span>'));
                }
                return marked.parse(prompt);
            },
            reveal() {
                el('#cardBack').classList.remove('hidden');
                if (el('#revisionMode').value === 'ai') {
                    el('#aiControls').classList.remove('hidden');
                }
            },
            async rate(rating) {
                const card = this.state.selectedCard;
                if (!card) return;
                if (el('#revisionMode').value === 'ai' && !this.state.aiKey) {
                    toast('Add an AI key or switch to Reveal mode');
                    return;
                }
                const deck = this.deckById(card.deckId);
                const alg = deck?.algorithm || 'FSRS';
                if (alg === 'FSRS') card.fsrs = SRS.fsrs(card, rating);
                else if (alg === 'SM-2') card.sm2 = SRS.sm2(card, rating);
                else if (alg === 'Leitner') card.leitner = SRS.leitner(card, rating);
                else if (alg === 'Random') Object.assign(card, { random: SRS.random(card) });
                card.fsrs = card.fsrs || {};
                card.fsrs.lastRating = rating;
                card.reviewHistory.push({ rating, at: new Date().toISOString() });
                await Storage.put('cards', card);
                this.queueOp({ type: 'card-upsert', payload: card });
                this.nextCard();
            },
            nextCard() {
                this.renderStudy();
            },
            cardsForDeck(deckId) {
                return this.state.cards.filter(c => c.deckId === deckId);
            },
            deckById(id) {
                return this.state.decks.find(d => d.id === id);
            },
            cardById(id) {
                return this.state.cards.find(c => c.id === id);
            },
            deckName(id) {
                return this.deckById(id)?.name ?? '‚Äî';
            },
            resetFilters() {
                this.state.filters = { again: false, hard: false, addedToday: false, stability: 25, tags: [], suspended: false, leech: false, manual: [] };
                el('#filterAgain').checked = false;
                el('#filterHard').checked = false;
                el('#filterAddedToday').checked = false;
                el('#filterStability').value = 25;
                el('#filterTags').value = '';
                el('#filterSuspended').checked = false;
                el('#filterLeech').checked = false;
                el('#stabilityValue').textContent = '25';
                this.renderCards();
            },
            async saveNotes() {
                const card = this.state.selectedCard;
                if (!card) return;
                card.notes = el('#notesArea').value;
                await Storage.put('cards', card);
                this.queueOp({ type: 'card-upsert', payload: card });
                el('#noteStatus').textContent = 'Saved offline';
                el('#notesPreview').innerHTML = card.notes ? marked.parse(card.notes) : '<p class="text-earth-metal/60 text-sm">No notes yet.</p>';
            },
            async copyMarkdown() {
                const card = this.state.selectedCard;
                if (!card) return;
                const deck = this.deckById(card.deckId);
                const block = `### ${card.name}\n\n${card.back}\n\n**Notes:**\n${card.notes || '_No notes_'}\n\nDeck: ${deck?.name ?? ''}`;
                await navigator.clipboard.writeText(block);
                toast('Copied markdown for LLM');
            },
            async handleAnkiImport(file) {
                if (!file) return;
                const ext = file.name.split('.').pop().toLowerCase();
                if (ext === 'apkg' || ext === 'zip') {
                    await this.importApkg(file);
                    return;
                }
                const text = await file.text();
                let payload;
                try { payload = JSON.parse(text); } catch { payload = null; }
                if (!payload?.cards?.length) return toast('Unsupported file');
                const deck = this.newDeck(file.name.replace('.apkg', '').replace('.json', ''), '#D8A7B1', 'FSRS');
                this.state.decks.push(deck);
                await Storage.put('decks', deck);
                for (const raw of payload.cards) {
                    const card = this.newCard(deck.id, raw.name || raw.front || 'Imported', raw.back || '', raw.type || 'Front-Back');
                    card.tags = raw.tags || [];
                    card.notes = raw.notes || '';
                    card.ankiGuid = raw.guid || crypto.randomUUID();
                    this.state.cards.push(card);
                    await Storage.put('cards', card);
                    this.queueOp({ type: 'card-upsert', payload: card });
                }
                this.queueOp({ type: 'deck-upsert', payload: deck });
                this.renderAll();
                toast('Imported Anki JSON and ready to sync to Notion');
            },
            async importApkg(file) {
                try {
                    const buf = await file.arrayBuffer();
                    const zip = await JSZip.loadAsync(buf);
                    const collection = await zip.file('collection.anki2').async('uint8array');
                    const SQL = await Storage.ensureSQL();
                    const db = new SQL.Database(collection);
                    const colRow = db.exec("SELECT * FROM col LIMIT 1")[0];
                    const row = colRow?.values?.[0] || [];
                    const models = JSON.parse(row[9] || '{}');
                    const decksJson = JSON.parse(row[10] || '{}');
                    const decksMap = {};
                    Object.values(decksJson).forEach(d => { decksMap[d.id] = d.name; });
                    const notes = db.exec("SELECT id,guid,mid,mod,usn,tags,flds,sfld,csum,flags,data FROM notes")[0]?.values || [];
                    const cards = db.exec("SELECT id,nid,did,ord,mod,usn,type,queue,due,ivl,factor,reps,lapses,left,odue,odid,flags,data FROM cards")[0]?.values || [];
                    const deckCache = {};
                    for (const cardRow of cards) {
                        const [cid, nid, did, ord] = cardRow;
                        const note = notes.find(n => n[0] === nid);
                        if (!note) continue;
                        const [_, guid, mid, mod, usn, tags, flds] = note;
                        const deckId = did;
                        const deckName = decksMap[deckId] || file.name.replace('.apkg', '');
                        if (!deckCache[deckId]) {
                            const deck = this.newDeck(deckName, '#D8A7B1', 'FSRS');
                            deckCache[deckId] = deck;
                            this.state.decks.push(deck);
                            await Storage.put('decks', deck);
                            this.queueOp({ type: 'deck-upsert', payload: deck });
                        }
                        const model = models[mid];
                        const fields = (flds || '').split('\u001f');
                        const front = fields[0] || 'Imported';
                        const back = fields[1] || '';
                        const isCloze = model?.type === 1;
                        const type = isCloze ? 'Cloze' : 'Front-Back';
                        const card = this.newCard(deckCache[deckId].id, front, isCloze ? back || front : back, type);
                        card.tags = (tags || '').trim().split(' ').filter(Boolean).map(t => t.replace(/^\s*/, '').replace(/\s*$/, ''));
                        card.ankiGuid = guid;
                        card.ankiNoteType = model?.name || '';
                        card.ankiFields = JSON.stringify(fields);
                        card.clozeIndexes = isCloze ? 'auto' : '';
                        this.state.cards.push(card);
                        await Storage.put('cards', card);
                        this.queueOp({ type: 'card-upsert', payload: card });
                    }
                    this.renderAll();
                    toast('Imported .apkg');
                } catch (e) {
                    console.error(e);
                    toast('Import failed');
                }
            },
            async exportAnki() {
                const deck = this.state.selectedDeck || this.state.decks[0];
                if (!deck) return toast('No deck to export');
                const cards = this.cardsForDeck(deck.id);
                try {
                    const dbBytes = await this.buildApkgSql(deck, cards);
                    const zip = new JSZip();
                    zip.file('collection.anki2', dbBytes);
                    zip.file('media', JSON.stringify({}));
                    const blob = await zip.generateAsync({ type: 'blob' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${deck.name}.apkg`;
                    a.click();
                    URL.revokeObjectURL(url);
                    toast('Exported .apkg');
                } catch (e) {
                    toast('Export failed');
                    console.error(e);
                }
            },
            async buildApkgSql(deck, cards) {
                const SQL = await Storage.ensureSQL();
                const db = new SQL.Database();
                db.run(`CREATE TABLE col (id integer primary key, crt integer, mod integer, scm integer, ver integer, dty integer, usn integer, ls integer, conf text, models text, decks text, dconf text, tags text);`);
                db.run(`CREATE TABLE notes (id integer primary key, guid text, mid integer, mod integer, usn integer, tags text, flds text, sfld integer, csum integer, flags integer, data text);`);
                db.run(`CREATE TABLE cards (id integer primary key, nid integer, did integer, ord integer, mod integer, usn integer, type integer, queue integer, due integer, ivl integer, factor integer, reps integer, lapses integer, left integer, odue integer, odid integer, flags integer, data text);`);
                db.run(`CREATE TABLE revlog (id integer primary key, cid integer, usn integer, ease integer, ivl integer, lastIvl integer, factor integer, time integer, type integer);`);
                db.run(`CREATE TABLE graves (id integer primary key, oid integer, type integer, usn integer);`);

                const now = Math.floor(Date.now() / 1000);
                const dayStart = Math.floor(Date.now() / 1000 / 86400);
                const deckId = Math.abs(this.hash(deck.name));
                const modelBasicId = deckId + 1;
                const modelClozeId = deckId + 2;

                const conf = { nextPos: 1, estTimes: true, activeDecks: [deckId], sortType: "noteFld", sortBackwards: false, newSpread: 0, dueCounts: true, curDeck: deckId, timeLim: 0 };
                const models = {};
                models[modelBasicId] = {
                    id: modelBasicId,
                    name: "Basic",
                    type: 0,
                    mod: now,
                    usn: 0,
                    sortf: 0,
                    did: deckId,
                    latexPre: "\\documentclass{article}\\begin{document}",
                    latexPost: "\\end{document}",
                    flds: [
                        { name: "Front", ord: 0, sticky: false, rtl: false, font: "Arial", size: 20, media: [] },
                        { name: "Back", ord: 1, sticky: false, rtl: false, font: "Arial", size: 20, media: [] }
                    ],
                    tmpls: [
                        { name: "Card 1", ord: 0, qfmt: "{{Front}}", afmt: "{{FrontSide}}<hr id=answer>{{Back}}", did: null, bqfmt: "", bafmt: "" }
                    ],
                    css: ".card { font-family: Arial; font-size: 20px; }"
                };
                models[modelClozeId] = {
                    id: modelClozeId,
                    name: "Cloze",
                    type: 1,
                    mod: now,
                    usn: 0,
                    sortf: 0,
                    did: deckId,
                    flds: [
                        { name: "Text", ord: 0, sticky: false, rtl: false, font: "Arial", size: 20, media: [] },
                        { name: "Back Extra", ord: 1, sticky: false, rtl: false, font: "Arial", size: 20, media: [] }
                    ],
                    tmpls: [{ name: "Cloze", ord: 0, qfmt: "{{cloze:Text}}", afmt: "{{cloze:Text}}<br>{{Back Extra}}", did: null }],
                    css: ".card { font-family: Arial; font-size: 20px; }"
                };

                const decks = {};
                decks[deckId] = { id: deckId, name: deck.name, mod: now, usn: 0, desc: "", dyn: 0, extendNew: 0, extendRev: 0, conf: 1, collapsed: false, browserCollapsed: false, newToday: [dayStart, 0], revToday: [dayStart, 0], lrnToday: [dayStart, 0], timeToday: [dayStart, 0] };
                const dconf = { 1: { id: 1, name: "Default", new: { perDay: 20 }, rev: { perDay: 200 }, lapse: { delays: [10], mult: 0 }, dyn: false, maxTaken: 60, timer: 0 } };
                const tags = {};
                const colRow = db.prepare("INSERT INTO col VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)");
                colRow.run([1, dayStart, now, now, 11, 0, 0, 0, JSON.stringify(conf), JSON.stringify(models), JSON.stringify(decks), JSON.stringify(dconf), JSON.stringify(tags)]);

                let nidCounter = now * 1000;
                let cidCounter = now * 1000 + 500;
                const noteStmt = db.prepare("INSERT INTO notes VALUES (?,?,?,?,?,?,?,?,?,?,?)");
                const cardStmt = db.prepare("INSERT INTO cards VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
                cards.forEach((card, idx) => {
                    const isCloze = (card.type || '').toLowerCase() === 'cloze';
                    const mid = isCloze ? modelClozeId : modelBasicId;
                    const nid = ++nidCounter;
                    const cid = ++cidCounter;
                    const fields = isCloze ? [card.name, card.back] : [card.name, card.back];
                    const flds = fields.join('\u001f');
                    const tagStr = card.tags.length ? card.tags.map(t => t.trim()).join(' ') + ' ' : '';
                    const sfld = fields[0];
                    const csum = Math.abs(this.hash(flds)) >>> 0;
                    noteStmt.run([nid, card.ankiGuid || crypto.randomUUID(), mid, now, 0, tagStr, flds, sfld, csum, 0, ""]);

                    const ivl = card.fsrs?.stability ? Math.max(1, Math.round(card.fsrs.stability)) : 1;
                    const due = dayStart + idx;
                    const factor = 2500;
                    cardStmt.run([cid, nid, deckId, 0, now, 0, 0, 2, due, ivl, factor, 0, 0, 0, 0, 0, 0, ""]);
                });

                return new Uint8Array(db.export());
            },
            hash(str) {
                let h = 0;
                for (let i = 0; i < str.length; i++) {
                    h = Math.imul(31, h) + str.charCodeAt(i) | 0;
                }
                return h;
            },
            updateCounts() {
                el('#deckCount').textContent = String(this.state.decks.length);
                el('#cardCount').textContent = String(this.state.cards.length);
                el('#queueCount').textContent = String(this.state.queue.length);
                el('#lastSync').textContent = this.state.lastSync ? new Date(this.state.lastSync).toLocaleString() : '‚Äî';
            },
            updateResetState() {
                const btn = el('#resetApp');
                const hasData = this.state.decks.length || this.state.cards.length || this.state.queue.length || this.state.lastSync;
                btn.disabled = !hasData;
                btn.classList.toggle('opacity-60', !hasData);
                btn.classList.toggle('cursor-not-allowed', !hasData);
            },
            openSettings() {
                const s = this.state.settings;
                el('#settingWorkerUrl').value = s.workerUrl;
                el('#settingProxyToken').value = s.proxyToken;
                el('#settingAuthToken').value = s.authToken.startsWith('secret_') ? s.authToken : s.authToken;
                el('#settingsModal').classList.remove('hidden');
                el('#settingsModal').classList.add('flex');
                this.renderStatus();
                this.updateSettingsButtons();
            },
            closeSettings() {
                el('#settingsModal').classList.add('hidden');
                el('#settingsModal').classList.remove('flex');
            },
            saveSettings() {
                this.state.settings.workerUrl = el('#settingWorkerUrl').value.trim();
                this.state.settings.proxyToken = el('#settingProxyToken').value.trim();
                const authVal = el('#settingAuthToken').value.trim();
                if (authVal) this.state.settings.authToken = authVal;
                const provider = el('#aiProvider').value;
                const model = el('#aiModel').value.trim();
                const key = el('#aiKey').value.trim();
                this.state.settings.aiProvider = provider;
                this.state.settings.aiModel = model;
                if (key) this.state.settings.aiKey = key;
                Storage.setSettings(this.state.settings);
                this.renderStatus();
                this.applyTheme();
                this.applyFontMode();
                this.renderGate();
                this.closeSettings();
                this.renderConnection();
                toast('Settings saved');
            },
            async verifyWorker() {
                const workerUrl = el('#settingWorkerUrl').value.trim();
                const proxyToken = el('#settingProxyToken').value.trim();
                if (!workerUrl) return toast('Add worker URL');
                try {
                    const url = new URL(workerUrl.replace(/\/$/, ''));
                    url.searchParams.append('url', 'https://api.notion.com/v1/users/me');
                    if (proxyToken) url.searchParams.append('token', proxyToken);
                    const res = await fetch(url.toString());
                    if (res.ok || res.status === 401) {
                        toast('Worker reachable');
                        // Persist the worker details immediately so downstream calls use the latest values
                        this.state.settings.workerUrl = workerUrl;
                        this.state.settings.proxyToken = proxyToken;
                        this.state.workerVerified = true;
                        this.state.settings.workerVerified = true;
                        Storage.setSettings(this.state.settings);
                        this.renderStatus();
                        this.renderGate();
                        if (this.pendingAuthVerify && this.state.settings.authToken) {
                            await this.verifyAuth();
                            this.pendingAuthVerify = false;
                        }
                        if (this.state.workerVerified && this.state.authVerified && this.state.autoScanPending) {
                            await this.scanSources();
                            this.state.autoScanPending = false;
                            this.openSettings();
                        }
                    } else throw new Error(res.status);
                } catch (e) {
                    toast('Worker check failed');
                    this.state.workerVerified = false;
                    this.state.settings.workerVerified = false;
                    Storage.setSettings(this.state.settings);
                    this.renderStatus();
                }
            },
            async verifyAuth() {
                if (!this.state.workerVerified) { this.updateSettingsButtons(); return toast('Verify worker first'); }
                const workerUrl = (el('#settingWorkerUrl').value.trim()) || this.state.settings.workerUrl;
                const proxyToken = (el('#settingProxyToken').value.trim()) || this.state.settings.proxyToken;
                const authVal = (el('#settingAuthToken').value.trim()) || this.state.settings.authToken;
                if (!workerUrl || !authVal) return toast('Add worker URL and Notion token');
                try {
                    // Verify using the freshest inputs instead of stale stored settings
                    const override = { workerUrl, proxyToken, authToken: authVal };
                    await API.request('GET', '/users/me', null, override);
                    toast('Notion token valid');
                    this.state.authVerified = true;
                    this.state.settings.authVerified = true;
                    this.state.settings.workerUrl = workerUrl;
                    this.state.settings.proxyToken = proxyToken;
                    this.state.settings.authToken = authVal;
                    this.state.settings.workerVerified = true;
                    Storage.setSettings(this.state.settings);
                    this.renderStatus();
                    this.renderGate();
                    // Always auto-scan once auth is valid (works for both OAuth and manual secret token)
                    this.state.autoScanPending = true;
                    if (this.state.workerVerified && this.state.authVerified) {
                        await this.scanSources();
                        this.state.autoScanPending = false;
                        this.openSettings();
                    }
                } catch (e) {
                    toast(e.message);
                    this.state.authVerified = false;
                    this.state.settings.authVerified = false;
                    Storage.setSettings(this.state.settings);
                    this.renderStatus();
                }
            },
            startOAuth() {
                if (!this.state.workerVerified) return toast('Verify worker first');
                this.saveSettings();
                const here = encodeURIComponent(window.location.href);
                window.location.href = `https://notion-oauth-handler.mimansa-jaiswal.workers.dev/auth/login?from=${here}`;
            },
            async scanSources() {
                if (!this.state.workerVerified || !this.state.authVerified) return toast('Verify worker and auth first');
                try {
                    const dbs = await API.listDatabases();
                    const deckOptions = [];
                    const cardOptions = [];
                    for (const d of dbs) {
                        const id = d.id;
                        const title = d.title?.[0]?.plain_text || id;
                        if (await this.validateDb(id, 'deck')) deckOptions.push({ id, title });
                        if (await this.validateDb(id, 'card')) cardOptions.push({ id, title });
                    }
                    this.state.sourcesCache = { deckOptions, cardOptions };
                    el('#deckSourceSelect').innerHTML = `<option value="">Select deck source</option>` + deckOptions.map(o => `<option value="${o.id}">${o.title}</option>`).join('');
                    el('#cardSourceSelect').innerHTML = `<option value="">Select card source</option>` + cardOptions.map(o => `<option value="${o.id}">${o.title}</option>`).join('');
                    if (deckOptions.length === 1) this.state.settings.deckSource = deckOptions[0].id;
                    if (cardOptions.length === 1) this.state.settings.cardSource = cardOptions[0].id;
                    Storage.setSettings(this.state.settings);
                    if (this.state.settings.deckSource) el('#deckSourceSelect').value = this.state.settings.deckSource;
                    if (this.state.settings.cardSource) el('#cardSourceSelect').value = this.state.settings.cardSource;
                    this.state.sourcesVerified = !!(this.state.settings.deckSource && this.state.settings.cardSource);
                    this.renderStatus();
                    this.renderGate();
                    toast('Sources loaded');
                } catch (e) {
                    toast(e.message);
                }
            },
            populateSourceSelects() {
                const deckOptions = this.state.sourcesCache.deckOptions || [];
                const cardOptions = this.state.sourcesCache.cardOptions || [];
                el('#deckSourceSelect').innerHTML = `<option value="">Select deck source</option>` + deckOptions.map(o => `<option value="${o.id}">${o.title}</option>`).join('');
                el('#cardSourceSelect').innerHTML = `<option value="">Select card source</option>` + cardOptions.map(o => `<option value="${o.id}">${o.title}</option>`).join('');
                if (this.state.settings.deckSource) el('#deckSourceSelect').value = this.state.settings.deckSource;
                if (this.state.settings.cardSource) el('#cardSourceSelect').value = this.state.settings.cardSource;
                el('#deckSourceSelect').onchange = (e) => { this.state.settings.deckSource = e.target.value; Storage.setSettings(this.state.settings); this.state.sourcesVerified = !!(this.state.settings.deckSource && this.state.settings.cardSource); this.renderStatus(); this.renderGate(); };
                el('#cardSourceSelect').onchange = (e) => { this.state.settings.cardSource = e.target.value; Storage.setSettings(this.state.settings); this.state.sourcesVerified = !!(this.state.settings.deckSource && this.state.settings.cardSource); this.renderStatus(); this.renderGate(); };
            },
            openModal(id) {
                const m = el('#' + id);
                m.classList.remove('hidden');
                m.classList.add('flex');
            },
            closeModal(id) {
                const m = el('#' + id);
                m.classList.add('hidden');
                m.classList.remove('flex');
            },
            copyWorkerCode() {
                const code = el('#workerCodeBlock').innerText;
                navigator.clipboard.writeText(code);
                toast('Worker code copied');
            },
            async resetApp() {
                if (!confirm('Clear local decks/cards/settings and restart?')) return;
                await Storage.wipeStore('decks');
                await Storage.wipeStore('cards');
                await Storage.wipeStore('meta');
                localStorage.removeItem(Storage.settingsKey);
                indexedDB.deleteDatabase('GhostInkDB');
                location.reload();
            },
            renderStatus() {
                const hasWorkerUrl = !!this.state.settings.workerUrl;
                const workerOk = hasWorkerUrl && this.state.workerVerified;
                const hasToken = !!this.state.settings.authToken;
                const authOk = workerOk && this.state.authVerified && hasToken;
                const hasSources = !!(this.state.settings.deckSource && this.state.settings.cardSource && this.state.sourcesVerified);

                // Keep flags consistent so other UI logic (buttons/locks) stay in sync with real readiness
                this.state.workerVerified = workerOk;
                this.state.authVerified = authOk;
                this.state.settings.workerVerified = workerOk;
                this.state.settings.authVerified = authOk;

                el('#statusWorker').textContent = `Worker: ${workerOk ? 'verified' : 'missing'}`;
                el('#statusAuth').textContent = `Auth: ${authOk ? 'verified' : workerOk ? 'missing' : 'blocked (verify worker)'}`;
                el('#statusSources').textContent = `Sources: ${hasSources ? 'verified' : 'missing'}`;
                this.updateSettingsButtons();
                this.renderConnection();
            },
            async validateDb(dbId, type) {
                try {
                    const meta = await API.getDatabase(dbId);
                    const props = meta?.properties || {};
                    const has = (name, kind) => props[name]?.type === kind;
                    if (type === 'deck') {
                        return has('Deck Name', 'title')
                            && has('Deck Color', 'rich_text')
                            && has('Default SRS Algorithm', 'select')
                            && has('Daily Review Limit', 'number')
                            && has('New Card Limit', 'number')
                            && has('Reverse Mode Enabled', 'checkbox')
                            && has('Created In-App', 'checkbox');
                    }
                    if (type === 'card') {
                        return has('Name', 'title')
                            && has('Back', 'rich_text')
                            && has('Card Type', 'select')
                            && has('Deck', 'relation')
                            && has('Tags', 'multi_select')
                            && has('Suspended', 'checkbox')
                            && has('Leech', 'checkbox')
                            && has('Difficulty', 'number')
                            && has('Stability', 'number')
                            && has('Retrievability', 'number')
                            && has('Last Rating', 'select')
                            && has('Last Review', 'date')
                            && has('Due Date', 'date')
                            && has('Interval / Box Level', 'number')
                            && has('Ease Factor', 'number')
                            && has('Updated In-App', 'checkbox');
                    }
                } catch (e) {
                    console.error('validateDb failed', e);
                }
                return false;
            },
            updateSettingsButtons() {
                const blockScanSave = !(this.state.workerVerified && this.state.authVerified);
                ['scanSources', 'saveSettings'].forEach(id => {
                    const btn = el('#' + id);
                    if (!btn) return;
                    btn.disabled = blockScanSave;
                    btn.classList.toggle('opacity-60', blockScanSave);
                    btn.classList.toggle('cursor-not-allowed', blockScanSave);
                });
                const oa = el('#oauthBtn');
                const va = el('#verifyAuth');
                const tokenInput = el('#settingAuthToken');
                const blockAuth = !this.state.workerVerified;
                if (oa) { oa.disabled = blockAuth; oa.classList.toggle('opacity-60', blockAuth); oa.classList.toggle('cursor-not-allowed', blockAuth); }
                if (va) { va.disabled = blockAuth; va.classList.toggle('opacity-60', blockAuth); va.classList.toggle('cursor-not-allowed', blockAuth); }
                if (tokenInput) tokenInput.disabled = blockAuth;
            },
            async autoVerifyWorker() {
                const url = this.state.settings.workerUrl;
                if (!url) return;
                try { await this.verifyWorker(); } catch (_) { /* ignore */ }
                if (this.pendingAuthVerify && this.state.workerVerified) {
                    await this.verifyAuth();
                    this.pendingAuthVerify = false;
                }
                if (this.state.workerVerified && this.state.authVerified && this.state.autoScanPending) {
                    await this.scanSources();
                    this.state.autoScanPending = false;
                    this.openSettings();
                }
            },
            applyTheme() {
                const mode = this.state.settings.themeMode || 'system';
                const systemPrefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                const theme = mode === 'system' ? (systemPrefersDark ? 'dark' : 'light') : mode;
                document.body.setAttribute('data-theme', theme);
                document.querySelectorAll('.theme-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.theme === mode);
                });
            },
            applyFontMode() {
                const mode = this.state.settings.fontMode || 'serif';
                document.body.setAttribute('data-font', mode === 'mono' ? 'mono' : 'serif');
                document.querySelectorAll('.font-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.font === mode);
                });
            },
            isReady() {
                const hasWorker = !!this.state.settings.workerUrl;
                const hasAuth = !!this.state.settings.authToken;
                const hasSources = !!(this.state.settings.deckSource && this.state.settings.cardSource);
                return hasWorker && this.state.workerVerified && hasAuth && this.state.authVerified && hasSources && this.state.sourcesVerified;
            },
            loadAISettings() {
                const s = Storage.getSettings();
                if (s.aiProvider) el('#aiProvider').value = s.aiProvider;
                if (s.aiModel) el('#aiModel').value = s.aiModel;
                if (s.aiKey) el('#aiKey').value = s.aiKey;
                this.state.aiProvider = s.aiProvider || '';
                this.state.aiModel = s.aiModel || '';
                this.state.aiKey = s.aiKey || '';
                if (s.themeMode) this.state.settings.themeMode = s.themeMode;
                if (s.fontMode) this.state.settings.fontMode = s.fontMode;
                this.applyTheme();
                this.applyFontMode();
            },
            async submitToAI() {
                if (!this.state.selectedCard) return;
                const ans = el('#aiAnswer').value.trim();
                if (!ans) { toast('Enter or record an answer first'); return; }
                if (!this.state.settings.aiKey) { toast('Add an AI key in Settings'); return; }
                const deck = this.deckById(this.state.selectedCard.deckId);
                const promptTemplate = deck?.aiPrompt || 'You are a strict flashcard grader. Question: {{question}}. Correct answer: {{answer}}. Learner answer: {{user}}. Judge correctness (short) and give brief feedback.';
                const prompt = promptTemplate
                    .replace('{{question}}', this.state.selectedCard.name)
                    .replace('{{answer}}', this.state.selectedCard.back)
                    .replace('{{user}}', ans);
                const provider = this.state.settings.aiProvider || 'openai';
                const model = this.state.settings.aiModel || (provider === 'anthropic' ? 'claude-3-haiku-20240307' : provider === 'gemini' ? 'gemini-1.5-flash-latest' : 'gpt-4o-mini');
                try {
                    el('#aiFeedback').innerHTML = 'Thinking...';
                    const res = await this.callAI(provider, model, prompt, this.state.settings.aiKey);
                    el('#aiFeedback').innerHTML = marked.parse(res);
                    this.reveal();
                } catch (e) {
                    el('#aiFeedback').innerHTML = '';
                    toast('AI error: ' + e.message);
                }
            },
            async callAI(provider, model, prompt, key) {
                if (provider === 'anthropic') {
                    const resp = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json',
                            'x-api-key': key,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify({ model, max_tokens: 256, messages: [{ role: 'user', content: prompt }] })
                    });
                    if (!resp.ok) throw new Error('Claude returned ' + resp.status);
                    const json = await resp.json();
                    return json.content?.[0]?.text || 'No response';
                }
                if (provider === 'gemini') {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${encodeURIComponent(key)}`;
                    const resp = await fetch(url, {
                        method: 'POST',
                        headers: { 'content-type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });
                    if (!resp.ok) throw new Error('Gemini returned ' + resp.status);
                    const json = await resp.json();
                    return json.candidates?.[0]?.content?.parts?.map(p => p.text).join('\n') || 'No response';
                }
                const resp = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'content-type': 'application/json', 'authorization': 'Bearer ' + key },
                    body: JSON.stringify({ model, messages: [{ role: 'user', content: prompt }], max_tokens: 256 })
                });
                if (!resp.ok) throw new Error('OpenAI returned ' + resp.status);
                const json = await resp.json();
                return json.choices?.[0]?.message?.content || 'No response';
            },
            attachSwipe() {
                const area = el('#cardFront');
                if (!area || typeof Hammer === 'undefined') return;
                area.style.touchAction = 'none';
                const mc = new Hammer.Manager(area);
                mc.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 10 }));
                mc.on('panmove', (e) => this.updateSwipeHints(e.deltaX, e.deltaY));
                mc.on('panend pancancel', (e) => {
                    const dx = e.deltaX;
                    const dy = e.deltaY;
                    this.resetSwipeHints();
                    const threshold = 50;
                    if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) return;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (dx > 0) this.rate('good'); else this.rate('hard');
                    } else {
                        if (dy < 0) this.rate('easy'); else this.rate('again');
                    }
                });
            },
            updateSwipeHints(dx, dy) {
                const absX = Math.abs(dx), absY = Math.abs(dy);
                this.resetSwipeHints();
                if (absX < 15 && absY < 15) return;
                if (absX > absY) {
                    if (dx > 0) el('#hintRight')?.classList.add('hint-active');
                    else el('#hintLeft')?.classList.add('hint-active');
                } else {
                    if (dy < 0) el('#hintUp')?.classList.add('hint-active');
                    else el('#hintDown')?.classList.add('hint-active');
                }
            },
            resetSwipeHints() {
                ['hintUp', 'hintDown', 'hintLeft', 'hintRight'].forEach(id => el('#' + id)?.classList.remove('hint-active'));
            },
            renderMath(container) {
                if (!container || typeof katex === 'undefined') return;
                container.querySelectorAll('.notion-equation').forEach(span => {
                    try {
                        const expr = span.textContent || '';
                        span.innerHTML = katex.renderToString(expr, { throwOnError: false });
                    } catch (e) { console.error(e); }
                });
            },
            recordAnswer() {
                if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
                    toast('Speech recognition not supported');
                    return;
                }
                const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
                const rec = new SR();
                rec.lang = 'en-US';
                rec.interimResults = false;
                rec.maxAlternatives = 1;
                el('#aiFeedback').innerHTML = 'Listening...';
                rec.onresult = (e) => {
                    const text = e.results[0][0].transcript;
                    el('#aiAnswer').value = text;
                    el('#aiFeedback').innerHTML = 'Captured. Now send.';
                };
                rec.onerror = () => { el('#aiFeedback').innerHTML = ''; toast('Mic error'); };
                rec.onend = () => { if (el('#aiFeedback').innerHTML === 'Listening...') el('#aiFeedback').innerHTML = ''; };
                rec.start();
            },
            async performDelete() {
                this.closeModal('confirmModal');
                const target = this.pendingDelete;
                if (!target) return;
                if (target.type === 'deck') {
                    await Storage.delete('decks', target.id);
                    this.state.decks = this.state.decks.filter(d => d.id !== target.id);
                    const cards = this.cardsForDeck(target.id);
                    for (const c of cards) await Storage.delete('cards', c.id);
                    this.state.cards = this.state.cards.filter(c => c.deckId !== target.id);
                    this.queueOp({ type: 'deck-delete', payload: { id: target.id, notionId: target.notionId } });
                    this.renderAll();
                    toast('Deck deleted');
                }
                if (target.type === 'card') {
                    await Storage.delete('cards', target.id);
                    this.state.cards = this.state.cards.filter(c => c.id !== target.id);
                    this.queueOp({ type: 'card-delete', payload: { id: target.id, notionId: target.notionId } });
                    this.renderCards();
                    toast('Card deleted');
                }
                this.pendingDelete = null;
            }
        };

        window.addEventListener('load', () => App.init());
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(() => { });
            });
        }
    </script>
</body>

</html>
