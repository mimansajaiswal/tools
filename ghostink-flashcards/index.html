<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GhostInk Flashcards</title>
    <meta name="theme-color" content="#917FB3">
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">

    <!-- Preconnect hints for CDN domains -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>

    <!-- Tailwind (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Hammer.js for touch gestures -->
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>

    <!-- Markdown renderer -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.2/sql-wasm.js"></script>
    <!-- KaTeX for equations -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>

    <!-- Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Fraunces:wght@600;700&family=Sora:wght@400;500;600&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        oatmeal: '#F3F0E6',
                        'oatmeal-dark': '#E6E2D6',
                        'earth-metal': '#4A4A4A',
                        charcoal: '#1F1F1F',
                        'white-linen': '#FAF9F6',
                        'dull-purple': '#917FB3',
                        'muted-pink': '#D8A7B1',
                        'muted-pink-dim': '#C696A0'
                    },
                    fontFamily: {
                        display: ['var(--font-display, "Fraunces")', 'serif'],
                        sans: ['var(--font-sans, "Sora")', 'system-ui', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        :root {
            --oatmeal: #F3F0E6;
            --oatmeal-dark: #E6E2D6;
            --earth-metal: #4A4A4A;
            --charcoal: #1F1F1F;
            --linen: #FAF9F6;
            --dull-purple: #917FB3;
            --muted-pink: #D8A7B1;
            --card-bg: rgba(250, 249, 246, 0.9);
            --card-border: rgba(26, 26, 26, 0.06);
            --text-main: #1F1F1F;
            --text-sub: rgba(31, 31, 31, 0.7);
            --surface: #faf9f6;
            --surface-strong: #f3f0e6;
            --border-weak: rgba(26, 26, 26, 0.06);
            --bg: #f6f3eb;
        }

        body {
            background: var(--bg);
            color: var(--text-main);
            font-family: var(--font-sans, "Manrope"), system-ui, sans-serif;
        }

        body[data-font="mono"] {
            --font-display: "JetBrains Mono";
            --font-sans: "JetBrains Mono";
            font-family: "JetBrains Mono", monospace;
        }

        body:not([data-font="mono"]) {
            --font-display: "Fraunces";
            --font-sans: "Sora";
        }

        body[data-theme="dark"] {
            --oatmeal: #1f1c2b;
            --oatmeal-dark: #252335;
            --linen: #1b1917;
            --card-bg: #201d1b;
            --card-border: rgba(255, 255, 255, 0.08);
            --text-main: #f4f1ff;
            --text-sub: rgba(244, 241, 255, 0.7);
            --surface: #1f1c1a;
            --surface-strong: #1b1917;
            --border-weak: rgba(255, 255, 255, 0.08);
            --bg: #1b1917;
        }

        .card {
            border: 1px solid var(--card-border);
            background: var(--card-bg);
            backdrop-filter: blur(12px);
        }

        .dash {
            background: repeating-linear-gradient(-45deg,
                    rgba(145, 127, 179, 0.08),
                    rgba(145, 127, 179, 0.08) 12px,
                    transparent 12px,
                    transparent 24px);
        }

        .pill {
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .glass {
            background: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .shadow-soft {
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.08);
        }

        body[data-theme="dark"] .shadow-soft {
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
        }

        /* Custom tooltip that appears below element */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 6px;
            padding: 4px 8px;
            background: var(--text-main, #1b1917);
            color: var(--bg, #faf9f6);
            font-size: 11px;
            white-space: nowrap;
            border-radius: 6px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s;
            z-index: 100;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
        }

        /* Notion color helpers */
        .notion-color-default {
            color: inherit;
        }

        .notion-color-gray {
            color: #9b9a97;
        }

        .notion-color-brown {
            color: #64473a;
        }

        .notion-color-orange {
            color: #d9730d;
        }

        .notion-color-yellow {
            color: #e0a30b;
        }

        .notion-color-green {
            color: #0f7b6c;
        }

        .notion-color-blue {
            color: #0b6ae6;
        }

        .notion-color-purple {
            color: #6940a5;
        }

        .notion-color-pink {
            color: #ad1a72;
        }

        .notion-color-red {
            color: #e03e3e;
        }

        .notion-color-gray-background {
            background: #ebeced;
        }

        .notion-color-brown-background {
            background: #ede4de;
        }

        .notion-color-orange-background {
            background: #faebdd;
        }

        .notion-color-yellow-background {
            background: #fbf3db;
        }

        .notion-color-green-background {
            background: #ddebea;
        }

        .notion-color-blue-background {
            background: #e7f3f8;
        }

        .notion-color-purple-background {
            background: #f1ecf9;
        }

        .notion-color-pink-background {
            background: #f6e0e9;
        }

        .notion-color-red-background {
            background: #fdebec;
        }

        body[data-theme="dark"] .notion-color-gray {
            color: #868686;
        }

        body[data-theme="dark"] .notion-color-brown {
            color: #b0937c;
        }

        body[data-theme="dark"] .notion-color-orange {
            color: #ffb45b;
        }

        body[data-theme="dark"] .notion-color-yellow {
            color: #f7cd46;
        }

        body[data-theme="dark"] .notion-color-green {
            color: #5bc0a7;
        }

        body[data-theme="dark"] .notion-color-blue {
            color: #6ab7ff;
        }

        body[data-theme="dark"] .notion-color-purple {
            color: #b18cff;
        }

        body[data-theme="dark"] .notion-color-pink {
            color: #ff8fb1;
        }

        body[data-theme="dark"] .notion-color-red {
            color: #ff7b73;
        }

        body[data-theme="dark"] .notion-color-gray-background {
            background: #2f3134;
        }

        body[data-theme="dark"] .notion-color-brown-background {
            background: #352922;
        }

        body[data-theme="dark"] .notion-color-orange-background {
            background: #422a15;
        }

        body[data-theme="dark"] .notion-color-yellow-background {
            background: #443716;
        }

        body[data-theme="dark"] .notion-color-green-background {
            background: #183a33;
        }

        body[data-theme="dark"] .notion-color-blue-background {
            background: #152f4d;
        }

        body[data-theme="dark"] .notion-color-purple-background {
            background: #2b2340;
        }

        body[data-theme="dark"] .notion-color-pink-background {
            background: #3b2431;
        }

        body[data-theme="dark"] .notion-color-red-background {
            background: #442022;
        }

        .cloze-blank {
            padding: 2px 6px;
            border-bottom: 1px dashed #917FB3;
            background: linear-gradient(90deg, rgba(145, 127, 179, 0.14), rgba(216, 167, 177, 0.14));
            border-radius: 6px;
        }

        .cloze-blank .cloze-answer {
            display: none;
        }

        .cloze-blank .cloze-placeholder {
            color: #917FB3;
            font-style: italic;
        }

        .cloze-blank.revealed .cloze-answer {
            display: inline;
            color: var(--dull-purple);
            font-weight: 600;
        }

        .cloze-blank.revealed .cloze-placeholder {
            display: none;
        }

        /* Link styling in card content and notes */
        #cardFront a,
        #cardBack a,
        #notesPreview a {
            color: var(--dull-purple);
            text-decoration: underline;
        }

        #cardFront a:hover,
        #cardBack a:hover,
        #notesPreview a:hover {
            opacity: 0.8;
        }

        .scroll-minimal::-webkit-scrollbar {
            width: 8px;
        }

        .scroll-minimal::-webkit-scrollbar-thumb {
            background: rgba(73, 73, 73, 0.25);
            border-radius: 10px;
        }

        /* Mobile FAB cluster - Joystick and action bar */
        @media (max-width: 640px) {
            .mobile-fab-cluster {
                position: fixed;
                bottom: 0;
                left: 12px;
                display: flex;
                flex-direction: row;
                align-items: flex-end;
                gap: 8px;
                padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
                pointer-events: none;
                z-index: 50;
            }

            .mobile-fab-cluster>* {
                pointer-events: auto;
            }

            /* Joystick wrapper with action buttons on right */
            .joystick-wrapper {
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 6px;
            }

            /* Side action buttons (next to joystick) */
            .joystick-side-actions {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .fab-btn {
                width: 36px;
                height: 36px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                border: none;
                cursor: pointer;
                transition: all 0.15s ease;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
            }

            .fab-btn:active {
                transform: scale(0.92);
            }

            .fab-btn-secondary {
                background: var(--surface-strong);
                border: 1px solid var(--card-border);
                color: var(--text-sub);
            }

            .fab-btn-secondary svg {
                width: 16px;
                height: 16px;
            }

            .fab-btn-primary {
                background: #494949;
                color: white;
                width: 40px;
                height: 40px;
            }

            .fab-btn-primary svg {
                width: 18px;
                height: 18px;
            }

            .fab-btn.hidden {
                display: none;
            }

            /* Joystick - circular arcade style */
            .joystick-container {
                position: relative;
                width: 96px;
                height: 96px;
            }

            .joystick {
                background: linear-gradient(var(--surface-strong), var(--surface));
                box-shadow: inset 0 0 3px rgba(0, 0, 0, .5),
                    inset 1px 2px 5px rgba(255, 255, 255, .15),
                    inset 2px 3px 12px rgba(0, 0, 0, .4),
                    0 3px 10px rgba(0, 0, 0, 0.2);
                border-radius: 50%;
                border: 1px solid var(--card-border);
                display: inline-block;
                height: 96px;
                position: relative;
                width: 96px;
                touch-action: none;
                user-select: none;
                -webkit-user-select: none;
            }

            /* Direction labels with filled icons */
            .joystick-label {
                position: absolute;
                font-size: 6px;
                font-weight: 700;
                text-transform: uppercase;
                letter-spacing: 0.3px;
                opacity: 0.5;
                transition: all 0.12s ease;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0px;
                pointer-events: none;
            }

            .joystick-label svg {
                width: 12px;
                height: 12px;
                fill: none;
                stroke: currentColor;
                stroke-width: 2.5;
            }

            .joystick-label.active {
                opacity: 1;
            }

            .joystick-label-up {
                top: 8px;
                left: 50%;
                transform: translateX(-50%);
                color: #16a34a;
            }

            .joystick-label-down {
                bottom: 8px;
                left: 50%;
                transform: translateX(-50%);
                color: #dc2626;
            }

            .joystick-label-left {
                left: 8px;
                top: 50%;
                transform: translateY(-50%);
                color: #ea580c;
            }

            .joystick-label-right {
                right: 8px;
                top: 50%;
                transform: translateY(-50%);
                color: #2563eb;
            }

            /* The knob (ball) */
            .joystick-knob {
                position: absolute;
                width: 28px;
                height: 28px;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                border-radius: 50%;
                background: radial-gradient(ellipse at 11px 9px, rgba(255, 255, 255, 0.9) 5%, #888 10%, #666 100%);
                box-shadow: inset 2px 2px 10px rgba(255, 255, 255, .4),
                    inset -2px -3px 10px rgba(0, 0, 0, .3),
                    0 3px 8px rgba(0, 0, 0, 0.4);
                transition: transform 0.08s ease-out, background 0.25s ease-in-out;
                z-index: 2;
            }

            /* Color variants based on direction */
            /* Clockwise from bottom: Again (down/red) â†’ Hard (left/orange) â†’ Good (up/green) â†’ Easy (right/blue) */
            .joystick.up .joystick-knob {
                background: radial-gradient(ellipse at 11px 9px, rgba(255, 255, 255, 0.9) 5%, #4ade80 10%, #16a34a 100%);
            }

            .joystick.down .joystick-knob {
                background: radial-gradient(ellipse at 11px 9px, rgba(255, 255, 255, 0.9) 5%, #f87171 10%, #dc2626 100%);
            }

            .joystick.left .joystick-knob {
                background: radial-gradient(ellipse at 11px 9px, rgba(255, 255, 255, 0.9) 5%, #fb923c 10%, #ea580c 100%);
            }

            .joystick.right .joystick-knob {
                background: radial-gradient(ellipse at 11px 9px, rgba(255, 255, 255, 0.9) 5%, #60a5fa 10%, #2563eb 100%);
            }

            /* Knob position based on direction */
            .joystick.up .joystick-knob {
                transform: translate(-50%, -50%) translateY(-18px);
            }

            .joystick.down .joystick-knob {
                transform: translate(-50%, -50%) translateY(18px);
            }

            .joystick.left .joystick-knob {
                transform: translate(-50%, -50%) translateX(-18px);
            }

            .joystick.right .joystick-knob {
                transform: translate(-50%, -50%) translateX(18px);
            }

            body[data-theme="dark"] .joystick-label-up {
                color: #4ade80;
            }

            body[data-theme="dark"] .joystick-label-down {
                color: #f87171;
            }

            body[data-theme="dark"] .joystick-label-left {
                color: #fb923c;
            }

            body[data-theme="dark"] .joystick-label-right {
                color: #60a5fa;
            }
        }

        /* Hide mobile FAB on larger screens */
        @media (min-width: 641px) {
            .mobile-fab-cluster {
                display: none !important;
            }
        }

        /* Card transition animation */
        #cardFront,
        #cardBack {
            transition: opacity 0.15s ease;
        }

        .card-transitioning {
            opacity: 0;
        }

        /* theme utility overrides so light/dark stay consistent */
        .bg-white-linen {
            background-color: var(--surface) !important;
        }

        .bg-oatmeal {
            background-color: var(--surface-strong) !important;
        }

        .bg-oatmeal\/60 {
            background-color: color-mix(in srgb, var(--surface-strong) 70%, transparent) !important;
        }

        .border-oatmeal-dark,
        .border-oatmeal-dark\/60,
        .border-oatmeal-dark\/70 {
            border-color: var(--card-border) !important;
        }

        .text-earth-metal,
        .text-earth-metal\/70,
        .text-earth-metal\/60 {
            color: var(--text-sub) !important;
        }

        .text-charcoal {
            color: var(--text-main) !important;
        }

        /* compact icon toggles */
        .pill-toggle {
            border: 1px solid var(--card-border);
            background: var(--surface);
        }

        .pill-toggle button {
            color: var(--text-sub);
        }

        .pill-toggle button.active {
            background: var(--dull-purple);
            color: #fff;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }

        .font-swatch-serif {
            font-family: 'Fraunces', serif !important;
            letter-spacing: 0.01em;
        }

        .font-swatch-mono {
            font-family: 'JetBrains Mono', monospace !important;
            letter-spacing: 0.01em;
        }

        /* Tab navigation */
        .tab-btn {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 0.75rem;
            transition: all 0.2s ease;
            color: var(--text-sub);
            background: transparent;
        }

        .tab-btn:hover {
            background: var(--surface-strong);
        }

        .tab-btn.active {
            background: var(--dull-purple);
            color: white;
        }

        .tab-content {
            display: block;
        }

        .tab-content.hidden {
            display: none;
        }

        /* Fix select dropdown positioning on mobile */
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%234A4A4A' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            padding-right: 2rem;
            position: relative;
            z-index: 1;
        }

        /* Mobile select touch optimization */
        @media (max-width: 640px) {
            select {
                font-size: 16px;
                /* Prevents iOS zoom on focus */
                min-height: 44px;
                /* Better touch target */
            }
        }
    </style>
</head>

<body class="text-earth-metal font-sans min-h-[100dvh]">
    <div class="min-h-[100dvh] flex flex-col">
        <header
            class="flex flex-wrap items-center justify-between gap-2 px-3 sm:px-5 md:px-10 pt-4 sm:pt-6 pb-3 sm:pb-4">
            <div class="flex items-center gap-2 sm:gap-3 min-w-0">
                <div
                    class="w-9 h-9 sm:w-12 sm:h-12 rounded-xl sm:rounded-2xl dash flex items-center justify-center shadow-soft shrink-0">
                    <i data-lucide="sparkles" class="w-5 h-5 sm:w-6 sm:h-6 text-dull-purple"></i>
                </div>
                <div class="min-w-0">
                    <h1 class="font-display text-lg sm:text-2xl text-charcoal tracking-tight truncate">GhostInk</h1>
                    <p class="text-xs sm:text-sm text-earth-metal/70 hidden sm:block">AI-enabled flashcards stored in
                        Notion</p>
                </div>
            </div>
            <div class="flex items-center gap-1 sm:gap-1.5 md:gap-2 shrink-0">
                <div id="connectionBadge"
                    class="px-2 py-1 rounded-full pill text-[10px] sm:text-xs bg-oatmeal border border-oatmeal-dark text-earth-metal hidden md:block">
                    Offline ready</div>
                <!-- Desktop-only options -->
                <div class="hidden sm:flex items-center gap-0.5 sm:gap-1 pill-toggle rounded-full px-1 sm:px-2 py-1">
                    <button class="p-1 rounded-full theme-btn" data-theme="light" data-tip="Light theme"
                        aria-label="Light theme"><i data-lucide="sun" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i></button>
                    <button class="p-1 rounded-full theme-btn" data-theme="dark" data-tip="Dark theme"
                        aria-label="Dark theme"><i data-lucide="moon" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i></button>
                    <button class="p-1 rounded-full theme-btn" data-theme="system" data-tip="System theme"
                        aria-label="System theme"><i data-lucide="laptop" class="w-4 h-4"></i></button>
                </div>
                <div class="hidden md:flex items-center gap-1 pill-toggle rounded-full px-2 py-1">
                    <button class="px-2 py-1 rounded-full font-btn text-xs" data-font="serif" data-tip="Serif font"
                        aria-label="Serif font">
                        <span class="font-swatch-serif inline-block">Aa</span>
                    </button>
                    <button class="px-2 py-1 rounded-full font-btn text-xs" data-font="mono" data-tip="Mono font"
                        aria-label="Monospace font">
                        <span class="font-swatch-mono inline-block">Aa</span>
                    </button>
                </div>
                <div class="hidden sm:flex items-center gap-0.5 sm:gap-1 pill-toggle rounded-full px-1 sm:px-2 py-1">
                    <button id="exportAnkiBtn" class="p-1 rounded-full" title="Export Anki" aria-label="Export to Anki">
                        <i data-lucide="download" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i>
                    </button>
                    <label class="p-1 rounded-full cursor-pointer" title="Import Anki" aria-label="Import from Anki">
                        <i data-lucide="upload-cloud" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i>
                        <input aria-label="Import .apkg" id="ankiImportInput" type="file" accept=".apkg,.json"
                            class="hidden">
                    </label>
                </div>
                <!-- Mobile more button -->
                <button id="mobileMoreBtn"
                    class="sm:hidden p-1.5 rounded-full bg-white-linen border border-oatmeal-dark" title="More options"
                    aria-label="More options">
                    <i data-lucide="more-horizontal" class="w-4 h-4"></i>
                </button>
                <button id="syncNowBtn"
                    class="p-1.5 sm:p-2 rounded-full bg-dull-purple text-white hover:bg-[#7d6aa1] transition-all"
                    data-tip="Sync now" title="Sync" aria-label="Sync with Notion">
                    <i data-lucide="refresh-ccw" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i>
                </button>
                <button id="openSettings"
                    class="p-1.5 sm:p-2 rounded-full bg-white-linen border border-oatmeal-dark hover:border-dull-purple transition-all"
                    data-tip="Settings" title="Settings" aria-label="Open settings">
                    <i data-lucide="settings" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i>
                </button>
            </div>
            <!-- Mobile expanded menu -->
            <div id="mobileMoreMenu"
                class="hidden w-full pt-2 pb-1 border-t border-[color:var(--card-border)] mt-2 flex-wrap gap-2 sm:hidden">
                <div class="flex items-center gap-1 pill-toggle rounded-full px-2 py-1">
                    <button class="p-1 rounded-full theme-btn" data-theme="light" aria-label="Light theme"><i
                            data-lucide="sun" class="w-4 h-4"></i></button>
                    <button class="p-1 rounded-full theme-btn" data-theme="dark" aria-label="Dark theme"><i
                            data-lucide="moon" class="w-4 h-4"></i></button>
                    <button class="p-1 rounded-full theme-btn" data-theme="system" aria-label="System theme"><i
                            data-lucide="laptop" class="w-4 h-4"></i></button>
                </div>
                <div class="flex items-center gap-1 pill-toggle rounded-full px-2 py-1">
                    <button class="px-2 py-1 rounded-full font-btn text-xs" data-font="serif"
                        aria-label="Serif font"><span class="font-swatch-serif">Aa</span></button>
                    <button class="px-2 py-1 rounded-full font-btn text-xs" data-font="mono"
                        aria-label="Monospace font"><span class="font-swatch-mono">Aa</span></button>
                </div>
                <div class="flex items-center gap-1 pill-toggle rounded-full px-2 py-1">
                    <button id="exportAnkiBtnMobile" class="p-1 rounded-full" title="Export Anki"
                        aria-label="Export to Anki"><i data-lucide="download" class="w-4 h-4"></i></button>
                    <label class="p-1 rounded-full cursor-pointer" title="Import Anki" aria-label="Import from Anki">
                        <i data-lucide="upload-cloud" class="w-4 h-4"></i>
                        <input aria-label="Import .apkg" id="ankiImportInputMobile" type="file" accept=".apkg,.json"
                            class="hidden">
                    </label>
                </div>
            </div>
        </header>

        <!-- Tab Navigation -->
        <nav id="tabBar"
            class="px-3 sm:px-5 md:px-10 py-2 sm:py-3 flex gap-1.5 sm:gap-2 border-b border-[color:var(--card-border)]">
            <button data-tab="study" class="tab-btn active text-xs sm:text-sm">ðŸ“– Study</button>
            <button data-tab="library" class="tab-btn text-xs sm:text-sm">ðŸ“š Library</button>
        </nav>

        <main class="px-3 sm:px-5 md:px-10 pb-6 sm:pb-10 space-y-4 md:space-y-6">
            <div id="lockedOverlay"
                class="rounded-2xl p-6 bg-[color:var(--surface-strong)] border border-[color:var(--card-border)] flex flex-col gap-5 max-w-3xl mx-auto mt-6 text-center hidden">
                <div class="space-y-3">
                    <p class="font-display text-xl text-charcoal leading-tight">AI-enabled flashcards stored in Notion
                    </p>
                    <p class="text-sm text-earth-metal/70 leading-relaxed">
                        Your cards live in Notion where you can see and edit them. Reveal answers like Anki, or
                        type/speak your answer and let AI check it against the ground truth.
                    </p>
                </div>
                <div class="grid md:grid-cols-3 gap-3 text-sm text-left">
                    <div
                        class="rounded-xl bg-[color:var(--surface)] border border-[color:var(--card-border)] p-3 space-y-1">
                        <div class="flex items-center gap-2 text-dull-purple font-semibold"><i data-lucide="link"
                                class="w-4 h-4"></i>Connect</div>
                        <p class="text-earth-metal/70">Add your worker URL and Notion token to sync.</p>
                    </div>
                    <div
                        class="rounded-xl bg-[color:var(--surface)] border border-[color:var(--card-border)] p-3 space-y-1">
                        <div class="flex items-center gap-2 text-dull-purple font-semibold"><i data-lucide="database"
                                class="w-4 h-4"></i>Sources</div>
                        <p class="text-earth-metal/70">Point to your Decks and Cards databases in Notion.</p>
                    </div>
                    <div
                        class="rounded-xl bg-[color:var(--surface)] border border-[color:var(--card-border)] p-3 space-y-1">
                        <div class="flex items-center gap-2 text-dull-purple font-semibold"><i data-lucide="wand-2"
                                class="w-4 h-4"></i>Study</div>
                        <p class="text-earth-metal/70">Reveal answers directly, or use AI mode to check your response.
                        </p>
                    </div>
                </div>
                <div class="flex justify-center">
                    <button id="lockedOpenSettings"
                        class="px-5 py-3 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1] flex items-center gap-2 whitespace-nowrap shadow-soft">
                        <i data-lucide="settings" class="w-4 h-4"></i><span>Open settings</span>
                    </button>
                </div>
            </div>

            <section id="mainContent" class="space-y-6">
                <!-- LIBRARY TAB -->
                <div id="libraryTab" class="tab-content space-y-4 md:space-y-6 hidden">
                    <!-- Decks Section -->
                    <article class="card rounded-2xl p-4 md:p-5 shadow-soft text-[color:var(--text-main)]">
                        <div class="flex items-center justify-between gap-2">
                            <div class="min-w-0">
                                <h2 class="font-display text-base md:text-lg text-charcoal">Decks</h2>
                                <p class="text-xs md:text-sm text-earth-metal/70 hidden sm:block">Click to select a deck
                                    and view its cards.</p>
                            </div>
                            <div class="flex items-center gap-2 shrink-0">
                                <button id="refreshDecksBtn"
                                    class="p-2 rounded-xl border border-oatmeal-dark/60 text-earth-metal hover:bg-oatmeal dark:hover:bg-white/5 flex items-center gap-2"
                                    data-tooltip="Sync with Notion">
                                    <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                                </button>
                                <button id="newDeckBtn"
                                    class="p-2 md:px-3 md:py-2 rounded-xl bg-charcoal dark:bg-white/10 dark:border-white/10 dark:border text-white text-sm hover:bg-earth-metal dark:hover:bg-white/20 flex items-center gap-2"
                                    data-tooltip="New deck">
                                    <i data-lucide="plus" class="w-4 h-4"></i>
                                    <span class="hidden md:inline">New deck</span>
                                </button>
                            </div>
                        </div>
                        <!-- Deck search -->
                        <div class="mt-3">
                            <input id="libraryDeckSearch" type="text" placeholder="Search decks..."
                                class="w-full rounded-xl border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-dull-purple/40">
                        </div>
                        <div id="deckGrid"
                            class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-2 md:gap-3 mt-3 max-h-[400px] sm:max-h-[400px] md:max-h-[240px] lg:max-h-[240px] overflow-y-auto scroll-minimal p-1">
                        </div>
                    </article>

                    <!-- Selected Deck Bar + Cards Section -->
                    <article id="cardsSection"
                        class="card rounded-2xl p-4 md:p-5 shadow-soft text-[color:var(--text-main)]">
                        <div id="selectedDeckBar" class="flex items-center justify-between gap-2">
                            <h2 class="font-display text-base md:text-lg text-charcoal truncate" id="selectedDeckName">
                                Select a deck above</h2>
                            <div class="flex items-center gap-1 md:gap-2 shrink-0">
                                <button id="resetAlgorithmBtn"
                                    class="p-2 md:px-3 md:py-2 rounded-xl border border-red-300 text-red-600 text-sm hover:bg-red-50 dark:border-red-900 dark:text-red-400 dark:hover:bg-red-900/20 flex items-center gap-2 hidden"
                                    data-tooltip="Reset algorithm parameters">
                                    <i data-lucide="rotate-ccw" class="w-4 h-4"></i>
                                    <span class="hidden lg:inline">Reset Algorithm</span>
                                </button>
                                <button id="newCardBtn"
                                    class="p-2 md:px-3 md:py-2 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1] flex items-center gap-2 hidden"
                                    data-tooltip="New card">
                                    <i data-lucide="plus-circle" class="w-4 h-4"></i>
                                    <span class="hidden md:inline">New card</span>
                                </button>
                            </div>
                        </div>
                        <!-- Cards content (hidden until deck selected) -->
                        <div id="cardsContent" class="hidden mt-3 md:mt-4">
                            <!-- Card search -->
                            <div class="mb-3">
                                <input id="cardSearchInput" type="text" placeholder="Search cards by name..."
                                    class="w-full rounded-xl border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-dull-purple/40">
                            </div>
                            <div id="cardsContainer"
                                class="max-h-[350px] md:max-h-[400px] overflow-y-auto scroll-minimal">
                                <table class="w-full text-xs md:text-sm">
                                    <thead class="text-earth-metal/60 sticky top-0 bg-[color:var(--card-bg)]">
                                        <tr class="border-b border-oatmeal-dark/70">
                                            <th class="py-2 text-left">Name</th>
                                            <th class="py-2 text-left hidden sm:table-cell">Type</th>
                                            <th class="py-2 text-left">Due</th>
                                            <th class="py-2 text-left hidden md:table-cell">Tags</th>
                                            <th class="py-2 text-left w-8 md:w-10"></th>
                                        </tr>
                                    </thead>
                                    <tbody id="cardTable" class="divide-y divide-oatmeal-dark/40"></tbody>
                                </table>
                            </div>
                            <div id="noCardsMessage"
                                class="text-center py-6 md:py-8 text-earth-metal/60 text-xs md:text-sm hidden">
                                No cards in this deck yet. Click "New card" to add one.
                            </div>
                        </div>
                    </article>
                </div>

                <!-- STUDY TAB -->
                <div id="studyTab" class="tab-content">
                    <!-- Centered Study Content -->
                    <div class="max-w-2xl mx-auto space-y-4 md:space-y-6">
                        <!-- Session Active Bar (shown when session is active) -->
                        <div id="sessionActiveBar"
                            class="hidden card rounded-2xl p-4 md:p-5 shadow-soft text-[color:var(--text-main)]">
                            <div class="flex items-center justify-between gap-3">
                                <div class="flex items-center gap-2">
                                    <i data-lucide="book-open" class="w-5 h-5 text-dull-purple"></i>
                                    <span id="sessionProgressText"
                                        class="text-sm md:text-base text-charcoal font-medium">Session: 0/0</span>
                                </div>
                                <div id="previewBadge"
                                    class="hidden text-[11px] px-2 py-1 rounded-lg bg-amber-100 text-amber-800 border border-amber-200">
                                    Preview mode: no scheduling changes
                                </div>
                                <button id="abandonSessionBtn"
                                    class="flex items-center gap-1.5 px-2 md:px-3 py-1.5 rounded-xl text-xs md:text-sm text-earth-metal/70 hover:text-muted-pink hover:bg-muted-pink/10 border border-oatmeal-dark/60 transition whitespace-nowrap">
                                    <i data-lucide="square" class="w-3 h-3"></i>
                                    <span class="hidden md:inline">Stop Session</span>
                                    <span class="md:hidden">Stop</span>
                                </button>
                            </div>
                        </div>

                        <!-- Study Filters Card -->
                        <article id="studySettingsCard"
                            class="card rounded-2xl p-4 md:p-5 shadow-soft text-[color:var(--text-main)]">
                            <div class="flex items-center justify-between gap-2 mb-3 md:mb-4">
                                <div class="flex items-center gap-2 min-w-0">
                                    <i data-lucide="settings-2" class="w-4 h-4 text-dull-purple shrink-0"></i>
                                    <h2 class="font-display text-base md:text-lg text-charcoal truncate">Study Mode
                                        Settings</h2>
                                </div>
                                <button id="resetFilters"
                                    class="text-xs text-dull-purple hover:underline hidden">Reset</button>
                            </div>

                            <!-- Always visible: Decks + Mode -->
                            <div class="space-y-3">
                                <div>
                                    <label class="text-xs text-earth-metal/70 block mb-2">Study from decks</label>
                                    <div class="relative">
                                        <input id="deckSearchInput" type="text" placeholder="Search decks..."
                                            class="w-full rounded-xl border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-dull-purple/40">
                                        <div id="deckDropdown"
                                            class="hidden absolute left-0 right-0 z-50 w-full mt-1 max-h-48 overflow-y-auto rounded-xl border border-oatmeal-dark/60 bg-[color:var(--card-bg)] shadow-lg">
                                        </div>
                                    </div>
                                    <div id="selectedDecksDisplay" class="flex flex-wrap gap-1.5 mt-2"></div>
                                </div>
                                <div>
                                    <label class="text-xs text-earth-metal/70 block mb-2">Revision mode</label>
                                    <select id="revisionMode"
                                        class="w-full rounded-xl border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm">
                                        <option value="manual">Reveal</option>
                                        <option value="ai">AI</option>
                                    </select>
                                </div>
                                <!-- Session controls -->
                                <div id="sessionControls" class="pt-3">
                                    <button id="startSessionBtn"
                                        class="w-full px-4 py-2.5 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1] transition flex items-center justify-center gap-2">
                                        <i data-lucide="play" class="w-4 h-4"></i>
                                        <span>Start Study Session</span>
                                    </button>
                                </div>
                            </div>

                            <!-- More options divider -->
                            <button id="toggleFilters"
                                class="w-full flex items-center justify-center gap-2 mt-4 py-2 text-xs text-earth-metal/60 hover:text-earth-metal transition-colors">
                                <span class="flex-1 h-px bg-[color:var(--card-border)]"></span>
                                <span class="flex items-center gap-1">
                                    <span id="moreOptionsText">More options</span>
                                    <i data-lucide="chevron-down" id="filtersChevron"
                                        class="w-3 h-3 transition-transform"></i>
                                </span>
                                <span class="flex-1 h-px bg-[color:var(--card-border)]"></span>
                            </button>

                            <div id="filtersContent" class="hidden pt-3 md:pt-4">
                                <div class="grid grid-cols-2 gap-2 md:gap-3 text-xs md:text-sm">
                                    <!-- Card selection mode -->
                                    <div class="col-span-2">
                                        <label class="text-xs text-earth-metal/70 block mb-2">Practice cards</label>
                                        <select id="cardSelectionMode"
                                            class="w-full rounded-xl border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm">
                                            <option value="due">Due cards only</option>
                                            <option value="all">All cards</option>
                                        </select>
                                    </div>
                                    <div id="noScheduleRow" class="col-span-2 hidden">
                                        <label class="flex items-center gap-2 text-xs md:text-sm">
                                            <input id="noScheduleChanges" type="checkbox" class="accent-dull-purple"
                                                checked>
                                            <span>No scheduling changes (preview mode)</span>
                                        </label>
                                        <p class="text-[11px] text-earth-metal/50 mt-1">When on, ratings wonâ€™t update
                                            due dates or algorithms.</p>
                                    </div>
                                    <label class="flex items-center gap-2">
                                        <input id="filterAgain" type="checkbox" class="accent-dull-purple">
                                        <span>Again recently</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input id="filterHard" type="checkbox" class="accent-dull-purple">
                                        <span>Hard/Again</span>
                                    </label>
                                    <label class="flex items-center gap-2 col-span-2">
                                        <input id="filterAddedToday" type="checkbox" class="accent-dull-purple">
                                        <span>Added today</span>
                                    </label>
                                    <div class="col-span-2">
                                        <label class="text-xs text-earth-metal/70">Stability below</label>
                                        <input id="filterStability" type="range" min="0" max="50" step="1"
                                            class="w-full accent-dull-purple">
                                        <div class="flex justify-between text-xs text-earth-metal/60">
                                            <span>0</span><span id="stabilityValue">25</span><span>50</span>
                                        </div>
                                    </div>
                                    <div class="col-span-2">
                                        <label class="text-xs text-earth-metal/70">Tags</label>
                                        <div id="filterTagsContainer"
                                            class="flex flex-wrap gap-1.5 mt-2 p-2 rounded-xl border border-oatmeal-dark/60 bg-white-linen min-h-[40px] text-xs cursor-pointer">
                                        </div>
                                    </div>
                                    <div class="col-span-2">
                                        <label class="text-xs text-earth-metal/70">Manual pick</label>
                                        <div id="manualSelection" class="flex flex-wrap gap-1.5 mt-2 text-xs"></div>
                                    </div>
                                    <label class="flex items-center gap-2">
                                        <input id="filterSuspended" type="checkbox" class="accent-dull-purple">
                                        <span>Hide suspended</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input id="filterLeech" type="checkbox" class="accent-dull-purple">
                                        <span>Hide leeches</span>
                                    </label>
                                    <button id="resetFiltersMobile"
                                        class="col-span-2 sm:hidden text-xs text-dull-purple hover:underline text-center py-2">Reset
                                        all filters</button>
                                </div>
                            </div>
                        </article>
                        <!-- Study Card -->
                        <article id="studyCardSection"
                            class="card rounded-2xl p-4 md:p-5 shadow-soft text-[color:var(--text-main)] hidden">
                            <div class="flex items-center justify-between gap-2">
                                <h2 class="font-display text-base md:text-lg text-charcoal">Study</h2>
                                <div class="flex items-center gap-1">
                                    <button id="addNoteBlock"
                                        class="p-1.5 rounded-lg hover:bg-oatmeal text-dull-purple hidden"
                                        title="Add note to page">
                                        <i data-lucide="file-plus" class="w-4 h-4"></i>
                                    </button>
                                    <button id="copyCardContent"
                                        class="p-1.5 rounded-lg hover:bg-oatmeal text-dull-purple hidden"
                                        title="Copy card content">
                                        <i data-lucide="clipboard" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            <div id="studyCardContent"
                                class="relative mt-3 p-3 md:p-4 rounded-xl bg-[color:var(--surface-strong)] border border-[color:var(--card-border)] space-y-3">
                                <div class="flex items-center justify-between text-xs text-[color:var(--text-sub)]">
                                    <span id="studyDeckLabel" class="truncate">Choose a deck</span>
                                </div>
                                <div id="cardFront"
                                    class="min-h-[100px] md:min-h-[120px] leading-relaxed text-[color:var(--text-main)] max-h-[40vh] md:max-h-[45vh] overflow-y-auto pr-1 scroll-minimal text-sm md:text-base">
                                </div>
                                <div class="space-y-2">
                                    <button id="revealBtn"
                                        class="relative px-3 py-2.5 w-full rounded-xl bg-charcoal dark:bg-white/10 dark:border-white/10 dark:border text-white text-sm hover:bg-earth-metal dark:hover:bg-white/20">
                                        Reveal
                                        <kbd
                                            class="hidden md:inline-block absolute right-3 top-1/2 -translate-y-1/2 text-[10px] px-1.5 py-0.5 rounded bg-white/20 font-medium">Space</kbd>
                                    </button>
                                    <div id="aiControls" class="hidden space-y-2">
                                        <textarea id="aiAnswer" rows="3" placeholder="Type your answer..."
                                            class="w-full rounded-xl border border-[color:var(--card-border)] bg-[color:var(--surface)] px-3 py-2 text-sm"></textarea>
                                        <div class="flex gap-2">
                                            <button id="aiRecord"
                                                class="p-2 rounded-xl bg-[color:var(--surface)] border border-[color:var(--card-border)] text-[color:var(--text-main)] text-sm flex-1"
                                                title="Record"><i data-lucide="mic"
                                                    class="w-4 h-4 mx-auto"></i></button>
                                            <button id="aiSubmit"
                                                class="px-3 py-2 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1] flex-1">
                                                Send <kbd
                                                    class="hidden md:inline-block text-[10px] px-1.5 py-0.5 rounded bg-white/20 font-medium ml-1 font-sans">âŒ˜
                                                    â†µ</kbd>
                                            </button>
                                        </div>
                                        <div id="aiFeedback"
                                            class="text-sm text-earth-metal/80 dark:text-white/70 bg-[var(--surface)] dark:bg-white/5 border border-oatmeal-dark/40 dark:border-white/10 rounded-xl p-2">
                                        </div>
                                    </div>
                                </div>
                                <div id="cardBack"
                                    class="leading-relaxed text-[color:var(--text-sub)] hidden max-h-[40vh] md:max-h-[45vh] overflow-y-auto pr-1 scroll-minimal text-sm md:text-base">
                                </div>
                                <!-- Study controls (hidden when session complete) -->
                                <div id="studyControls">
                                    <div class="grid grid-cols-4 gap-1 md:gap-2">
                                        <button data-rate="Again" aria-label="Rate as Again (1)"
                                            class="rate-btn relative px-1 md:px-2 py-2 rounded-lg bg-red-100 border border-red-300 text-red-700 text-[10px] md:text-xs hover:bg-red-200 flex items-center justify-center gap-1">
                                            <i data-lucide="refresh-cw" class="w-3 h-3"></i>
                                            <span>Again</span>
                                            <kbd
                                                class="hidden md:flex absolute -top-1.5 -right-1.5 w-4 h-4 items-center justify-center text-[8px] rounded bg-red-600 text-white font-medium shadow-sm">1</kbd>
                                        </button>
                                        <button data-rate="Hard" aria-label="Rate as Hard (2)"
                                            class="rate-btn relative px-1 md:px-2 py-2 rounded-lg bg-orange-100 border border-orange-300 text-orange-700 text-[10px] md:text-xs hover:bg-orange-200 flex items-center justify-center gap-1">
                                            <i data-lucide="alert-triangle" class="w-3 h-3"></i>
                                            <span>Hard</span>
                                            <kbd
                                                class="hidden md:flex absolute -top-1.5 -right-1.5 w-4 h-4 items-center justify-center text-[8px] rounded bg-orange-500 text-white font-medium shadow-sm">2</kbd>
                                        </button>
                                        <button data-rate="Good" aria-label="Rate as Good (3)"
                                            class="rate-btn relative px-1 md:px-2 py-2 rounded-lg bg-green-100 border border-green-300 text-green-700 text-[10px] md:text-xs hover:bg-green-200 flex items-center justify-center gap-1">
                                            <i data-lucide="thumbs-up" class="w-3 h-3"></i>
                                            <span>Good</span>
                                            <kbd
                                                class="hidden md:flex absolute -top-1.5 -right-1.5 w-4 h-4 items-center justify-center text-[8px] rounded bg-green-600 text-white font-medium shadow-sm">3</kbd>
                                        </button>
                                        <button data-rate="Easy" aria-label="Rate as Easy (4)"
                                            class="rate-btn relative px-1 md:px-2 py-2 rounded-lg bg-blue-100 border border-blue-300 text-blue-700 text-[10px] md:text-xs hover:bg-blue-200 flex items-center justify-center gap-1">
                                            <i data-lucide="zap" class="w-3 h-3"></i>
                                            <span>Easy</span>
                                            <kbd
                                                class="hidden md:flex absolute -top-1.5 -right-1.5 w-4 h-4 items-center justify-center text-[8px] rounded bg-blue-600 text-white font-medium shadow-sm">4</kbd>
                                        </button>
                                    </div>
                                    <div class="text-[10px] md:text-[11px] text-earth-metal/70 flex justify-end mt-2">
                                        <button id="skipCard"
                                            class="px-2 py-1 rounded-lg border border-oatmeal-dark/50 text-dull-purple hover:bg-dull-purple/10 shrink-0 flex items-center gap-1">
                                            <i data-lucide="square-slash" class="w-3 h-3"></i>
                                            <span>Skip</span>
                                            <kbd
                                                class="hidden md:inline text-[9px] ml-0.5 px-1 py-0.5 rounded bg-dull-purple/10 text-dull-purple font-medium">S</kbd>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </article>

                        <!-- Mobile FAB cluster - Joystick and action buttons (only visible on mobile) -->
                        <div id="mobileFabCluster" class="mobile-fab-cluster hidden">
                            <!-- Joystick wrapper with side actions -->
                            <div class="joystick-wrapper">
                                <!-- Arcade-style joystick for rating -->
                                <div id="joystickContainer" class="joystick-container hidden">
                                    <div id="joystick" class="joystick">
                                        <!-- Direction labels with filled icons -->
                                        <!-- Clockwise from bottom: Again (down) â†’ Hard (left) â†’ Good (up) â†’ Easy (right) -->
                                        <div class="joystick-label joystick-label-up">
                                            <i data-lucide="thumbs-up"></i>
                                        </div>
                                        <div class="joystick-label joystick-label-down">
                                            <i data-lucide="refresh-cw"></i>
                                        </div>
                                        <div class="joystick-label joystick-label-left">
                                            <i data-lucide="alert-triangle"></i>
                                        </div>
                                        <div class="joystick-label joystick-label-right">
                                            <i data-lucide="zap"></i>
                                        </div>
                                        <!-- The knob -->
                                        <div class="joystick-knob"></div>
                                    </div>
                                </div>

                                <!-- Side action buttons (next to joystick) -->
                                <div class="joystick-side-actions">
                                    <button id="fabAddNote" class="fab-btn fab-btn-secondary hidden" title="Add note">
                                        <i data-lucide="file-plus"></i>
                                    </button>
                                    <button id="fabCopy" class="fab-btn fab-btn-secondary hidden" title="Copy">
                                        <i data-lucide="clipboard"></i>
                                    </button>
                                </div>
                            </div>

                            <!-- Pre-reveal actions -->
                            <div id="fabPreRevealActions" class="joystick-side-actions">
                                <button id="fabSkip" class="fab-btn fab-btn-secondary" title="Skip">
                                    <i data-lucide="square-slash"></i>
                                </button>
                                <button id="fabReveal" class="fab-btn fab-btn-primary" title="Reveal">
                                    <i data-lucide="eye"></i>
                                </button>
                            </div>
                        </div>

                        <!-- Notes Preview (below study card, no textarea) -->
                        <div id="notesSection"
                            class="rounded-xl border border-[color:var(--card-border)] p-3 md:p-4 bg-[color:var(--card-bg)] hidden">
                            <div class="flex items-center justify-between mb-2 md:mb-3">
                                <span class="font-semibold text-charcoal text-sm md:text-base">Notes</span>
                                <button id="editNotesBtn" class="p-1.5 rounded-lg hover:bg-oatmeal text-dull-purple"
                                    title="Edit notes">
                                    <i data-lucide="edit-2" class="w-4 h-4"></i>
                                </button>
                            </div>
                            <div id="notesPreview"
                                class="prose prose-sm max-h-60 md:max-h-80 overflow-y-auto text-xs md:text-sm text-[color:var(--text-main)] scroll-minimal">
                                <p class="text-earth-metal/60 text-xs md:text-sm">No notes for this card</p>
                            </div>
                        </div>

                        <!-- Mobile bottom spacer to prevent joystick overlap -->
                        <div class="h-36 md:hidden" aria-hidden="true"></div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <div id="toast" role="status" aria-live="polite"
        class="fixed z-[110] bottom-6 right-6 px-4 py-3 rounded-xl bg-charcoal dark:bg-zinc-800 text-white text-sm shadow-soft hidden opacity-0 transition-opacity duration-300">
    </div>
    <div id="tooltip"
        class="fixed z-[120] px-2.5 py-1.5 rounded-lg text-xs bg-charcoal dark:bg-zinc-800 text-white shadow-soft pointer-events-none hidden">
    </div>

    <!-- Global loading overlay -->
    <div id="loadingOverlay"
        class="fixed inset-0 z-[130] bg-black/40 backdrop-blur-sm hidden items-center justify-center">
        <div class="flex flex-col items-center gap-3 text-white text-center px-6">
            <div class="h-12 w-12 border-4 border-white/30 border-t-white rounded-full animate-spin"></div>
            <p id="loadingMessage" class="text-sm font-medium">Loading...</p>
            <p class="text-xs text-white/80" id="loadingSubtext">Preparing your decks and cards.</p>
        </div>
    </div>

    <div id="confirmModal" role="dialog" aria-modal="true" aria-labelledby="confirmModalTitle"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div class="card rounded-2xl p-5 w-full max-w-sm shadow-soft">
            <p id="confirmModalTitle" class="text-charcoal font-display text-lg mb-2">Confirm delete</p>
            <p class="text-sm text-earth-metal/70">This removes it locally and syncs deletion to Notion.</p>
            <div class="flex justify-end gap-2 mt-4">
                <button id="cancelDelete"
                    class="px-3 py-2 rounded-xl bg-white-linen border border-oatmeal-dark/70 text-earth-metal text-sm">Cancel</button>
                <button id="confirmDelete" class="px-3 py-2 rounded-xl bg-muted-pink text-white text-sm">Delete</button>
            </div>
        </div>
    </div>

    <!-- Reset Algorithm Confirmation Modal -->
    <div id="resetAlgorithmModal" role="dialog" aria-modal="true" aria-labelledby="resetAlgorithmTitle"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4 z-50">
        <div class="card rounded-2xl p-5 w-full max-w-md shadow-soft">
            <div class="flex items-center gap-3 mb-3">
                <div class="p-2 rounded-full bg-red-100">
                    <i data-lucide="alert-triangle" class="w-5 h-5 text-red-600"></i>
                </div>
                <h3 id="resetAlgorithmTitle" class="text-charcoal font-display text-lg">Reset Algorithm Parameters</h3>
            </div>
            <div class="space-y-3 text-sm text-earth-metal/80">
                <p>This will reset <strong>all spaced repetition data</strong> for every card in <span
                        id="resetDeckName" class="font-semibold text-charcoal">this deck</span>:</p>
                <ul class="list-disc list-inside space-y-1 text-earth-metal/70 ml-2">
                    <li>Due dates will be cleared</li>
                    <li>Ease factors, intervals, and stability will reset</li>
                    <li>Review history will be preserved</li>
                    <li>Cards will appear as new again</li>
                </ul>
                <div class="p-3 rounded-xl bg-amber-50 border border-amber-200 flex items-start gap-2">
                    <i data-lucide="cloud-upload" class="w-4 h-4 text-amber-600 mt-0.5 shrink-0"></i>
                    <p class="text-amber-800 text-xs">These changes will be synced to Notion. This action cannot be
                        undone.</p>
                </div>
            </div>
            <div class="flex justify-end gap-2 mt-5">
                <button id="cancelResetAlgorithm"
                    class="px-4 py-2 rounded-xl bg-white-linen border border-oatmeal-dark/70 text-earth-metal text-sm hover:bg-oatmeal">Cancel</button>
                <button id="confirmResetAlgorithm"
                    class="px-4 py-2 rounded-xl bg-red-600 text-white text-sm hover:bg-red-700 flex items-center gap-2">
                    <i data-lucide="rotate-ccw" class="w-4 h-4"></i>
                    Reset All Cards
                </button>
            </div>
        </div>
    </div>

    <!-- Settings -->
    <div id="settingsModal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div id="settingsCard" class="card rounded-2xl p-5 w-full max-w-3xl shadow-soft max-h-[90vh] overflow-y-auto">
            <div class="flex items-center justify-between mb-3">
                <h3 id="settingsTitle" class="font-display text-lg text-charcoal">Connection</h3>
                <button id="closeSettings" aria-label="Close settings"
                    class="text-earth-metal/60 hover:text-charcoal"><i data-lucide="x" class="w-5 h-5"></i></button>
            </div>
            <!-- Status bar spanning full width -->
            <div class="rounded-xl border border-oatmeal-dark/60 p-3 bg-oatmeal/60 mb-4">
                <div class="flex items-center gap-2 mb-2">
                    <i data-lucide="shield-check" class="w-4 h-4 text-dull-purple"></i>
                    <p class="font-semibold text-charcoal text-sm">Status</p>
                </div>
                <div class="flex flex-wrap gap-4 text-xs text-earth-metal/80">
                    <span id="statusWorker">Worker: missing</span>
                    <span id="statusAuth">Auth: missing</span>
                    <span id="statusSources">Sources: missing</span>
                </div>
            </div>
            <div class="grid md:grid-cols-2 gap-6 text-sm">
                <div class="space-y-4">
                    <div class="rounded-xl border border-oatmeal-dark/60 p-3 bg-white-linen">
                        <div class="flex items-center justify-between">
                            <p class="font-semibold text-charcoal">Worker proxy</p>
                            <button id="openWorkerHelp"
                                class="px-3 py-1.5 rounded-full bg-oatmeal text-earth-metal text-xs border border-oatmeal-dark/70 flex items-center gap-2">
                                <i data-lucide="code" class="w-4 h-4"></i> Worker code
                            </button>
                        </div>
                        <p class="text-xs text-earth-metal/70 mt-1">Add Cloudflare Worker URL even if you plan to sign
                            in with Notion.</p>
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/70">Cloudflare Worker URL</label>
                        <input id="settingWorkerUrl" type="text" placeholder="https://your-proxy.workers.dev"
                            class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/70">Proxy token (optional)</label>
                        <input id="settingProxyToken" type="password" placeholder="ALL_CORS_PROXY_MATCH_TOKEN"
                            class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                    </div>
                    <button id="verifyWorker"
                        class="px-3 py-2 rounded-xl bg-oatmeal text-earth-metal text-sm border border-oatmeal-dark/70 w-full">Verify
                        worker</button>
                    <div>
                        <label class="text-xs text-earth-metal/70">Notion integration secret (instead of OAuth)</label>
                        <input id="settingAuthToken" type="password" placeholder="secret_..."
                            class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 disabled:opacity-60 disabled:cursor-not-allowed">
                    </div>
                    <button id="verifyAuth"
                        class="px-3 py-2 rounded-xl bg-oatmeal text-earth-metal text-sm border border-oatmeal-dark/70 w-full disabled:opacity-60 disabled:cursor-not-allowed">Verify
                        Notion token</button>
                    <button id="oauthBtn"
                        class="w-full px-3 py-2 rounded-xl border border-dull-purple text-dull-purple text-sm hover:bg-oatmeal flex items-center gap-2 justify-center disabled:opacity-60 disabled:cursor-not-allowed">
                        <i data-lucide="log-in" class="w-4 h-4"></i>Sign in with Notion
                    </button>
                    <div>
                        <label class="text-xs text-earth-metal/60">Decks source</label>
                        <select id="deckSourceSelect" disabled
                            class="w-full rounded-xl border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm disabled:opacity-60 disabled:cursor-not-allowed"></select>
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/60">Cards source</label>
                        <select id="cardSourceSelect" disabled
                            class="w-full rounded-xl border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm disabled:opacity-60 disabled:cursor-not-allowed"></select>
                    </div>
                    <div class="flex gap-2 flex-wrap">
                        <button id="scanSources" disabled
                            class="px-3 py-2 rounded-xl bg-charcoal dark:bg-white/10 dark:border-white/10 dark:border text-white text-sm hover:bg-earth-metal dark:hover:bg-white/20 flex-1 min-w-[140px] disabled:opacity-60 disabled:cursor-not-allowed disabled:hover:bg-charcoal">Scan
                            sources</button>
                        <button id="saveSettings" disabled
                            class="px-3 py-2 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1] flex-1 min-w-[140px] disabled:opacity-60 disabled:cursor-not-allowed disabled:hover:bg-dull-purple">Save</button>
                    </div>
                    <div class="w-full h-2 bg-oatmeal rounded-full overflow-hidden">
                        <div id="syncProgress" class="h-2 bg-dull-purple w-0 transition-all duration-500"></div>
                    </div>
                </div>
                <div class="space-y-4">
                    <div class="rounded-xl border border-oatmeal-dark/60 p-3 bg-white-linen">
                        <div class="flex items-center gap-2">
                            <i data-lucide="database" class="w-4 h-4 text-dull-purple"></i>
                            <p class="font-semibold text-charcoal">Offline vault</p>
                        </div>
                        <div class="mt-3 grid grid-cols-2 gap-3 text-sm">
                            <div class="rounded-xl bg-oatmeal p-3">
                                <p class="text-earth-metal/60">Decks cached</p>
                                <p id="deckCount" class="text-xl font-semibold text-charcoal">0</p>
                            </div>
                            <div class="rounded-xl bg-oatmeal p-3">
                                <p class="text-earth-metal/60">Cards cached</p>
                                <p id="cardCount" class="text-xl font-semibold text-charcoal">0</p>
                            </div>
                            <div class="rounded-xl bg-white-linen p-3">
                                <p class="text-earth-metal/60">Pending sync</p>
                                <p id="queueCount" class="text-xl font-semibold text-charcoal">0</p>
                            </div>
                            <div class="rounded-xl bg-white-linen p-3">
                                <p class="text-earth-metal/60">Last sync</p>
                                <p id="lastSync" class="text-xl font-semibold text-charcoal">â€”</p>
                            </div>
                        </div>
                        <p class="mt-3 text-xs text-earth-metal/70">IndexedDB holds all decks/cards/FSRS/notes for
                            offline-first use.</p>
                    </div>
                    <div class="rounded-xl border border-oatmeal-dark/60 p-3 bg-white-linen">
                        <div class="flex items-center gap-2 mb-2">
                            <i data-lucide="bot" class="w-4 h-4 text-dull-purple"></i>
                            <p class="font-semibold text-charcoal">AI judge settings</p>
                        </div>
                        <div class="space-y-2">
                            <div>
                                <label class="text-xs text-earth-metal/70">Provider</label>
                                <select id="aiProvider"
                                    class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm">
                                    <option value="">Disabled</option>
                                    <option value="openai">OpenAI</option>
                                    <option value="anthropic">Claude</option>
                                    <option value="gemini">Gemini</option>
                                </select>
                            </div>
                            <div id="aiProviderFields" class="space-y-2 hidden">
                                <div>
                                    <label class="text-xs text-earth-metal/70">Model</label>
                                    <input id="aiModel" type="text"
                                        placeholder="gpt-4o-mini / claude-3-haiku / gemini-1.5-flash"
                                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm">
                                </div>
                                <input id="aiKey" type="password" placeholder="API key (kept locally)"
                                    class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm">
                                <button id="verifyAi"
                                    class="px-3 py-2 rounded-xl bg-oatmeal text-earth-metal text-sm border border-oatmeal-dark/70 w-full">Verify
                                    AI settings</button>
                                <p class="text-[11px] text-earth-metal/60">Keys stay on-device (localStorage). AI
                                    judging
                                    only runs if verified.</p>
                            </div>
                        </div>
                    </div>
                    <!-- Speech-to-Text Settings (only shown when AI mode is enabled) -->
                    <div id="sttSettings" class="rounded-xl border border-oatmeal-dark/60 p-3 bg-white-linen hidden">
                        <div class="flex items-center gap-2 mb-2">
                            <i data-lucide="mic" class="w-4 h-4 text-dull-purple"></i>
                            <p class="font-semibold text-charcoal">Speech-to-text</p>
                        </div>
                        <div class="space-y-2">
                            <div>
                                <label class="text-xs text-earth-metal/70">Provider</label>
                                <select id="sttProvider"
                                    class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm">
                                    <option value="">Browser (default)</option>
                                    <option value="openai">OpenAI Whisper</option>
                                    <option value="gemini">Gemini</option>
                                    <option value="groq">Groq Whisper</option>
                                </select>
                            </div>
                            <div id="sttProviderFields" class="space-y-2 hidden">
                                <div>
                                    <label class="text-xs text-earth-metal/70">Model</label>
                                    <input id="sttModel" type="text" placeholder="whisper-1 / gemini-2.0-flash"
                                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-2 py-2 text-sm">
                                </div>
                                <input id="sttKey" type="password" placeholder="API key (required for cloud providers)"
                                    class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm">
                                <div>
                                    <label class="text-xs text-earth-metal/70">Starter prompt (optional context)</label>
                                    <input id="sttPrompt" type="text" placeholder="e.g., Technical terms, names..."
                                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm mt-1">
                                </div>
                                <button id="verifyStt"
                                    class="px-3 py-2 rounded-xl bg-oatmeal text-earth-metal text-sm border border-oatmeal-dark/70 w-full">Verify
                                    STT settings</button>
                            </div>
                            <p class="text-[11px] text-earth-metal/60">Browser uses free built-in speech recognition.
                                Cloud providers offer better accuracy.</p>
                        </div>
                    </div>
                    <!-- Danger Zone -->
                    <div class="mt-4 border-t border-oatmeal-dark/40 pt-4">
                        <button id="toggleDangerZone"
                            class="w-full flex items-center justify-between text-sm text-muted-pink hover:text-muted-pink/80 transition">
                            <span class="flex items-center gap-2">
                                <i data-lucide="alert-triangle" class="w-4 h-4"></i>
                                <span>Danger Zone</span>
                            </span>
                            <i data-lucide="chevron-down" id="dangerZoneChevron"
                                class="w-4 h-4 transition-transform"></i>
                        </button>
                        <div id="dangerZoneContent"
                            class="hidden mt-3 p-3 rounded-xl bg-muted-pink/10 border border-muted-pink/30">
                            <p class="text-xs text-earth-metal/70 mb-3">This will permanently delete all GhostInk data
                                including decks, cards, settings, and session data. Data synced to Notion will not be
                                affected.</p>
                            <button id="resetApp"
                                class="px-3 py-2 rounded-xl bg-muted-pink text-white text-sm hover:bg-muted-pink/90 w-full">Reset
                                GhostInk</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Worker helper -->
    <div id="workerHelpModal" class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div class="card rounded-2xl p-5 w-full max-w-3xl shadow-soft h-[80vh] flex flex-col">
            <div class="flex items-center justify-between mb-3">
                <h3 class="font-display text-lg text-charcoal">Cloudflare Worker proxy</h3>
                <button id="closeWorkerHelp" class="text-earth-metal/60 hover:text-charcoal"><i data-lucide="x"
                        class="w-5 h-5"></i></button>
            </div>
            <div class="flex-1 overflow-y-auto space-y-3 text-sm text-earth-metal">
                <p>Deploy this Worker to bypass CORS and forward Notion requests.</p>
                <ol class="list-decimal pl-6 space-y-2">
                    <li>Open <a class="text-dull-purple underline" href="https://workers.cloudflare.com/"
                            target="_blank">Cloudflare Workers</a> and create a new Worker.</li>
                    <li>Replace its contents with the code below, save, and deploy.</li>
                    <li>(Optional) Add variable <code>ALL_CORS_PROXY_MATCH_TOKEN</code> to require a token.</li>
                    <li>Paste the Worker URL into Settings.</li>
                </ol>
                <div class="relative">
                    <button id="copyWorkerCode"
                        class="absolute top-2 right-2 bg-white/80 hover:bg-white px-2 py-1 rounded text-xs shadow text-charcoal font-bold">Copy</button>
                    <pre id="workerCodeBlock"
                        class="bg-charcoal text-white-linen p-4 rounded text-xs font-mono overflow-x-auto">
const NOTION_API_END_POINT = "https://api.notion.com/v1";

export default {
  async fetch(request, env) {
    return await handleRequest(request, env);
  }
};

function corsHeaders(request) {
  return {
    "Access-Control-Allow-Origin": request.headers.get("Origin") || "*",
    "Access-Control-Allow-Methods": "GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization, Notion-Version",
  };
}

function handleOptions(request) {
  return new Response(null, { headers: corsHeaders(request) });
}

async function handleRequest(request, env) {
  if (request.method === "OPTIONS") return handleOptions(request);

  const url = new URL(request.url);
  const requiredToken = (env.ALL_CORS_PROXY_MATCH_TOKEN || "").trim();
  if (requiredToken) {
    const provided = url.searchParams.get("token");
    if (provided !== requiredToken) return new Response("Unauthorized", { status: 403 });
    url.searchParams.delete("token");
  }

  const isGeneral = url.searchParams.has("url");
  let targetUrl;
  if (isGeneral) {
    targetUrl = url.searchParams.get("url");
    url.searchParams.delete("url");
    try { targetUrl = new URL(targetUrl).toString(); } catch (err) { return new Response("Invalid target URL", { status: 400 }); }
  } else {
    const secretKey = url.searchParams.get("secret");
    if (!secretKey) return new Response("Missing secret key parameter", { status: 400 });
    url.searchParams.delete("secret");
    const base = NOTION_API_END_POINT.replace(/\/$/, "");
    const path = url.pathname.startsWith("/") ? url.pathname : "/" + url.pathname;
    targetUrl = base + path + url.search;
    request = new Request(targetUrl, request);
    request.headers.set("Authorization", `Bearer ${secretKey}`);
    request.headers.set("Notion-Version", "2025-09-03");
  }

  const proxied = new Request(targetUrl, request);
  proxied.headers.set("Origin", new URL(targetUrl).origin);

  const response = await fetch(proxied);
  const out = new Response(response.body, response);
  out.headers.set("Access-Control-Allow-Origin", request.headers.get("Origin") || "*");
  out.headers.append("Vary", "Origin");
  return out;
}
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Deck modal -->
    <div id="deckModal" role="dialog" aria-modal="true" aria-labelledby="deckModalTitle"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4">
        <div class="card rounded-2xl p-5 w-full max-w-md shadow-soft">
            <div class="flex items-center justify-between mb-3">
                <h3 class="font-display text-lg text-charcoal" id="deckModalTitle">New deck</h3>
                <button id="closeDeckModal" aria-label="Close deck modal"
                    class="text-earth-metal/60 hover:text-charcoal"><i data-lucide="x" class="w-5 h-5"></i></button>
            </div>
            <div class="space-y-3 text-sm">
                <input id="deckNameInput" type="text" placeholder="Deck name"
                    class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                <div>
                    <label class="text-xs text-earth-metal/70">Algorithm</label>
                    <select id="deckAlgoInput"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                        <option>SM-2</option>
                        <option>FSRS</option>
                    </select>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="text-xs text-earth-metal/70">Daily review limit</label>
                        <input id="deckReviewLimit" type="number"
                            class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"
                            value="50">
                    </div>
                    <div>
                        <label class="text-xs text-earth-metal/70">New card limit</label>
                        <input id="deckNewLimit" type="number"
                            class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"
                            value="20">
                    </div>
                </div>
                <label class="flex items-center gap-2 text-sm">
                    <input id="deckOrderedInput" type="checkbox" class="accent-dull-purple">
                    <span>Ordered (keep original insertion order)</span>
                </label>
                <label class="flex items-center gap-2 text-sm">
                    <input id="deckReverseInput" type="checkbox" class="accent-dull-purple">
                    <span>Reverse mode enabled</span>
                </label>
                <div>
                    <label class="text-xs text-earth-metal/70">AI revision prompt (optional)</label>
                    <textarea id="deckPromptInput" rows="3"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"
                        placeholder="Use {{question}} {{answer}} {{user}} placeholders"></textarea>
                    <div class="flex flex-wrap gap-2 mt-2 text-[11px] text-earth-metal/60">
                        <span
                            class="px-2 py-1 rounded-lg bg-oatmeal-dark/50 italic text-dull-purple">{{question}}</span>
                        <span class="px-2 py-1 rounded-lg bg-oatmeal-dark/50 italic text-dull-purple">{{answer}}</span>
                        <span class="px-2 py-1 rounded-lg bg-oatmeal-dark/50 italic text-dull-purple">{{user}}</span>
                        <span class="px-2 py-1 rounded-lg bg-oatmeal-dark/50 text-earth-metal/70">Variables replace
                            question, correct answer, and learner answer.</span>
                    </div>
                </div>
            </div>
            <div class="flex justify-end gap-2 mt-4">
                <button id="archiveDeckBtn"
                    class="px-3 py-2 rounded-xl border border-earth-metal/40 text-earth-metal text-sm hidden">Archive
                    deck</button>
                <button id="deleteDeckBtn"
                    class="px-3 py-2 rounded-xl border border-muted-pink text-muted-pink text-sm hidden">Delete
                    deck</button>
                <button id="saveDeckBtn"
                    class="px-4 py-2 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1]">Save</button>
            </div>
        </div>
    </div>

    <!-- Card modal -->
    <div id="cardModal" role="dialog" aria-modal="true" aria-labelledby="cardModalTitle"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4 z-50">
        <div class="card rounded-2xl p-5 w-full max-w-2xl shadow-soft max-h-[90vh] overflow-y-auto">
            <div class="flex items-center justify-between mb-3">
                <h3 class="font-display text-lg text-charcoal" id="cardModalTitle">New card</h3>
                <button id="closeCardModal" aria-label="Close card modal"
                    class="text-earth-metal/60 hover:text-charcoal"><i data-lucide="x" class="w-5 h-5"></i></button>
            </div>
            <p class="text-[10px] text-earth-metal/50 mb-2">Editing Name, Back, or Notes will remove Notion text colors
                and highlights on sync</p>
            <div class="grid md:grid-cols-2 gap-4 text-sm">
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Deck</label>
                    <select id="cardDeckInput"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"></select>
                </div>
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Card type</label>
                    <select id="cardTypeInput"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                        <option value="Front-Back">Front / Back</option>
                        <option value="Cloze">Cloze</option>
                    </select>
                </div>
                <div class="md:col-span-2 space-y-2">
                    <label class="text-xs text-earth-metal/70">Name</label>
                    <textarea id="cardNameInput" rows="3"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"></textarea>
                </div>
                <div id="cardBackSection" class="md:col-span-2 space-y-2">
                    <label class="text-xs text-earth-metal/70">Back</label>
                    <textarea id="cardBackInput" rows="4"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"></textarea>
                </div>
                <div class="md:col-span-2 space-y-2">
                    <label class="text-xs text-earth-metal/70">Notes (markdown)</label>
                    <textarea id="cardNotesInput" rows="3" placeholder="Add notes for this card..."
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2"></textarea>
                </div>
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Tags (comma)</label>
                    <input id="cardTagsInput" type="text"
                        class="w-full rounded-xl border border-oatmeal-dark/70 bg-[var(--surface)] dark:bg-white/5 px-3 py-2">
                </div>
                <div class="space-y-2">
                    <label class="text-xs text-earth-metal/70">Suspended / Leech</label>
                    <div class="flex gap-4">
                        <label class="flex items-center gap-2"><input id="cardSuspendedInput" type="checkbox"
                                class="accent-dull-purple"> Suspended</label>
                        <label class="flex items-center gap-2"><input id="cardLeechInput" type="checkbox"
                                class="accent-dull-purple"> Leech</label>
                    </div>
                </div>
            </div>
            <!-- Review History Section (shown when editing existing card) -->
            <div id="cardReviewHistorySection" class="mt-4 hidden">
                <details class="group">
                    <summary class="text-xs text-earth-metal/70 cursor-pointer select-none flex items-center gap-1">
                        <i data-lucide="chevron-right" class="w-3 h-3 group-open:rotate-90 transition-transform"></i>
                        Review History (<span id="cardReviewHistoryCount">0</span>)
                    </summary>
                    <div id="cardReviewHistoryTable"
                        class="mt-2 max-h-40 overflow-y-auto border border-charcoal/10 rounded-lg"></div>
                </details>
            </div>
            <div class="flex justify-end gap-2 mt-4">
                <button id="deleteCardBtn"
                    class="px-3 py-2 rounded-xl border border-muted-pink text-muted-pink text-sm hidden">Delete
                    card</button>
                <button id="saveCardBtn"
                    class="px-4 py-2 rounded-xl bg-charcoal dark:bg-white/10 dark:border-white/10 dark:border text-white text-sm hover:bg-earth-metal dark:hover:bg-white/20">Save</button>
            </div>
        </div>
    </div>

    <!-- AI Settings Required Modal -->
    <div id="aiSettingsRequiredModal"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4 z-50">
        <div class="card rounded-2xl p-5 w-full max-w-md shadow-soft text-center space-y-4">
            <div class="w-12 h-12 rounded-full bg-dull-purple/20 flex items-center justify-center mx-auto">
                <i data-lucide="bot" class="w-6 h-6 text-dull-purple"></i>
            </div>
            <h3 class="font-display text-lg text-charcoal">AI Settings Required</h3>
            <p class="text-sm text-earth-metal/70">To use AI mode, you need to configure and verify your AI provider
                settings first.</p>
            <div class="flex gap-2 justify-center">
                <button id="closeAiSettingsModal"
                    class="px-4 py-2 rounded-xl border border-oatmeal-dark text-earth-metal text-sm">Cancel</button>
                <button id="openSettingsFromAiModal"
                    class="px-4 py-2 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1]">Open
                    Settings</button>
            </div>
        </div>
    </div>

    <!-- Notes Edit Modal -->
    <div id="notesModal" role="dialog" aria-modal="true" aria-labelledby="notesModalTitle"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4 z-50">
        <div class="card rounded-2xl p-5 w-full max-w-lg shadow-soft space-y-4 max-h-[90vh] flex flex-col">
            <div class="flex items-center justify-between">
                <h3 id="notesModalTitle" class="font-display text-lg text-charcoal">Edit Notes</h3>
                <button id="closeNotesModal" aria-label="Close notes modal"
                    class="p-1.5 rounded-lg hover:bg-oatmeal text-earth-metal">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            <p class="text-xs text-earth-metal/70">Write notes in Markdown format. They will be synced to Notion.</p>
            <textarea id="notesArea" rows="12"
                class="flex-1 w-full rounded-xl border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm font-mono resize-none focus:outline-none focus:ring-2 focus:ring-dull-purple/40"
                placeholder="Add notes for this card..."></textarea>
            <div class="flex items-center justify-between">
                <span id="noteStatus" class="text-xs text-earth-metal/60"></span>
                <div class="flex gap-2">
                    <button id="cancelNotesBtn"
                        class="px-4 py-2 rounded-xl border border-oatmeal-dark text-earth-metal text-sm">Cancel</button>
                    <button id="saveNotesBtn"
                        class="px-4 py-2 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1]">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Reset Confirmation Modal -->
    <div id="resetConfirmModal"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4 z-50">
        <div class="card rounded-2xl p-5 w-full max-w-sm shadow-soft">
            <div class="flex items-center gap-3 mb-3">
                <div class="p-2 rounded-full bg-muted-pink/20">
                    <i data-lucide="alert-triangle" class="w-5 h-5 text-muted-pink"></i>
                </div>
                <h3 class="font-display text-lg text-charcoal">Reset GhostInk?</h3>
            </div>
            <p class="text-sm text-earth-metal/70 mb-4">This will permanently delete all local data including decks,
                cards, settings, and study session. This cannot be undone.</p>
            <div class="flex justify-end gap-2">
                <button id="cancelReset"
                    class="px-4 py-2 rounded-xl border border-oatmeal-dark text-earth-metal text-sm">Cancel</button>
                <button id="confirmReset"
                    class="px-4 py-2 rounded-xl bg-muted-pink text-white text-sm hover:bg-muted-pink/90">Reset</button>
            </div>
        </div>
    </div>

    <!-- Add Block Note Modal -->
    <div id="addBlockModal"
        class="fixed inset-0 bg-black/40 backdrop-blur-sm hidden items-center justify-center p-4 z-50">
        <div class="card rounded-2xl p-5 w-full max-w-lg shadow-soft space-y-4 max-h-[90vh] flex flex-col">
            <div class="flex items-center justify-between">
                <h3 class="font-display text-lg text-charcoal">Add Note to Page</h3>
                <button id="closeAddBlockModal" class="p-1.5 rounded-lg hover:bg-oatmeal text-earth-metal">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            <p class="text-xs text-earth-metal/70">This will be appended as a new paragraph on the Notion page with a
                timestamp.</p>
            <textarea id="blockNoteArea" rows="8"
                class="flex-1 w-full rounded-xl border border-oatmeal-dark/60 bg-[var(--surface)] dark:bg-white/5 px-3 py-2 text-sm font-mono resize-none focus:outline-none focus:ring-2 focus:ring-dull-purple/40"
                placeholder="Write in Markdown..."></textarea>
            <div class="flex items-center justify-end gap-2">
                <button id="cancelAddBlockBtn"
                    class="px-4 py-2 rounded-xl border border-oatmeal-dark text-earth-metal text-sm">Cancel</button>
                <button id="saveAddBlockBtn"
                    class="px-4 py-2 rounded-xl bg-dull-purple text-white text-sm hover:bg-[#7d6aa1]">Add to
                    Page</button>
            </div>
        </div>
    </div>

    <script>
        // Configure marked to open all links in new tab
        const renderer = new marked.Renderer();
        const originalLinkRenderer = renderer.link.bind(renderer);
        renderer.link = (href, title, text) => {
            const html = originalLinkRenderer(href, title, text);
            return html.replace('<a ', '<a target="_blank" rel="noopener noreferrer" ');
        };
        marked.setOptions({ renderer });

        const el = (sel) => document.querySelector(sel);
        const escapeHtml = (str) => {
            if (!str) return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        };
        const toast = (msg) => {
            const t = el('#toast');
            t.textContent = msg;
            t.classList.remove('hidden', 'opacity-0');
            setTimeout(() => t.classList.add('opacity-0'), 2500);
            setTimeout(() => t.classList.add('hidden'), 3000);
        };
        const toastLong = (msg) => {
            const t = el('#toast');
            t.textContent = msg;
            t.classList.remove('hidden', 'opacity-0');
        };
        const toastHide = () => {
            const t = el('#toast');
            t.classList.add('opacity-0');
            setTimeout(() => t.classList.add('hidden'), 500);
        };
        const showLoading = (msg = 'Loading...', subtext = '') => {
            const ov = el('#loadingOverlay');
            const lm = el('#loadingMessage');
            const ls = el('#loadingSubtext');
            if (lm) lm.textContent = msg;
            if (ls) ls.textContent = subtext;
            ov.classList.remove('hidden');
            ov.classList.add('flex');
        };
        const hideLoading = () => {
            const ov = el('#loadingOverlay');
            ov.classList.add('hidden');
            ov.classList.remove('flex');
        };
        const Tooltip = {
            timer: null,
            lastShown: null,
            el: null,
            ensure() { this.el = this.el || document.querySelector('#tooltip'); return this.el; },
            show(target) {
                const tip = target.dataset.tip;
                if (!tip) return;
                const node = this.ensure();
                node.textContent = tip;
                const rect = target.getBoundingClientRect();
                const x = rect.left + rect.width / 2;
                const y = rect.top - 8;
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                node.style.transform = 'translate(-50%, -100%)';
                node.classList.remove('hidden');
                this.lastShown = target;
            },
            hide() {
                const node = this.ensure();
                node.classList.add('hidden');
                this.lastShown = null;
            },
            bind() {
                document.addEventListener('mouseover', (e) => {
                    const t = e.target.closest('[data-tip]');
                    if (!t) return;
                    if (this.lastShown) { this.show(t); return; }
                    clearTimeout(this.timer);
                    this.timer = setTimeout(() => this.show(t), 160);
                });
                document.addEventListener('mouseout', (e) => {
                    if (!e.relatedTarget || !e.relatedTarget.closest('[data-tip]')) {
                        clearTimeout(this.timer);
                        this.hide();
                    }
                });
                document.addEventListener('focusin', (e) => {
                    const t = e.target.closest('[data-tip]');
                    if (t) this.show(t);
                });
                document.addEventListener('focusout', () => this.hide());
            }
        };

        const SYNC_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes background tick
        const MIN_PULL_INTERVAL_MS = 3 * 60 * 1000; // pull at most every 3 minutes
        const MIN_PUSH_INTERVAL_MS = 60 * 1000; // push at most every minute

        const Storage = {
            db: null,
            settingsKey: 'ghostink_settings_v1',
            sqlReady: null,
            async init() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open('GhostInkDB', 2);
                    req.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('decks')) db.createObjectStore('decks', { keyPath: 'id' });
                        if (!db.objectStoreNames.contains('cards')) db.createObjectStore('cards', { keyPath: 'id' });
                        if (!db.objectStoreNames.contains('meta')) db.createObjectStore('meta', { keyPath: 'key' });
                    };
                    req.onsuccess = (e) => {
                        this.db = e.target.result;
                        // Listen for version change (another tab is resetting/upgrading)
                        this.db.onversionchange = () => {
                            this.db.close();
                            this.db = null;
                            // Reload this tab since the database is being reset
                            location.reload();
                        };
                        resolve();
                    };
                    req.onerror = reject;
                });
            },
            tx(store, mode = 'readonly') {
                return this.db.transaction(store, mode).objectStore(store);
            },
            async getAll(store) {
                return new Promise((resolve, reject) => {
                    const req = this.tx(store).getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = reject;
                });
            },
            async getMeta(key) {
                return new Promise((resolve, reject) => {
                    const req = this.tx('meta').get(key);
                    req.onsuccess = () => resolve(req.result ? req.result.value : null);
                    req.onerror = reject;
                });
            },
            async setMeta(key, value) {
                return new Promise((resolve, reject) => {
                    const req = this.tx('meta', 'readwrite').put({ key, value });
                    req.onsuccess = resolve;
                    req.onerror = reject;
                });
            },
            async put(store, value) {
                return new Promise((resolve, reject) => {
                    const req = this.tx(store, 'readwrite').put(value);
                    req.onsuccess = resolve;
                    req.onerror = reject;
                });
            },
            async delete(store, key) {
                return new Promise((resolve, reject) => {
                    const req = this.tx(store, 'readwrite').delete(key);
                    req.onsuccess = resolve;
                    req.onerror = reject;
                });
            },
            async wipeStore(store) {
                return new Promise((resolve, reject) => {
                    const req = this.tx(store, 'readwrite').clear();
                    req.onsuccess = resolve;
                    req.onerror = reject;
                });
            },
            getSettings() {
                const raw = localStorage.getItem(this.settingsKey);
                if (!raw) {
                    return { workerUrl: '', proxyToken: '', authToken: '', deckSource: '', cardSource: '', aiProvider: '', aiModel: '', aiKey: '', sttProvider: '', sttModel: '', sttKey: '', sttPrompt: '', sttVerified: false, themeMode: 'system', fontMode: 'serif', workerVerified: false, authVerified: false, sourcesVerified: false, aiVerified: false, sourcesCache: { deckOptions: [], cardOptions: [] } };
                }
                try {
                    return JSON.parse(raw);
                } catch (e) {
                    console.error('Failed to parse settings, resetting to defaults:', e);
                    return { workerUrl: '', proxyToken: '', authToken: '', deckSource: '', cardSource: '', aiProvider: '', aiModel: '', aiKey: '', sttProvider: '', sttModel: '', sttKey: '', sttPrompt: '', sttVerified: false, themeMode: 'system', fontMode: 'serif', workerVerified: false, authVerified: false, sourcesVerified: false, aiVerified: false, sourcesCache: { deckOptions: [], cardOptions: [] } };
                }
            },
            setSettings(newSettings) {
                localStorage.setItem(this.settingsKey, JSON.stringify(newSettings));
            },
            getSession() {
                const raw = localStorage.getItem('ghostink_session_v1');
                return raw ? JSON.parse(raw) : null;
            },
            setSession(session) {
                if (session) {
                    localStorage.setItem('ghostink_session_v1', JSON.stringify(session));
                } else {
                    localStorage.removeItem('ghostink_session_v1');
                }
            },
            async ensureSQL() {
                if (this.sqlReady) return this.sqlReady;
                this.sqlReady = window.initSqlJs({ locateFile: (file) => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.2/${file}` });
                return this.sqlReady;
            }
        };

        const API = {
            async request(method, endpoint, body = null, override = null) {
                const { workerUrl, authToken, proxyToken } = override || Storage.getSettings();
                if (!workerUrl || !authToken) throw new Error('Missing worker URL or Notion token');
                const cleanWorker = workerUrl.trim().replace(/\/$/, '');
                const fetchUrl = new URL(cleanWorker);
                fetchUrl.searchParams.append('url', `https://api.notion.com/v1${endpoint}`);
                if (proxyToken) fetchUrl.searchParams.append('token', proxyToken.trim());
                const headers = { 'Authorization': `Bearer ${authToken.trim()}`, 'Notion-Version': '2025-09-03' };
                let payload = body;
                if (body && !(body instanceof FormData)) {
                    headers['Content-Type'] = 'application/json';
                    payload = JSON.stringify(body);
                }
                const res = await fetch(fetchUrl.toString(), { method, headers, body: payload });
                if (!res.ok) {
                    let txt = await res.text();
                    try {
                        const j = JSON.parse(txt);
                        txt = j.message || txt;
                    } catch (_) { }
                    throw new Error(txt || `Request failed ${res.status}`);
                }
                return await res.json();
            },
            async listDatabases() {
                const results = [];
                let cursor = null;
                let hasMore = true;
                while (hasMore) {
                    const body = { filter: { value: 'data_source', property: 'object' } };
                    if (cursor) body.start_cursor = cursor;
                    const res = await API.request('POST', '/search', body);
                    results.push(...res.results);
                    hasMore = res.has_more;
                    cursor = res.next_cursor;
                }
                return results;
            },
            async queryDatabase(dbId, filter = null) {
                const rows = [];
                let cursor = null;
                let hasMore = true;
                while (hasMore) {
                    const body = { page_size: 100 }; // Notion max page size
                    if (cursor) body.start_cursor = cursor;
                    if (filter) {
                        body.filter = filter;
                    }
                    const res = await API.request('POST', `/data_sources/${dbId}/query`, body);
                    rows.push(...res.results);
                    hasMore = res.has_more;
                    cursor = res.next_cursor;
                }
                return rows;
            },
            async getDatabase(dbId) {
                return API.request('GET', `/data_sources/${dbId}`);
            },
            async createPage(dbId, properties) {
                return API.request('POST', '/pages', { parent: { data_source_id: dbId }, properties });
            },
            async updatePage(pageId, properties) {
                return API.request('PATCH', `/pages/${pageId}`, { properties });
            },
            async archivePage(pageId) {
                return API.request('PATCH', `/pages/${pageId}`, { archived: true });
            },
            async appendBlocks(pageId, children) {
                return API.request('PATCH', `/blocks/${pageId}/children`, { children });
            }
        };

        /**
         * SRS (Spaced Repetition System) algorithms for flashcard scheduling.
         * Contains implementations of FSRS v4 and SM-2 algorithms.
         */
        const SRS = {
            /**
             * FSRS (Free Spaced Repetition Scheduler) v4 algorithm.
             * Calculates new difficulty, stability, and next review date based on user rating.
             * @param {Object} card - The card being reviewed
             * @param {Object} card.fsrs - FSRS state (difficulty, stability, lastReview, etc.)
             * @param {string} rating - User rating: 'again', 'hard', 'good', or 'easy'
             * @returns {Object} Updated FSRS state with new difficulty, stability, retrievability, dueDate
             */
            fsrs(card, rating) {
                const now = new Date();
                const ratingName = rating;
                const lastD = card.fsrs?.difficulty ?? initDifficulty('good');
                const lastS = card.fsrs?.stability ?? initStability('good');
                const lastReview = card.fsrs?.lastReview ? new Date(card.fsrs.lastReview) : null;
                const isNew = !lastReview;
                let newD, newS, retr;
                if (isNew) {
                    newD = initDifficulty(ratingName);
                    newS = initStability(ratingName);
                    retr = REQUEST_RETENTION;
                } else {
                    const elapsed = Math.max(0.01, (now - lastReview) / 86400000);
                    const r = forgettingCurve(elapsed, lastS);
                    newD = nextDifficulty(lastD, ratingName);
                    if (ratingName === 'again') newS = nextForgetStability(lastD, lastS, r);
                    else newS = nextRecallStability(newD, lastS, r, ratingName);
                    retr = REQUEST_RETENTION;
                }
                const intervalDays = nextInterval(newS);
                return {
                    difficulty: newD,
                    stability: newS,
                    retrievability: retr,
                    lastRating: ratingName,
                    lastReview: now.toISOString(),
                    dueDate: new Date(now.getTime() + intervalDays * 86400000).toISOString()
                };
            },
            /**
             * SM-2 (SuperMemo 2) algorithm for spaced repetition.
             * Updates ease factor and interval based on user rating.
             * @param {Object} card - The card being reviewed
             * @param {Object} card.sm2 - SM-2 state (easeFactor, interval, repetitions, etc.)
             * @param {string} rating - User rating: 'again', 'hard', 'good', or 'easy'
             * @returns {Object} Updated SM-2 state with new easeFactor, interval, dueDate
             */
            sm2(card, rating) {
                const now = new Date();
                const ease = card.sm2?.easeFactor ?? 2.5;
                const interval = card.sm2?.interval ?? 0;
                const repetitions = card.sm2?.repetitions ?? 0;
                // Map ratings to SM-2 quality grades (0-5 scale)
                // again=0 (complete blackout), hard=3 (correct with difficulty), good=4 (correct), easy=5 (perfect)
                const grade = { again: 0, hard: 3, good: 4, easy: 5 }[rating] ?? 4;

                let newEase, newInterval, newReps;

                if (grade < 3) {
                    // Failed recall - reset to beginning
                    newReps = 0;
                    newInterval = 1;
                    newEase = ease; // EF unchanged on failure per original SM-2
                } else {
                    // Successful recall
                    newReps = repetitions + 1;
                    // Update ease factor: EF' = EF + (0.1 - (5 - q) * (0.08 + (5 - q) * 0.02))
                    newEase = Math.max(1.3, ease + (0.1 - (5 - grade) * (0.08 + (5 - grade) * 0.02)));

                    // Calculate interval based on repetition count
                    if (newReps === 1) {
                        newInterval = 1;
                    } else if (newReps === 2) {
                        newInterval = 6;
                    } else {
                        newInterval = Math.round(interval * newEase);
                    }
                }

                return {
                    easeFactor: newEase,
                    interval: newInterval,
                    repetitions: newReps,
                    dueDate: new Date(now.getTime() + newInterval * 86400000).toISOString(),
                    lastRating: rating,
                    lastReview: now.toISOString()
                };
            }
        };

        const normalizeRating = (name) => name ? name.toLowerCase() : null;
        const displayRating = (name) => name ? name.charAt(0).toUpperCase() + name.slice(1).toLowerCase() : null;
        const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
        const hexToRgb = (hex) => {
            const h = hex.replace('#', '');
            if (h.length === 3) return { r: parseInt(h[0] + h[0], 16), g: parseInt(h[1] + h[1], 16), b: parseInt(h[2] + h[2], 16) };
            return { r: parseInt(h.slice(0, 2), 16), g: parseInt(h.slice(2, 4), 16), b: parseInt(h.slice(4, 6), 16) };
        };
        const rgbToHex = ({ r, g, b }) => '#' + [r, g, b].map(x => clamp(Math.round(x), 0, 255).toString(16).padStart(2, '0')).join('');
        const mix = (c1, c2, t) => {
            const a = hexToRgb(c1);
            const b = hexToRgb(c2);
            return rgbToHex({ r: a.r + (b.r - a.r) * t, g: a.g + (b.g - a.g) * t, b: a.b + (b.b - a.b) * t });
        };
        const detectCardType = (name = '', back = '') => {
            const text = `${name} ${back}`.toLowerCase();
            const hasCloze = /\{\{c\d+::.+?\}\}/i.test(text);
            if (hasCloze) return 'Cloze';
            return 'Front-Back';
        };
        // FSRS constants (v4.11 defaults)
        // fsrsW: weight parameters optimized for memory retention modeling
        const fsrsW = [0.4, 0.6, 2.4, 5.8, 4.93, 0.94, 0.86, 0.01, 1.49, 0.14, 0.94, 2.18, 0.05, 0.34, 1.26, 0.29, 2.61];
        const DECAY = -0.5;
        const FACTOR = Math.pow(0.9, 1 / DECAY) - 1; // derived from requestRetention 0.9
        const REQUEST_RETENTION = 0.9; // target probability of recall
        const MAX_INTERVAL = 36500; // ~100 years maximum interval
        const ratingsMap = { again: 1, hard: 2, good: 3, easy: 4 };
        const clamp2 = (n) => +Number.isFinite(n) ? Math.max(0, Math.round(n * 100) / 100) : 0;
        const constrainDifficulty = (d) => Math.min(Math.max(+d.toFixed(2), 1), 10);
        const meanReversion = (init, current) => fsrsW[7] * init + (1 - fsrsW[7]) * current;

        /** Calculate initial difficulty for a new card based on first rating */
        const initDifficulty = (ratingName) => {
            const r = ratingsMap[ratingName] || 3;
            return constrainDifficulty(fsrsW[4] - fsrsW[5] * (r - 3));
        };
        /** Calculate initial stability for a new card based on first rating */
        const initStability = (ratingName) => {
            const r = ratingsMap[ratingName] || 3;
            return +Math.max(fsrsW[r - 1], 0.1).toFixed(2);
        };
        /** Calculate probability of recall using the forgetting curve formula */
        const forgettingCurve = (elapsedDays, stability) => Math.pow(1 + FACTOR * elapsedDays / stability, DECAY);
        /** Calculate next review interval in days based on stability */
        const nextInterval = (stability) => {
            const raw = stability / FACTOR * (Math.pow(REQUEST_RETENTION, 1 / DECAY) - 1);
            const rounded = Math.min(Math.max(Math.round(raw), 1), MAX_INTERVAL);
            return rounded;
        };
        /** Update difficulty after a review (applies mean reversion) */
        const nextDifficulty = (d, ratingName) => {
            const r = ratingsMap[ratingName] || 3;
            const next_d = d - fsrsW[6] * (r - 3);
            return constrainDifficulty(meanReversion(fsrsW[4], next_d));
        };
        /** Calculate new stability after successful recall */
        const nextRecallStability = (d, s, r, ratingName) => {
            const hardPenalty = ratingName === 'hard' ? fsrsW[15] : 1;
            const easyBonus = ratingName === 'easy' ? fsrsW[16] : 1;
            const val = s * (1 + Math.exp(fsrsW[8]) * (11 - d) * Math.pow(s, -fsrsW[9]) * (Math.exp((1 - r) * fsrsW[10]) - 1) * hardPenalty * easyBonus);
            return clamp2(val);
        };
        /** Calculate new stability after forgetting (rated 'again') */
        const nextForgetStability = (d, s, r) => {
            const val = Math.min(
                fsrsW[11] * Math.pow(d, -fsrsW[12]) * (Math.pow(s + 1, fsrsW[13]) - 1) * Math.exp((1 - r) * fsrsW[14]),
                s
            );
            return clamp2(val);
        };
        const toRichTextChunks = (text) => {
            const str = (text || '').toString();
            if (!str) return [];
            const MAX_CHARS = 2000;
            const MAX_ITEMS = 100;
            const chunks = [];
            for (let i = 0; i < str.length && chunks.length < MAX_ITEMS; i += MAX_CHARS) {
                chunks.push({ text: { content: str.slice(i, i + MAX_CHARS) } });
            }
            return chunks;
        };
        // Compact review history format: "g1702473000,h1702559400,a1702645800"
        // Rating codes: a=again, h=hard, g=good, e=easy
        // Timestamp: Unix epoch seconds
        const compactReviewHistory = (history) => {
            if (!history || !history.length) return '';
            const ratingCodes = { again: 'a', hard: 'h', good: 'g', easy: 'e' };
            return history.map(entry => {
                const code = ratingCodes[entry.rating] || 'g';
                const ts = Math.floor(new Date(entry.at).getTime() / 1000);
                return `${code}${ts}`;
            }).join(',');
        };
        const parseReviewHistory = (compact) => {
            if (!compact || typeof compact !== 'string') return [];
            // Handle legacy JSON format
            if (compact.startsWith('[')) {
                try { return JSON.parse(compact); } catch { return []; }
            }
            const ratingNames = { a: 'again', h: 'hard', g: 'good', e: 'easy' };
            return compact.split(',').filter(Boolean).map(entry => {
                const code = entry[0];
                const ts = parseInt(entry.slice(1), 10);
                return {
                    rating: ratingNames[code] || 'good',
                    at: new Date(ts * 1000).toISOString()
                };
            });
        };
        const richToMarkdown = (arr = []) => {
            return (arr || []).map(rt => {
                if (!rt) return '';
                const a = rt.annotations || {};
                let s = '';
                if (rt.type === 'equation' && rt.equation?.expression) {
                    s = `<span class="notion-equation">${rt.equation.expression}</span>`;
                } else {
                    const t = rt.plain_text || '';
                    if (!t) return '';
                    if (rt.href) s = `[${t}](${rt.href})`; else s = t;
                    if (a.code) s = '`' + s + '`';
                    if (a.bold) s = '**' + s + '**';
                    if (a.italic) s = '*' + s + '*';
                    if (a.strikethrough) s = '~~' + s + '~~';
                    if (a.underline) s = '__' + s + '__';
                    if (a.color && a.color !== 'default') {
                        s = `<span class="notion-color-${a.color.replace('_', '-')}">${s}</span>`;
                    }
                }
                return s;
            }).join('');
        };

        // Convert markdown to Notion rich_text array with annotations
        const markdownToNotionRichText = (markdown) => {
            if (!markdown) return [];
            const str = markdown.toString();
            if (!str) return [];

            const result = [];

            // Combined regex to find all patterns including equations and Notion colors
            // Order: equations, colors, bold, italic, code, strikethrough, links
            const tokenRegex = /(<span class="notion-equation">(.+?)<\/span>)|(<span class="notion-color-([a-z-]+)">(.+?)<\/span>)|(\*\*(.+?)\*\*)|(\*(.+?)\*)|(`(.+?)`)|(\~\~(.+?)\~\~)|(\[(.+?)\]\((.+?)\))/g;

            let lastIndex = 0;
            let match;

            while ((match = tokenRegex.exec(str)) !== null) {
                // Add plain text before this match
                if (match.index > lastIndex) {
                    const plainText = str.slice(lastIndex, match.index);
                    if (plainText) {
                        result.push({ type: 'text', text: { content: plainText } });
                    }
                }

                // Determine which pattern matched
                if (match[1]) {
                    // Equation: <span class="notion-equation">expr</span>
                    result.push({
                        type: 'equation',
                        equation: { expression: match[2] }
                    });
                } else if (match[3]) {
                    // Notion color: <span class="notion-color-*">text</span>
                    // Convert color class back to Notion color name (e.g., "purple-background" -> "purple_background")
                    const colorClass = match[4].replace(/-/g, '_');
                    result.push({
                        type: 'text',
                        text: { content: match[5] },
                        annotations: { color: colorClass }
                    });
                } else if (match[6]) {
                    // Bold: **text**
                    result.push({
                        type: 'text',
                        text: { content: match[7] },
                        annotations: { bold: true }
                    });
                } else if (match[8]) {
                    // Italic: *text*
                    result.push({
                        type: 'text',
                        text: { content: match[9] },
                        annotations: { italic: true }
                    });
                } else if (match[10]) {
                    // Code: `text`
                    result.push({
                        type: 'text',
                        text: { content: match[11] },
                        annotations: { code: true }
                    });
                } else if (match[12]) {
                    // Strikethrough: ~~text~~
                    result.push({
                        type: 'text',
                        text: { content: match[13] },
                        annotations: { strikethrough: true }
                    });
                } else if (match[14]) {
                    // Link: [text](url)
                    result.push({
                        type: 'text',
                        text: { content: match[15], link: { url: match[16] } }
                    });
                }

                lastIndex = match.index + match[0].length;
            }

            // Add remaining plain text after last match
            if (lastIndex < str.length) {
                result.push({ type: 'text', text: { content: str.slice(lastIndex) } });
            }

            // If no matches found, return as single plain text chunk
            if (result.length === 0) {
                result.push({ type: 'text', text: { content: str } });
            }

            // Chunk large content (Notion 2000 char limit per rich_text item)
            const chunked = [];
            for (const item of result) {
                const content = item.text?.content || item.equation?.expression || '';
                if (content.length <= 2000) {
                    chunked.push(item);
                } else if (item.type === 'equation') {
                    // Can't chunk equations, just add as-is
                    chunked.push(item);
                } else {
                    // Split large content into chunks, preserving annotations and type
                    for (let i = 0; i < content.length && chunked.length < 100; i += 2000) {
                        chunked.push({
                            type: 'text',
                            text: {
                                content: content.slice(i, i + 2000),
                                link: item.text?.link
                            },
                            annotations: item.annotations
                        });
                    }
                }
            }

            // Notion limits to 100 rich_text items
            return chunked.slice(0, 100);
        };

        /**
         * NotionMapper - Bidirectional mapping between app objects and Notion API format.
         * Handles conversion of decks and cards to/from Notion page properties.
         */
        const DEFAULT_AI_PROMPT = 'You are a strict flashcard grader.\nQuestion: {{question}}\nCorrect answer: {{answer}}\nLearner answer: {{user}}\nJudge correctness (short) and give brief feedback.';

        const NotionMapper = {
            /**
             * Convert a Notion page to an app deck object
             * @param {Object} page - Notion page object from API
             * @returns {Object} Deck object for internal use
             */
            deckFrom(page) {
                const props = page.properties || {};
                const title = props['Deck Name']?.title?.map(t => t.plain_text).join('') || 'Untitled deck';
                return {
                    id: page.id,
                    notionId: page.id,
                    name: title,
                    algorithm: props['Default SRS Algorithm']?.select?.name || 'SM-2',
                    ordered: props['Ordered']?.checkbox ?? false,
                    reviewLimit: props['Daily Review Limit']?.number || 50,
                    newLimit: props['New Card Limit']?.number || 20,
                    reverse: props['Reverse Mode Enabled']?.checkbox || false,
                    createdInApp: props['Created In-App']?.checkbox || false,
                    archived: props['Archived?']?.checkbox || false,
                    ankiMetadata: props['Anki Metadata']?.rich_text?.[0]?.plain_text || '',
                    aiPrompt: props['AI Revision Prompt']?.rich_text?.map(t => t.plain_text).join('') || DEFAULT_AI_PROMPT,
                    updatedInApp: false
                };
            },
            /**
             * Convert an app deck object to Notion page properties
             * @param {Object} deck - App deck object
             * @returns {Object} Notion properties object for API
             */
            deckProps(deck) {
                return {
                    'Deck Name': { title: markdownToNotionRichText(deck.name) },
                    'Default SRS Algorithm': { select: { name: deck.algorithm } },
                    'Ordered': { checkbox: !!deck.ordered },
                    'Daily Review Limit': { number: deck.reviewLimit },
                    'New Card Limit': { number: deck.newLimit },
                    'Reverse Mode Enabled': { checkbox: !!deck.reverse },
                    'Created In-App': { checkbox: true },
                    'Anki Metadata': { rich_text: deck.ankiMetadata ? [{ text: { content: deck.ankiMetadata } }] : [] },
                    'AI Revision Prompt': { rich_text: markdownToNotionRichText(deck.aiPrompt) }
                };
            },
            /**
             * Convert a Notion page to an app card object
             * @param {Object} page - Notion page object from API
             * @param {Array} decks - Array of deck objects for resolving relations
             * @returns {Object} Card object for internal use
             */
            cardFrom(page, decks) {
                const p = page.properties || {};
                const deckRel = p['Deck']?.relation?.[0]?.id || null;
                const name = richToMarkdown(p['Name']?.title) || 'Card';
                const back = richToMarkdown(p['Back']?.rich_text) || '';
                const tags = p['Tags']?.multi_select?.map(t => ({ name: t.name, color: t.color || 'default' })) || [];
                const fsrs = {
                    difficulty: p['Difficulty']?.number ?? initDifficulty('good'),
                    stability: p['Stability']?.number ?? initStability('good'),
                    retrievability: p['Retrievability']?.number ?? 0.9,
                    lastRating: normalizeRating(p['Last Rating']?.select?.name) || null,
                    lastReview: p['Last Review']?.date?.start || null,
                    dueDate: p['Due Date']?.date?.start || null
                };
                const sm2 = {
                    interval: p['Interval / Box Level']?.number ?? 1,
                    easeFactor: p['Ease Factor']?.number ?? 2.5,
                    // Infer repetitions from interval: 1 day = 1 rep, 6 days = 2 reps, else 3+
                    repetitions: (p['Interval / Box Level']?.number ?? 1) <= 1 ? 1 : (p['Interval / Box Level']?.number === 6 ? 2 : 3),
                    dueDate: p['Due Date']?.date?.start || null,
                    lastRating: normalizeRating(p['Last Rating']?.select?.name) || null,
                    lastReview: p['Last Review']?.date?.start || null
                };
                return {
                    id: page.id,
                    notionId: page.id,
                    deckId: deckRel,
                    name,
                    back,
                    type: p['Card Type']?.select?.name || detectCardType(name, back),
                    tags,
                    notes: richToMarkdown(p['Notes']?.rich_text) || '',
                    suspended: p['Suspended']?.checkbox || false,
                    leech: p['Leech']?.checkbox || false,
                    fsrs,
                    sm2,
                    syncId: page.id,
                    updatedInApp: p['Updated In-App']?.checkbox || false,
                    reviewHistory: parseReviewHistory(p['Review History']?.rich_text?.[0]?.plain_text || ''),
                    ankiGuid: p['Anki GUID']?.rich_text?.[0]?.plain_text || '',
                    ankiNoteType: p['Anki Note Type']?.select?.name || '',
                    ankiFields: p['Anki Fields JSON']?.rich_text?.[0]?.plain_text || '',
                    clozeIndexes: p['Cloze Indexes']?.rich_text?.[0]?.plain_text || '',
                    createdAt: page.created_time,
                    // Store original Notion rich_text to preserve colors/equations on sync
                    _notionRichText: {
                        name: p['Name']?.title || [],
                        back: p['Back']?.rich_text || [],
                        notes: p['Notes']?.rich_text || []
                    }
                };
            },
            /**
             * Convert an app card object to Notion page properties.
             * Preserves original rich_text (colors, equations) if content unchanged.
             * @param {Object} card - App card object
             * @param {string|null} notionDeckId - Notion page ID for deck relation
             * @returns {Object} Notion properties object for API
             */
            cardProps(card, notionDeckId = null) {
                // Helper to get rich_text: use original if content unchanged, else convert markdown
                const getRichText = (field, content, originalRichText) => {
                    // If we have original rich_text and content hasn't been edited in app
                    if (originalRichText && originalRichText.length > 0 && !card.updatedInApp) {
                        // Check if content matches original (convert original back to markdown and compare)
                        const originalMarkdown = richToMarkdown(originalRichText);
                        if (content === originalMarkdown) {
                            // Content unchanged - use original rich_text to preserve colors/equations
                            return originalRichText;
                        }
                    }
                    // Content was changed - convert markdown to rich_text (may lose colors)
                    return markdownToNotionRichText(content);
                };

                const orig = card._notionRichText || {};
                return {
                    'Name': { title: getRichText('name', card.name, orig.name) },
                    'Back': { rich_text: getRichText('back', card.back, orig.back) },
                    'Card Type': { select: { name: card.type } },
                    'Deck': notionDeckId ? { relation: [{ id: notionDeckId }] } : { relation: [] },
                    'Tags': { multi_select: card.tags.map(t => ({ name: t.name })) },
                    'Notes': { rich_text: getRichText('notes', card.notes, orig.notes) },
                    'Suspended': { checkbox: !!card.suspended },
                    'Leech': { checkbox: !!card.leech },
                    'Difficulty': { number: card.fsrs?.difficulty ?? 4 },
                    'Stability': { number: card.fsrs?.stability ?? 1 },
                    'Retrievability': { number: card.fsrs?.retrievability ?? 0.9 },
                    'Last Rating': card.fsrs?.lastRating ? { select: { name: displayRating(card.fsrs.lastRating) } } : { select: null },
                    'Last Review': { date: card.fsrs?.lastReview ? { start: card.fsrs.lastReview } : null },
                    'Due Date': { date: card.fsrs?.dueDate ? { start: card.fsrs.dueDate } : null },
                    'Interval / Box Level': { number: card.sm2?.interval ?? 1 },
                    'Ease Factor': { number: card.sm2?.easeFactor ?? 2.5 },
                    'Updated In-App': { checkbox: true },
                    'Review History': { rich_text: toRichTextChunks(compactReviewHistory(card.reviewHistory || [])) },
                    'Anki GUID': card.ankiGuid ? { rich_text: [{ type: 'text', text: { content: card.ankiGuid } }] } : { rich_text: [] },
                    'Anki Note Type': card.ankiNoteType ? { select: { name: card.ankiNoteType } } : { select: null },
                    'Anki Fields JSON': card.ankiFields ? { rich_text: [{ type: 'text', text: { content: card.ankiFields } }] } : { rich_text: [] },
                    'Cloze Indexes': card.clozeIndexes ? { rich_text: [{ type: 'text', text: { content: card.clozeIndexes } }] } : { rich_text: [] }
                };
            }
        };

        const App = {
            state: {
                decks: [],
                cards: [],
                queue: [],
                selectedDeck: null,
                selectedCard: null,
                filters: { again: false, hard: false, addedToday: false, stability: 25, tags: [], suspended: false, leech: false, manual: [], studyDecks: [] },
                cardSearch: '',
                deckSearch: '',
                reverse: false,
                lastSync: null,
                lastPull: null,
                lastPush: null,
                activeTab: 'study',
                settings: Storage.getSettings(),
                sourcesCache: [],
                workerVerified: Storage.getSettings().workerVerified || false,
                authVerified: Storage.getSettings().authVerified || false,
                sourcesVerified: Storage.getSettings().sourcesVerified || false,
                autoSyncTimer: null,
                syncing: false,
                autoScanPending: false,
                answerRevealed: false,
                cardReversed: false,
                studyNonDue: false,
                session: null,  // Active study session (loaded from localStorage)
                sessionReversed: null,  // Pre-computed reverse decision from session
                lastRating: null,  // For undo feature: { cardId, sm2, fsrs, history, rating, sessionIndex }
                undoToastTimeout: null,
                lastFocusedElement: null  // For modal focus management
            },
            async init() {
                showLoading('Preparing app...', 'Loading your decks and cards.');
                await Storage.init();
                await this.loadFromDB();
                this.loadSession();  // Load any active study session
                this.captureOAuth();
                this.bind();
                this.seedIfEmpty();
                this.renderAll();
                await this.autoVerifyWorker();
                window.addEventListener('online', () => this.handleOnline());
                window.addEventListener('offline', () => this.renderConnection());
                this.applyTheme();
                this.applyFontMode();
                if (window.matchMedia) {
                    const mq = window.matchMedia('(prefers-color-scheme: dark)');
                    mq.addEventListener('change', () => this.applyTheme());
                }
                Tooltip.bind();
                this.startAutoSync();
                hideLoading();
            },
            loadSession() {
                this.state.session = Storage.getSession();
            },
            saveSession() {
                Storage.setSession(this.state.session);
            },
            generateCardQueue(deckIds, includeNonDue = false) {
                let cards = this.state.cards.filter(c =>
                    deckIds.includes(c.deckId) &&
                    this.passFilters(c) &&
                    (includeNonDue || this.isDue(c))
                );

                if (cards.length === 0) return [];

                // Get deck settings from first deck
                const deck = this.deckById(deckIds[0]);
                const limit = deck?.reviewLimit || 50;

                if (deck?.ordered) {
                    // Keep original insertion order (fallback to id if createdAt missing)
                    cards.sort((a, b) => {
                        const aKey = a.createdAt || a.id || '';
                        const bKey = b.createdAt || b.id || '';
                        return aKey.localeCompare(bKey);
                    });
                } else {
                    // Shuffle by default
                    for (let i = cards.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [cards[i], cards[j]] = [cards[j], cards[i]];
                    }
                }

                // Apply limit
                cards = cards.slice(0, limit);

                // Pre-compute reverse decisions
                return cards.map(card => {
                    const typeKey = (card.type || '').toLowerCase();
                    const isCloze = typeKey === 'cloze';
                    const isFrontStyle = typeKey.includes('front');
                    // Never reverse cloze cards
                    const shouldReverse = !isCloze && deck?.reverse && isFrontStyle && Math.random() < 0.5;
                    return {
                        cardId: card.id,
                        reversed: shouldReverse
                    };
                });
            },
            startSession() {
                // Default to all decks if none selected
                let deckIds = this.state.filters.studyDecks || [];
                if (deckIds.length === 0) {
                    deckIds = this.state.decks.map(d => d.id);
                }
                if (deckIds.length === 0) {
                    toast('No decks available');
                    return;
                }

                // Check card selection mode (due only vs all)
                const cardSelectionMode = el('#cardSelectionMode')?.value || 'due';
                let revisionMode = el('#revisionMode')?.value || 'manual';

                if (revisionMode === 'ai' && !navigator.onLine) {
                    revisionMode = 'manual';
                    toast('Offline: switched to Manual mode');
                }

                const includeNonDue = cardSelectionMode === 'all';
                const noScheduleChanges = includeNonDue
                    ? (el('#noScheduleChanges')?.checked ?? true)
                    : false;

                const cardQueue = this.generateCardQueue(deckIds, includeNonDue);
                if (cardQueue.length === 0) {
                    toast(includeNonDue ? 'No cards in selected decks' : 'No due cards in selected decks');
                    return;
                }

                const deck = this.deckById(deckIds[0]);
                this.state.session = {
                    id: 'session_' + Date.now(),
                    startedAt: new Date().toISOString(),
                    startTime: Date.now(),
                    deckIds: deckIds,
                    algorithm: deck?.algorithm || 'SM-2',
                    settings: {
                        revisionMode: revisionMode,
                        cardSelectionMode: cardSelectionMode,
                        filters: { ...this.state.filters }
                    },
                    cardQueue: cardQueue,
                    currentIndex: 0,
                    completed: [],
                    skipped: [],
                    studyingNonDue: includeNonDue,
                    ratingCounts: { Again: 0, Hard: 0, Good: 0, Easy: 0 },
                    noScheduleChanges
                };

                this.saveSession();
                this.renderStudy();
                toast(`Session started: ${cardQueue.length} cards`);
            },
            abandonSession() {
                this.state.session = null;
                this.saveSession();
                this.renderStudy();
                toast('Session stopped');
            },
            getSessionCard() {
                const session = this.state.session;
                if (!session || session.currentIndex >= session.cardQueue.length) {
                    return null;
                }
                const queueItem = session.cardQueue[session.currentIndex];
                return {
                    card: this.cardById(queueItem.cardId),
                    reversed: queueItem.reversed
                };
            },
            advanceSession(wasSkipped = false) {
                const session = this.state.session;
                if (!session) return;

                const queueItem = session.cardQueue[session.currentIndex];
                if (queueItem) {
                    if (wasSkipped) {
                        session.skipped.push(queueItem.cardId);
                    } else {
                        session.completed.push(queueItem.cardId);
                    }
                }

                session.currentIndex++;
                this.saveSession();

                // Add fade transition between cards
                const cardFront = el('#cardFront');
                const cardBack = el('#cardBack');
                if (cardFront) cardFront.classList.add('card-transitioning');
                if (cardBack) cardBack.classList.add('card-transitioning');

                setTimeout(() => {
                    // Check if session is complete
                    if (session.currentIndex >= session.cardQueue.length) {
                        this.renderSessionComplete();
                    } else {
                        this.renderStudy();
                    }
                    if (cardFront) cardFront.classList.remove('card-transitioning');
                    if (cardBack) cardBack.classList.remove('card-transitioning');
                }, 150);
            },
            renderSessionComplete() {
                const session = this.state.session;
                if (!session) return;

                const completedCount = session.completed.length;
                const skippedCount = session.skipped.length;

                // Calculate session statistics
                const durationMs = Date.now() - (session.startTime || Date.now());
                const durationMins = Math.round(durationMs / 60000);
                const cardsPerMin = durationMins > 0 ? (completedCount / durationMins).toFixed(1) : completedCount;
                const ratings = session.ratingCounts || { Again: 0, Hard: 0, Good: 0, Easy: 0 };
                const totalRatings = ratings.Again + ratings.Hard + ratings.Good + ratings.Easy;

                // Update session UI to show completion state
                const activeBar = el('#sessionActiveBar');
                const progressText = el('#sessionProgressText');
                if (activeBar) {
                    progressText.textContent = `Study Session - Complete!`;
                }

                // Hide mobile FAB since session is complete (showing stats)
                this.updateMobileFab();

                // Hide all study controls
                const studyControls = el('#studyControls');
                if (studyControls) studyControls.classList.add('hidden');
                const revealBtn = el('#revealBtn');
                if (revealBtn) revealBtn.classList.add('hidden');
                const addNoteBtn = el('#addNoteBlock');
                if (addNoteBtn) addNoteBtn.classList.add('hidden');
                const copyBtn = el('#copyCardContent');
                if (copyBtn) copyBtn.classList.add('hidden');
                const notesSection = el('#notesSection');
                if (notesSection) notesSection.classList.add('hidden');

                // Calculate percentages for positioning
                const againPct = totalRatings > 0 ? (ratings.Again / totalRatings * 100) : 0;
                const hardPct = totalRatings > 0 ? (ratings.Hard / totalRatings * 100) : 0;
                const goodPct = totalRatings > 0 ? (ratings.Good / totalRatings * 100) : 0;
                const easyPct = totalRatings > 0 ? (ratings.Easy / totalRatings * 100) : 0;

                // Build rating distribution bar with aligned numbers
                const ratingBar = totalRatings > 0 ? `
                    <div class="flex w-full h-2 rounded-full overflow-hidden bg-oatmeal-dark/30 mt-2">
                        ${ratings.Again > 0 ? `<div class="bg-red-400" style="width: ${againPct}%"></div>` : ''}
                        ${ratings.Hard > 0 ? `<div class="bg-orange-400" style="width: ${hardPct}%"></div>` : ''}
                        ${ratings.Good > 0 ? `<div class="bg-green-400" style="width: ${goodPct}%"></div>` : ''}
                        ${ratings.Easy > 0 ? `<div class="bg-blue-400" style="width: ${easyPct}%"></div>` : ''}
                    </div>
                    <div class="flex w-full text-[10px] mt-1">
                        ${ratings.Again > 0 ? `<span class="text-red-500 text-center" style="width: ${againPct}%">${ratings.Again}</span>` : ''}
                        ${ratings.Hard > 0 ? `<span class="text-orange-500 text-center" style="width: ${hardPct}%">${ratings.Hard}</span>` : ''}
                        ${ratings.Good > 0 ? `<span class="text-green-500 text-center" style="width: ${goodPct}%">${ratings.Good}</span>` : ''}
                        ${ratings.Easy > 0 ? `<span class="text-blue-500 text-center" style="width: ${easyPct}%">${ratings.Easy}</span>` : ''}
                    </div>
                ` : '';

                el('#studyDeckLabel').textContent = 'Session Complete';
                el('#cardFront').innerHTML = `
                    <div class="text-center py-4 md:py-6">
                        <h3 class="font-display text-base md:text-lg text-charcoal mb-1">Session Complete</h3>
                        <p class="text-earth-metal/60 text-xs md:text-sm">
                            ${completedCount} card${completedCount !== 1 ? 's' : ''} reviewed${skippedCount > 0 ? `, ${skippedCount} skipped` : ''}
                        </p>
                        <p class="text-earth-metal/50 text-[10px] md:text-xs mb-3">
                            ${durationMins > 0 ? `${durationMins} min` : '<1 min'} Â· ${cardsPerMin} cards/min
                        </p>
                        <div class="max-w-[200px] mx-auto mb-4">
                            ${ratingBar}
                        </div>
                        <div class="flex flex-col gap-3 items-center">
                            <div class="flex flex-col items-center">
                                <button id="restartAllCardsBtn" class="px-4 py-2 bg-dull-purple text-white rounded-xl text-sm hover:bg-dull-purple/90 transition">
                                    Restart
                                </button>
                                <label class="flex items-center gap-2 text-[11px] text-earth-metal/70 mt-2">
                                    <input id="restartNoScheduleChanges" type="checkbox" class="accent-dull-purple" checked>
                                    <span>No scheduling changes</span>
                                </label>
                                <p class="text-[10px] md:text-xs text-earth-metal/50 mt-1">Restart with all cards in selected decks</p>
                            </div>
                            <button id="endSessionBtn" class="px-4 py-2 border border-oatmeal-dark/60 text-earth-metal/70 rounded-xl text-sm hover:bg-oatmeal/50 transition">
                                End Session
                            </button>
                        </div>
                    </div>
                `;
                el('#cardBack').innerHTML = '';
                el('#cardBack').classList.add('hidden');
                this.state.selectedCard = null;
                this.setRatingEnabled(false);

                // Bind completion buttons
                setTimeout(() => {
                    const restartBtn = el('#restartAllCardsBtn');
                    const endBtn = el('#endSessionBtn');
                    if (restartBtn) restartBtn.onclick = () => this.restartWithAllCards();
                    if (endBtn) endBtn.onclick = () => this.abandonSession();
                }, 0);
            },
            restartWithAllCards() {
                const session = this.state.session;
                if (!session) return;

                const previewCheckbox = el('#restartNoScheduleChanges');
                const noScheduleChanges = previewCheckbox ? previewCheckbox.checked : true;
                const cardQueue = this.generateCardQueue(session.deckIds, true);
                if (cardQueue.length === 0) {
                    toast('No cards available');
                    this.abandonSession();
                    return;
                }

                session.cardQueue = cardQueue;
                session.currentIndex = 0;
                session.completed = [];
                session.skipped = [];
                session.studyingNonDue = true;
                session.noScheduleChanges = noScheduleChanges;
                if (session.settings) session.settings.cardSelectionMode = 'all';
                this.saveSession();
                this.renderStudy();
                toast(`Practicing ${cardQueue.length} cards`);
            },
            captureOAuth() {
                const hashParams = new URLSearchParams(location.hash.replace('#', '?'));
                const searchParams = new URLSearchParams(location.search);
                const token = hashParams.get('token') || searchParams.get('token') || searchParams.get('accessToken');
                if (token) {
                    this.state.settings.authToken = token;
                    this.state.authVerified = true;
                    this.state.settings.authVerified = true;
                    Storage.setSettings(this.state.settings);
                    toast('Notion token captured');
                    history.replaceState({}, document.title, location.pathname);
                    this.openSettings();
                    if (this.state.settings.workerUrl) {
                        this.scanSources();
                    } else {
                        toast('Add worker URL then scan sources');
                    }
                }
            },
            async loadFromDB() {
                this.state.decks = (await Storage.getAll('decks')).map(d => ({
                    ordered: false,
                    aiPrompt: d.aiPrompt || DEFAULT_AI_PROMPT,
                    ...d
                }));
                this.state.cards = await Storage.getAll('cards');
                this.state.queue = (await Storage.getMeta('queue')) || [];
                const meta = await Storage.getAll('meta');
                const last = meta.find(m => m.key === 'lastSync');
                if (last) this.state.lastSync = last.value;
                const lp = meta.find(m => m.key === 'lastPull');
                if (lp) this.state.lastPull = lp.value;
                const lpush = meta.find(m => m.key === 'lastPush');
                if (lpush) this.state.lastPush = lpush.value;
            },
            async seedIfEmpty() {
                return;
            },
            newDeck(name, algorithm = 'SM-2') {
                return {
                    id: crypto.randomUUID(),
                    notionId: null,
                    name,
                    algorithm,
                    ordered: false,
                    reviewLimit: 50,
                    newLimit: 20,
                    reverse: false,
                    createdInApp: true,
                    updatedInApp: true,
                    aiPrompt: DEFAULT_AI_PROMPT,
                    aiProvider: '',
                    aiModel: '',
                    aiKey: ''
                };
            },
            newCard(deckId, name, back, type) {
                const now = new Date().toISOString();
                return {
                    id: crypto.randomUUID(),
                    notionId: null,
                    deckId,
                    name,
                    back,
                    type,
                    tags: [],
                    notes: '',
                    suspended: false,
                    leech: false,
                    fsrs: { difficulty: 4, stability: 1, retrievability: 0.9, lastRating: null, lastReview: null, dueDate: now },
                    sm2: { interval: 1, easeFactor: 2.5, dueDate: now },
                    syncId: crypto.randomUUID(),
                    updatedInApp: true,
                    reviewHistory: [],
                    createdAt: now
                };
            },
            bind() {
                el('#syncNowBtn').onclick = () => this.syncNow();
                // Tab navigation
                document.querySelectorAll('.tab-btn').forEach(btn => btn.onclick = () => this.switchTab(btn.dataset.tab));
                document.querySelectorAll('.theme-btn').forEach(btn => btn.onclick = () => {
                    this.state.settings.themeMode = btn.dataset.theme;
                    Storage.setSettings(this.state.settings);
                    this.applyTheme();
                });
                document.querySelectorAll('.font-btn').forEach(btn => btn.onclick = () => {
                    this.state.settings.fontMode = btn.dataset.font;
                    Storage.setSettings(this.state.settings);
                    this.applyFontMode();
                });
                el('#newDeckBtn').onclick = () => this.openDeckModal();
                el('#refreshDecksBtn').onclick = () => this.manualSync();
                el('#closeDeckModal').onclick = () => this.closeDeckModal();
                el('#saveDeckBtn').onclick = () => this.saveDeckFromModal();
                el('#deleteDeckBtn').onclick = () => this.deleteDeckFromModal();
                el('#archiveDeckBtn').onclick = () => this.archiveDeckFromModal();
                el('#newCardBtn').onclick = () => this.openCardModal();
                el('#resetAlgorithmBtn').onclick = () => this.openResetAlgorithmModal();
                el('#cancelResetAlgorithm').onclick = () => this.closeModal('resetAlgorithmModal');
                el('#confirmResetAlgorithm').onclick = () => this.confirmResetAlgorithm();
                el('#resetAlgorithmModal').addEventListener('click', (e) => { if (e.target === el('#resetAlgorithmModal')) this.closeModal('resetAlgorithmModal'); });
                el('#closeCardModal').onclick = () => this.closeCardModal();
                el('#saveCardBtn').onclick = () => this.saveCardFromModal();
                el('#cardTypeInput').onchange = () => this.updateCardBackVisibility();
                el('#deleteCardBtn').onclick = () => this.deleteCardFromModal();
                const cardSelectionMode = el('#cardSelectionMode');
                const noScheduleRow = el('#noScheduleRow');
                const noScheduleChk = el('#noScheduleChanges');
                const toggleNoScheduleUI = () => {
                    const isAll = cardSelectionMode.value === 'all';
                    if (noScheduleRow) {
                        noScheduleRow.classList.toggle('hidden', !isAll);
                        if (isAll && noScheduleChk) noScheduleChk.checked = true;
                        if (!isAll && noScheduleChk) noScheduleChk.checked = false;
                    }
                };
                if (cardSelectionMode) {
                    cardSelectionMode.onchange = toggleNoScheduleUI;
                    toggleNoScheduleUI();
                }
                el('#revealBtn').onclick = () => this.reveal();
                el('#skipCard').onclick = () => this.nextCard();
                el('#copyCardContent').onclick = () => this.copyCardContent();
                el('#addNoteBlock').onclick = () => this.openAddBlockModal();
                el('#closeAddBlockModal').onclick = () => this.closeModal('addBlockModal');
                el('#cancelAddBlockBtn').onclick = () => this.closeModal('addBlockModal');
                el('#saveAddBlockBtn').onclick = () => this.saveBlockNote();
                el('#addBlockModal').addEventListener('click', (e) => { if (e.target === el('#addBlockModal')) this.closeModal('addBlockModal'); });
                // Session control buttons
                el('#startSessionBtn').onclick = () => this.startSession();
                el('#abandonSessionBtn').onclick = () => this.abandonSession();
                document.querySelectorAll('.rate-btn').forEach(btn => btn.onclick = (e) => this.rate(e.currentTarget.dataset.rate));
                el('#cardSearchInput').oninput = (e) => { this.state.cardSearch = e.target.value; this.renderCards(); };
                el('#libraryDeckSearch').oninput = (e) => { this.state.deckSearch = e.target.value; this.renderDecks(); };
                el('#filterAgain').onchange = (e) => { this.state.filters.again = e.target.checked; this.renderCards(); this.updateActiveFiltersCount(); };
                el('#filterHard').onchange = (e) => { this.state.filters.hard = e.target.checked; this.renderCards(); this.updateActiveFiltersCount(); };
                el('#filterAddedToday').onchange = (e) => { this.state.filters.addedToday = e.target.checked; this.renderCards(); this.updateActiveFiltersCount(); };
                el('#filterStability').oninput = (e) => { this.state.filters.stability = Number(e.target.value); el('#stabilityValue').textContent = e.target.value; this.renderCards(); this.updateActiveFiltersCount(); };
                // Tag filter handled via renderTagFilter()
                el('#resetFilters').onclick = () => this.resetFilters();
                const resetMobile = el('#resetFiltersMobile');
                if (resetMobile) resetMobile.onclick = () => this.resetFilters();
                el('#filterSuspended').onchange = (e) => { this.state.filters.suspended = e.target.checked; this.renderCards(); this.updateActiveFiltersCount(); };
                el('#filterLeech').onchange = (e) => { this.state.filters.leech = e.target.checked; this.renderCards(); this.updateActiveFiltersCount(); };
                // Toggle filters panel
                el('#toggleFilters').onclick = () => this.toggleFiltersPanel();
                el('#ankiImportInput').onchange = (e) => this.handleAnkiImport(e.target.files[0]);
                el('#exportAnkiBtn').onclick = () => this.exportAnki();
                // Mobile menu toggle and duplicate handlers
                el('#mobileMoreBtn').onclick = () => {
                    const menu = el('#mobileMoreMenu');
                    menu.classList.toggle('hidden');
                    menu.classList.toggle('flex');
                };
                const exportMobile = el('#exportAnkiBtnMobile');
                if (exportMobile) exportMobile.onclick = () => this.exportAnki();
                const importMobile = el('#ankiImportInputMobile');
                if (importMobile) importMobile.onchange = (e) => this.handleAnkiImport(e.target.files[0]);
                this.initMobileFab();
                this.bindDeckSearch();
                // Keyboard shortcuts for study
                // Keyboard shortcuts for study
                document.addEventListener('keydown', (e) => {
                    // Undo shortcut (Ctrl+Z or Cmd+Z) - works globally during study
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && this.state.lastRating) {
                        e.preventDefault();
                        this.undoLastRating();
                        return;
                    }
                    if (!this.state.session || !this.state.selectedCard) return;

                    // Allow Ctrl+Enter or Cmd+Enter to send from textarea
                    if (e.target.id === 'aiAnswer' && (e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                        e.preventDefault();
                        const btn = el('#aiSubmit');
                        if (!btn.disabled) this.submitToAI();
                        return;
                    }

                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                    // Space key logic
                    if (e.key === ' ' && !this.state.answerRevealed) {
                        e.preventDefault();
                        if (el('#revisionMode').value === 'ai') {
                            const btn = el('#aiSubmit');
                            // If text area has content (button enabled), Send. Otherwise do nothing.
                            if (!btn.disabled) this.submitToAI();
                        } else {
                            this.reveal();
                        }
                    }

                    // Toggle Mic with M key in AI mode
                    if (e.key.toLowerCase() === 'm' && el('#revisionMode').value === 'ai' && !this.state.answerRevealed) {
                        e.preventDefault();
                        if (this.state.currentRecorder) {
                            this.state.currentRecorder.stop();
                        } else {
                            this.recordAnswer();
                        }
                    }

                    if (this.state.answerRevealed) {
                        const ratings = { '1': 'Again', '2': 'Hard', '3': 'Good', '4': 'Easy' };
                        if (ratings[e.key]) this.rate(ratings[e.key]);
                    }
                    if (e.key.toLowerCase() === 's') this.nextCard();
                });
                document.addEventListener('click', (e) => {
                    // Handle edit deck button click
                    const editDeckBtn = e.target.closest('.edit-deck-btn');
                    if (editDeckBtn) {
                        e.stopPropagation();
                        const deckId = editDeckBtn.dataset.deckId;
                        this.editDeck(deckId);
                        return;
                    }
                    // Handle deck selection (click on deck card)
                    const deckCard = e.target.closest('[data-deck-id]');
                    if (deckCard && !e.target.closest('.edit-card-btn') && !e.target.closest('.info-card-btn') && !e.target.closest('.edit-deck-btn') && !e.target.closest('.deck-option') && !e.target.closest('.selected-deck-pill')) {
                        this.selectDeck(deckCard.dataset.deckId);
                        return;
                    }
                    // Handle edit card button click
                    const editCardBtn = e.target.closest('.edit-card-btn');
                    if (editCardBtn) {
                        e.stopPropagation();
                        const cardId = editCardBtn.dataset.cardId;
                        this.editCard(cardId);
                        return;
                    }
                    // Handle info card button click (show review history popover)
                    const infoCardBtn = e.target.closest('.info-card-btn');
                    if (infoCardBtn) {
                        e.stopPropagation();
                        const cardId = infoCardBtn.dataset.cardId;
                        this.showReviewHistoryPopover(infoCardBtn, cardId);
                        return;
                    }
                });
                el('#openSettings').onclick = () => this.openSettings();
                el('#closeSettings').onclick = () => this.closeSettings();
                el('#saveSettings').onclick = () => this.saveSettings();
                el('#verifyWorker').onclick = () => this.verifyWorker();
                el('#verifyAuth').onclick = () => this.verifyAuth();
                el('#oauthBtn').onclick = () => { if (this.state.settings.workerUrl) this.startOAuth(); else toast('Add worker URL first'); };
                el('#scanSources').onclick = () => this.scanSources();
                el('#openWorkerHelp').onclick = () => this.openModal('workerHelpModal');
                el('#closeWorkerHelp').onclick = () => this.closeModal('workerHelpModal');
                el('#copyWorkerCode').onclick = () => this.copyWorkerCode();
                el('#lockedOpenSettings').onclick = () => this.openSettings();
                el('#resetApp').onclick = () => this.openModal('resetConfirmModal');
                el('#cancelReset').onclick = () => this.closeModal('resetConfirmModal');
                el('#confirmReset').onclick = () => this.resetApp();
                el('#toggleDangerZone').onclick = () => this.toggleDangerZone();
                el('#resetConfirmModal').addEventListener('click', (e) => { if (e.target === el('#resetConfirmModal')) this.closeModal('resetConfirmModal'); });
                this.updateSettingsButtons();
                window.addEventListener('keydown', (e) => { if (e.key === 'Escape') { this.closeSettings(); this.closeModal('workerHelpModal'); this.closeDeckModal(); this.closeCardModal(); this.closeModal('confirmModal'); this.closeModal('aiSettingsRequiredModal'); this.closeModal('notesModal'); this.closeModal('addBlockModal'); } });
                el('#settingsModal').addEventListener('click', (e) => { if (e.target === el('#settingsModal')) this.closeSettings(); });
                el('#workerHelpModal').addEventListener('click', (e) => { if (e.target === el('#workerHelpModal')) this.closeModal('workerHelpModal'); });
                el('#revisionMode').onchange = (e) => {
                    if (e.target.value === 'ai') {
                        if (!navigator.onLine) {
                            e.target.value = 'manual';
                            toast('Online connection required for AI mode');
                            return;
                        }
                        if (!this.state.settings.aiVerified) {
                            e.target.value = 'manual';
                            this.openModal('aiSettingsRequiredModal');
                            return;
                        }
                    }
                    const on = e.target.value === 'ai';
                    el('#aiControls').classList.toggle('hidden', !on);
                };
                el('#closeAiSettingsModal').onclick = () => this.closeModal('aiSettingsRequiredModal');
                el('#openSettingsFromAiModal').onclick = () => { this.closeModal('aiSettingsRequiredModal'); this.openSettings(); };
                el('#aiSettingsRequiredModal').addEventListener('click', (e) => { if (e.target === el('#aiSettingsRequiredModal')) this.closeModal('aiSettingsRequiredModal'); });
                // Notes modal bindings
                el('#editNotesBtn').onclick = () => this.openNotesModal();
                el('#closeNotesModal').onclick = () => this.closeModal('notesModal');
                el('#cancelNotesBtn').onclick = () => this.closeModal('notesModal');
                el('#saveNotesBtn').onclick = () => this.saveNotes();
                el('#notesModal').addEventListener('click', (e) => { if (e.target === el('#notesModal')) this.closeModal('notesModal'); });
                el('#verifyAi').onclick = () => this.verifyAiSettings();
                el('#verifyStt').onclick = () => this.verifySttSettings();
                el('#aiSubmit').onclick = () => this.submitToAI();
                el('#aiAnswer').oninput = (e) => {
                    const btn = el('#aiSubmit');
                    const hasText = e.target.value.trim().length > 0;
                    btn.disabled = !hasText;
                    btn.classList.toggle('opacity-50', !hasText);
                    btn.classList.toggle('cursor-not-allowed', !hasText);
                };
                el('#aiRecord').onclick = () => this.recordAnswer();
                el('#confirmDelete').onclick = () => this.performDelete();
                el('#cancelDelete').onclick = () => this.closeModal('confirmModal');
                el('#confirmModal').addEventListener('click', (e) => { if (e.target === el('#confirmModal')) this.closeModal('confirmModal'); });
                el('#deckModal').addEventListener('click', (e) => { if (e.target === el('#deckModal')) this.closeDeckModal(); });
                el('#cardModal').addEventListener('click', (e) => { if (e.target === el('#cardModal')) this.closeCardModal(); });
            },
            renderAll() {
                this.renderDecks();
                this.renderCards();
                this.renderConnection();
                this.renderStudy();
                this.renderStudyDeckSelection();
                this.renderTagFilter();
                this.updateCounts();
                this.populateSourceSelects();
                this.renderGate();
                this.renderStatus();
                this.renderSelectedDeckBar();
                this.updateActiveFiltersCount();
                lucide.createIcons();
                this.loadAISettings();
                // Show/hide STT settings based on whether AI is verified
                const isAiVerified = this.state.settings?.aiVerified;
                el('#sttSettings')?.classList.toggle('hidden', !isAiVerified);
            },
            // Tab switching
            switchTab(tab) {
                // Block library access during active study session
                if (tab === 'library' && this.state.session) {
                    toast('Please stop your study session first to access the library');
                    return;
                }
                document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                const tabEl = el(`#${tab}Tab`);
                if (tabEl) tabEl.classList.remove('hidden');
                const btnEl = el(`[data-tab="${tab}"]`);
                if (btnEl) btnEl.classList.add('active');
                this.state.activeTab = tab;
                lucide.createIcons();
            },
            // Toggle filters panel
            toggleFiltersPanel() {
                const content = el('#filtersContent');
                const chevron = el('#filtersChevron');
                const text = el('#moreOptionsText');
                const isHidden = content && content.classList.contains('hidden');
                if (content) content.classList.toggle('hidden');
                if (chevron) chevron.style.transform = isHidden ? 'rotate(180deg)' : '';
                if (text) text.textContent = isHidden ? 'Less options' : 'More options';
            },
            // Update active filters count (for reset button visibility)
            updateActiveFiltersCount() {
                const f = this.state.filters;
                let count = 0;
                if (f.again) count++;
                if (f.hard) count++;
                if (f.addedToday) count++;
                if (f.stability < 25) count++;
                if (f.tags && f.tags.length > 0) count++;
                if (f.suspended) count++;
                if (f.leech) count++;
                if (f.manual && f.manual.length > 0) count++;
                if (f.studyDecks && f.studyDecks.length > 0) count++;
                // Show reset button if any filters are active
                const resetBtn = el('#resetFilters');
                if (resetBtn) {
                    resetBtn.classList.toggle('hidden', count === 0);
                }
            },
            // Render selected deck bar
            renderSelectedDeckBar() {
                const deck = this.state.selectedDeck;
                const nameEl = el('#selectedDeckName');
                const newCardBtn = el('#newCardBtn');
                const resetBtn = el('#resetAlgorithmBtn');
                const cardsContent = el('#cardsContent');
                if (deck) {
                    if (nameEl) nameEl.textContent = deck.name;
                    if (newCardBtn) newCardBtn.classList.remove('hidden');
                    if (resetBtn) resetBtn.classList.remove('hidden');
                    if (cardsContent) cardsContent.classList.remove('hidden');
                } else {
                    if (nameEl) nameEl.textContent = 'Select a deck above';
                    if (newCardBtn) newCardBtn.classList.add('hidden');
                    if (resetBtn) resetBtn.classList.add('hidden');
                    if (cardsContent) cardsContent.classList.add('hidden');
                }
            },
            renderGate() {
                const ready = this.isReady();
                el('#mainContent').style.display = ready ? 'block' : 'none';
                el('#lockedOverlay').classList.toggle('hidden', ready);
                const oauth = el('#oauthBtn');
                const verifyAuthBtn = el('#verifyAuth');
                const tokenInput = el('#settingAuthToken');
                if (oauth) oauth.disabled = !this.state.settings.workerUrl;
                if (verifyAuthBtn) verifyAuthBtn.disabled = !this.state.settings.workerUrl;
                if (tokenInput) tokenInput.disabled = !this.state.settings.workerUrl;
                this.updateSettingsButtons();
            },
            renderConnection() {
                const badge = el('#connectionBadge');
                const online = navigator.onLine;
                const hasWorkerUrl = !!this.state.settings.workerUrl;
                const workerOk = hasWorkerUrl && this.state.workerVerified;
                const hasToken = !!this.state.settings.authToken;
                const authOk = workerOk && hasToken;
                const ready = online && workerOk && authOk;

                if (!online) {
                    badge.textContent = 'Offline';
                    badge.className = 'px-3 py-1 rounded-full pill text-xs bg-oatmeal border border-oatmeal-dark text-earth-metal';
                    return;
                }

                if (!hasWorkerUrl) {
                    badge.textContent = 'Online Â· add worker URL';
                } else if (!workerOk) {
                    badge.textContent = 'Online Â· verify worker';
                } else if (!hasToken) {
                    badge.textContent = 'Online Â· set token';
                } else if (!authOk) {
                    badge.textContent = 'Online Â· verify token';
                } else {
                    badge.textContent = 'Online Â· Notion ready';
                }
                badge.className = ready
                    ? 'px-3 py-1 rounded-full pill text-xs bg-white-linen border border-oatmeal-dark text-earth-metal'
                    : 'px-3 py-1 rounded-full pill text-xs bg-oatmeal border border-oatmeal-dark text-earth-metal';
            },
            renderDecks() {
                const grid = el('#deckGrid');
                const theme = document.body.getAttribute('data-theme') || 'light';
                const selectedId = this.state.selectedDeck?.id;
                const searchQuery = (this.state.deckSearch || '').toLowerCase().trim();
                let decks = this.state.decks;
                if (searchQuery) {
                    decks = decks.filter(d => d.name.toLowerCase().includes(searchQuery));
                }
                if (decks.length === 0) {
                    grid.innerHTML = `<p class="text-earth-metal/60 text-sm col-span-full text-center py-4">${searchQuery ? 'No decks match your search.' : 'No decks yet. Click "New deck" to create one.'}</p>`;
                    return;
                }
                grid.innerHTML = decks.map(d => {
                    const isSelected = d.id === selectedId;
                    const selectedClass = isSelected ? 'ring-2 ring-dull-purple' : '';
                    return `
                    <article class="rounded-2xl border border-[color:var(--card-border)] p-3 bg-[color:var(--surface)] text-[color:var(--text-main)] flex flex-col gap-2 hover:bg-[color:var(--surface-strong)] transition cursor-pointer ${selectedClass}" data-deck-id="${d.id}">
                        <div class="flex items-center justify-between">
                            <p class="font-semibold text-[color:var(--text-main)] truncate flex-1">${escapeHtml(d.name)}</p>
                            <div class="flex items-center gap-1.5">
                                <button class="edit-deck-btn p-1 rounded hover:bg-dull-purple/20 text-dull-purple" data-deck-id="${d.id}" title="Edit deck">
                                    <i data-lucide="edit-2" class="w-3.5 h-3.5 pointer-events-none"></i>
                                </button>
                                <span class="text-[11px] px-2 py-1 rounded-full bg-[color:var(--surface-strong)] text-[color:var(--text-main)] border border-[color:var(--card-border)]">${d.algorithm}</span>
                            </div>
                        </div>
                        <div class="flex items-center gap-3 text-xs text-[color:var(--text-sub)]">
                            <span>${this.cardsForDeck(d.id).filter(c => this.isDue(c)).length} due</span>
                            <span>${this.cardsForDeck(d.id).length} cards</span>
                        </div>
                        <div class="flex items-center gap-2 text-[11px] text-[color:var(--text-sub)]">
                            <i data-lucide="refresh-cw" class="w-3 h-3"></i>
                            <span>Reverse ${d.reverse ? 'on' : 'off'}</span>
                        </div>
                        <div class="flex items-center gap-2 text-[11px] text-[color:var(--text-sub)]">
                            <i data-lucide="list-ordered" class="w-3 h-3"></i>
                            <span>Ordered ${d.ordered ? 'on' : 'off'}</span>
                        </div>
                    </article>
                `}).join('');
                lucide.createIcons();
            },
            renderCards() {
                const tbody = el('#cardTable');
                const noCardsMsg = el('#noCardsMessage');
                const container = el('#cardsContainer');

                // If no deck selected, show message and hide table
                if (!this.state.selectedDeck) {
                    tbody.innerHTML = '';
                    if (container) container.classList.add('hidden');
                    if (noCardsMsg) {
                        noCardsMsg.textContent = 'Select a deck above to view its cards';
                        noCardsMsg.classList.remove('hidden');
                    }
                    this.renderManualSelection();
                    this.updateCounts();
                    return;
                }

                let cards = this.cardsForDeck(this.state.selectedDeck.id);
                cards = cards.filter(c => this.passFilters(c));

                // Apply card name search filter
                const searchQuery = (this.state.cardSearch || '').toLowerCase().trim();
                if (searchQuery) {
                    cards = cards.filter(c => {
                        const plainName = (c.name || '').replace(/<[^>]*>/g, '').replace(/\{\{c\d+::(.*?)\}\}/g, '$1').toLowerCase();
                        return plainName.includes(searchQuery);
                    });
                }

                if (cards.length === 0) {
                    tbody.innerHTML = '';
                    if (container) container.classList.add('hidden');
                    if (noCardsMsg) {
                        noCardsMsg.textContent = searchQuery ? 'No cards match your search.' : 'No cards in this deck yet. Click "New card" to add one.';
                        noCardsMsg.classList.remove('hidden');
                    }
                } else {
                    if (container) container.classList.remove('hidden');
                    if (noCardsMsg) noCardsMsg.classList.add('hidden');
                    tbody.innerHTML = cards.map(c => {
                        // Strip HTML tags and cloze syntax for display, then escape for safety
                        const plainName = (c.name || '').replace(/<[^>]*>/g, '').replace(/\{\{c\d+::(.*?)\}\}/g, '$1');
                        const nameText = escapeHtml(plainName.slice(0, 50));
                        const tagPills = c.tags.slice(0, 2).map(t => `<span class="notion-color-${t.color.replace('_', '-')}-background px-1.5 py-0.5 rounded text-[10px]">${escapeHtml(t.name)}</span>`).join(' ');
                        // Get due date
                        const dueDate = c.fsrs?.dueDate || c.sm2?.dueDate;
                        const dueDisplay = dueDate ? new Date(dueDate).toLocaleDateString() : 'â€”';
                        return `
                        <tr class="hover:bg-oatmeal/50 dark:hover:bg-white/5" data-card-id="${c.id}">
                            <td class="py-2 pr-2 text-charcoal"><div class="truncate max-w-[150px] sm:max-w-[250px] md:max-w-[350px] lg:max-w-[450px]">${nameText}</div></td>
                            <td class="py-2 pr-2 capitalize hidden sm:table-cell">${c.type}</td>
                            <td class="py-2 pr-2 text-earth-metal/70 text-xs whitespace-nowrap">${dueDisplay}</td>
                            <td class="py-2 pr-2 hidden md:table-cell text-xs"><div class="flex gap-1 flex-wrap">${tagPills}${c.tags.length > 2 ? '<span class="text-earth-metal/50">...</span>' : ''}</div></td>
                            <td class="py-2 flex gap-1">
                                <button class="info-card-btn p-1 rounded hover:bg-dull-purple/20 text-earth-metal/60 relative" data-card-id="${c.id}" title="Review history">
                                    <i data-lucide="info" class="w-4 h-4 pointer-events-none"></i>
                                </button>
                                <button class="edit-card-btn p-1 rounded hover:bg-dull-purple/20 text-dull-purple" data-card-id="${c.id}" title="Edit card">
                                    <i data-lucide="edit-2" class="w-4 h-4 pointer-events-none"></i>
                                </button>
                            </td>
                        </tr>`;
                    }).join('');
                    lucide.createIcons();
                }
                this.renderManualSelection();
                this.updateCounts();
            },
            renderStudy() {
                // Update session UI controls
                const session = this.state.session;
                const activeBar = el('#sessionActiveBar');
                const progressText = el('#sessionProgressText');
                const studySettingsCard = el('#studySettingsCard');
                const studyCardSection = el('#studyCardSection');
                const notesSection = el('#notesSection');

                // Show/hide sections based on session state
                if (session) {
                    // Session is active - hide settings, show session bar and study card
                    // Notes are hidden until answer is revealed
                    if (studySettingsCard) studySettingsCard.classList.add('hidden');
                    if (studyCardSection) studyCardSection.classList.remove('hidden');
                    if (notesSection) notesSection.classList.add('hidden'); // Hidden until reveal
                    if (activeBar) {
                        activeBar.classList.remove('hidden');
                        const current = session.currentIndex + 1;
                        const total = session.cardQueue.length;
                        progressText.textContent = `Study Session (${current}/${total})`;
                        const previewBadge = el('#previewBadge');
                        if (previewBadge) previewBadge.classList.toggle('hidden', !session.noScheduleChanges);
                    }
                    lucide.createIcons();
                } else {
                    // No session - show settings, hide session bar, study card, and notes
                    if (studySettingsCard) studySettingsCard.classList.remove('hidden');
                    if (studyCardSection) studyCardSection.classList.add('hidden');
                    if (notesSection) notesSection.classList.add('hidden');
                    if (activeBar) activeBar.classList.add('hidden');
                }

                const card = this.pickCard();
                const deck = card ? this.deckById(card.deckId) : null;
                const isCloze = card && (card.type || '').toLowerCase() === 'cloze';

                // Check if no cards are due but decks are selected
                const f = this.state.filters;
                const hasSelectedDecks = f.studyDecks && f.studyDecks.length > 0;
                const allCards = hasSelectedDecks
                    ? this.state.cards.filter(c => f.studyDecks.includes(c.deckId))
                    : this.state.cards;
                const dueCards = allCards.filter(c => this.passFilters(c) && this.isDue(c));
                const nonDueCards = allCards.filter(c => this.passFilters(c) && !this.isDue(c));

                if (!card && hasSelectedDecks && nonDueCards.length > 0 && !session) {
                    // No due cards but there are non-due cards available (only show when no session)
                    el('#studyDeckLabel').textContent = 'No cards due';
                    el('#cardFront').innerHTML = `
                        <div class="text-center py-4">
                            <p class="text-earth-metal/70 text-sm mb-3">No cards are due for review right now.</p>
                            <p class="text-earth-metal/60 text-xs mb-4">${nonDueCards.length} card${nonDueCards.length === 1 ? '' : 's'} available for extra practice.</p>
                            <button id="studyNonDueBtn" class="px-4 py-2 bg-dull-purple text-white rounded-xl text-sm hover:bg-dull-purple/90 transition">
                                Practice non-due cards
                            </button>
                        </div>
                    `;
                    el('#cardBack').innerHTML = '';
                    el('#cardBack').classList.add('hidden');
                    el('#aiControls').classList.add('hidden');
                    this.state.answerRevealed = false;
                    this.setRatingEnabled(false);
                    this.updateMobileFab();
                    this.state.selectedCard = null;
                    // Bind the button
                    setTimeout(() => {
                        const btn = el('#studyNonDueBtn');
                        if (btn) btn.onclick = () => this.enableNonDueStudy();
                    }, 0);
                    return;
                }

                el('#studyDeckLabel').textContent = deck ? deck.name : 'Choose a deck';
                // Clear cardFront before setting new content to force fresh DOM
                el('#cardFront').innerHTML = '';
                const front = card ? this.renderCardFront(card, deck) : '<p class="text-earth-metal/70 text-sm">No card selected</p>';
                el('#cardFront').innerHTML = front;
                // Show opposite side based on whether card was reversed
                const backContent = card ? (this.state.cardReversed ? card.name : card.back) : '';
                el('#cardBack').innerHTML = card ? marked.parse(backContent || '') : '';
                this.renderMath(el('#cardFront'));
                this.renderMath(el('#cardBack'));
                // Ensure cloze blanks are NOT revealed on new card (must be after renderMath)
                document.querySelectorAll('#cardFront .cloze-blank').forEach(span => span.classList.remove('revealed'));
                el('#cardBack').classList.add('hidden');
                el('#aiControls').classList.add('hidden');
                // Show study controls (may have been hidden by session complete)
                const studyControls = el('#studyControls');
                if (studyControls) studyControls.classList.remove('hidden');

                const isAiMode = el('#revisionMode').value === 'ai';
                const revealBtn = el('#revealBtn');

                if (isAiMode) {
                    if (revealBtn) revealBtn.classList.add('hidden');
                    el('#aiControls').classList.remove('hidden');
                    const submitBtn = el('#aiSubmit');
                    submitBtn.disabled = true;
                    submitBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    setTimeout(() => el('#aiAnswer').focus(), 50);
                } else {
                    if (revealBtn) revealBtn.classList.remove('hidden');
                    el('#aiControls').classList.add('hidden');
                }

                // Hide copy button until reveal (shows answer content)
                const copyBtn = el('#copyCardContent');
                if (copyBtn) copyBtn.classList.add('hidden');
                // Hide add note button until reveal
                const addNoteBtn = el('#addNoteBlock');
                if (addNoteBtn) addNoteBtn.classList.add('hidden');
                // Reset answer revealed state and disable rating buttons
                this.state.answerRevealed = false;
                this.setRatingEnabled(false);
                this.updateMobileFab();
                this.state.selectedCard = card || null;
                this.renderNotes();
                this.renderFsrsMeta();
                el('#aiAnswer').value = '';
                el('#aiFeedback').innerHTML = '';
                lucide.createIcons();
            },
            renderNotes() {
                const notes = this.state.selectedCard?.notes ?? '';
                el('#notesPreview').innerHTML = notes ? marked.parse(notes) : '<p class="text-earth-metal/60 text-sm">No notes for this card</p>';
                this.renderMath(el('#notesPreview'));
            },
            renderFsrsMeta() {
                // Stats display removed - internal calculation only
            },
            renderManualSelection() {
                const wrap = el('#manualSelection');
                wrap.innerHTML = this.state.filters.manual.map(id => {
                    const c = this.cardById(id);
                    return c ? `<span class="px-2 py-1 rounded-full bg-oatmeal text-earth-metal text-xs">${c.name.slice(0, 20)}</span>` : '';
                }).join('');
            },
            renderTagFilter() {
                const container = el('#filterTagsContainer');
                if (!container) return;
                // Collect unique tags from all cards
                const tagMap = new Map();
                this.state.cards.forEach(c => {
                    (c.tags || []).forEach(t => {
                        if (!tagMap.has(t.name)) tagMap.set(t.name, t.color || 'default');
                    });
                });
                const allTags = Array.from(tagMap.entries()).sort((a, b) => a[0].localeCompare(b[0]));
                const selectedTags = this.state.filters.tags || [];
                if (allTags.length === 0) {
                    container.innerHTML = '<span class="text-earth-metal/50 text-xs">No tags available</span>';
                    return;
                }
                container.innerHTML = allTags.map(([name, color]) => {
                    const isSelected = selectedTags.includes(name);
                    const bgClass = `notion-color-${color.replace('_', '-')}-background`;
                    return `<button class="tag-filter-btn px-2 py-1 rounded-full text-[11px] transition-all ${isSelected ? bgClass + ' ring-2 ring-dull-purple ring-offset-1' : bgClass + ' opacity-60 hover:opacity-100'}" data-tag="${escapeHtml(name)}">${escapeHtml(name)}</button>`;
                }).join('');
                // Attach click handlers
                container.querySelectorAll('.tag-filter-btn').forEach(btn => {
                    btn.onclick = () => {
                        const tag = btn.dataset.tag;
                        const idx = this.state.filters.tags.indexOf(tag);
                        if (idx >= 0) this.state.filters.tags.splice(idx, 1);
                        else this.state.filters.tags.push(tag);
                        this.renderTagFilter();
                        this.renderCards();
                        this.updateActiveFiltersCount();
                    };
                });
            },
            renderStudyDeckSelection() {
                const dropdown = el('#deckDropdown');
                const display = el('#selectedDecksDisplay');
                const input = el('#deckSearchInput');
                if (!dropdown || !display || !input) return;

                const selected = this.state.filters.studyDecks || [];
                const query = (input.value || '').toLowerCase();

                // Render dropdown options
                const filtered = this.state.decks.filter(d => d.name.toLowerCase().includes(query));
                dropdown.innerHTML = filtered.map(d => {
                    const isSelected = selected.includes(d.id);
                    const dueCount = this.cardsForDeck(d.id).filter(c => this.isDue(c)).length;
                    return `<div class="deck-option flex items-center justify-between px-3 py-2 cursor-pointer hover:bg-oatmeal/50 ${isSelected ? 'bg-dull-purple/10' : ''}" data-deck-id="${d.id}">
                        <span class="flex items-center gap-2">
                            ${isSelected ? '<i data-lucide="check" class="w-3 h-3 text-dull-purple"></i>' : '<span class="w-3"></span>'}
                            <span class="text-sm">${escapeHtml(d.name)}</span>
                        </span>
                        <span class="text-xs text-earth-metal/60">${dueCount} due</span>
                    </div>`;
                }).join('');
                if (filtered.length === 0) {
                    dropdown.innerHTML = '<div class="px-3 py-2 text-sm text-earth-metal/60 italic">No decks found</div>';
                }

                // Render selected deck pills
                display.innerHTML = selected.map(id => {
                    const d = this.deckById(id);
                    if (!d) return '';
                    return `<span class="selected-deck-pill inline-flex items-center gap-1 px-2 py-1 rounded-full bg-dull-purple text-white text-xs" data-deck-id="${id}">
                        ${escapeHtml(d.name)}
                        <button class="remove-deck-btn hover:bg-white/20 rounded-full p-0.5" data-deck-id="${id}">
                            <i data-lucide="x" class="w-3 h-3 pointer-events-none"></i>
                        </button>
                    </span>`;
                }).join('');
                if (selected.length === 0) {
                    const totalDue = this.state.cards.filter(c => this.isDue(c)).length;
                    display.innerHTML = `<span class="text-dull-purple/80 text-xs italic">All decks (${totalDue} due)</span>`;
                }
                lucide.createIcons();
            },
            bindDeckSearch() {
                const input = el('#deckSearchInput');
                const dropdown = el('#deckDropdown');
                if (!input || !dropdown) return;

                input.onfocus = () => {
                    dropdown.classList.remove('hidden');
                    this.renderStudyDeckSelection();
                };
                input.oninput = () => this.renderStudyDeckSelection();
                input.onblur = (e) => {
                    // Delay hiding to allow click on dropdown
                    setTimeout(() => {
                        if (!dropdown.contains(document.activeElement)) {
                            dropdown.classList.add('hidden');
                        }
                    }, 150);
                };

                dropdown.onmousedown = (e) => {
                    e.preventDefault(); // Prevent blur
                    const option = e.target.closest('.deck-option');
                    if (option) {
                        const deckId = option.dataset.deckId;
                        const idx = this.state.filters.studyDecks.indexOf(deckId);
                        if (idx >= 0) {
                            this.state.filters.studyDecks.splice(idx, 1);
                        } else {
                            this.state.filters.studyDecks.push(deckId);
                        }
                        // Reset non-due study mode when decks change
                        this.state.studyNonDue = false;
                        this.renderStudyDeckSelection();
                        this.renderStudy();
                        this.updateActiveFiltersCount();
                    }
                };

                el('#selectedDecksDisplay').onclick = (e) => {
                    const btn = e.target.closest('.remove-deck-btn');
                    if (btn) {
                        const deckId = btn.dataset.deckId;
                        const idx = this.state.filters.studyDecks.indexOf(deckId);
                        if (idx >= 0) {
                            this.state.filters.studyDecks.splice(idx, 1);
                            // Reset non-due study mode when decks change
                            this.state.studyNonDue = false;
                            this.renderStudyDeckSelection();
                            this.renderStudy();
                            this.updateActiveFiltersCount();
                        }
                    }
                };
            },
            openDeckModal(deck) {
                if (!this.isReady()) { this.openSettings(); return; }
                this.state.editingDeck = deck || null;
                el('#deckModalTitle').textContent = deck ? 'Edit deck' : 'New deck';
                el('#deckNameInput').value = deck?.name ?? '';
                el('#deckAlgoInput').value = deck?.algorithm ?? 'SM-2';
                el('#deckReviewLimit').value = deck?.reviewLimit ?? 50;
                el('#deckNewLimit').value = deck?.newLimit ?? 20;
                el('#deckOrderedInput').checked = deck?.ordered ?? false;
                el('#deckReverseInput').checked = deck?.reverse ?? false;
                el('#deckPromptInput').value = deck?.aiPrompt ?? DEFAULT_AI_PROMPT;
                el('#deleteDeckBtn').classList.toggle('hidden', !deck);
                el('#archiveDeckBtn').classList.toggle('hidden', !deck);
                el('#deckModal').classList.remove('hidden');
                el('#deckModal').classList.add('flex');
            },
            editDeck(deckId) {
                const deck = this.state.decks.find(d => d.id === deckId);
                if (deck) this.openDeckModal(deck);
            },
            closeDeckModal() {
                el('#deckModal').classList.add('hidden');
                el('#deckModal').classList.remove('flex');
            },
            async saveDeckFromModal() {
                const d = this.state.editingDeck || this.newDeck('', 'SM-2');
                d.name = el('#deckNameInput').value || d.name || 'Untitled deck';
                d.algorithm = el('#deckAlgoInput').value;
                d.reviewLimit = Number(el('#deckReviewLimit').value) || 50;
                d.newLimit = Number(el('#deckNewLimit').value) || 20;
                d.ordered = el('#deckOrderedInput').checked;
                d.reverse = el('#deckReverseInput').checked;
                d.aiPrompt = el('#deckPromptInput').value || '';
                if (!this.state.editingDeck) this.state.decks.push(d);
                d.updatedInApp = true;
                await Storage.put('decks', d);
                this.queueOp({ type: 'deck-upsert', payload: d });
                this.closeDeckModal();
                this.renderDecks();
                this.renderStudy();
                toast('Deck saved');
            },
            async deleteDeckFromModal() {
                const deck = this.state.editingDeck;
                if (!deck) return;
                this.pendingDelete = { type: 'deck', id: deck.id, notionId: deck.notionId };
                this.openModal('confirmModal');
            },
            async archiveDeckFromModal() {
                const deck = this.state.editingDeck;
                if (!deck) return;
                // Check if this was the selected deck
                const wasSelected = this.state.selectedDeck?.id === deck.id;
                // Remove from study deck filters if it was there
                if (this.state.filters.studyDecks) {
                    this.state.filters.studyDecks = this.state.filters.studyDecks.filter(id => id !== deck.id);
                }
                // Remove deck and its cards from local storage (but keep in Notion)
                const cards = this.cardsForDeck(deck.id);
                for (const card of cards) {
                    const idx = this.state.cards.findIndex(c => c.id === card.id);
                    if (idx >= 0) this.state.cards.splice(idx, 1);
                    await Storage.delete('cards', card.id);
                }
                const deckIdx = this.state.decks.findIndex(d => d.id === deck.id);
                if (deckIdx >= 0) this.state.decks.splice(deckIdx, 1);
                await Storage.delete('decks', deck.id);
                // Update Notion to set Archived? to true
                if (deck.notionId) {
                    try {
                        await API.updatePage(deck.notionId, { 'Archived?': { checkbox: true } });
                    } catch (e) {
                        console.error('Failed to archive deck in Notion:', e);
                    }
                }
                // Clear selection if this was the selected deck
                if (wasSelected) {
                    this.state.selectedDeck = null;
                }
                this.closeDeckModal();
                this.renderDecks();
                this.renderCards();
                this.renderSelectedDeckBar();
                this.renderStudyDeckSelection();
                this.renderStudy();
                toast('Deck archived');
            },
            openResetAlgorithmModal() {
                const deck = this.state.selectedDeck;
                if (!deck) {
                    toast('Select a deck first');
                    return;
                }
                el('#resetDeckName').textContent = deck.name;
                this.openModal('resetAlgorithmModal');
            },
            async confirmResetAlgorithm() {
                const deck = this.state.selectedDeck;
                if (!deck) return;
                const cards = this.cardsForDeck(deck.id);
                if (cards.length === 0) {
                    toast('No cards in this deck');
                    this.closeModal('resetAlgorithmModal');
                    return;
                }
                // Reset algorithm parameters for all cards in the deck
                let resetCount = 0;
                for (const card of cards) {
                    // Reset SM-2 parameters
                    card.sm2 = {
                        easeFactor: 2.5,
                        interval: 1,
                        dueDate: null,
                        lastRating: null,
                        lastReview: null
                    };
                    // Reset FSRS parameters with proper initial values
                    card.fsrs = {
                        stability: initStability('good'),
                        difficulty: initDifficulty('good'),
                        dueDate: null,
                        lastReview: null,
                        lastRating: null,
                        retrievability: 0.9
                    };
                    // Save locally
                    await Storage.put('cards', card);
                    // Queue for sync to Notion
                    this.queueOp({ type: 'card-upsert', payload: card });
                    resetCount++;
                }
                // Update in-memory state
                this.state.cards = this.state.cards.map(c => {
                    const updated = cards.find(uc => uc.id === c.id);
                    return updated || c;
                });
                this.closeModal('resetAlgorithmModal');
                // Re-render all views that show due counts
                this.renderCards();
                this.renderDecks();
                this.renderStudyDeckSelection();
                this.renderStudy();
                toast(`Reset ${resetCount} card${resetCount !== 1 ? 's' : ''} â€” syncing to Notion`);
            },
            openCardModal(card) {
                if (!this.isReady()) { this.openSettings(); return; }
                this.state.editingCard = card || null;
                el('#cardModalTitle').textContent = card ? 'Edit card' : 'New card';
                const deckSelect = el('#cardDeckInput');
                deckSelect.innerHTML = this.state.decks.map(d => `<option value="${d.id}">${d.name}</option>`).join('');
                deckSelect.value = card?.deckId || this.state.selectedDeck?.id || this.state.decks[0]?.id;
                el('#cardTypeInput').value = card?.type ?? 'Front-Back';
                el('#cardNameInput').value = card?.name ?? '';
                el('#cardBackInput').value = card?.back ?? '';
                el('#cardNotesInput').value = card?.notes ?? '';
                el('#cardTagsInput').value = card?.tags?.map(t => t.name).join(', ') ?? '';
                el('#cardSuspendedInput').checked = card?.suspended ?? false;
                el('#cardLeechInput').checked = card?.leech ?? false;
                el('#deleteCardBtn').classList.toggle('hidden', !card);
                // Show/hide back section based on card type
                this.updateCardBackVisibility();
                // Populate review history section
                this.renderCardModalReviewHistory(card);
                el('#cardModal').classList.remove('hidden');
                el('#cardModal').classList.add('flex');
                lucide.createIcons();
            },
            renderCardModalReviewHistory(card) {
                const section = el('#cardReviewHistorySection');
                const countEl = el('#cardReviewHistoryCount');
                const tableEl = el('#cardReviewHistoryTable');

                if (!card || !card.reviewHistory || card.reviewHistory.length === 0) {
                    section.classList.add('hidden');
                    return;
                }

                section.classList.remove('hidden');
                const history = card.reviewHistory;
                countEl.textContent = history.length;

                const ratingColors = { again: 'text-red-500', hard: 'text-orange-500', good: 'text-green-500', easy: 'text-blue-500' };
                // Show all reviews (most recent first)
                const sortedHistory = [...history].reverse();
                tableEl.innerHTML = `
                    <table class="w-full text-xs">
                        <thead class="sticky top-0 bg-oatmeal dark:bg-white/5"><tr class="text-earth-metal/50 border-b border-charcoal/10"><th class="text-left py-1.5 px-2">Rating</th><th class="text-left py-1.5 px-2">Date</th><th class="text-left py-1.5 px-2">Time</th></tr></thead>
                        <tbody>
                            ${sortedHistory.map(h => `
                                <tr class="border-b border-charcoal/5 last:border-0">
                                    <td class="py-1 px-2 capitalize ${ratingColors[h.rating] || ''}">${h.rating}</td>
                                    <td class="py-1 px-2 text-earth-metal/70">${new Date(h.at).toLocaleDateString()}</td>
                                    <td class="py-1 px-2 text-earth-metal/70">${new Date(h.at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            },
            updateCardBackVisibility() {
                const isCloze = el('#cardTypeInput').value === 'Cloze';
                const backSection = el('#cardBackSection');
                if (backSection) backSection.classList.toggle('hidden', isCloze);
            },
            closeCardModal() {
                el('#cardModal').classList.add('hidden');
                el('#cardModal').classList.remove('flex');
            },
            async saveCardFromModal() {
                let card = this.state.editingCard || this.newCard('', '', '', 'Front-Back');
                const oldName = card.name;
                const oldBack = card.back;
                const oldNotes = card.notes;
                card.deckId = el('#cardDeckInput').value;
                card.type = el('#cardTypeInput').value;
                card.name = el('#cardNameInput').value || 'Untitled';
                card.back = el('#cardBackInput').value || '';
                card.notes = el('#cardNotesInput').value || '';
                if (!this.state.editingCard) {
                    const autoType = detectCardType(card.name, card.back);
                    if (card.type === 'Front-Back' && autoType === 'Cloze') card.type = 'Cloze';
                }
                card.tags = el('#cardTagsInput').value.split(',').map(t => t.trim()).filter(Boolean).map(name => ({ name, color: 'default' }));
                card.suspended = el('#cardSuspendedInput').checked;
                card.leech = el('#cardLeechInput').checked;
                // Only set updatedInApp if name/back/notes changed (affects rich_text preservation)
                // Note: Editing Name, Back, or Notes will cause text colors and highlights to be lost on sync
                if (card.name !== oldName || card.back !== oldBack || card.notes !== oldNotes) {
                    card.updatedInApp = true;
                }
                if (!this.state.editingCard) this.state.cards.push(card);
                await Storage.put('cards', card);
                this.queueOp({ type: 'card-upsert', payload: card });
                this.closeCardModal();
                this.renderCards();
                toast('Card saved');
            },
            async deleteCardFromModal() {
                const card = this.state.editingCard;
                if (!card) return;
                this.pendingDelete = { type: 'card', id: card.id, notionId: card.notionId };
                this.openModal('confirmModal');
            },
            async syncNow() {
                if (!this.isReady()) return toast('Complete settings first');
                const loadingMsg = el('#loadingMessage');
                el('#syncProgress').style.width = '10%';
                try {
                    // Push first to save local changes
                    if (loadingMsg && !el('#loadingOverlay').classList.contains('hidden')) {
                        loadingMsg.textContent = 'Pushing local changes...';
                    }
                    await this.pushQueue();
                    el('#syncProgress').style.width = '50%';

                    // Then pull to get updates
                    if (loadingMsg && !el('#loadingOverlay').classList.contains('hidden')) {
                        loadingMsg.textContent = 'Fetching decks...';
                    }
                    await this.pullFromNotion();
                    el('#syncProgress').style.width = '100%';

                    if (loadingMsg && !el('#loadingOverlay').classList.contains('hidden')) {
                        loadingMsg.textContent = 'Preparing your library...';
                    }
                    const nowIso = new Date().toISOString();
                    this.state.lastPull = nowIso;
                    this.state.lastPush = nowIso;
                    this.state.lastSync = nowIso;
                    await Storage.put('meta', { key: 'lastPull', value: nowIso });
                    await Storage.put('meta', { key: 'lastPush', value: nowIso });
                    await Storage.put('meta', { key: 'lastSync', value: nowIso });
                    toast('Synced with Notion');
                } catch (e) {
                    console.error('Sync failed', e);
                    toast('Sync failed - check connection');
                } finally {
                    setTimeout(() => el('#syncProgress').style.width = '0%', 700);
                }
            },
            async pullFromNotion() {
                const { deckSource, cardSource } = this.state.settings;
                if (!deckSource || !cardSource) return;
                const since = this.state.lastPull;

                // Build deck filter: exclude archived decks
                let deckFilter = { property: 'Archived?', checkbox: { equals: false } };
                if (since) {
                    // Combine with timestamp filter for incremental sync
                    deckFilter = {
                        and: [
                            { timestamp: 'last_edited_time', last_edited_time: { on_or_after: since } },
                            { property: 'Archived?', checkbox: { equals: false } }
                        ]
                    };
                }

                // Query non-archived decks first
                const decks = await API.queryDatabase(deckSource, deckFilter);
                const mappedDecks = decks.map(d => NotionMapper.deckFrom(d));

                // Identify decks that are new (not in local state) - need to fetch their cards
                const existingDeckIds = new Set(this.state.decks.map(d => d.notionId));
                const newDeckIds = mappedDecks.filter(d => !existingDeckIds.has(d.notionId)).map(d => d.notionId);

                // For card filtering, use all non-archived decks (existing + new)
                const allNonArchivedDeckIds = new Set([...existingDeckIds, ...newDeckIds]);

                // Query cards (with timestamp if incremental), then filter client-side
                let cardFilter = null;
                if (since) {
                    cardFilter = { timestamp: 'last_edited_time', last_edited_time: { on_or_after: since } };
                }
                const cards = await API.queryDatabase(cardSource, cardFilter);
                let mappedCards = cards.map(c => NotionMapper.cardFrom(c, mappedDecks));

                // If we have new decks, fetch their cards separately (they may not have been edited recently)
                if (since && newDeckIds.length > 0) {
                    for (const deckId of newDeckIds) {
                        const deckCards = await API.queryDatabase(cardSource, {
                            property: 'Deck',
                            relation: { contains: deckId }
                        });
                        const newCards = deckCards.map(c => NotionMapper.cardFrom(c, mappedDecks));
                        // Add cards we don't already have
                        for (const nc of newCards) {
                            if (!mappedCards.find(c => c.notionId === nc.notionId)) {
                                mappedCards.push(nc);
                            }
                        }
                    }
                }

                // Filter out cards that belong to archived decks
                const filteredCards = mappedCards.filter(c => {
                    // If card has no deck relation, include it
                    if (!c.deckId) return true;
                    // Include only if deck is in our non-archived list
                    return allNonArchivedDeckIds.has(c.deckId);
                });

                if (!since) {
                    await Storage.wipeStore('decks');
                    await Storage.wipeStore('cards');
                    this.state.decks = [];
                    this.state.cards = [];
                }

                // Also remove cards from decks that are no longer in our state (archived in Notion)
                // This handles the case where a deck was archived after our last sync
                if (since) {
                    const archivedDeckIds = this.state.decks
                        .filter(d => !mappedDecks.find(md => md.notionId === d.notionId))
                        .map(d => d.notionId);
                    // Note: We don't remove archived decks from local state automatically
                    // User should manually archive in app if they want it removed
                }

                const upsertDeck = (deck) => {
                    const idx = this.state.decks.findIndex(d => d.notionId === deck.notionId);
                    if (idx >= 0) this.state.decks[idx] = { ...this.state.decks[idx], ...deck };
                    else this.state.decks.push(deck);
                };
                const upsertCard = (card) => {
                    const idx = this.state.cards.findIndex(c => c.notionId === card.notionId);
                    if (idx >= 0) this.state.cards[idx] = { ...this.state.cards[idx], ...card };
                    else this.state.cards.push(card);
                };

                for (const d of mappedDecks) { upsertDeck(d); await Storage.put('decks', d); }
                for (const c of filteredCards) { upsertCard(c); await Storage.put('cards', c); }
                this.renderAll();
            },
            async pushQueue() {
                const { deckSource, cardSource } = this.state.settings;
                const queue = [...this.state.queue];
                this.state.queue = [];
                el('#queueCount').textContent = '0';
                const failed = [];
                for (const op of queue) {
                    try {
                        if (op.type === 'deck-upsert') {
                            const props = NotionMapper.deckProps(op.payload);
                            if (op.payload.notionId) await API.updatePage(op.payload.notionId, props);
                            else {
                                const res = await API.createPage(deckSource, props);
                                op.payload.notionId = res.id;
                                op.payload.id = op.payload.id || res.id;
                                await Storage.put('decks', op.payload);
                            }
                        }
                        if (op.type === 'deck-delete' && op.payload.notionId) await API.archivePage(op.payload.notionId);
                        if (op.type === 'card-upsert') {
                            const deck = this.deckById(op.payload.deckId);
                            const props = NotionMapper.cardProps(op.payload, deck?.notionId || deck?.id || null);
                            if (op.payload.notionId) await API.updatePage(op.payload.notionId, props);
                            else {
                                const res = await API.createPage(cardSource, props);
                                op.payload.notionId = res.id;
                                op.payload.id = op.payload.id || res.id;
                                op.payload.syncId = res.id;
                            }
                            // After successful push, reset updatedInApp and update _notionRichText
                            // so subsequent pushes (e.g., SRS updates) preserve the rich_text we just sent
                            op.payload.updatedInApp = false;
                            op.payload._notionRichText = {
                                name: props['Name'].title,
                                back: props['Back'].rich_text,
                                notes: props['Notes'].rich_text
                            };
                            // Update local state
                            const cardIdx = this.state.cards.findIndex(c => c.notionId === op.payload.notionId || c.id === op.payload.id);
                            if (cardIdx >= 0) {
                                this.state.cards[cardIdx] = { ...this.state.cards[cardIdx], ...op.payload };
                            }
                            await Storage.put('cards', op.payload);
                        }
                        if (op.type === 'card-delete' && op.payload.notionId) await API.archivePage(op.payload.notionId);
                        if (op.type === 'block-append' && op.payload.pageId) {
                            await API.appendBlocks(op.payload.pageId, op.payload.blocks);
                        }
                    } catch (e) {
                        console.error(`Queue op failed: ${op.type}`, e);
                        failed.push(op);
                    }
                }
                // Re-queue failed operations for retry
                if (failed.length > 0) {
                    this.state.queue = [...failed, ...this.state.queue];
                    el('#queueCount').textContent = String(this.state.queue.length);
                    toast(`${failed.length} sync operation(s) failed, will retry`);
                }
                await Storage.setMeta('queue', this.state.queue);
            },
            queueOp(op) {
                this.state.queue.push(op);
                el('#queueCount').textContent = String(this.state.queue.length);
                Storage.setMeta('queue', this.state.queue).catch(() => { });
            },
            async manualSync() {
                if (!this.isReady()) { toast('Complete setup first'); return; }
                if (this.state.syncing) { toast('Sync already in progress'); return; }

                this.state.syncing = true;
                const btn = el('#refreshDecksBtn');
                const svg = btn?.querySelector('svg');
                if (svg) svg.classList.add('animate-spin');

                try {
                    // Always push first to save local progress
                    if (this.state.queue.length > 0) {
                        await this.pushQueue();
                        this.state.lastPush = new Date().toISOString();
                        await Storage.put('meta', { key: 'lastPush', value: this.state.lastPush });
                    }
                    // Then pull to get updates
                    await this.pullFromNotion();
                    this.state.lastPull = new Date().toISOString();
                    await Storage.put('meta', { key: 'lastPull', value: this.state.lastPull });

                    this.state.lastSync = new Date().toISOString();
                    await Storage.put('meta', { key: 'lastSync', value: this.state.lastSync });
                    this.renderConnection();
                    toast('Synced with Notion');
                } catch (e) {
                    console.error('Manual sync failed', e);
                    toast('Sync failed - check connection');
                } finally {
                    this.state.syncing = false;
                    if (svg) svg.classList.remove('animate-spin');
                }
            },
            startAutoSync() {
                if (this.state.autoSyncTimer) clearInterval(this.state.autoSyncTimer);
                this.state.autoSyncTimer = setInterval(() => this.autoSyncTick(), SYNC_INTERVAL_MS);
                this.autoSyncTick(); // kick off once on load
            },
            async autoSyncTick() {
                if (this.state.syncing) return;
                if (!navigator.onLine) return;
                if (!this.isReady()) return;
                const now = Date.now();
                const lastPullMs = this.state.lastPull ? new Date(this.state.lastPull).getTime() : 0;
                const lastPushMs = this.state.lastPush ? new Date(this.state.lastPush).getTime() : 0;
                const shouldPull = now - lastPullMs > MIN_PULL_INTERVAL_MS;
                const shouldPush = this.state.queue.length > 0 && (now - lastPushMs > MIN_PUSH_INTERVAL_MS);
                if (!shouldPull && !shouldPush) return;
                this.state.syncing = true;
                try {
                    // Always push first to avoid overwriting local changes with stale Notion data
                    if (shouldPush) {
                        await this.pushQueue();
                        this.state.lastPush = new Date().toISOString();
                        await Storage.put('meta', { key: 'lastPush', value: this.state.lastPush });
                    }
                    if (shouldPull) {
                        await this.pullFromNotion();
                        this.state.lastPull = new Date().toISOString();
                        await Storage.put('meta', { key: 'lastPull', value: this.state.lastPull });
                    }
                    this.state.lastSync = new Date().toISOString();
                    await Storage.put('meta', { key: 'lastSync', value: this.state.lastSync });
                    this.renderConnection();
                } catch (e) {
                    console.error('Auto sync failed', e);
                } finally {
                    this.state.syncing = false;
                }
            },
            handleOnline() {
                this.renderConnection();
                this.autoSyncTick();
            },
            selectDeck(id) {
                const deck = this.deckById(id);
                this.state.selectedDeck = deck;
                this.renderDecks(); // Re-render to show selection highlight
                this.renderCards();
                this.renderStudy();
                this.renderSelectedDeckBar();
                // Scroll to cards section
                const cardsSection = el('#cardsSection');
                if (cardsSection) cardsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            },
            selectCard(id) {
                const card = this.cardById(id);
                this.state.selectedCard = card;
                if (!this.state.filters.manual.includes(id)) this.state.filters.manual.push(id);
                this.renderManualSelection();
                this.renderStudy();
                this.openCardModal(card);
            },
            editCard(id) {
                const card = this.cardById(id);
                if (!card) return;
                this.state.selectedCard = card;
                this.openCardModal(card);
            },
            showReviewHistoryPopover(btn, cardId) {
                // Close any existing popover
                const existing = document.querySelector('.review-history-popover');
                if (existing) existing.remove();

                const card = this.cardById(cardId);
                if (!card) return;

                const history = card.reviewHistory || [];
                const ratingColors = { again: 'text-red-500', hard: 'text-orange-500', good: 'text-green-500', easy: 'text-blue-500' };

                // Create popover content
                let content;
                if (history.length === 0) {
                    content = '<p class="text-earth-metal/50 text-center py-2">No reviews yet</p>';
                } else {
                    // Show last 10 reviews (most recent first)
                    const recentHistory = [...history].reverse().slice(0, 10);
                    content = `
                        <table class="w-full text-xs">
                            <thead><tr class="text-earth-metal/50 border-b border-charcoal/10"><th class="text-left py-1">Rating</th><th class="text-left py-1">Date</th></tr></thead>
                            <tbody>
                                ${recentHistory.map(h => `
                                    <tr class="border-b border-charcoal/5 last:border-0">
                                        <td class="py-1 capitalize ${ratingColors[h.rating] || ''}">${h.rating}</td>
                                        <td class="py-1 text-earth-metal/70">${new Date(h.at).toLocaleDateString()} ${new Date(h.at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                        ${history.length > 10 ? `<p class="text-earth-metal/50 text-xs text-center mt-1">+${history.length - 10} more</p>` : ''}
                    `;
                }

                // Create and position popover
                const popover = document.createElement('div');
                popover.className = 'review-history-popover absolute z-50 bg-oatmeal dark:bg-zinc-800 border border-charcoal/20 dark:border-white/10 rounded-lg shadow-lg p-3 min-w-[200px] max-w-[280px]';
                popover.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-medium text-sm text-charcoal dark:text-oatmeal">Review History</span>
                        <button class="close-popover text-earth-metal/50 hover:text-earth-metal p-0.5"><i data-lucide="x" class="w-4 h-4"></i></button>
                    </div>
                    ${content}
                `;

                // Position popover near button
                document.body.appendChild(popover);
                const btnRect = btn.getBoundingClientRect();
                const popRect = popover.getBoundingClientRect();

                // Position to the left of button, or right if not enough space
                let left = btnRect.left - popRect.width - 8;
                if (left < 8) left = btnRect.right + 8;
                let top = btnRect.top;
                if (top + popRect.height > window.innerHeight - 8) top = window.innerHeight - popRect.height - 8;

                popover.style.left = `${left}px`;
                popover.style.top = `${top}px`;

                lucide.createIcons({ nodes: [popover] });

                // Close handlers
                popover.querySelector('.close-popover').onclick = () => popover.remove();
                const closeOnClickOutside = (e) => {
                    if (!popover.contains(e.target) && !btn.contains(e.target)) {
                        popover.remove();
                        document.removeEventListener('click', closeOnClickOutside);
                    }
                };
                setTimeout(() => document.addEventListener('click', closeOnClickOutside), 0);
            },
            passFilters(card) {
                const f = this.state.filters;
                const now = new Date();
                if (f.again && card.fsrs?.lastRating !== 'again') return false;
                if (f.hard && !['again', 'hard'].includes(card.fsrs?.lastRating)) return false;
                if (f.addedToday && card.createdAt && new Date(card.createdAt).toDateString() !== now.toDateString()) return false;
                if (card.fsrs?.stability && card.fsrs.stability > f.stability) return false;
                if (f.tags.length && !f.tags.some(t => card.tags.some(ct => ct.name === t))) return false;
                if (f.suspended && card.suspended) return false;
                if (f.leech && card.leech) return false;
                if (f.manual.length && !f.manual.includes(card.id)) return false;
                return true;
            },
            isDue(card) {
                const due = card.fsrs?.dueDate || card.sm2?.dueDate;
                return due ? new Date(due) <= new Date() : true;
            },
            pickCard() {
                // If session is active, return the session's current card
                if (this.state.session) {
                    const sessionData = this.getSessionCard();
                    if (sessionData && sessionData.card) {
                        // Store the pre-computed reverse decision from session
                        this.state.sessionReversed = sessionData.reversed;
                        return sessionData.card;
                    }
                    // Session complete or no more cards
                    return null;
                }

                const f = this.state.filters;
                // If studyNonDue is enabled, include all cards regardless of due date
                let pool = this.state.studyNonDue
                    ? this.state.cards.filter(c => this.passFilters(c))
                    : this.state.cards.filter(c => this.passFilters(c) && this.isDue(c));
                // Filter by selected study decks
                if (f.studyDecks && f.studyDecks.length > 0) {
                    pool = pool.filter(c => f.studyDecks.includes(c.deckId));
                }
                if (pool.length === 0) return null;

                return pool[0] || null;
            },
            renderCardFront(card, deck) {
                const typeKey = (card.type || '').toLowerCase();
                const isCloze = typeKey === 'cloze';
                const isFrontStyle = typeKey.includes('front');
                // Use session's pre-computed reverse decision if active, otherwise random
                let shouldReverse;
                if (this.state.session && typeof this.state.sessionReversed === 'boolean') {
                    shouldReverse = !isCloze && this.state.sessionReversed;
                } else {
                    shouldReverse = !isCloze && deck?.reverse && isFrontStyle && Math.random() < 0.5;
                }
                // Store reverse state for reveal
                this.state.cardReversed = shouldReverse;
                const prompt = shouldReverse ? card.back : card.name;
                if (isCloze) {
                    // Create cloze blanks with hidden answer and visible placeholder
                    const processed = prompt.replace(/\{\{c\d+::(.*?)\}\}/g, (match, answer) => {
                        return `<span class="cloze-blank"><span class="cloze-placeholder">[...]</span><span class="cloze-answer">${answer}</span></span>`;
                    });
                    return marked.parse(processed);
                }
                return marked.parse(prompt);
            },
            setRatingEnabled(enabled) {
                document.querySelectorAll('.rate-btn').forEach(btn => {
                    btn.disabled = !enabled;
                    btn.classList.toggle('opacity-30', !enabled);
                    btn.classList.toggle('cursor-not-allowed', !enabled);
                    btn.classList.toggle('pointer-events-none', !enabled);
                });
            },
            reveal() {
                const card = this.state.selectedCard;
                const isCloze = card && (card.type || '').toLowerCase() === 'cloze';

                // Only show cardBack for non-cloze cards
                if (!isCloze) {
                    el('#cardBack').classList.remove('hidden');
                }

                // Show notes section after reveal (no longer a hint)
                const notesSection = el('#notesSection');
                if (notesSection) notesSection.classList.remove('hidden');

                // Show add note button after reveal
                const addNoteBtn = el('#addNoteBlock');
                if (addNoteBtn) addNoteBtn.classList.remove('hidden');

                // Show copy button after reveal
                const copyBtn = el('#copyCardContent');
                if (copyBtn) copyBtn.classList.remove('hidden');

                // Reveal cloze blanks
                document.querySelectorAll('#cardFront .cloze-blank').forEach(span => span.classList.add('revealed'));

                // Enable rating (in both Manual and AI modes, reveal() signifies answer is now visible)
                this.state.answerRevealed = true;
                this.setRatingEnabled(true);
                this.updateMobileFab();
            },
            async rate(rating) {
                const card = this.state.selectedCard;
                if (!card) return;
                if (!this.state.answerRevealed) {
                    const mode = el('#revisionMode').value;
                    toast(mode === 'ai' ? 'Judge the answer first' : 'Reveal the answer first');
                    return;
                }
                if (el('#revisionMode').value === 'ai' && !this.state.aiKey) {
                    toast('Add an AI key or switch to Reveal mode');
                    return;
                }
                // Save previous state for undo
                const previousState = {
                    cardId: card.id,
                    sm2: JSON.parse(JSON.stringify(card.sm2 || {})),
                    fsrs: JSON.parse(JSON.stringify(card.fsrs || {})),
                    history: [...card.reviewHistory],
                    rating: rating,
                    sessionIndex: this.state.session ? this.state.session.currentIndex : null,
                    ratingCounts: this.state.session?.ratingCounts ? { ...this.state.session.ratingCounts } : null
                };
                const previewMode = this.state.session?.noScheduleChanges && (this.state.session.settings?.cardSelectionMode === 'all' || this.state.session.studyingNonDue);
                // Track rating in session statistics
                if (this.state.session && this.state.session.ratingCounts) {
                    this.state.session.ratingCounts[rating]++;
                }
                if (previewMode) {
                    this.state.lastRating = null;
                    this.setRatingEnabled(false);
                    this.advanceSession(false);
                    toast('Preview mode: scheduling unchanged');
                    return;
                }
                const deck = this.deckById(card.deckId);
                const alg = deck?.algorithm || 'SM-2';
                if (alg === 'FSRS') card.fsrs = SRS.fsrs(card, rating);
                else card.sm2 = SRS.sm2(card, rating);  // SM-2 is default
                card.fsrs = card.fsrs || {};
                card.fsrs.lastRating = normalizeRating(rating);
                card.reviewHistory.push({ rating, at: new Date().toISOString() });
                await Storage.put('cards', card);
                this.queueOp({ type: 'card-upsert', payload: card });
                // Show undo toast
                this.showUndoToast(previousState);
                // If session is active, advance the session; otherwise just render next card
                if (this.state.session) {
                    this.advanceSession(false);
                } else {
                    this.nextCard();
                }
            },
            nextCard() {
                if (this.state.session) {
                    this.advanceSession(true); // wasSkipped = true
                } else {
                    this.renderStudy();
                }
            },
            showUndoToast(previousState) {
                // Clear any existing undo toast timeout
                if (this.state.undoToastTimeout) {
                    clearTimeout(this.state.undoToastTimeout);
                }
                this.state.lastRating = previousState;
                const t = el('#toast');
                t.innerHTML = `Rated "${previousState.rating}" <button id="undoBtn" class="ml-2 underline font-medium hover:text-ghost-dark">Undo</button>`;
                t.classList.remove('hidden', 'opacity-0');
                el('#undoBtn').onclick = () => this.undoLastRating();
                this.state.undoToastTimeout = setTimeout(() => {
                    this.state.lastRating = null;
                    t.classList.add('opacity-0');
                    setTimeout(() => {
                        t.classList.add('hidden');
                        t.innerHTML = '';
                    }, 300);
                }, 2000);
            },
            async undoLastRating() {
                const prev = this.state.lastRating;
                if (!prev) {
                    toast('Nothing to undo');
                    return;
                }
                // Clear the undo toast timeout
                if (this.state.undoToastTimeout) {
                    clearTimeout(this.state.undoToastTimeout);
                    this.state.undoToastTimeout = null;
                }
                // Find the card and restore its state
                const card = this.cardById(prev.cardId);
                if (!card) {
                    toast('Card not found');
                    this.state.lastRating = null;
                    return;
                }
                // Restore SRS state
                card.sm2 = prev.sm2;
                card.fsrs = prev.fsrs;
                card.reviewHistory = prev.history;
                // Save restored card
                await Storage.put('cards', card);
                // Also update in memory
                const cardIndex = this.state.cards.findIndex(c => c.id === card.id);
                if (cardIndex !== -1) {
                    this.state.cards[cardIndex] = card;
                }
                // Restore session state if applicable
                if (this.state.session && prev.sessionIndex !== null) {
                    this.state.session.currentIndex = prev.sessionIndex;
                    // Remove from completed array if it was added
                    const completedIdx = this.state.session.completed.indexOf(prev.cardId);
                    if (completedIdx !== -1) {
                        this.state.session.completed.splice(completedIdx, 1);
                    }
                    // Restore rating counts
                    if (prev.ratingCounts) {
                        this.state.session.ratingCounts = prev.ratingCounts;
                    }
                    this.saveSession();
                }
                this.state.lastRating = null;
                // Hide the undo toast
                const t = el('#toast');
                t.classList.add('hidden', 'opacity-0');
                t.innerHTML = '';
                // Re-render study view to show the card again
                this.renderStudy();
                toast('Rating undone');
            },
            enableNonDueStudy() {
                // Temporarily ignore due dates for this study session
                this.state.studyNonDue = true;
                this.renderStudy();
            },
            cardsForDeck(deckId) {
                return this.state.cards.filter(c => c.deckId === deckId);
            },
            deckById(id) {
                return this.state.decks.find(d => d.id === id);
            },
            cardById(id) {
                return this.state.cards.find(c => c.id === id);
            },
            deckName(id) {
                return this.deckById(id)?.name ?? 'â€”';
            },
            getDeckLabel(deckIds) {
                if (!deckIds || deckIds.length === 0) return 'No decks';
                const allDeckIds = this.state.decks.map(d => d.id);
                const isAllDecks = deckIds.length === allDeckIds.length &&
                    deckIds.every(id => allDeckIds.includes(id));
                if (isAllDecks) return 'All decks';
                if (deckIds.length === 1) return this.deckById(deckIds[0])?.name || 'Unknown';
                return `${deckIds.length} decks`;
            },
            resetFilters() {
                this.state.filters = { again: false, hard: false, addedToday: false, stability: 25, tags: [], suspended: false, leech: false, manual: [], studyDecks: [] };
                el('#filterAgain').checked = false;
                el('#filterHard').checked = false;
                el('#filterAddedToday').checked = false;
                el('#filterStability').value = 25;
                el('#filterSuspended').checked = false;
                el('#filterLeech').checked = false;
                el('#stabilityValue').textContent = '25';
                this.renderStudyDeckSelection();
                this.renderTagFilter();
                this.renderStudy();
                this.renderCards();
            },
            openNotesModal() {
                const card = this.state.selectedCard;
                if (!card) return toast('No card selected');
                el('#notesArea').value = card.notes || '';
                el('#noteStatus').textContent = '';
                this.openModal('notesModal');
            },
            async saveNotes() {
                const card = this.state.selectedCard;
                if (!card) return;
                card.notes = el('#notesArea').value;
                await Storage.put('cards', card);
                this.queueOp({ type: 'card-upsert', payload: card });
                el('#noteStatus').textContent = 'Saved';
                el('#notesPreview').innerHTML = card.notes ? marked.parse(card.notes) : '<p class="text-earth-metal/60 text-sm">No notes yet.</p>';
                this.renderMath(el('#notesPreview'));
                this.closeModal('notesModal');
                toast('Notes saved');
            },
            openAddBlockModal() {
                const card = this.state.selectedCard;
                if (!card) return toast('No card selected');
                if (!card.notionId) return toast('Card not synced to Notion yet');
                el('#blockNoteArea').value = '';
                this.openModal('addBlockModal');
            },
            async saveBlockNote() {
                const card = this.state.selectedCard;
                if (!card || !card.notionId) return toast('Card not synced to Notion');
                const content = el('#blockNoteArea').value.trim();
                if (!content) return toast('Please enter some text');

                // Add timestamp prefix
                const timestamp = new Date().toLocaleString();
                const fullContent = `[${timestamp}] ${content}`;

                // Create Notion paragraph block (no 'object' property needed for children)
                const block = {
                    type: 'paragraph',
                    paragraph: {
                        rich_text: markdownToNotionRichText(fullContent)
                    }
                };

                // Queue the block append operation
                this.queueOp({
                    type: 'block-append',
                    payload: {
                        pageId: card.notionId,
                        blocks: [block]
                    }
                });

                this.closeModal('addBlockModal');
                toast('Note queued for sync');
            },
            async copyCardContent() {
                const card = this.state.selectedCard;
                if (!card) return toast('No card selected');
                const deck = this.deckById(card.deckId);
                const isCloze = (card.type || '').toLowerCase() === 'cloze';
                let content = `## ${card.name}\n\n`;
                if (!isCloze && card.back) {
                    content += `**Answer:**\n${card.back}\n\n`;
                }
                if (card.notes) {
                    content += `**Notes:**\n${card.notes}\n\n`;
                }
                content += `Deck: ${deck?.name ?? 'â€”'}`;
                await navigator.clipboard.writeText(content);
                toast('Copied to clipboard');
            },
            async handleAnkiImport(file) {
                if (!file) return;
                const ext = file.name.split('.').pop().toLowerCase();
                if (ext === 'apkg' || ext === 'zip') {
                    await this.importApkg(file);
                    return;
                }
                const text = await file.text();
                let payload;
                try { payload = JSON.parse(text); } catch { payload = null; }
                if (!payload?.cards?.length) return toast('Unsupported file');
                const deck = this.newDeck(file.name.replace('.apkg', '').replace('.json', ''), 'SM-2');
                this.state.decks.push(deck);
                await Storage.put('decks', deck);
                for (const raw of payload.cards) {
                    const card = this.newCard(deck.id, raw.name || raw.front || 'Imported', raw.back || '', raw.type || 'Front-Back');
                    card.tags = (raw.tags || []).map(t => typeof t === 'string' ? { name: t, color: 'default' } : t);
                    card.notes = raw.notes || '';
                    card.ankiGuid = raw.guid || crypto.randomUUID();
                    this.state.cards.push(card);
                    await Storage.put('cards', card);
                    this.queueOp({ type: 'card-upsert', payload: card });
                }
                this.queueOp({ type: 'deck-upsert', payload: deck });
                this.renderAll();
                toast('Imported Anki JSON and ready to sync to Notion');
            },
            async importApkg(file) {
                try {
                    const buf = await file.arrayBuffer();
                    const zip = await JSZip.loadAsync(buf);
                    const collectionFile = zip.file('collection.anki2');
                    if (!collectionFile) {
                        toast('Invalid .apkg file: missing collection.anki2');
                        return;
                    }
                    const collection = await collectionFile.async('uint8array');
                    const SQL = await Storage.ensureSQL();
                    const db = new SQL.Database(collection);
                    const colRow = db.exec("SELECT * FROM col LIMIT 1")[0];
                    const row = colRow?.values?.[0] || [];
                    const models = JSON.parse(row[9] || '{}');
                    const decksJson = JSON.parse(row[10] || '{}');
                    const decksMap = {};
                    Object.values(decksJson).forEach(d => { decksMap[d.id] = d.name; });
                    const notes = db.exec("SELECT id,guid,mid,mod,usn,tags,flds,sfld,csum,flags,data FROM notes")[0]?.values || [];
                    const cards = db.exec("SELECT id,nid,did,ord,mod,usn,type,queue,due,ivl,factor,reps,lapses,left,odue,odid,flags,data FROM cards")[0]?.values || [];
                    const deckCache = {};
                    for (const cardRow of cards) {
                        const [cid, nid, did, ord] = cardRow;
                        const note = notes.find(n => n[0] === nid);
                        if (!note) continue;
                        const [_, guid, mid, mod, usn, tags, flds] = note;
                        const deckId = did;
                        const deckName = decksMap[deckId] || file.name.replace('.apkg', '');
                        if (!deckCache[deckId]) {
                            const deck = this.newDeck(deckName, 'SM-2');
                            deckCache[deckId] = deck;
                            this.state.decks.push(deck);
                            await Storage.put('decks', deck);
                            this.queueOp({ type: 'deck-upsert', payload: deck });
                        }
                        const model = models[mid];
                        const fields = (flds || '').split('\u001f');
                        const front = fields[0] || 'Imported';
                        const back = fields[1] || '';
                        const isCloze = model?.type === 1;
                        const type = isCloze ? 'Cloze' : 'Front-Back';
                        const card = this.newCard(deckCache[deckId].id, front, isCloze ? back || front : back, type);
                        card.tags = (tags || '').trim().split(' ').filter(Boolean).map(t => ({ name: t.replace(/^\s*/, '').replace(/\s*$/, ''), color: 'default' }));
                        card.ankiGuid = guid;
                        card.ankiNoteType = model?.name || '';
                        card.ankiFields = JSON.stringify(fields);
                        card.clozeIndexes = isCloze ? 'auto' : '';
                        this.state.cards.push(card);
                        await Storage.put('cards', card);
                        this.queueOp({ type: 'card-upsert', payload: card });
                    }
                    this.renderAll();
                    toast('Imported .apkg');
                } catch (e) {
                    console.error(e);
                    toast('Import failed');
                }
            },
            async exportAnki() {
                const deck = this.state.selectedDeck || this.state.decks[0];
                if (!deck) return toast('No deck to export');
                const cards = this.cardsForDeck(deck.id);
                try {
                    const dbBytes = await this.buildApkgSql(deck, cards);
                    const zip = new JSZip();
                    zip.file('collection.anki2', dbBytes);
                    zip.file('media', JSON.stringify({}));
                    const blob = await zip.generateAsync({ type: 'blob' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${deck.name}.apkg`;
                    a.click();
                    URL.revokeObjectURL(url);
                    toast('Exported .apkg');
                } catch (e) {
                    toast('Export failed');
                    console.error(e);
                }
            },
            async buildApkgSql(deck, cards) {
                const SQL = await Storage.ensureSQL();
                const db = new SQL.Database();
                db.run(`CREATE TABLE col (id integer primary key, crt integer, mod integer, scm integer, ver integer, dty integer, usn integer, ls integer, conf text, models text, decks text, dconf text, tags text);`);
                db.run(`CREATE TABLE notes (id integer primary key, guid text, mid integer, mod integer, usn integer, tags text, flds text, sfld integer, csum integer, flags integer, data text);`);
                db.run(`CREATE TABLE cards (id integer primary key, nid integer, did integer, ord integer, mod integer, usn integer, type integer, queue integer, due integer, ivl integer, factor integer, reps integer, lapses integer, left integer, odue integer, odid integer, flags integer, data text);`);
                db.run(`CREATE TABLE revlog (id integer primary key, cid integer, usn integer, ease integer, ivl integer, lastIvl integer, factor integer, time integer, type integer);`);
                db.run(`CREATE TABLE graves (id integer primary key, oid integer, type integer, usn integer);`);

                const now = Math.floor(Date.now() / 1000);
                const dayStart = Math.floor(Date.now() / 1000 / 86400);
                const deckId = Math.abs(this.hash(deck.name));
                const modelBasicId = deckId + 1;
                const modelClozeId = deckId + 2;

                const conf = { nextPos: 1, estTimes: true, activeDecks: [deckId], sortType: "noteFld", sortBackwards: false, newSpread: 0, dueCounts: true, curDeck: deckId, timeLim: 0 };
                const models = {};
                models[modelBasicId] = {
                    id: modelBasicId,
                    name: "Basic",
                    type: 0,
                    mod: now,
                    usn: 0,
                    sortf: 0,
                    did: deckId,
                    latexPre: "\\documentclass{article}\\begin{document}",
                    latexPost: "\\end{document}",
                    flds: [
                        { name: "Front", ord: 0, sticky: false, rtl: false, font: "Arial", size: 20, media: [] },
                        { name: "Back", ord: 1, sticky: false, rtl: false, font: "Arial", size: 20, media: [] }
                    ],
                    tmpls: [
                        { name: "Card 1", ord: 0, qfmt: "{{Front}}", afmt: "{{FrontSide}}<hr id=answer>{{Back}}", did: null, bqfmt: "", bafmt: "" }
                    ],
                    css: ".card { font-family: Arial; font-size: 20px; }"
                };
                models[modelClozeId] = {
                    id: modelClozeId,
                    name: "Cloze",
                    type: 1,
                    mod: now,
                    usn: 0,
                    sortf: 0,
                    did: deckId,
                    flds: [
                        { name: "Text", ord: 0, sticky: false, rtl: false, font: "Arial", size: 20, media: [] },
                        { name: "Back Extra", ord: 1, sticky: false, rtl: false, font: "Arial", size: 20, media: [] }
                    ],
                    tmpls: [{ name: "Cloze", ord: 0, qfmt: "{{cloze:Text}}", afmt: "{{cloze:Text}}<br>{{Back Extra}}", did: null }],
                    css: ".card { font-family: Arial; font-size: 20px; }"
                };

                const decks = {};
                decks[deckId] = { id: deckId, name: deck.name, mod: now, usn: 0, desc: "", dyn: 0, extendNew: 0, extendRev: 0, conf: 1, collapsed: false, browserCollapsed: false, newToday: [dayStart, 0], revToday: [dayStart, 0], lrnToday: [dayStart, 0], timeToday: [dayStart, 0] };
                const dconf = { 1: { id: 1, name: "Default", new: { perDay: 20 }, rev: { perDay: 200 }, lapse: { delays: [10], mult: 0 }, dyn: false, maxTaken: 60, timer: 0 } };
                const tags = {};
                const colRow = db.prepare("INSERT INTO col VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)");
                colRow.run([1, dayStart, now, now, 11, 0, 0, 0, JSON.stringify(conf), JSON.stringify(models), JSON.stringify(decks), JSON.stringify(dconf), JSON.stringify(tags)]);

                let nidCounter = now * 1000;
                let cidCounter = now * 1000 + 500;
                const noteStmt = db.prepare("INSERT INTO notes VALUES (?,?,?,?,?,?,?,?,?,?,?)");
                const cardStmt = db.prepare("INSERT INTO cards VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
                cards.forEach((card, idx) => {
                    const isCloze = (card.type || '').toLowerCase() === 'cloze';
                    const mid = isCloze ? modelClozeId : modelBasicId;
                    const nid = ++nidCounter;
                    const cid = ++cidCounter;
                    const fields = isCloze ? [card.name, card.back] : [card.name, card.back];
                    const flds = fields.join('\u001f');
                    const tagStr = card.tags.length ? card.tags.map(t => t.name.trim()).join(' ') + ' ' : '';
                    const sfld = fields[0];
                    const csum = Math.abs(this.hash(flds)) >>> 0;
                    noteStmt.run([nid, card.ankiGuid || crypto.randomUUID(), mid, now, 0, tagStr, flds, sfld, csum, 0, ""]);

                    const ivl = card.fsrs?.stability ? Math.max(1, Math.round(card.fsrs.stability)) : 1;
                    const due = dayStart + idx;
                    const factor = 2500;
                    cardStmt.run([cid, nid, deckId, 0, now, 0, 0, 2, due, ivl, factor, 0, 0, 0, 0, 0, 0, ""]);
                });

                return new Uint8Array(db.export());
            },
            hash(str) {
                let h = 0;
                for (let i = 0; i < str.length; i++) {
                    h = Math.imul(31, h) + str.charCodeAt(i) | 0;
                }
                return h;
            },
            updateCounts() {
                el('#deckCount').textContent = String(this.state.decks.length);
                el('#cardCount').textContent = String(this.state.cards.length);
                el('#queueCount').textContent = String(this.state.queue.length);
                el('#lastSync').textContent = this.state.lastSync ? new Date(this.state.lastSync).toLocaleString() : 'â€”';
            },
            openSettings() {
                this.state.lastFocusedElement = document.activeElement;
                const s = this.state.settings;
                el('#settingWorkerUrl').value = s.workerUrl;
                el('#settingProxyToken').value = s.proxyToken;
                el('#settingAuthToken').value = s.authToken.startsWith('secret_') ? s.authToken : s.authToken;
                el('#settingsModal').classList.remove('hidden');
                el('#settingsModal').classList.add('flex');
                this.renderStatus();
                this.updateSettingsButtons();
                setTimeout(() => { el('#settingWorkerUrl').focus(); }, 50);
            },
            closeSettings() {
                el('#settingsModal').classList.add('hidden');
                el('#settingsModal').classList.remove('flex');
                if (this.state.lastFocusedElement) {
                    this.state.lastFocusedElement.focus();
                    this.state.lastFocusedElement = null;
                }
            },
            async saveSettings() {
                this.state.settings.workerUrl = el('#settingWorkerUrl').value.trim();
                this.state.settings.proxyToken = el('#settingProxyToken').value.trim();
                const authVal = el('#settingAuthToken').value.trim();
                if (authVal) {
                    this.state.settings.authToken = authVal;
                    this.state.authVerified = true;
                    this.state.settings.authVerified = true;
                }
                // Save AI settings
                const aiProvider = el('#aiProvider').value;
                const aiModel = el('#aiModel').value.trim();
                const aiKey = el('#aiKey').value.trim();
                this.state.settings.aiProvider = aiProvider;
                this.state.settings.aiModel = aiModel;
                if (aiKey) this.state.settings.aiKey = aiKey;
                // Save STT settings
                const sttProvider = el('#sttProvider').value;
                const sttModel = el('#sttModel').value.trim();
                const sttKey = el('#sttKey').value.trim();
                const sttPrompt = el('#sttPrompt').value.trim();
                this.state.settings.sttProvider = sttProvider;
                this.state.settings.sttModel = sttModel;
                if (sttKey) this.state.settings.sttKey = sttKey;
                this.state.settings.sttPrompt = sttPrompt;
                // Update state for STT
                this.state.sttProvider = sttProvider;
                this.state.sttModel = sttModel;
                if (sttKey) this.state.sttKey = sttKey;
                this.state.sttPrompt = sttPrompt;
                Storage.setSettings(this.state.settings);
                this.renderStatus();
                this.applyTheme();
                this.applyFontMode();
                this.renderGate();

                // Check if this is first sync (no decks/cards loaded yet)
                const isFirstSync = this.state.decks.length === 0 && this.state.cards.length === 0;

                if (isFirstSync && this.isReady()) {
                    // Close settings and show sync loading overlay
                    this.closeSettings();
                    showLoading('Syncing your content...', 'Fetching decks and cards from Notion.');

                    try {
                        await this.syncNow();
                        toast('Initial sync complete');
                    } catch (err) {
                        console.error('First sync error:', err);
                        toast('Sync error - please try again');
                    } finally {
                        hideLoading();
                        this.renderAll();
                    }
                } else {
                    this.closeSettings();
                    this.renderConnection();
                    toast('Settings saved');
                }
            },
            async verifyWorker() {
                const workerUrl = el('#settingWorkerUrl').value.trim();
                const proxyToken = el('#settingProxyToken').value.trim();
                if (!workerUrl) return toast('Add worker URL');
                try {
                    const url = new URL(workerUrl.replace(/\/$/, ''));
                    url.searchParams.append('url', 'https://api.notion.com/v1/users/me');
                    if (proxyToken) url.searchParams.append('token', proxyToken);
                    const res = await fetch(url.toString());
                    if (res.ok || res.status === 401) {
                        toast('Worker reachable');
                        this.state.settings.workerUrl = workerUrl;
                        this.state.settings.proxyToken = proxyToken;
                        this.state.workerVerified = true;
                        this.state.settings.workerVerified = true;
                        Storage.setSettings(this.state.settings);
                        this.renderStatus();
                        this.renderGate();
                    } else throw new Error(res.status);
                } catch (e) {
                    toast('Worker check failed');
                    this.state.workerVerified = false;
                    this.state.settings.workerVerified = false;
                    Storage.setSettings(this.state.settings);
                    this.renderStatus();
                }
            },
            async verifyAuth() {
                if (!this.state.settings.workerUrl) { this.updateSettingsButtons(); return toast('Add worker URL first'); }
                const workerUrl = (el('#settingWorkerUrl').value.trim()) || this.state.settings.workerUrl;
                const proxyToken = (el('#settingProxyToken').value.trim()) || this.state.settings.proxyToken;
                const authVal = (el('#settingAuthToken').value.trim()) || this.state.settings.authToken;
                if (!authVal) return toast('Add Notion token');
                this.state.settings.workerUrl = workerUrl;
                this.state.settings.proxyToken = proxyToken;
                this.state.settings.authToken = authVal;
                this.state.authVerified = true;
                this.state.settings.authVerified = true;
                Storage.setSettings(this.state.settings);
                toast('Token saved');
                this.renderStatus();
                this.renderGate();
                await this.scanSources();
            },
            async verifyAiSettings() {
                const provider = el('#aiProvider').value;
                const model = el('#aiModel').value.trim();
                const key = el('#aiKey').value.trim();
                if (!provider) return toast('Select an AI provider');
                if (!model) return toast('Enter a model name');
                if (!key) return toast('Enter an API key');
                try {
                    showLoading('Verifying AI settings...', 'Testing connection to AI provider.');
                    let endpoint, headers, body;
                    if (provider === 'openai') {
                        endpoint = 'https://api.openai.com/v1/models';
                        headers = { 'Authorization': `Bearer ${key}` };
                    } else if (provider === 'anthropic') {
                        endpoint = 'https://api.anthropic.com/v1/messages';
                        headers = { 'x-api-key': key, 'anthropic-version': '2023-06-01', 'Content-Type': 'application/json' };
                        body = JSON.stringify({ model, max_tokens: 1, messages: [{ role: 'user', content: 'Hi' }] });
                    } else if (provider === 'gemini') {
                        endpoint = `https://generativelanguage.googleapis.com/v1beta/models?key=${key}`;
                        headers = {};
                    }
                    const res = await fetch(endpoint, { method: body ? 'POST' : 'GET', headers, body });
                    if (res.ok || res.status === 400) {
                        this.state.settings.aiProvider = provider;
                        this.state.settings.aiModel = model;
                        this.state.settings.aiKey = key;
                        this.state.settings.aiVerified = true;
                        Storage.setSettings(this.state.settings);
                        // Show STT settings now that AI is verified
                        el('#sttSettings')?.classList.remove('hidden');
                        toast('AI settings verified');
                    } else {
                        throw new Error(`API returned ${res.status}`);
                    }
                } catch (e) {
                    this.state.settings.aiVerified = false;
                    Storage.setSettings(this.state.settings);
                    // Hide STT settings since AI is not verified
                    el('#sttSettings')?.classList.add('hidden');
                    toast('AI verification failed: ' + e.message);
                } finally {
                    hideLoading();
                }
            },
            async verifySttSettings() {
                const provider = el('#sttProvider').value;
                const model = el('#sttModel').value.trim();
                const key = el('#sttKey').value.trim();
                const prompt = el('#sttPrompt').value.trim();

                // If browser is selected, just save and return
                if (!provider) {
                    this.state.settings.sttProvider = '';
                    this.state.settings.sttModel = '';
                    this.state.settings.sttKey = '';
                    this.state.settings.sttPrompt = prompt;
                    this.state.settings.sttVerified = true;
                    Storage.setSettings(this.state.settings);
                    this.state.sttProvider = '';
                    this.state.sttVerified = true;
                    toast('Using browser speech recognition');
                    return;
                }

                if (!key) return toast('Enter an API key for cloud provider');

                try {
                    showLoading('Verifying STT settings...', 'Testing connection to speech provider.');
                    let endpoint, headers;

                    if (provider === 'openai') {
                        // Verify OpenAI key by checking models endpoint
                        endpoint = 'https://api.openai.com/v1/models';
                        headers = { 'Authorization': `Bearer ${key}` };
                    } else if (provider === 'groq') {
                        // Verify Groq key by checking models endpoint
                        endpoint = 'https://api.groq.com/openai/v1/models';
                        headers = { 'Authorization': `Bearer ${key}` };
                    } else if (provider === 'gemini') {
                        // Verify Gemini key by listing models
                        endpoint = `https://generativelanguage.googleapis.com/v1beta/models?key=${key}`;
                        headers = {};
                    }

                    const res = await fetch(endpoint, { method: 'GET', headers });
                    if (res.ok) {
                        this.state.settings.sttProvider = provider;
                        this.state.settings.sttModel = model || this.getDefaultSttModel(provider);
                        this.state.settings.sttKey = key;
                        this.state.settings.sttPrompt = prompt;
                        this.state.settings.sttVerified = true;
                        Storage.setSettings(this.state.settings);
                        this.state.sttProvider = provider;
                        this.state.sttModel = model || this.getDefaultSttModel(provider);
                        this.state.sttKey = key;
                        this.state.sttPrompt = prompt;
                        this.state.sttVerified = true;
                        toast('STT settings verified');
                    } else {
                        throw new Error(`API returned ${res.status}`);
                    }
                } catch (e) {
                    this.state.settings.sttVerified = false;
                    Storage.setSettings(this.state.settings);
                    toast('STT verification failed: ' + e.message);
                } finally {
                    hideLoading();
                }
            },
            getDefaultSttModel(provider) {
                if (provider === 'openai') return 'whisper-1';
                if (provider === 'groq') return 'whisper-large-v3';
                if (provider === 'gemini') return 'gemini-2.0-flash';
                return '';
            },
            startOAuth() {
                if (!this.state.settings.workerUrl) return toast('Add worker URL first');
                this.saveSettings();
                showLoading('Starting Notion sign-in...', 'Redirecting to Notion authorization.');
                const here = encodeURIComponent(window.location.href);
                window.location.href = `https://notion-oauth-handler.mimansa-jaiswal.workers.dev/auth/login?from=${here}`;
            },
            async scanSources() {
                if (!this.state.settings.workerUrl || !this.state.settings.authToken) return toast('Add worker URL and token first');
                try {
                    showLoading('Scanning databases...', 'Finding valid deck and card sources.');
                    toastLong('Scanning data sources...');
                    const dbs = await API.listDatabases();
                    const deckOptions = [];
                    const cardOptions = [];
                    for (const d of dbs) {
                        const id = d.id;
                        const title = d.title?.[0]?.plain_text || id;
                        if (await this.validateDb(id, 'deck')) deckOptions.push({ id, title });
                        if (await this.validateDb(id, 'card')) cardOptions.push({ id, title });
                    }
                    this.state.sourcesCache = { deckOptions, cardOptions };
                    this.state.settings.sourcesCache = { deckOptions, cardOptions };
                    el('#deckSourceSelect').innerHTML = `<option value=\"\">Select deck source</option>` + deckOptions.map(o => `<option value=\"${o.id}\">${o.title}</option>`).join('');
                    el('#cardSourceSelect').innerHTML = `<option value=\"\">Select card source</option>` + cardOptions.map(o => `<option value=\"${o.id}\">${o.title}</option>`).join('');
                    if (deckOptions.length === 1) this.state.settings.deckSource = deckOptions[0].id;
                    if (cardOptions.length === 1) this.state.settings.cardSource = cardOptions[0].id;
                    Storage.setSettings(this.state.settings);
                    if (this.state.settings.deckSource) el('#deckSourceSelect').value = this.state.settings.deckSource;
                    if (this.state.settings.cardSource) el('#cardSourceSelect').value = this.state.settings.cardSource;
                    this.state.sourcesVerified = !!(this.state.settings.deckSource && this.state.settings.cardSource);
                    this.state.settings.sourcesVerified = this.state.sourcesVerified;
                    Storage.setSettings(this.state.settings);
                    this.renderStatus();
                    this.renderGate();
                    toast('Sources loaded');
                } catch (e) {
                    toast(e.message);
                } finally {
                    hideLoading();
                    toastHide();
                }
            },
            populateSourceSelects() {
                const cache = this.state.settings.sourcesCache || { deckOptions: [], cardOptions: [] };
                const deckOptions = cache.deckOptions || [];
                const cardOptions = cache.cardOptions || [];
                this.state.sourcesCache = { deckOptions, cardOptions };
                el('#deckSourceSelect').innerHTML = `<option value="">Select deck source</option>` + deckOptions.map(o => `<option value="${o.id}">${o.title}</option>`).join('');
                el('#cardSourceSelect').innerHTML = `<option value="">Select card source</option>` + cardOptions.map(o => `<option value="${o.id}">${o.title}</option>`).join('');
                if (this.state.settings.deckSource) el('#deckSourceSelect').value = this.state.settings.deckSource;
                if (this.state.settings.cardSource) el('#cardSourceSelect').value = this.state.settings.cardSource;
                el('#deckSourceSelect').onchange = (e) => { this.state.settings.deckSource = e.target.value; this.state.sourcesVerified = !!(this.state.settings.deckSource && this.state.settings.cardSource); this.state.settings.sourcesVerified = this.state.sourcesVerified; Storage.setSettings(this.state.settings); this.renderStatus(); this.renderGate(); };
                el('#cardSourceSelect').onchange = (e) => { this.state.settings.cardSource = e.target.value; this.state.sourcesVerified = !!(this.state.settings.deckSource && this.state.settings.cardSource); this.state.settings.sourcesVerified = this.state.sourcesVerified; Storage.setSettings(this.state.settings); this.renderStatus(); this.renderGate(); };
            },
            openModal(id) {
                const m = el('#' + id);
                // Store the element that triggered the modal
                this.state.lastFocusedElement = document.activeElement;
                m.classList.remove('hidden');
                m.classList.add('flex');
                // Focus the first focusable element in the modal
                setTimeout(() => {
                    const focusable = m.querySelector('button, input, select, textarea, [tabindex]:not([tabindex="-1"])');
                    if (focusable) focusable.focus();
                }, 50);
            },
            closeModal(id) {
                const m = el('#' + id);
                m.classList.add('hidden');
                m.classList.remove('flex');
                // Return focus to the element that triggered the modal
                if (this.state.lastFocusedElement) {
                    this.state.lastFocusedElement.focus();
                    this.state.lastFocusedElement = null;
                }
            },
            copyWorkerCode() {
                const code = el('#workerCodeBlock').innerText;
                try {
                    navigator.clipboard.writeText(code);
                    toast('Worker code copied');
                } catch (e) {
                    console.error('Clipboard write failed:', e);
                    toast('Failed to copy - please select and copy manually');
                }
            },
            toggleDangerZone() {
                const content = el('#dangerZoneContent');
                const chevron = el('#dangerZoneChevron');
                content.classList.toggle('hidden');
                chevron.classList.toggle('rotate-180');
            },
            async resetApp() {
                this.closeModal('resetConfirmModal');
                showLoading('Resetting GhostInk...', 'Clearing all local data.');
                // Clear IndexedDB stores
                await Storage.wipeStore('decks');
                await Storage.wipeStore('cards');
                await Storage.wipeStore('meta');
                // Clear all GhostInk-specific localStorage keys
                localStorage.removeItem(Storage.settingsKey);
                localStorage.removeItem('ghostink_session_v1');
                // Close the database connection before deleting
                if (Storage.db) {
                    Storage.db.close();
                    Storage.db = null;
                }
                // Delete the entire database and wait for it to complete
                await new Promise((resolve, reject) => {
                    const req = indexedDB.deleteDatabase('GhostInkDB');
                    req.onsuccess = resolve;
                    req.onerror = reject;
                    req.onblocked = () => {
                        console.warn('Database delete blocked, reloading anyway');
                        resolve();
                    };
                });
                location.reload();
            },
            renderStatus() {
                const hasWorkerUrl = !!this.state.settings.workerUrl;
                const workerOk = hasWorkerUrl && (this.state.workerVerified || this.state.settings.workerVerified);
                const hasToken = !!this.state.settings.authToken;
                const authOk = workerOk && hasToken && (this.state.authVerified || this.state.settings.authVerified);
                const hasSources = !!(this.state.settings.deckSource && this.state.settings.cardSource && this.state.sourcesVerified);

                el('#statusWorker').textContent = `Worker: ${workerOk ? 'verified' : hasWorkerUrl ? 'unverified' : 'missing'}`;
                el('#statusAuth').textContent = `Auth: ${authOk ? 'verified' : workerOk ? (hasToken ? 'unverified' : 'missing') : 'blocked (verify worker)'}`;
                el('#statusSources').textContent = `Sources: ${hasSources ? 'verified' : 'missing'}`;
                this.updateSettingsButtons();
                this.renderConnection();
            },
            async validateDb(dbId, type) {
                try {
                    const meta = await API.getDatabase(dbId);
                    const props = meta?.properties || {};
                    const has = (name, kind) => props[name]?.type === kind;
                    if (type === 'deck') {
                        const required = [
                            ['Deck Name', 'title'],
                            ['Default SRS Algorithm', 'select'],
                            ['Ordered', 'checkbox'],
                            ['Daily Review Limit', 'number'],
                            ['New Card Limit', 'number'],
                            ['Reverse Mode Enabled', 'checkbox'],
                            ['Created In-App', 'checkbox'],
                            ['Archived?', 'checkbox']
                        ];
                        const missing = required.filter(([n, k]) => !has(n, k));
                        if (missing.length) return false;
                        return true;
                    }
                    if (type === 'card') {
                        const required = [
                            ['Name', 'title'],
                            ['Back', 'rich_text'],
                            ['Card Type', 'select'],
                            ['Deck', 'relation'],
                            ['Tags', 'multi_select'],
                            ['Suspended', 'checkbox'],
                            ['Leech', 'checkbox'],
                            ['Difficulty', 'number'],
                            ['Stability', 'number'],
                            ['Retrievability', 'number'],
                            ['Last Rating', 'select'],
                            ['Last Review', 'date'],
                            ['Due Date', 'date'],
                            ['Interval / Box Level', 'number'],
                            ['Ease Factor', 'number'],
                            ['Updated In-App', 'checkbox']
                        ];
                        const missing = required.filter(([n, k]) => !has(n, k));
                        if (missing.length) return false;
                        return true;
                    }
                } catch (e) {
                    // Validation failed - database doesn't match expected schema
                }
                return false;
            },
            updateSettingsButtons() {
                const s = this.state.settings;
                // Block scan/save/sources until both worker AND Notion auth are verified
                const workerOk = s.workerVerified || this.state.workerVerified;
                const notionOk = s.authVerified || this.state.authVerified;
                const blockScanSave = !(workerOk && notionOk);

                ['scanSources', 'saveSettings', 'deckSourceSelect', 'cardSourceSelect'].forEach(id => {
                    const elem = el('#' + id);
                    if (!elem) return;
                    elem.disabled = blockScanSave;
                });
                const oa = el('#oauthBtn');
                const va = el('#verifyAuth');
                const tokenInput = el('#settingAuthToken');
                const blockAuth = !this.state.settings.workerUrl;
                if (oa) { oa.disabled = blockAuth; oa.classList.toggle('opacity-60', blockAuth); oa.classList.toggle('cursor-not-allowed', blockAuth); }
                if (va) { va.disabled = blockAuth; va.classList.toggle('opacity-60', blockAuth); va.classList.toggle('cursor-not-allowed', blockAuth); }
                if (tokenInput) tokenInput.disabled = blockAuth;
            },
            async autoVerifyWorker() {
                const s = this.state.settings;
                // If already verified from storage, just re-render gate
                if (s.workerUrl && this.state.workerVerified && s.authToken && this.state.sourcesVerified) {
                    this.renderGate();
                    return;
                }
                // Otherwise, silently verify worker using stored settings (not input fields)
                if (!s.workerUrl) return;
                try {
                    const url = new URL(s.workerUrl.replace(/\/$/, ''));
                    url.searchParams.append('url', 'https://api.notion.com/v1/users/me');
                    if (s.proxyToken) url.searchParams.append('token', s.proxyToken);
                    const res = await fetch(url.toString());
                    if (res.ok || res.status === 401) {
                        this.state.workerVerified = true;
                        this.state.settings.workerVerified = true;
                        Storage.setSettings(this.state.settings);
                    }
                } catch (_) { /* silent fail - user can manually verify */ }
                this.renderGate();
                this.renderConnection();
            },
            applyTheme() {
                const mode = this.state.settings.themeMode || 'system';
                const systemPrefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                const theme = mode === 'system' ? (systemPrefersDark ? 'dark' : 'light') : mode;
                document.body.setAttribute('data-theme', theme);
                document.querySelectorAll('.theme-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.theme === mode);
                });
            },
            applyFontMode() {
                const mode = this.state.settings.fontMode || 'serif';
                document.body.setAttribute('data-font', mode === 'mono' ? 'mono' : 'serif');
                document.querySelectorAll('.font-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.font === mode);
                });
            },
            isReady() {
                const s = this.state.settings;
                const hasSettings = !!(s.workerUrl && s.authToken && s.deckSource && s.cardSource);
                // If offline, trust the stored settings (assume they were verified before)
                if (!navigator.onLine && hasSettings) return true;
                // If online, require full verification
                return hasSettings && s.workerVerified && (s.authVerified || this.state.authVerified) && s.sourcesVerified;
            },
            loadAISettings() {
                const s = Storage.getSettings();
                if (s.aiProvider) el('#aiProvider').value = s.aiProvider;
                if (s.aiModel) el('#aiModel').value = s.aiModel;
                if (s.aiKey) el('#aiKey').value = s.aiKey;
                this.state.aiProvider = s.aiProvider || '';
                this.state.aiModel = s.aiModel || '';
                this.state.aiKey = s.aiKey || '';
                // Load STT settings
                if (s.sttProvider) el('#sttProvider').value = s.sttProvider;
                if (s.sttModel) el('#sttModel').value = s.sttModel;
                if (s.sttKey) el('#sttKey').value = s.sttKey;
                if (s.sttPrompt) el('#sttPrompt').value = s.sttPrompt;
                this.state.sttProvider = s.sttProvider || '';
                this.state.sttModel = s.sttModel || '';
                this.state.sttKey = s.sttKey || '';
                this.state.sttPrompt = s.sttPrompt || '';
                this.state.sttVerified = s.sttVerified || false;
                if (s.themeMode) this.state.settings.themeMode = s.themeMode;
                if (s.fontMode) this.state.settings.fontMode = s.fontMode;
                this.applyTheme();
                this.applyFontMode();
                // Toggle provider field visibility based on current selection
                this.toggleAiProviderFields();
                this.toggleSttProviderFields();
                // Add change listeners for provider dropdowns
                el('#aiProvider').onchange = () => this.toggleAiProviderFields();
                el('#sttProvider').onchange = () => this.toggleSttProviderFields();
            },
            toggleAiProviderFields() {
                const provider = el('#aiProvider').value;
                const fields = el('#aiProviderFields');
                if (fields) {
                    if (provider) {
                        fields.classList.remove('hidden');
                    } else {
                        fields.classList.add('hidden');
                    }
                }
            },
            toggleSttProviderFields() {
                const provider = el('#sttProvider').value;
                const fields = el('#sttProviderFields');
                if (fields) {
                    if (provider) {
                        fields.classList.remove('hidden');
                    } else {
                        fields.classList.add('hidden');
                    }
                }
            },
            async submitToAI() {
                if (!this.state.selectedCard) return;
                const ans = el('#aiAnswer').value.trim();
                if (!ans) { toast('Enter or record an answer first'); return; }
                if (!this.state.settings.aiKey) { toast('Add an AI key in Settings'); return; }
                const deck = this.deckById(this.state.selectedCard.deckId);
                const promptTemplate = deck?.aiPrompt || DEFAULT_AI_PROMPT;
                // Swap question and answer if card is reversed
                const isReversed = this.state.cardReversed;
                const question = isReversed ? this.state.selectedCard.back : this.state.selectedCard.name;
                const answer = isReversed ? this.state.selectedCard.name : this.state.selectedCard.back;
                const prompt = promptTemplate
                    .replace('{{question}}', question)
                    .replace('{{answer}}', answer)
                    .replace('{{user}}', ans);
                const provider = this.state.settings.aiProvider || 'openai';
                const model = this.state.settings.aiModel || (provider === 'anthropic' ? 'claude-3-haiku-20240307' : provider === 'gemini' ? 'gemini-1.5-flash-latest' : 'gpt-4o-mini');
                try {
                    el('#aiFeedback').innerHTML = 'Thinking...';
                    const res = await this.callAI(provider, model, prompt, this.state.settings.aiKey);
                    el('#aiFeedback').innerHTML = marked.parse(res);
                    this.reveal();
                } catch (e) {
                    el('#aiFeedback').innerHTML = '';
                    toast('AI error: ' + e.message);
                }
            },
            async callAI(provider, model, prompt, key) {
                if (provider === 'anthropic') {
                    const resp = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json',
                            'x-api-key': key,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify({ model, max_tokens: 256, messages: [{ role: 'user', content: prompt }] })
                    });
                    if (!resp.ok) throw new Error('Claude returned ' + resp.status);
                    const json = await resp.json();
                    return json.content?.[0]?.text || 'No response';
                }
                if (provider === 'gemini') {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${encodeURIComponent(key)}`;
                    const resp = await fetch(url, {
                        method: 'POST',
                        headers: { 'content-type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });
                    if (!resp.ok) throw new Error('Gemini returned ' + resp.status);
                    const json = await resp.json();
                    return json.candidates?.[0]?.content?.parts?.map(p => p.text).join('\n') || 'No response';
                }
                const resp = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'content-type': 'application/json', 'authorization': 'Bearer ' + key },
                    body: JSON.stringify({ model, messages: [{ role: 'user', content: prompt }], max_tokens: 256 })
                });
                if (!resp.ok) throw new Error('OpenAI returned ' + resp.status);
                const json = await resp.json();
                return json.choices?.[0]?.message?.content || 'No response';
            },
            initMobileFab() {
                const cluster = el('#mobileFabCluster');
                if (!cluster) return;

                // Bind action buttons (always bind, visibility controlled by updateMobileFab)
                el('#fabReveal')?.addEventListener('click', () => this.reveal());
                el('#fabSkip')?.addEventListener('click', () => this.nextCard());
                el('#fabCopy')?.addEventListener('click', () => this.copyCardContent());
                el('#fabAddNote')?.addEventListener('click', () => this.openAddBlockModal());

                // Initialize joystick with Hammer.js
                this.initJoystick();

                // Listen for window resize to show/hide FAB cluster
                window.addEventListener('resize', () => this.updateMobileFab());
            },
            initJoystick() {
                const joystick = el('#joystick');
                if (!joystick || typeof Hammer === 'undefined') return;

                const THRESHOLD = 15;
                let currentDirection = null;

                const mc = new Hammer.Manager(joystick, { touchAction: 'none' });
                mc.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 5 }));

                const getDirection = (dx, dy) => {
                    const absX = Math.abs(dx);
                    const absY = Math.abs(dy);
                    if (absX < THRESHOLD && absY < THRESHOLD) return null;
                    if (absX > absY) {
                        return dx > 0 ? 'right' : 'left';
                    } else {
                        return dy > 0 ? 'down' : 'up';
                    }
                };

                const updateJoystick = (direction) => {
                    // Remove all direction classes
                    joystick.classList.remove('up', 'down', 'left', 'right');
                    // Remove active from all labels
                    joystick.querySelectorAll('.joystick-label').forEach(l => l.classList.remove('active'));

                    if (direction) {
                        joystick.classList.add(direction);
                        joystick.querySelector(`.joystick-label-${direction}`)?.classList.add('active');
                    }
                };

                mc.on('panmove', (e) => {
                    currentDirection = getDirection(e.deltaX, e.deltaY);
                    updateJoystick(currentDirection);
                });

                mc.on('panend', (e) => {
                    if (currentDirection) {
                        // Clockwise from bottom: Again (down) â†’ Hard (left) â†’ Good (up) â†’ Easy (right)
                        const ratings = { up: 'Good', down: 'Again', left: 'Hard', right: 'Easy' };
                        this.rate(ratings[currentDirection]);
                    }
                    currentDirection = null;
                    updateJoystick(null);
                });

                mc.on('pancancel', () => {
                    currentDirection = null;
                    updateJoystick(null);
                });
            },
            updateMobileFab() {
                const isSmallDevice = window.matchMedia('(max-width: 640px)').matches;
                const cluster = el('#mobileFabCluster');

                // Hide FAB on large screens
                if (!isSmallDevice) {
                    if (cluster) cluster.classList.add('hidden');
                    return;
                }

                const hasCard = !!this.state.selectedCard;
                const inSession = !!this.state.session;
                const revealed = this.state.answerRevealed;
                // Check if the actual reveal button in the card is visible (not hidden)
                const revealBtnVisible = el('#revealBtn') && !el('#revealBtn').classList.contains('hidden');

                const joystickContainer = el('#joystickContainer');
                const fabPreRevealActions = el('#fabPreRevealActions');
                const fabCopy = el('#fabCopy');
                const fabAddNote = el('#fabAddNote');

                // Only show FAB cluster when there's an active card with reveal button visible or already revealed
                const showFab = hasCard && inSession && (revealBtnVisible || revealed);
                if (cluster) cluster.classList.toggle('hidden', !showFab);

                // Show joystick only when answer is revealed
                if (joystickContainer) joystickContainer.classList.toggle('hidden', !revealed);
                // Show pre-reveal actions (skip + reveal) only when not revealed and reveal button is visible
                if (fabPreRevealActions) fabPreRevealActions.classList.toggle('hidden', revealed || !revealBtnVisible);
                // Show copy and add note only when revealed
                if (fabCopy) fabCopy.classList.toggle('hidden', !revealed);
                if (fabAddNote) fabAddNote.classList.toggle('hidden', !revealed);

                // Re-init lucide icons for the joystick
                if (revealed) {
                    setTimeout(() => lucide.createIcons(), 0);
                }
            },
            renderMath(container) {
                if (!container || typeof katex === 'undefined') return;
                container.querySelectorAll('.notion-equation').forEach(span => {
                    try {
                        const expr = span.textContent || '';
                        span.innerHTML = katex.renderToString(expr, { throwOnError: false });
                    } catch (e) { console.error(e); }
                });
            },
            async recordAnswer() {
                const provider = this.state.sttProvider;

                // If cloud provider is configured and verified, use it
                if (provider && this.state.sttVerified && this.state.sttKey) {
                    await this.recordWithCloudSTT();
                    return;
                }

                // Fall back to browser speech recognition
                if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
                    toast('Speech recognition not supported. Configure a cloud provider in settings.');
                    return;
                }
                const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
                const rec = new SR();
                rec.lang = 'en-US';
                rec.interimResults = true;
                rec.continuous = true;
                rec.maxAlternatives = 1;
                el('#aiFeedback').innerHTML = 'Listening... (Press M to stop)';

                let finalTranscript = el('#aiAnswer').value;
                if (finalTranscript) finalTranscript += ' ';

                rec.onresult = (e) => {
                    let interim = '';
                    for (let i = e.resultIndex; i < e.results.length; ++i) {
                        if (e.results[i].isFinal) {
                            finalTranscript += e.results[i][0].transcript;
                        } else {
                            interim += e.results[i][0].transcript;
                        }
                    }
                    el('#aiAnswer').value = finalTranscript + interim;
                    // Trigger input event to update Send button state
                    el('#aiAnswer').dispatchEvent(new Event('input'));
                };

                // Store recorder instance to allow stopping it
                this.state.currentRecorder = rec;

                rec.onerror = (e) => {
                    if (e.error !== 'aborted') {
                        el('#aiFeedback').innerHTML = '';
                        toast('Mic error: ' + e.error);
                    }
                    this.state.currentRecorder = null;
                };
                rec.onend = () => {
                    if (el('#aiFeedback').innerHTML.includes('Listening')) {
                        el('#aiFeedback').innerHTML = 'Captured. Now send.';
                    }
                    this.state.currentRecorder = null;
                };
                rec.start();
            },
            async recordWithCloudSTT() {
                const provider = this.state.sttProvider;
                const model = this.state.sttModel || this.getDefaultSttModel(provider);
                const key = this.state.sttKey;
                const prompt = this.state.sttPrompt || '';

                el('#aiFeedback').innerHTML = 'Recording... Click again to stop.';
                const recordBtn = el('#aiRecord');

                // If already recording, stop
                if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                    this.mediaRecorder.stop();
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const chunks = [];
                    this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });

                    this.mediaRecorder.ondataavailable = (e) => chunks.push(e.data);

                    this.mediaRecorder.onstop = async () => {
                        stream.getTracks().forEach(t => t.stop());
                        el('#aiFeedback').innerHTML = 'Transcribing...';

                        try {
                            const audioBlob = new Blob(chunks, { type: 'audio/webm' });
                            let transcript = '';

                            if (provider === 'openai' || provider === 'groq') {
                                transcript = await this.transcribeWithWhisper(audioBlob, provider, model, key, prompt);
                            } else if (provider === 'gemini') {
                                transcript = await this.transcribeWithGemini(audioBlob, model, key, prompt);
                            }

                            el('#aiAnswer').value = transcript;
                            el('#aiFeedback').innerHTML = 'Captured. Now send.';
                        } catch (e) {
                            el('#aiFeedback').innerHTML = '';
                            toast('Transcription failed: ' + e.message);
                        }
                    };

                    this.mediaRecorder.onerror = () => {
                        stream.getTracks().forEach(t => t.stop());
                        el('#aiFeedback').innerHTML = '';
                        toast('Recording error');
                    };

                    this.mediaRecorder.start();

                    // Auto-stop after 60 seconds
                    setTimeout(() => {
                        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                            this.mediaRecorder.stop();
                        }
                    }, 60000);

                } catch (e) {
                    el('#aiFeedback').innerHTML = '';
                    toast('Microphone access denied');
                }
            },
            async transcribeWithWhisper(audioBlob, provider, model, key, prompt) {
                const endpoint = provider === 'openai'
                    ? 'https://api.openai.com/v1/audio/transcriptions'
                    : 'https://api.groq.com/openai/v1/audio/transcriptions';

                const formData = new FormData();
                formData.append('file', audioBlob, 'audio.webm');
                formData.append('model', model);
                if (prompt) formData.append('prompt', prompt);

                const res = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${key}` },
                    body: formData
                });

                if (!res.ok) throw new Error(`API returned ${res.status}`);
                const data = await res.json();
                return data.text || '';
            },
            async transcribeWithGemini(audioBlob, model, key, prompt) {
                // Convert audio to base64 using chunked approach to avoid stack overflow
                const arrayBuffer = await audioBlob.arrayBuffer();
                const bytes = new Uint8Array(arrayBuffer);
                let binary = '';
                const chunkSize = 8192;
                for (let i = 0; i < bytes.length; i += chunkSize) {
                    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
                }
                const base64Audio = btoa(binary);

                const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`;

                const systemPrompt = prompt
                    ? `Transcribe this audio. Context: ${prompt}. Return only the transcription, no other text.`
                    : 'Transcribe this audio. Return only the transcription, no other text.';

                const res = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [
                                { text: systemPrompt },
                                { inline_data: { mime_type: 'audio/webm', data: base64Audio } }
                            ]
                        }]
                    })
                });

                if (!res.ok) throw new Error(`API returned ${res.status}`);
                const data = await res.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
            },
            async performDelete() {
                this.closeModal('confirmModal');
                const target = this.pendingDelete;
                if (!target) return;
                if (target.type === 'deck') {
                    await Storage.delete('decks', target.id);
                    this.state.decks = this.state.decks.filter(d => d.id !== target.id);
                    const cards = this.cardsForDeck(target.id);
                    for (const c of cards) await Storage.delete('cards', c.id);
                    this.state.cards = this.state.cards.filter(c => c.deckId !== target.id);
                    this.queueOp({ type: 'deck-delete', payload: { id: target.id, notionId: target.notionId } });
                    this.renderAll();
                    toast('Deck deleted');
                }
                if (target.type === 'card') {
                    await Storage.delete('cards', target.id);
                    this.state.cards = this.state.cards.filter(c => c.id !== target.id);
                    this.queueOp({ type: 'card-delete', payload: { id: target.id, notionId: target.notionId } });
                    this.renderCards();
                    toast('Card deleted');
                }
                this.pendingDelete = null;
            }
        };

        window.addEventListener('load', () => App.init());
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(() => { });
            });
        }
    </script>
</body>

</html>