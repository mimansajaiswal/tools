<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Chronicles</title>

    <!-- Tailwind CSS (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Font: DM Serif Display (Headers) & Inter (Body) -->
    <link
        href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">

    <!-- Tailwind Config for Custom Palette -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        oatmeal: '#F3F0E6',
                        'oatmeal-dark': '#E6E2D6',
                        'earth-metal': '#4A4A4A',
                        charcoal: '#2D2D2D',
                        'white-linen': '#FAF9F6',
                        'dull-purple': '#917FB3',
                        'dull-purple-hover': '#7A6A9A',
                        'muted-pink': '#D8A7B1',
                        'muted-pink-dim': '#C696A0'
                    },
                    fontFamily: {
                        serif: ['"DM Serif Display"', 'serif'],
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #F3F0E6;
        }

        ::-webkit-scrollbar-thumb {
            background: #D8A7B1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #917FB3;
        }

        /* Utility */
        .glass-panel {
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        /* Camera Overlay Transition */
        .overlay-ghost {
            transition: opacity 0.3s ease, clip-path 0.3s ease;
            pointer-events: none;
        }

        /* Loader */
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #917FB3;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Toast Animation */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast-enter {
            animation: slideIn 0.3s ease-out forwards;
        }

        .toast-exit {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Grid Lines */
        .grid-line {
            position: absolute;
            pointer-events: none;
        }
    </style>
</head>

<body
    class="bg-oatmeal text-earth-metal font-sans h-[100dvh] flex flex-col md:flex-row overflow-hidden selection:bg-dull-purple selection:text-white">

    <!-- Toast Container -->
    <div id="toastContainer"
        class="fixed top-4 right-4 z-[100] flex flex-col gap-2 w-full max-w-sm pointer-events-none"></div>

    <!-- Hidden Canvas for Processing (Global) -->
    <canvas id="photoCanvas" class="hidden"></canvas>

    <!-- Sidebar (Desktop) / Bottom Nav (Mobile) -->
    <aside
        class="order-2 md:order-1 w-full md:w-64 h-16 md:h-full flex-shrink-0 flex flex-row md:flex-col border-t md:border-t-0 md:border-r border-oatmeal-dark bg-oatmeal/50 transition-all duration-300 justify-between z-20">

        <!-- Logo Area -->
        <div class="hidden md:flex h-16 px-6 border-b border-oatmeal-dark items-center gap-3 flex-shrink-0">
            <div class="w-8 h-8 rounded-full bg-dull-purple flex items-center justify-center text-white-linen">
                <i data-lucide="history" class="w-5 h-5"></i>
            </div>
            <div class="flex flex-col">
                <h1 class="font-serif text-lg text-charcoal tracking-wide leading-none">Photo Chronicles</h1>
                <span class="text-[9px] uppercase tracking-widest text-earth-metal/60">with Notion</span>
            </div>
        </div>

        <!-- Diary List -->
        <div class="hidden md:flex flex-col flex-1 overflow-hidden">
            <div class="flex-1 overflow-y-auto p-3 space-y-2" id="diaryListContainer">
                <!-- Diaries injected here -->
            </div>
            <!-- Data Safety Notice (Sidebar) -->
            <div
                class="p-4 text-[10px] text-earth-metal/50 leading-tight border-t border-oatmeal-dark/50 bg-oatmeal/30">
                <i data-lucide="info" class="w-3 h-3 inline mb-0.5 mr-1"></i>
                This app displays content from your browser cache for speed. If your cache is cleared, don't worryâ€”your
                data is safe in Notion.
            </div>
        </div>

        <!-- Mobile Nav Items (Only visible on small screens) -->
        <div class="md:hidden flex w-full justify-around items-center px-4">
            <button onclick="App.openModal('settingsModal')" class="p-2 text-earth-metal hover:text-dull-purple">
                <i data-lucide="settings" class="w-6 h-6"></i>
            </button>
            <button onclick="App.initNewEntry()"
                class="p-3 -mt-6 bg-dull-purple text-white rounded-full shadow-lg border-4 border-oatmeal">
                <i data-lucide="plus" class="w-6 h-6"></i>
            </button>
            <button onclick="App.attemptNewDiary()" class="p-2 text-earth-metal hover:text-dull-purple">
                <i data-lucide="book-plus" class="w-6 h-6"></i>
            </button>
        </div>

        <!-- Sidebar Footer (Desktop) -->
        <div class="hidden md:block p-4 border-t border-oatmeal-dark space-y-2 flex-shrink-0">
            <button onclick="App.attemptNewDiary()"
                class="w-full flex items-center justify-start gap-3 p-2 rounded-lg hover:bg-white-linen text-dull-purple transition-colors">
                <i data-lucide="plus-circle" class="w-5 h-5"></i>
                <span class="font-medium">New Diary</span>
            </button>
            <button onclick="App.openModal('settingsModal')"
                class="w-full flex items-center justify-start gap-3 p-2 rounded-lg hover:bg-white-linen text-earth-metal transition-colors">
                <i data-lucide="settings" class="w-5 h-5"></i>
                <span class="font-medium">Settings</span>
            </button>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="order-1 md:order-2 flex-1 flex flex-col min-h-0 relative" id="mainView">

        <!-- Header -->
        <header
            class="h-16 border-b border-oatmeal-dark flex items-center justify-between px-4 md:px-6 bg-oatmeal/80 backdrop-blur-sm z-10 flex-shrink-0">
            <div class="flex items-center gap-3 overflow-hidden">
                <!-- Mobile Diary Switcher Trigger -->
                <button id="mobileDiaryToggleBtn" onclick="App.toggleMobileDiaryMenu(event)"
                    class="md:hidden p-1 rounded hover:bg-white/50 -ml-1 text-earth-metal">
                    <i data-lucide="library" class="w-5 h-5"></i>
                </button>

                <h2 id="activeDiaryTitle" class="font-serif text-xl md:text-2xl text-charcoal truncate">Select a Diary
                </h2>
                <span id="syncStatus"
                    class="hidden flex-shrink-0 text-[10px] px-2 py-1 rounded-full bg-white border border-oatmeal-dark text-earth-metal items-center gap-1">
                    <span class="w-2 h-2 rounded-full bg-gray-400"></span>
                    <span>Init</span>
                </span>
            </div>

            <div class="flex items-center gap-2">
                <button onclick="SyncManager.syncCurrentDiary()" title="Refresh Sync"
                    class="p-2 hover:bg-white-linen rounded-full text-earth-metal transition-colors">
                    <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                </button>
                <!-- Desktop Add Button -->
                <button id="addEntryBtn" onclick="App.initNewEntry()"
                    class="hidden md:flex bg-dull-purple hover:bg-dull-purple-hover text-white-linen px-4 py-2 rounded-lg shadow-sm transition-all items-center gap-2">
                    <i data-lucide="pen-tool" class="w-4 h-4"></i>
                    <span>Add Entry</span>
                </button>
            </div>
        </header>

        <!-- Mobile Diary Menu (Dropdown/Sheet) -->
        <div id="mobileDiaryMenu"
            class="md:hidden hidden absolute top-16 left-0 w-full bg-white-linen shadow-xl border-b border-oatmeal-dark z-20 max-h-[60vh] overflow-y-auto">
            <div class="p-2" id="mobileDiaryList">
                <!-- Diaries injected here -->
            </div>
        </div>

        <!-- Entry Gallery -->
        <div id="entryGallery" class="flex-1 overflow-y-auto p-4 md:p-8 pb-24 md:pb-8">
            <!-- Content injected via JS -->
        </div>

    </main>

    <!-- MODALS -->

    <!-- 1. Settings Modal -->
    <div id="settingsModal"
        class="fixed inset-0 bg-charcoal/20 backdrop-blur-sm hidden items-center justify-center z-50 p-4"
        onclick="if(event.target===this) App.closeModal('settingsModal')">
        <div
            class="bg-white-linen w-full max-w-md p-6 rounded-xl shadow-xl border border-oatmeal-dark relative max-h-full overflow-y-auto">
            <button onclick="App.closeModal('settingsModal')"
                class="absolute top-4 right-4 text-earth-metal/50 hover:text-earth-metal">
                <i data-lucide="x" class="w-5 h-5"></i>
            </button>
            <h3 class="font-serif text-xl mb-4 text-charcoal">Settings</h3>

            <!-- Connection Status Indicator -->
            <div id="connectionStatus" class="mb-6"></div>

            <div class="space-y-6">

                <!-- Database Instructions (Before Proxy) -->
                <div
                    class="bg-dull-purple/5 border border-dull-purple/20 p-3 rounded text-xs text-earth-metal leading-relaxed">
                    <p class="font-bold mb-1">Required Notion Database Format:</p>
                    <p class="text-[11px] mb-2 opacity-80">Columns: Name (title), Tags (multi-select), Date (date),
                        Files (media), Notes (text).</p>
                    <p>
                        Need a template? <a
                            href="https://mimansajaiswal-embedded-dbs.notion.site/photo-chronicles-template?v=2b423941af7b8019977c000c05dd66cf"
                            target="_blank"
                            class="text-dull-purple underline hover:text-dull-purple-hover font-bold">Duplicate this
                            one</a> and add your own tags to start.
                    </p>
                </div>

                <!-- 1. Proxy Settings (Step 1) -->
                <div class="space-y-3 bg-oatmeal/30 p-3 rounded border border-oatmeal-dark/50 relative">
                    <span
                        class="absolute -top-2.5 left-2 bg-white-linen text-[10px] font-bold px-1 text-dull-purple">STEP
                        1: PROXY</span>

                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal">API Proxy
                                Worker URL</label>
                            <button onclick="App.openModal('workerHelpModal')"
                                class="text-dull-purple hover:text-charcoal" title="How to set up Worker">
                                <i data-lucide="info" class="w-4 h-4"></i>
                            </button>
                        </div>
                        <input type="text" id="settingWorkerUrl" placeholder="https://..."
                            oninput="App.onSettingInput()"
                            class="w-full bg-oatmeal border border-oatmeal-dark rounded p-2 text-sm mb-2">
                    </div>
                    <div>
                        <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal mb-1">Proxy
                            Secret (Optional)</label>
                        <input type="password" id="settingProxyToken" placeholder="ALL_CORS_PROXY_MATCH_TOKEN"
                            oninput="App.onSettingInput()"
                            class="w-full bg-oatmeal border border-oatmeal-dark rounded p-2 text-sm mb-2">
                    </div>
                    <button onclick="App.verifyWorker()" id="verifyWorkerBtn"
                        class="w-full bg-dull-purple/10 hover:bg-dull-purple/20 text-dull-purple border border-dull-purple/20 py-2 rounded text-xs font-bold uppercase tracking-wider transition-colors flex items-center justify-center gap-2">
                        Verify Proxy
                    </button>
                </div>

                <!-- 2. Authentication (Step 2) -->
                <div id="authSection"
                    class="bg-oatmeal/50 p-4 rounded-lg border border-oatmeal-dark relative opacity-50 pointer-events-none transition-opacity">
                    <span
                        class="absolute -top-2.5 left-2 bg-white-linen text-[10px] font-bold px-1 text-earth-metal">STEP
                        2: AUTH</span>

                    <div class="flex justify-between items-center mb-2 mt-1">
                        <label
                            class="block text-xs font-bold uppercase tracking-wider text-earth-metal">Authentication</label>
                        <a href="https://developers.notion.com/docs/create-a-notion-integration#create-your-integration-in-notion"
                            target="_blank" class="text-dull-purple hover:text-charcoal" title="How to get a token">
                            <i data-lucide="info" class="w-4 h-4"></i>
                        </a>
                    </div>
                    <div class="flex gap-2 mb-2">
                        <button onclick="App.saveBeforeOAuth()"
                            class="flex-1 bg-charcoal text-white-linen py-2 rounded flex items-center justify-center gap-2 hover:bg-black transition-colors shadow-sm group">
                            <i data-lucide="zap"
                                class="w-4 h-4 text-yellow-400 group-hover:text-yellow-300 transition-colors"></i>
                            <span class="text-sm font-medium">Connect via OAuth</span>
                        </button>
                    </div>
                    <div class="relative flex py-2 items-center">
                        <div class="flex-grow border-t border-oatmeal-dark/50"></div>
                        <span
                            class="flex-shrink-0 mx-2 text-[10px] text-earth-metal/40 font-bold uppercase tracking-widest">OR
                            MANUAL KEY</span>
                        <div class="flex-grow border-t border-oatmeal-dark/50"></div>
                    </div>

                    <!-- Updated Manual Key Input with Verify Button -->
                    <div class="flex gap-2">
                        <input type="password" id="settingAuthToken" placeholder="Paste 'secret_...' token here"
                            oninput="App.onSettingInput()"
                            class="flex-1 bg-white-linen border border-oatmeal-dark rounded p-2 text-xs outline-none text-earth-metal placeholder-earth-metal/30">
                        <button onclick="App.testManualConnection(this)"
                            class="bg-dull-purple/10 text-dull-purple hover:bg-dull-purple hover:text-white text-xs font-medium px-3 rounded transition-colors border border-dull-purple/20">
                            Verify Key
                        </button>
                    </div>
                </div>
            </div>

            <details class="group mt-8 border-t border-oatmeal-dark pt-4">
                <summary
                    class="text-xs font-bold uppercase tracking-wider text-red-800 mb-2 cursor-pointer list-none flex items-center gap-2 outline-none">
                    <span class="flex-1">Danger Zone</span>
                    <i data-lucide="chevron-down"
                        class="w-4 h-4 text-red-800 group-open:rotate-180 transition-transform"></i>
                </summary>
                <div class="pt-2">
                    <button onclick="App.resetApp()"
                        class="w-full border border-red-200 bg-red-50 text-red-600 hover:bg-red-100 py-2 rounded text-xs font-medium flex items-center justify-center gap-2 transition-colors">
                        <i data-lucide="trash" class="w-3 h-3"></i> Reset App & Clear Cache
                    </button>
                </div>
            </details>

            <div class="mt-6 flex justify-end items-center gap-3">
                <button onclick="App.saveSettings()" id="saveSettingsBtn" disabled
                    class="px-4 py-2 rounded bg-dull-purple text-white-linen hover:bg-dull-purple-hover font-medium disabled:opacity-50 disabled:cursor-not-allowed transition-opacity">Save
                    Settings</button>
            </div>
        </div>
    </div>

    <!-- 2. Worker Help Modal -->
    <div id="workerHelpModal"
        class="fixed inset-0 bg-charcoal/20 backdrop-blur-sm hidden items-center justify-center z-[60] p-4"
        onclick="if(event.target===this) App.closeModal('workerHelpModal')">
        <div
            class="bg-white-linen w-full max-w-2xl h-[80vh] p-6 rounded-xl shadow-2xl border border-oatmeal-dark flex flex-col">
            <div class="flex justify-between items-center mb-4 border-b border-oatmeal-dark pb-2">
                <h3 class="font-serif text-xl text-charcoal">Setup Cloudflare Worker</h3>
                <button onclick="App.closeModal('workerHelpModal')" class="text-earth-metal/50 hover:text-earth-metal">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto space-y-4 text-sm text-earth-metal pr-2">
                <p>To bypass Notion's CORS restrictions, you need a small proxy. We use Cloudflare Workers (Free).</p>
                <ol class="list-decimal pl-5 space-y-2">
                    <li>Go to <a href="https://workers.cloudflare.com/" target="_blank"
                            class="text-dull-purple underline">Cloudflare Workers</a> and create a new Worker.</li>
                    <li>Copy the code below and paste it into the Worker editor (replace default code).</li>
                    <li>Save and Deploy.</li>
                    <li>(Optional) In Worker Settings > Variables, add <code>ALL_CORS_PROXY_MATCH_TOKEN</code> with a
                        secret password.</li>
                    <li>Copy your Worker's URL (e.g., <code>https://my-proxy.user.workers.dev</code>) and paste it into
                        the app settings.</li>
                </ol>
                <div class="relative">
                    <button onclick="App.copyWorkerCode(this)"
                        class="absolute top-2 right-2 bg-white/80 hover:bg-white px-2 py-1 rounded text-xs shadow text-charcoal font-bold">Copy
                        Code</button>
                    <pre id="workerCodeBlock"
                        class="bg-charcoal text-white-linen p-4 rounded text-xs font-mono overflow-x-auto">
const NOTION_API_END_POINT = "https://api.notion.com/v1";

export default {
  async fetch(request, env) {
    return await handleRequest(request, env);
  }
};

function getCorsHeaders(request) {
  return {
    "Access-Control-Allow-Origin": request.headers.get("Origin") || "*",
    "Access-Control-Allow-Methods": "GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization, Notion-Version",
  };
}

function handleOptions(request) {
  return new Response(null, {
    headers: getCorsHeaders(request),
  });
}

async function handleRequest(request, env) {
  if (request.method === "OPTIONS") {
    return handleOptions(request);
  }

  const url = new URL(request.url);
  const requiredToken = (env.ALL_CORS_PROXY_MATCH_TOKEN || "").trim();

  if (requiredToken !== "") {
    const providedToken = url.searchParams.get("token");
    if (providedToken !== requiredToken) {
      return new Response("Unauthorized", { status: 403 });
    }
    url.searchParams.delete("token");
  }

  const isGeneral = url.searchParams.has("url");
  let targetUrl;
  let secretKey = null;

  if (isGeneral) {
    targetUrl = url.searchParams.get("url");
    url.searchParams.delete("url");
    try {
      targetUrl = new URL(targetUrl).toString();
    } catch (err) {
      return new Response("Invalid target URL", { status: 400 });
    }
  } else {
    secretKey = url.searchParams.get("secret");
    if (!secretKey) {
      return new Response("Missing secret key parameter", { status: 400 });
    }
    url.searchParams.delete("secret");

    let normalizedPath = url.pathname.replace(/\/{2,}/g, '/');
    const base = NOTION_API_END_POINT.replace(/\/$/, "");
    const path = normalizedPath.startsWith("/") ? normalizedPath : "/" + normalizedPath;
    targetUrl = base + path + url.search;
  }

  const modifiedRequest = new Request(targetUrl, request);
  modifiedRequest.headers.set("Origin", new URL(targetUrl).origin);

  if (!isGeneral && secretKey) {
    modifiedRequest.headers.set("Authorization", `Bearer ${secretKey}`);
    modifiedRequest.headers.set("Notion-Version", "2022-06-28");
  }

  const response = await fetch(modifiedRequest);
  const newResponse = new Response(response.body, response);
  newResponse.headers.set("Access-Control-Allow-Origin", request.headers.get("Origin") || "*");
  newResponse.headers.append("Vary", "Origin");

  return newResponse;
}
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- 3. New Diary Modal (Revamped) -->
    <div id="newDiaryModal"
        class="fixed inset-0 bg-charcoal/20 backdrop-blur-sm hidden items-center justify-center z-50 p-4"
        onclick="if(event.target===this) App.closeModal('newDiaryModal')">
        <div
            class="bg-white-linen w-full max-w-md p-6 rounded-xl shadow-xl border border-oatmeal-dark overflow-visible flex flex-col h-[500px]">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="font-serif text-xl text-charcoal">New Diary</h3>
                <button onclick="App.scanForDatabases()"
                    class="text-xs text-dull-purple hover:underline flex items-center gap-1" id="refreshDbBtn">
                    <i data-lucide="refresh-cw" class="w-3 h-3"></i> Refresh
                </button>
            </div>

            <div class="space-y-4 flex-1 overflow-y-auto pr-1">

                <!-- Searchable Dropdown -->
                <div class="relative">
                    <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal mb-1">Select Notion
                        Database</label>

                    <!-- Info Text Moved Here -->
                    <div class="text-[10px] text-earth-metal/60 mb-3 leading-tight">
                        Only showing datasources with required columns: Name (title), Date (date), Tags (multi-select),
                        Notes (text), Files (media).
                    </div>

                    <div class="relative">
                        <input type="text" id="dbSearchInput" placeholder="Search Databases..."
                            onfocus="App.toggleDbDropdown(true)" onkeyup="App.filterDbList(event)"
                            class="w-full bg-oatmeal border border-oatmeal-dark rounded p-2 text-sm focus:ring-2 focus:ring-dull-purple/50 outline-none"
                            autocomplete="off">
                        <i data-lucide="chevron-down"
                            class="absolute right-3 top-3 w-4 h-4 text-earth-metal/50 pointer-events-none"></i>
                    </div>

                    <!-- Dropdown List -->
                    <div id="dbDropdownList"
                        class="hidden absolute top-full left-0 w-full mt-1 bg-white shadow-xl rounded-lg border border-oatmeal-dark max-h-60 overflow-y-auto z-50">
                        <!-- Items injected here -->
                        <div class="p-4 text-center text-xs text-earth-metal/50">Type to search...</div>
                    </div>
                </div>

                <!-- Selected DB Info -->
                <div id="selectedDbInfo" class="hidden bg-dull-purple/5 p-3 rounded border border-dull-purple/20 mt-4">
                    <div class="text-xs font-bold text-dull-purple uppercase tracking-wider mb-1">Selected</div>
                    <div class="font-serif text-lg text-charcoal" id="previewDbTitle"></div>
                    <div class="text-xs text-earth-metal/70 mt-1 line-clamp-2" id="previewDbDesc"></div>
                </div>
            </div>

            <div class="mt-6 flex justify-end gap-3 flex-shrink-0 pt-4 border-t border-oatmeal-dark">
                <button onclick="App.closeModal('newDiaryModal')"
                    class="px-4 py-2 rounded text-earth-metal hover:bg-oatmeal">Cancel</button>
                <button onclick="App.createDiary()"
                    class="px-4 py-2 rounded bg-dull-purple text-white-linen hover:bg-dull-purple-hover">Create
                    Diary</button>
            </div>
        </div>
    </div>

    <!-- 4. Delete Confirmation Modal -->
    <div id="deleteModal"
        class="fixed inset-0 bg-charcoal/20 backdrop-blur-sm hidden items-center justify-center z-[70] p-4"
        onclick="if(event.target===this) App.closeModal('deleteModal')">
        <div class="bg-white-linen w-full max-w-sm p-6 rounded-xl shadow-xl border border-oatmeal-dark">
            <h3 class="font-serif text-lg text-charcoal mb-2">Delete Entry?</h3>
            <p class="text-sm text-earth-metal/80 mb-6">This will remove the entry from your <b>local storage</b> AND
                <b>Notion</b>. This action cannot be undone.
            </p>
            <div class="flex justify-end gap-3">
                <button onclick="App.closeModal('deleteModal')"
                    class="px-4 py-2 rounded text-earth-metal hover:bg-oatmeal text-sm">Cancel</button>
                <button onclick="App.executeDelete()"
                    class="px-4 py-2 rounded bg-red-500 text-white hover:bg-red-600 text-sm font-medium">Delete
                    Everywhere</button>
            </div>
        </div>
    </div>

    <!-- 6. Reset Confirmation Modal (New) -->
    <div id="resetConfirmationModal"
        class="fixed inset-0 bg-charcoal/20 backdrop-blur-sm hidden items-center justify-center z-[80] p-4"
        onclick="if(event.target===this) App.closeModal('resetConfirmationModal')">
        <div class="bg-white-linen w-full max-w-sm p-6 rounded-xl shadow-xl border border-red-200">
            <div class="flex items-center gap-3 mb-2 text-red-700">
                <i data-lucide="alert-triangle" class="w-6 h-6"></i>
                <h3 class="font-serif text-lg">Reset App?</h3>
            </div>
            <p class="text-sm text-earth-metal/80 mb-6 leading-relaxed">
                This will <b>disconnect Notion</b> and <b>delete all local settings & cache</b>.
                <br><br>
                Your data stored in Notion will stay safe, but you will need to reconnect to see it again.
            </p>
            <div class="flex justify-end gap-3">
                <button onclick="App.closeModal('resetConfirmationModal')"
                    class="px-4 py-2 rounded text-earth-metal hover:bg-oatmeal text-sm">Cancel</button>
                <button onclick="App.executeReset()"
                    class="px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700 text-sm font-medium shadow-md hover:shadow-lg transition-all">Yes,
                    Reset Everything</button>
            </div>
        </div>
    </div>

    <!-- 5. Entry Modal (Live Composite Layout) -->
    <div id="entryModal" class="fixed inset-0 bg-white-linen z-50 hidden flex-col overflow-hidden">

        <!-- Close Button -->
        <button onclick="App.closeModal('entryModal')"
            class="absolute top-4 left-4 z-50 bg-black/50 text-white p-2 rounded-full backdrop-blur-sm hover:bg-black/70 transition">
            <i data-lucide="x" class="w-6 h-6"></i>
        </button>

        <!-- Top Section: Camera Viewfinder (Canvas-based) -->
        <div id="cameraSection"
            class="relative w-full h-[40%] md:h-[50%] max-h-[600px] bg-zinc-100 flex-shrink-0 flex items-center justify-center overflow-hidden group">

            <!-- Hidden Video Source -->
            <video id="videoSource" autoplay playsinline class="hidden"></video>

            <!-- The Viewfinder Canvas (Live Composite) -->
            <canvas id="viewfinder" class="w-full h-full object-contain z-10"></canvas>

            <!-- Ghost Overlay (Restored as img) -->
            <img id="ghostOverlay"
                class="absolute inset-0 w-full h-full object-contain z-30 pointer-events-none transition-opacity duration-200 opacity-0">

            <!-- Camera Controls -->
            <div id="camControls"
                class="absolute bottom-4 left-0 right-0 z-40 flex flex-col items-center gap-3 transition-opacity duration-200">

                <!-- Segment Indicator (If collage mode > 1) -->
                <div id="segmentIndicator"
                    class="text-charcoal/70 bg-white/80 px-2 py-1 rounded text-[10px] font-mono uppercase tracking-widest hidden shadow-sm">
                    Segment <span id="segCurrent">1</span>/<span id="segTotal">1</span>
                </div>

                <!-- Main Controls Row -->
                <div class="flex items-center justify-center gap-4 md:gap-6">

                    <!-- 1. Mirror Toggle (If user facing) -->
                    <button id="mirrorToggleBtn" onclick="App.toggleMirror()"
                        class="hidden bg-black/40 backdrop-blur-md p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="flip-horizontal" class="w-6 h-6"></i>
                    </button>

                    <!-- 2. Flip Camera Button -->
                    <button onclick="App.flipCamera()"
                        class="bg-black/40 backdrop-blur-md p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="refresh-ccw" class="w-6 h-6"></i>
                    </button>

                    <!-- 3. Insert Image (File Input) -->
                    <label
                        class="cursor-pointer bg-black/40 backdrop-blur-md p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="image" class="w-6 h-6"></i>
                        <input type="file" id="fileInput" accept="image/*" class="hidden"
                            onchange="App.handleFileUpload(event)">
                    </label>

                    <!-- 4. Capture Button (Center) -->
                    <button onclick="App.captureSegment()" id="captureBtn"
                        class="w-16 h-16 rounded-full border-4 border-white/80 bg-charcoal/60 shadow-[0_0_12px_rgba(0,0,0,0.5)] flex items-center justify-center hover:bg-black/70 transition active:scale-95 backdrop-blur-sm">
                        <div class="w-12 h-12 bg-white rounded-full shadow-inner"></div>
                    </button>

                    <!-- 5. Layout Button (Grid Mode) -->
                    <div class="relative group">
                        <button onclick="App.toggleCollageMenu()" id="gridBtn"
                            class="bg-black/40 backdrop-blur-md p-3 rounded-full hover:bg-black/60 text-white transition font-bold text-xs flex items-center justify-center w-12 h-12">
                            1x
                        </button>

                        <!-- Vertical Popup for Grid Selection -->
                        <div id="collageMenu"
                            class="hidden absolute bottom-full left-1/2 -translate-x-1/2 mb-2 bg-black/80 backdrop-blur-md rounded-xl flex-col p-1 gap-1 transition-all shadow-lg w-16 items-center">
                            <button onclick="App.setCollageMode(1)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">1x</button>
                            <button onclick="App.setCollageMode(2)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">2x
                                &rarr;</button>
                            <button onclick="App.setCollageMode(5)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">2x
                                &darr;</button>
                            <button onclick="App.setCollageMode(3)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">3x
                                &rarr;</button>
                            <button onclick="App.setCollageMode(6)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">3x
                                &darr;</button>
                            <button onclick="App.setCollageMode(7)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">3x
                                1/2</button>
                            <button onclick="App.setCollageMode(4)"
                                class="collage-btn w-12 h-8 rounded text-[10px] font-bold text-white hover:bg-white/20 flex items-center justify-center">4x</button>
                        </div>
                    </div>

                    <!-- 6. Portrait/Landscape Toggle -->
                    <button onclick="App.toggleOrientation()" id="orientationBtn"
                        class="bg-black/40 backdrop-blur-md p-3 rounded-full hover:bg-black/60 text-white transition">
                        <i data-lucide="rectangle-horizontal" class="w-6 h-6"></i>
                    </button>

                    <!-- 7. Ghost Button -->
                    <div class="relative flex items-center">
                        <button onclick="App.toggleGhost()" id="ghostToggleBtn"
                            class="bg-black/40 backdrop-blur-md p-3 rounded-full hover:bg-black/60 text-white transition opacity-50 peer">
                            <i data-lucide="ghost" class="w-6 h-6"></i>
                        </button>
                        <!-- Slider ABOVE - Fixed width & Position -->
                        <div id="ghostSliderContainer"
                            class="hidden absolute bottom-full mb-4 -right-1 bg-black/60 p-2 rounded flex-col items-center">
                            <input type="range" min="0" max="1" step="0.1" value="0.3"
                                class="w-16 h-1 bg-white/50 rounded-lg appearance-none cursor-pointer"
                                oninput="App.setGhostOpacity(this.value)">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Section: Form (Scrollable) -->
        <div id="formSection" class="flex-1 bg-white-linen p-6 md:p-8 overflow-y-auto w-full md:max-w-2xl md:mx-auto">
            <div class="space-y-5 pb-20">

                <!-- Taken Photo Preview & Retake UI (Hidden by default) -->
                <div id="takenPhotoUI" class="hidden flex-col gap-3 mb-4">
                    <div class="w-full h-64 bg-oatmeal rounded-lg overflow-hidden relative shadow-sm group cursor-pointer"
                        onclick="App.handleCollageClick(event)">
                        <img id="smallPreview" class="w-full h-full object-contain">
                        <!-- Hint overlay -->
                        <div
                            class="absolute inset-0 bg-black/20 opacity-0 group-hover:opacity-100 transition flex items-center justify-center text-white text-xs font-bold pointer-events-none">
                            Click segment to retake
                        </div>
                    </div>
                    <div class="flex justify-center gap-2">
                        <button onclick="App.retakeAll()"
                            class="text-xs bg-charcoal text-white px-4 py-2 rounded-full hover:bg-black flex items-center gap-2 transition">
                            <i data-lucide="refresh-cw" class="w-3 h-3"></i> Retake All
                        </button>
                    </div>
                </div>

                <!-- Title -->
                <div>
                    <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal mb-1">Title</label>
                    <input type="text" id="entryTitle"
                        class="w-full bg-oatmeal border-none rounded-lg p-3 focus:ring-2 focus:ring-dull-purple/50 outline-none text-lg font-serif"
                        placeholder="Untitled Entry">
                </div>

                <!-- Date -->
                <div>
                    <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal mb-1">Date</label>
                    <input type="datetime-local" id="entryDate"
                        class="w-full bg-oatmeal border-none rounded-lg p-3 focus:ring-2 focus:ring-dull-purple/50 outline-none text-sm text-charcoal">
                </div>

                <!-- Notes -->
                <div>
                    <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal mb-1">Notes</label>
                    <textarea id="entryNotes"
                        class="w-full bg-oatmeal border-none rounded-lg p-4 h-32 focus:ring-2 focus:ring-dull-purple/50 outline-none resize-none placeholder-earth-metal/30 leading-relaxed"
                        placeholder="What did you see today?"></textarea>
                </div>

                <!-- Tags -->
                <div>
                    <div class="flex justify-between items-center mb-1">
                        <label class="block text-xs font-bold uppercase tracking-wider text-earth-metal">Tags</label>
                        <button onclick="SyncManager.fetchTags(false)"
                            class="text-[10px] text-dull-purple hover:underline flex items-center gap-1">
                            <i data-lucide="refresh-ccw" class="w-3 h-3"></i> Refresh
                        </button>
                    </div>
                    <div class="flex flex-wrap gap-2 mb-2" id="activeTags"></div>
                    <div class="relative">
                        <input type="text" id="tagInput" placeholder="Add a tag..."
                            class="w-full bg-oatmeal border-none rounded-lg p-3 focus:ring-2 focus:ring-dull-purple/50 outline-none"
                            onkeyup="App.handleTagInput(event)" onfocus="App.handleTagInput(event)">
                        <div id="tagSuggestions"
                            class="absolute top-full left-0 w-full bg-white shadow-lg rounded mt-1 z-10 hidden max-h-32 overflow-y-auto border border-oatmeal-dark">
                        </div>
                    </div>
                </div>

                <!-- Save Button -->
                <div class="pt-4 flex justify-end">
                    <button onclick="App.saveEntry()" id="saveEntryBtn" disabled
                        class="bg-charcoal hover:bg-black disabled:opacity-50 disabled:cursor-not-allowed text-white-linen px-8 py-3 rounded-xl transition-all shadow-md flex items-center justify-center gap-2 text-base font-medium">
                        <span>Save Entry</span>
                        <i data-lucide="arrow-right" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- JAVASCRIPT LOGIC -->
    <script>
        const UTILS = {
            id: () => Math.random().toString(36).substr(2, 9),
            now: () => new Date().toISOString(),
            localToUTC: (localDateTimeString) => {
                if (!localDateTimeString) return new Date().toISOString();
                const d = new Date(localDateTimeString);
                return d.toISOString();
            },
            toLocalISO: (date) => {
                const offset = date.getTimezoneOffset() * 60000;
                return new Date(date.getTime() - offset).toISOString().slice(0, 16);
            },
            formatDate: (iso) => new Date(iso).toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }),
            toBase64: (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            }),
            dataURLtoBlob: (dataurl) => {
                var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
                    bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
                while (n--) { u8arr[n] = bstr.charCodeAt(n); }
                return new Blob([u8arr], { type: mime });
            }
        };

        const Storage = {
            getSettings: () => JSON.parse(localStorage.getItem('mirror_settings') || '{"workerUrl":"","authToken":"","proxyToken":"","orientation":"landscape","collageMode":1,"ghostOpacity":0.3}'),
            setSettings: (s) => localStorage.setItem('mirror_settings', JSON.stringify(s)),
            getData: () => JSON.parse(localStorage.getItem('mirror_data') || '[]'),
            setData: (d) => localStorage.setItem('mirror_data', JSON.stringify(d)),

            // New: Cache for valid Notion Databases
            getCachedDatabases: () => JSON.parse(localStorage.getItem('notion_db_cache') || '[]'),
            setCachedDatabases: (dbs) => localStorage.setItem('notion_db_cache', JSON.stringify(dbs)),

            saveDiary: (diary) => {
                const data = Storage.getData();
                data.push(diary);
                Storage.setData(data);
            },
            deleteEntry: (diaryId, entryId) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.entries = diary.entries.filter(e => e.id !== entryId);
                    Storage.setData(data);
                }
            },
            saveEntry: (diaryId, entry) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.entries.unshift(entry);
                    const unique = [];
                    const map = new Map();
                    for (const item of diary.entries) {
                        if (!map.has(item.id)) {
                            map.set(item.id, true);
                            unique.push(item);
                        }
                    }
                    diary.entries = unique;
                    entry.tags.forEach(t => {
                        if (!diary.tags.includes(t)) diary.tags.push(t);
                    });
                    Storage.setData(data);
                }
            },
            updateEntrySyncStatus: (diaryId, entryId, status, notionId = null) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                const entry = diary?.entries.find(e => e.id === entryId);
                if (entry) {
                    entry.synced = status;
                    if (notionId) entry.notionId = notionId;
                    Storage.setData(data);
                }
            },
            updateDiaryTags: (diaryId, newTags) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    const merged = [...new Set([...diary.tags, ...newTags])];
                    diary.tags = merged;
                    Storage.setData(data);
                }
            },
            setLastFetch: (diaryId, timeStr) => {
                const data = Storage.getData();
                const diary = data.find(d => d.id === diaryId);
                if (diary) {
                    diary.lastFetch = timeStr;
                    Storage.setData(data);
                }
            }
        };

        const API = {
            request: async (method, notionEndpoint, body = null, overrideSettings = null) => {
                const { workerUrl, authToken, proxyToken } = overrideSettings || Storage.getSettings();
                if (!workerUrl || !authToken) throw new Error("Missing Settings");

                const cleanWorkerUrl = workerUrl.trim().replace(/\/$/, '');
                const cleanToken = proxyToken ? proxyToken.trim() : null;
                const cleanAuth = authToken.trim();
                const target = `https://api.notion.com/v1${notionEndpoint}`;

                const fetchUrl = new URL(cleanWorkerUrl);
                fetchUrl.searchParams.append('url', target);
                if (cleanToken) fetchUrl.searchParams.append('token', cleanToken);

                const headers = { 'Authorization': `Bearer ${cleanAuth}`, 'Notion-Version': '2022-06-28' };
                if (!(body instanceof FormData)) {
                    headers['Content-Type'] = 'application/json';
                    body = body ? JSON.stringify(body) : null;
                }

                try {
                    const res = await fetch(fetchUrl.toString(), { method, headers, body });
                    if (!res.ok) {
                        const txt = await res.text();
                        // Try to parse concise error message from Notion or Proxy
                        let errorMsg = `API Error ${res.status}`;
                        try {
                            const json = JSON.parse(txt);
                            if (json.message) errorMsg = json.message;
                            else if (json.error && json.error.message) errorMsg = json.error.message;
                        } catch (e) {
                            // fallback to short text preview
                            if (txt && txt.length < 100) errorMsg += `: ${txt}`;
                        }
                        throw new Error(errorMsg);
                    }
                    return await res.json();
                } catch (e) {
                    if (e.name === 'TypeError' && e.message.includes('Failed to fetch')) {
                        throw new Error("CORS Error: Please check your Worker allowed headers.");
                    }
                    throw e;
                }
            },
            uploadFileContent: async (uploadUrl, fileBlob) => {
                const { workerUrl, authToken, proxyToken } = Storage.getSettings();
                const cleanWorkerUrl = workerUrl.trim().replace(/\/$/, '');
                const fetchUrl = new URL(cleanWorkerUrl);
                fetchUrl.searchParams.append('url', uploadUrl);
                if (proxyToken) fetchUrl.searchParams.append('token', proxyToken);

                const formData = new FormData();
                formData.append("file", fileBlob, "photo.jpg");
                const headers = { 'Authorization': `Bearer ${authToken}`, 'Notion-Version': '2025-09-03' };

                const res = await fetch(fetchUrl.toString(), { method: 'POST', headers, body: formData });
                if (!res.ok) throw new Error(`Upload Failed`);
                return await res.json();
            },
            // New: Scan for all accessible databases
            fetchDatabases: async (settings = null) => {
                let results = [];
                let hasMore = true;
                let nextCursor = undefined;

                // Search for databases only
                while (hasMore) {
                    const payload = {
                        filter: { value: 'database', property: 'object' },
                        page_size: 100,
                        start_cursor: nextCursor
                    };
                    const res = await API.request('POST', '/search', payload, settings);
                    results = [...results, ...res.results];
                    hasMore = res.has_more;
                    nextCursor = res.next_cursor;
                    // Safety break for extremely large accounts (limit to ~300 for performance)
                    if (results.length > 300) hasMore = false;
                }
                return results;
            }
        };

        const SyncManager = {
            statusEl: null,
            init: () => {
                SyncManager.statusEl = document.getElementById('syncStatus');
                window.addEventListener('online', SyncManager.syncCurrentDiary);
                if (App.state.activeDiaryId) SyncManager.syncCurrentDiary();
            },
            updateUI: (status) => {
                if (!SyncManager.statusEl) return;
                SyncManager.statusEl.classList.remove('hidden', 'flex');
                const textSpan = SyncManager.statusEl.querySelector('span:last-child');
                const dot = SyncManager.statusEl.querySelector('span:first-child');

                if (status === 'syncing') {
                    dot.className = "loader w-2 h-2 border-earth-metal";
                    textSpan.innerText = "Syncing...";
                } else if (status === 'offline') {
                    dot.className = "w-2 h-2 rounded-full bg-red-400";
                    textSpan.innerText = "Offline";
                } else if (status === 'synced') {
                    dot.className = "w-2 h-2 rounded-full bg-green-400";
                    textSpan.innerText = "Synced";
                    setTimeout(() => SyncManager.statusEl.classList.add('hidden'), 3000);
                } else {
                    dot.className = "w-2 h-2 rounded-full bg-red-600";
                    textSpan.innerText = "Error";
                }
            },

            fetchTags: async (silent = false) => {
                const diaryId = App.state.activeDiaryId;
                if (!diaryId) return;
                const diary = Storage.getData().find(d => d.id === diaryId);

                try {
                    if (!silent) App.showToast("Fetching tags...", "info");
                    const res = await API.request('GET', `/databases/${diary.originalDbId || diary.notionDataSourceId}`);
                    const properties = res.properties || {};

                    if (properties["Tags"] && properties["Tags"].multi_select) {
                        const options = properties["Tags"].multi_select.options.map(o => o.name);
                        Storage.updateDiaryTags(diaryId, options);
                        App.state.diaries = Storage.getData();
                        if (!silent) App.showToast(`Updated ${options.length} tags.`, "success");
                    }
                } catch (e) {
                    console.error("Tag fetch failed", e);
                    if (!silent) App.showToast("Could not fetch tags schema.", "error");
                }
            },

            syncCurrentDiary: async () => {
                if (!navigator.onLine) { SyncManager.updateUI('offline'); return; }
                const diaryId = App.state.activeDiaryId;
                if (!diaryId) return;

                let diary = Storage.getData().find(d => d.id === diaryId);
                if (!diary || !diary.originalDbId) return;

                SyncManager.updateUI('syncing');
                App.state.isLoading = true; // Set loading state
                App.renderDiaryView(); // Render loading state

                try {
                    // 1. PUSH
                    const unsynced = diary.entries.filter(e => !e.synced);
                    for (const entry of unsynced) {
                        try {
                            const notionId = await SyncManager.pushEntryToNotion(diary.originalDbId, entry);
                            Storage.updateEntrySyncStatus(diaryId, entry.id, true, notionId);
                            App.state.diaries = Storage.getData();
                            // Don't re-render here to avoid flickering during load, waiting for full pull
                        } catch (err) {
                            console.error("Failed to push entry", entry, err);
                            App.showToast(`Sync failed for entry "${entry.title}".`, "error");
                        }
                    }

                    // 2. PULL
                    const fetchLimit = 51;
                    let payload = {
                        page_size: fetchLimit,
                        sorts: [{ property: 'Date', direction: 'descending' }]
                    };

                    if (diary.lastFetch) {
                        payload.filter = {
                            timestamp: "last_edited_time",
                            last_edited_time: { on_or_after: diary.lastFetch }
                        };
                    }

                    const response = await API.request('POST', `/databases/${diary.originalDbId}/query`, payload);

                    let newCount = 0;
                    const currentData = Storage.getData();
                    const activeDiary = currentData.find(d => d.id === diaryId);

                    response.results.forEach(page => {
                        const localIndex = activeDiary.entries.findIndex(e => e.notionId === page.id);

                        const props = page.properties;
                        const getDate = (p) => p?.date?.start || UTILS.now();
                        const getTags = (p) => p?.multi_select?.map(x => x.name) || [];
                        const notesContent = props.Notes?.rich_text?.[0]?.plain_text;
                        const titleContent = props.Name?.title?.[0]?.plain_text;
                        const finalNotes = notesContent || "";
                        const finalTitle = titleContent || "(No Title)";

                        let photoUrl = null;
                        if (props.Files?.files?.length > 0) {
                            const f = props.Files.files[0];
                            photoUrl = f.file?.url || f.external?.url;
                        }

                        const syncedEntry = {
                            id: localIndex > -1 ? activeDiary.entries[localIndex].id : UTILS.id(),
                            notionId: page.id,
                            date: getDate(props.Date),
                            title: finalTitle,
                            notes: finalNotes,
                            tags: getTags(props.Tags),
                            photoDataURL: photoUrl,
                            synced: true
                        };

                        if (localIndex > -1) {
                            activeDiary.entries[localIndex] = syncedEntry;
                        } else {
                            activeDiary.entries.push(syncedEntry);
                            newCount++;
                        }
                    });

                    activeDiary.entries.sort((a, b) => new Date(b.date) - new Date(a.date));

                    if (activeDiary.entries.length > 51) {
                        activeDiary.entries = activeDiary.entries.slice(0, 51);
                    }

                    Storage.setData(currentData);
                    Storage.setLastFetch(diaryId, new Date().toISOString());

                    App.state.diaries = currentData;

                    SyncManager.updateUI('synced');
                    SyncManager.fetchTags(true);

                } catch (e) {
                    console.error("Sync Error", e);
                    SyncManager.updateUI('error');
                    if (e.message.includes("CORS")) App.showToast(e.message, 'error');
                } finally {
                    App.state.isLoading = false;
                    App.renderDiaryView();
                    App.renderSidebar();
                }
            },

            pushEntryToNotion: async (dbId, entry) => {
                let uploadedFileId = null;

                if (entry.photoDataURL && entry.photoDataURL.startsWith('data:')) {
                    try {
                        const initRes = await API.request('POST', '/file_uploads', {
                            "object": "file_upload", "filename": "photo.jpg", "content_type": "image/jpeg"
                        });
                        const blob = UTILS.dataURLtoBlob(entry.photoDataURL);
                        await API.uploadFileContent(initRes.upload_url, blob);
                        uploadedFileId = initRes.id;
                    } catch (err) {
                        App.showToast("Image upload failed, saving text.", "error");
                    }
                }

                const titleToSend = entry.title || "Untitled Entry";

                const properties = {
                    "Name": { "title": [{ "text": { "content": titleToSend } }] },
                    "Date": { "date": { "start": entry.date } },
                    "Notes": { "rich_text": [{ "text": { "content": entry.notes } }] },
                    "Tags": { "multi_select": entry.tags.map(t => ({ "name": t })) }
                };

                if (uploadedFileId) {
                    properties["Files"] = { "files": [{ "type": "file_upload", "file_upload": { "id": uploadedFileId } }] };
                }

                const res = await API.request('POST', '/pages', {
                    parent: { type: "database_id", database_id: dbId },
                    properties
                });
                return res.id;
            }
        };

        const App = {
            state: {
                diaries: [],
                activeDiaryId: null,
                stream: null,
                facingMode: 'environment',
                capturedImage: null,
                currentTags: [],
                ghostMode: false,
                ghostImageObj: null, // New: Image object for ghost
                ghostOpacity: 0.3,   // New: Opacity value
                orientation: 'landscape', // Default
                // Collage State
                collageMode: 1,
                activeSegment: 0,
                segments: [],
                mirrorVideo: false,
                // New Diary State
                selectedDb: null,
                cachedDbs: [], // In-memory cache for filtering
                isLoading: false // Global loading state for entries
            },

            collageConfigs: {
                1: [{ x: 0, y: 0, w: 1, h: 1 }], // 1x
                2: [{ x: 0, y: 0, w: 0.5, h: 1 }, { x: 0.5, y: 0, w: 0.5, h: 1 }], // 2x
                3: [{ x: 0, y: 0, w: 0.3333, h: 1 }, { x: 0.3333, y: 0, w: 0.3333, h: 1 }, { x: 0.6666, y: 0, w: 0.3334, h: 1 }], // 3x (Precise)
                4: [{ x: 0, y: 0, w: 0.5, h: 0.5 }, { x: 0.5, y: 0, w: 0.5, h: 0.5 }, { x: 0, y: 0.5, w: 0.5, h: 0.5 }, { x: 0.5, y: 0.5, w: 0.5, h: 0.5 }], // 4x
                5: [{ x: 0, y: 0, w: 1, h: 0.5 }, { x: 0, y: 0.5, w: 1, h: 0.5 }], // 2x Vertical
                6: [{ x: 0, y: 0, w: 1, h: 0.3333 }, { x: 0, y: 0.3333, w: 1, h: 0.3333 }, { x: 0, y: 0.6666, w: 1, h: 0.3334 }], // 3x Vertical
                7: [{ x: 0.25, y: 0, w: 0.5, h: 0.5 }, { x: 0, y: 0.5, w: 0.5, h: 0.5 }, { x: 0.5, y: 0.5, w: 0.5, h: 0.5 }] // 3x Pyramid
            },

            init: () => {
                lucide.createIcons();
                App.state.diaries = Storage.getData();
                App.renderSidebar();

                // Load settings
                const s = Storage.getSettings();
                App.state.orientation = s.orientation || 'landscape';
                App.state.collageMode = s.collageMode || 1;
                App.state.ghostOpacity = s.ghostOpacity || 0.3;

                // Set initial icon for orientation button
                const oBtn = document.getElementById('orientationBtn');
                if (oBtn) {
                    const iconName = App.state.orientation === 'landscape' ? 'rectangle-horizontal' : 'rectangle-vertical';
                    oBtn.innerHTML = `<i data-lucide="${iconName}" class="w-6 h-6"></i>`;
                    lucide.createIcons();
                }

                const urlParams = new URLSearchParams(window.location.search);
                const newAuth = urlParams.get('accessToken');

                if (newAuth) {
                    const settings = Storage.getSettings();
                    const newSettings = { ...settings, authToken: newAuth };
                    Storage.setSettings(newSettings);
                    window.history.replaceState({}, document.title, window.location.pathname);
                    App.showToast(`Connected! Scanning databases...`, 'success');
                    // Trigger scan immediately after OAuth return
                    if (newSettings.workerUrl) App.scanForDatabases(newSettings);
                }

                if (window.innerWidth < 768 && App.state.diaries.length > 0) {
                    App.selectDiary(App.state.diaries[0].id);
                } else {
                    App.renderWelcomeState();
                }

                // Add Global Escape Key Listener
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        const modals = ['settingsModal', 'newDiaryModal', 'workerHelpModal', 'deleteModal', 'entryModal'];
                        modals.forEach(id => {
                            const el = document.getElementById(id);
                            if (el && !el.classList.contains('hidden')) App.closeModal(id);
                        });
                        // Close mobile menu on escape
                        document.getElementById('mobileDiaryMenu').classList.add('hidden');
                    }
                });

                // Close dropdowns if clicked outside
                document.addEventListener('click', (e) => {
                    // 1. DB Search Dropdown
                    const dropdown = document.getElementById('dbDropdownList');
                    const input = document.getElementById('dbSearchInput');
                    if (dropdown && !dropdown.classList.contains('hidden') && !dropdown.contains(e.target) && e.target !== input) {
                        dropdown.classList.add('hidden');
                    }

                    // 2. Mobile Diary Menu
                    const mobMenu = document.getElementById('mobileDiaryMenu');
                    const isBtn = e.target.closest('#mobileDiaryToggleBtn');
                    const isMenu = e.target.closest('#mobileDiaryMenu');

                    if (mobMenu && !mobMenu.classList.contains('hidden') && !isMenu && !isBtn) {
                        mobMenu.classList.add('hidden');
                    }
                });

                SyncManager.init();

                // Start rendering loop for camera canvas
                requestAnimationFrame(App.drawLoop);
            },

            // --- New Diary & DB Scanning Logic ---

            isValidChronicleDb: (props) => {
                // Schema check: Ensure required props exist. Extra props are ignored.
                if (!props['Name'] || props['Name'].type !== 'title') return false;
                if (!props['Tags'] || props['Tags'].type !== 'multi_select') return false;
                if (!props['Date'] || props['Date'].type !== 'date') return false;
                if (!props['Notes'] || props['Notes'].type !== 'rich_text') return false;
                if (!props['Files'] || props['Files'].type !== 'files') return false;
                return true;
            },

            scanForDatabases: async (settings = null) => {
                const btn = document.getElementById('refreshDbBtn');
                const list = document.getElementById('dbDropdownList');

                if (btn) {
                    // Lucide replaces <i> with <svg>, so we target svg
                    const icon = btn.querySelector('svg');
                    if (icon) icon.classList.add('animate-spin');
                }

                // Reset filtered list
                App.state.cachedDbs = [];

                try {
                    const allDbs = await API.fetchDatabases(settings);
                    const validDbs = allDbs.filter(db => App.isValidChronicleDb(db.properties)).map(db => ({
                        id: db.id,
                        title: db.title?.[0]?.plain_text || "Untitled Database",
                        description: db.description?.[0]?.plain_text || ""
                    }));

                    Storage.setCachedDatabases(validDbs);
                    App.state.cachedDbs = validDbs; // Sync memory

                    if (document.getElementById('newDiaryModal').classList.contains('flex')) {
                        App.renderDbDropdownItems(validDbs);
                    }
                    if (!settings) App.showToast(`Found ${validDbs.length} compatible databases.`, "success");
                } catch (e) {
                    console.error(e);
                    App.showToast("Failed to fetch databases", "error");
                } finally {
                    if (btn) {
                        // Lucide replaces <i> with <svg>, so we target svg
                        const icon = btn.querySelector('svg');
                        if (icon) icon.classList.remove('animate-spin');
                    }
                }
            },

            toggleDbDropdown: (forceShow = null) => {
                const list = document.getElementById('dbDropdownList');
                if (forceShow === true) list.classList.remove('hidden');
                else if (forceShow === false) list.classList.add('hidden');
                else list.classList.toggle('hidden');

                // On show, reset filter if input empty
                if (!list.classList.contains('hidden') && document.getElementById('dbSearchInput').value === '') {
                    App.renderDbDropdownItems(App.state.cachedDbs);
                }
            },

            filterDbList: (e) => {
                const term = e.target.value.toLowerCase();
                const filtered = App.state.cachedDbs.filter(db => db.title.toLowerCase().includes(term));
                App.renderDbDropdownItems(filtered);
                App.toggleDbDropdown(true);
            },

            renderDbDropdownItems: (dbs) => {
                const list = document.getElementById('dbDropdownList');
                list.innerHTML = '';

                // Filter out already used DBs
                const usedIds = App.state.diaries.map(d => d.originalDbId);
                const availableDbs = dbs.filter(db => !usedIds.includes(db.id));

                if (availableDbs.length === 0) {
                    list.innerHTML = `<div class="p-4 text-center text-xs text-earth-metal/50">No databases found.</div>`;
                    return;
                }

                availableDbs.forEach(db => {
                    const el = document.createElement('div');
                    el.className = "p-3 border-b border-oatmeal-dark last:border-0 hover:bg-white-linen cursor-pointer transition-colors flex flex-col gap-1";
                    el.onclick = () => App.selectDatabase(db);
                    el.innerHTML = `
                        <div class="flex items-center justify-between">
                            <span class="font-bold text-sm text-charcoal">${db.title}</span>
                        </div>
                        ${db.description ? `<div class="text-[10px] text-earth-metal/60 truncate">${db.description}</div>` : ''}
                    `;
                    list.appendChild(el);
                });
            },

            selectDatabase: (db) => {
                App.state.selectedDb = db;

                // Update UI
                const input = document.getElementById('dbSearchInput');
                input.value = db.title;

                // Show selected info box
                const infoBox = document.getElementById('selectedDbInfo');
                document.getElementById('previewDbTitle').innerText = db.title;
                document.getElementById('previewDbDesc').innerText = db.description || "No description";
                infoBox.classList.remove('hidden');

                App.toggleDbDropdown(false);
            },

            attemptNewDiary: () => {
                App.state.selectedDb = null;
                document.getElementById('dbSearchInput').value = '';
                document.getElementById('selectedDbInfo').classList.add('hidden');

                const s = Storage.getSettings();
                if (!s.workerUrl || !s.authToken) {
                    App.showToast("Please connect to Notion first.", "error");
                    App.openModal('settingsModal');
                } else {
                    App.openModal('newDiaryModal');
                    // Check cache first
                    const cached = Storage.getCachedDatabases();
                    App.state.cachedDbs = cached;
                    if (cached.length > 0) {
                        App.renderDbDropdownItems(cached);
                    } else {
                        App.scanForDatabases();
                    }
                }
            },

            createDiary: async () => {
                if (!App.state.selectedDb) return App.showToast("Please select a database.", "error");

                const db = App.state.selectedDb;

                const newDiary = {
                    id: UTILS.id(),
                    title: db.title,
                    originalDbId: db.id,
                    description: db.description,
                    tags: [],
                    entries: []
                };

                Storage.saveDiary(newDiary);
                App.state.diaries = Storage.getData();
                App.closeModal('newDiaryModal');

                // Select the diary - this triggers renderSidebar and SyncManager.syncCurrentDiary()
                // No need to call sync manually again
                App.selectDiary(newDiary.id);

                App.showToast("Diary Created!", "success");
            },

            resetApp: () => {
                // Trigger the custom modal instead of native confirm()
                App.openModal('resetConfirmationModal');
            },

            executeReset: () => {
                try {
                    localStorage.clear();
                    // Force reload to clear memory state
                    window.location.href = window.location.pathname;
                } catch (e) {
                    console.error(e);
                    App.showToast("Failed to clear storage automatically. Please clear browser cache.", "error");
                }
            },

            // Mobile Specific: Diary Switching
            toggleMobileDiaryMenu: (e) => {
                if (e) e.stopPropagation(); // Prevent immediate closure by document click listener

                const menu = document.getElementById('mobileDiaryMenu');
                const list = document.getElementById('mobileDiaryList');

                if (menu.classList.contains('hidden')) {
                    menu.classList.remove('hidden');
                    list.innerHTML = '';

                    if (App.state.diaries.length === 0) {
                        list.innerHTML = `<div class="p-4 text-center text-xs text-earth-metal/50">No diaries yet.</div>`;
                    } else {
                        App.state.diaries.forEach(diary => {
                            const isActive = diary.id === App.state.activeDiaryId;
                            const div = document.createElement('div');
                            div.className = `p-3 rounded-lg cursor-pointer flex items-center justify-between mb-1 ${isActive ? 'bg-oatmeal-dark/30 font-bold text-dull-purple' : 'hover:bg-white'}`;
                            div.onclick = () => {
                                App.selectDiary(diary.id);
                                menu.classList.add('hidden');
                            };
                            div.innerHTML = `<span>${diary.title}</span> ${isActive ? '<i data-lucide="check" class="w-4 h-4"></i>' : ''}`;
                            list.appendChild(div);
                        });
                        lucide.createIcons();
                    }
                } else {
                    menu.classList.add('hidden');
                }
            },

            // --- End New Logic ---

            showToast: (message, type = 'info') => {
                const container = document.getElementById('toastContainer');
                const el = document.createElement('div');
                let bg = type === 'success' ? 'bg-oatmeal border-green-500' : (type === 'error' ? 'bg-white border-red-500' : 'bg-white-linen border-dull-purple');
                let icon = type === 'success' ? 'check-circle' : (type === 'error' ? 'alert-circle' : 'info');

                el.className = `toast-enter pointer-events-auto p-4 rounded shadow-md flex gap-3 text-sm ${bg} border-l-4 transition-all`;
                el.innerHTML = `<i data-lucide="${icon}" class="w-5 h-5 mt-0.5"></i><div class="flex-1">${message}</div>`;
                container.appendChild(el);
                lucide.createIcons();
                let timeout = type === 'error' ? 3000 : 1500; // Fast
                setTimeout(() => { el.classList.add('toast-exit'); setTimeout(() => el.remove(), 300); }, timeout);
            },

            renderSidebar: () => {
                const container = document.getElementById('diaryListContainer');
                container.innerHTML = '';
                if (App.state.diaries.length === 0) {
                    container.innerHTML = `<div class="text-xs text-center text-earth-metal/50 mt-4">No diaries yet.</div>`;
                    return;
                }
                App.state.diaries.forEach(diary => {
                    const isActive = diary.id === App.state.activeDiaryId;
                    const div = document.createElement('div');
                    const count = diary.entries.length;
                    const countDisplay = count > 50 ? "50+" : count;

                    div.className = `p-3 rounded-lg cursor-pointer flex flex-col gap-1 transition-colors ${isActive ? 'bg-white-linen shadow-sm border border-oatmeal-dark' : 'hover:bg-oatmeal-dark/50'}`;
                    div.onclick = () => App.selectDiary(diary.id);
                    div.innerHTML = `
                        <div class="font-medium text-charcoal truncate">${diary.title}</div>
                        <div class="text-[10px] text-earth-metal/60">${countDisplay} entries</div>
                    `;
                    container.appendChild(div);
                });
            },

            renderWelcomeState: () => {
                const gallery = document.getElementById('entryGallery');
                const s = Storage.getSettings();
                const isConnected = s.workerUrl && s.authToken;
                const hasDiaries = App.state.diaries.length > 0;

                if (!isConnected) {
                    gallery.innerHTML = `
                        <div class="h-full flex flex-col items-center justify-center text-center gap-4">
                            <div class="bg-dull-purple/10 p-4 rounded-full"><i data-lucide="plug" class="w-10 h-10 text-dull-purple"></i></div>
                            <div>
                                <h3 class="font-serif text-2xl text-charcoal mb-2">Welcome to Photo Chronicles w/ Notion</h3>
                                <p class="text-earth-metal/60 max-w-xs mx-auto mb-6">Connect your Notion workspace to start tracking your progress.</p>
                                <div class="p-4 text-[10px] text-earth-metal/50 leading-tight border-t border-oatmeal-dark/50 bg-oatmeal/30 mb-6">
                                    <i data-lucide="info" class="w-3 h-3 inline mb-0.5 mr-1"></i>
                                    This app is just showing what is in your browser cache until you connect to Notion. If your browser cache might have been cleared, your data is still safe in Notion.
                                </div>
                                <button onclick="App.openModal('settingsModal')" class="bg-charcoal text-white px-6 py-3 rounded-lg font-medium hover:bg-black transition">Connect to Notion</button>
                            </div>
                        </div>`;
                } else if (!hasDiaries) {
                    gallery.innerHTML = `
                        <div class="h-full flex flex-col items-center justify-center text-center gap-4">
                            <div class="bg-oatmeal-dark p-4 rounded-full"><i data-lucide="book-plus" class="w-10 h-10 text-earth-metal"></i></div>
                            <div>
                                <h3 class="font-serif text-2xl text-charcoal mb-2">You're Connected!</h3>
                                <p class="text-earth-metal/60 max-w-xs mx-auto mb-6">Create your first diary to link a Notion Database.</p>
                                <button onclick="App.attemptNewDiary()" class="bg-dull-purple text-white px-6 py-3 rounded-lg font-medium hover:bg-dull-purple-hover transition">Create First Diary</button>
                            </div>
                        </div>`;
                } else {
                    gallery.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-center text-earth-metal/60"><i data-lucide="book-open" class="w-12 h-12 mb-4 opacity-50"></i><p>Select a diary.</p></div>`;
                }
                lucide.createIcons();
            },

            renderDiaryView: () => {
                const diary = App.state.diaries.find(d => d.id === App.state.activeDiaryId);
                const gallery = document.getElementById('entryGallery');
                const title = document.getElementById('activeDiaryTitle');

                if (!diary) return;
                title.innerText = diary.title;
                gallery.innerHTML = '';

                // Loading State
                if (App.state.isLoading && diary.entries.length === 0) {
                    gallery.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-center text-earth-metal/60">
                        <div class="loader w-8 h-8 border-4 border-dull-purple border-t-transparent rounded-full mb-4"></div>
                        <p>Loading entries...</p>
                    </div>`;
                    return;
                }

                if (diary.entries.length === 0) {
                    gallery.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-center text-earth-metal/60"><i data-lucide="camera" class="w-12 h-12 mb-4 opacity-50"></i><p>Empty.</p></div>`;
                    lucide.createIcons();
                    return;
                }

                const grid = document.createElement('div');
                grid.className = "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6";

                const displayEntries = diary.entries.slice(0, 50);

                displayEntries.forEach(entry => {
                    const card = document.createElement('div');
                    card.className = "relative group bg-white-linen rounded-xl overflow-hidden shadow-sm border border-oatmeal-dark hover:shadow-md transition-shadow flex flex-col";

                    const imgHtml = entry.photoDataURL
                        ? `<img src="${entry.photoDataURL}" class="w-full h-48 object-contain bg-oatmeal" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNjY2MiIHN0cm9rZS13aWR0aD0iMiI+PHJlY3QgeD0iMyIgeT0iMyIgd2lkdGg9IjE4IiBoZWlnaHQ9IjE4IiByeD0iMiIgcnk9IjIiPjwvcmVjdD48Y2lyY2xlIGN4PSI4LjUiIGN5PSI4LjUiIHI9IjEuNSI+PC9jaXJjbGU+PHBvbHlsaW5lIHBvaW50cz0iMjEgMTUgMTYgMTAgNSAyMSI+PC9wb2x5bGluZT48L3N2Zz4n">`
                        : `<div class="w-full h-48 bg-oatmeal flex items-center justify-center text-earth-metal/30"><i data-lucide="image-off"></i></div>`;

                    const tagsHtml = (entry.tags || []).map(t => `<span class="text-[10px] uppercase font-bold text-dull-purple bg-dull-purple/10 px-2 py-1 rounded">${t}</span>`).join('');
                    const dispTitle = entry.title || "Untitled";

                    // Delete Button Overlay
                    const deleteBtn = `
                        <div class="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity z-10">
                            <button onclick="event.stopPropagation(); App.confirmDelete('${diary.id}', '${entry.id}')" class="bg-white/80 hover:bg-white text-red-500 p-2 rounded-full shadow-sm backdrop-blur-sm transition">
                                <i data-lucide="trash-2" class="w-4 h-4"></i>
                            </button>
                        </div>
                    `;

                    card.innerHTML = `
                        ${deleteBtn}
                        ${imgHtml}
                        <div class="p-4 flex flex-col gap-2 flex-1">
                            <div class="flex justify-between items-start">
                                <span class="text-xs font-mono text-earth-metal/60">${UTILS.formatDate(entry.date)}</span>
                                <span class="text-[10px] ${entry.synced ? 'text-green-500' : 'text-amber-500'}">${entry.synced ? 'Synced' : 'Local'}</span>
                            </div>
                            <h4 class="font-bold text-sm text-charcoal truncate">${dispTitle}</h4>
                            <p class="text-sm text-charcoal line-clamp-3 flex-1 whitespace-pre-wrap">${entry.notes}</p>
                            <div class="flex flex-wrap gap-1 mt-2">${tagsHtml}</div>
                        </div>
                    `;
                    grid.appendChild(card);
                });
                gallery.appendChild(grid);

                const footerMsg = diary.entries.length > 50 ? "50+ entries available." : "End of entries.";
                let footer = document.createElement('div');
                footer.id = 'galleryFooter';
                footer.className = "text-center text-xs text-earth-metal/40 py-8";
                footer.innerText = footerMsg;
                gallery.appendChild(footer);

                lucide.createIcons();
            },

            selectDiary: (id) => {
                App.state.activeDiaryId = id;
                App.renderSidebar();
                App.renderDiaryView();
                // Close mobile sidebar if open
                if (window.innerWidth < 768) {
                    const sidebar = document.getElementById('sidebar');
                    if (sidebar) sidebar.classList.add('-translate-x-full');
                    // Remove overlay reference or check existence
                    const overlay = document.getElementById('mobileSidebarOverlay');
                    if (overlay) overlay.classList.add('hidden');
                }
                SyncManager.syncCurrentDiary();
            },

            toggleMobileSidebar: () => {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('mobileSidebarOverlay');

                if (sidebar.classList.contains('-translate-x-full')) {
                    sidebar.classList.remove('-translate-x-full');
                    overlay.classList.remove('hidden');
                } else {
                    sidebar.classList.add('-translate-x-full');
                    overlay.classList.add('hidden');
                }
            },

            // Init Entry with Collage Reset
            initNewEntry: async () => {
                App.state.currentTags = [];
                App.state.capturedImage = null;
                App.state.activeSegment = 0;
                App.state.segments = [];
                App.state.mirrorVideo = false; // Default mirror off
                App.state.ghostImageObj = null; // Reset ghost image

                // Load persisted collage mode from state (loaded in init)
                // Do NOT reset collage mode to 1 here
                App.setCollageMode(App.state.collageMode);

                document.getElementById('entryNotes').value = '';
                document.getElementById('entryTitle').value = '';
                document.getElementById('entryDate').value = UTILS.toLocalISO(new Date());
                document.getElementById('activeTags').innerHTML = '';
                document.getElementById('tagInput').value = '';
                document.getElementById('saveEntryBtn').disabled = true;
                document.getElementById('mirrorToggleBtn').classList.add('hidden');

                document.getElementById('takenPhotoUI').classList.remove('flex');
                document.getElementById('takenPhotoUI').classList.add('hidden');
                document.getElementById('cameraSection').classList.remove('hidden');

                const diary = App.state.diaries.find(d => d.id === App.state.activeDiaryId);
                if (!diary) return App.showToast("Create a diary first.", "error");

                const toggleBtn = document.getElementById('ghostToggleBtn');
                const lastEntryWithPhoto = diary.entries.find(e => e.photoDataURL);

                const ghostImg = document.getElementById('ghostOverlay'); // Fixed Reference

                // Setup Ghost - Auto Enabled if photo exists
                if (lastEntryWithPhoto) {
                    // Set src on the restored img tag
                    ghostImg.src = lastEntryWithPhoto.photoDataURL;

                    // Auto-Enable Ghost Mode as per request, BUT hide slider initially
                    toggleBtn.classList.remove('hidden');
                    toggleBtn.classList.remove('opacity-50'); // Active state
                    App.state.ghostMode = true;
                    // Use saved opacity
                    const savedOpacity = App.state.ghostOpacity;
                    ghostImg.classList.remove('opacity-0');
                    ghostImg.style.opacity = savedOpacity;

                    // Update slider UI but keep container HIDDEN
                    const sliderInput = document.querySelector('#ghostSliderContainer input');
                    if (sliderInput) sliderInput.value = savedOpacity;
                    document.getElementById('ghostSliderContainer').classList.add('hidden');

                    // Load image object for canvas drawing
                    const img = new Image();
                    img.onload = () => { App.state.ghostImageObj = img; };
                    img.src = lastEntryWithPhoto.photoDataURL;
                } else {
                    toggleBtn.classList.add('hidden');
                    App.state.ghostMode = false;
                    ghostImg.classList.add('opacity-0');
                    document.getElementById('ghostSliderContainer').classList.add('hidden');
                }

                App.openModal('entryModal');
                App.initCamera();
                SyncManager.fetchTags(true);
            },

            setCollageMode: (mode) => {
                App.state.collageMode = mode;
                App.state.activeSegment = 0;
                App.state.segments = [];

                // Save to storage
                const s = Storage.getSettings();
                s.collageMode = mode;
                Storage.setSettings(s);

                // Reset all button styles
                document.querySelectorAll('.collage-btn').forEach(btn => {
                    btn.classList.add('bg-white/20', 'hover:bg-white/10');
                    btn.classList.remove('bg-white', 'text-black');
                });

                // Update active button based on mode-to-index mapping
                // Order in HTML: 1, 2, 5, 3, 6, 7, 4
                // Modes: 1=1x, 2=2xH, 5=2xV, 3=3xH, 6=3xV, 7=3xPyr, 4=4x
                const modeToIdx = { 1: 0, 2: 1, 5: 2, 3: 3, 6: 4, 7: 5, 4: 6 };
                const btns = document.querySelectorAll('.collage-btn');
                const targetBtn = btns[modeToIdx[mode]];

                if (targetBtn) {
                    targetBtn.classList.remove('bg-white/20', 'hover:bg-white/10');
                    targetBtn.classList.add('bg-white', 'text-black');
                }

                App.updateGridOverlay();

                const segInd = document.getElementById('segmentIndicator');
                if (mode > 1) {
                    segInd.classList.remove('hidden');
                    document.getElementById('segTotal').innerText = App.collageConfigs[mode].length;
                    document.getElementById('segCurrent').innerText = 1;
                } else {
                    segInd.classList.add('hidden');
                }

                // Toggle dropdown visibility
                document.getElementById('collageMenu').classList.add('hidden');
                document.getElementById('collageMenu').classList.remove('flex');

                // Update main button text
                let label = "1x";
                if (mode === 2) label = "2x â†’";
                if (mode === 3) label = "3x â†’";
                if (mode === 4) label = "4x";
                if (mode === 5) label = "2x â†“";
                if (mode === 6) label = "3x â†“";
                if (mode === 7) label = "3x 1/2"; // Using a short label for "1 top 2 bottom"
                document.getElementById('gridBtn').innerText = label;
            },

            toggleCollageMenu: () => {
                const menu = document.getElementById('collageMenu');
                if (menu.classList.contains('hidden')) {
                    menu.classList.remove('hidden');
                    menu.classList.add('flex');
                } else {
                    menu.classList.add('hidden');
                    menu.classList.remove('flex');
                }
            },

            toggleOrientation: () => {
                const current = App.state.orientation;
                const next = current === 'landscape' ? 'portrait' : 'landscape';
                App.state.orientation = next;

                // Save to settings
                const s = Storage.getSettings();
                s.orientation = next;
                Storage.setSettings(s);

                // Update UI Icon
                const btn = document.getElementById('orientationBtn');
                if (btn) {
                    const iconName = next === 'landscape' ? 'rectangle-horizontal' : 'rectangle-vertical';
                    btn.innerHTML = `<i data-lucide="${iconName}" class="w-6 h-6"></i>`;
                    lucide.createIcons();
                }
            },

            updateGridOverlay: () => {
                // No-op now as canvas handles it
            },

            // updateGhostClip function removed - logic moved to drawLoop

            initCamera: async () => {
                const video = document.getElementById('videoSource');
                try {
                    if (App.state.stream) {
                        App.state.stream.getTracks().forEach(t => t.stop());
                    }
                    App.state.stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: App.state.facingMode },
                        audio: false
                    });
                    video.srcObject = App.state.stream;

                    // Handle Mirror Button Visibility based on facing mode
                    const mirrorBtn = document.getElementById('mirrorToggleBtn');
                    if (App.state.facingMode === 'user') {
                        mirrorBtn.classList.remove('hidden');
                    } else {
                        mirrorBtn.classList.add('hidden');
                        App.state.mirrorVideo = false; // Force disable mirror on back cam
                        const btn = document.getElementById('mirrorToggleBtn');
                        btn.classList.remove('bg-white/40'); // Reset UI to "off" state visually
                        btn.classList.add('bg-black/40');
                    }
                } catch (e) {
                    // console.log("Cam fail");
                }
            },

            // Main Render Loop for "Live Composite"
            drawLoop: () => {
                const video = document.getElementById('videoSource');
                const cvs = document.getElementById('viewfinder');
                const ctx = cvs.getContext('2d');

                const isPortrait = App.state.orientation === 'portrait';
                const mode = App.state.collageMode;

                // Base Frame Resolution
                const BaseW = isPortrait ? 960 : 1280;
                const BaseH = isPortrait ? 1280 : 960;

                // Determine Final Canvas Multipliers based on Mode
                // This expands the canvas size rather than cutting the view
                let multW = 1;
                let multH = 1;

                if (mode === 2) {
                    multW = 2; // 2x Horizontal -> 2x Wide
                } else if (mode === 3) {
                    multW = 3; // 3x Horizontal -> 3x Wide
                } else if (mode === 4) {
                    multW = 2; // 4x Grid -> 2x Wide, 2x Tall
                    multH = 2;
                } else if (mode === 5) {
                    multH = 2; // 2x Vertical -> 1x Wide, 2x Tall
                } else if (mode === 6) {
                    multH = 3; // 3x Vertical
                } else if (mode === 7) {
                    multW = 2; // 3x Mixed -> 2 Wide, 2 Tall (Pyramid)
                    multH = 2;
                }

                const W = BaseW * multW;
                const H = BaseH * multH;

                // Update Canvas Size if changed
                if (cvs.width !== W || cvs.height !== H) {
                    cvs.width = W;
                    cvs.height = H;
                }

                // Clear with transparent to show container bg
                ctx.clearRect(0, 0, W, H);

                const layout = App.collageConfigs[App.state.collageMode];

                // 1. Draw Ghost Overlay (if active) - Always draw FULL size over canvas
                // Note: With expanded canvas, we center-crop-fill the ghost image to cover the whole new area
                // This maintains the "previous photo context"
                if (App.state.ghostMode && App.state.ghostImageObj) {
                    ctx.save();
                    ctx.globalAlpha = App.state.ghostOpacity;

                    // Draw the ghost image
                    const img = App.state.ghostImageObj;
                    const imgW = img.width;
                    const imgH = img.height;
                    const srcRatio = imgW / imgH;
                    const dstRatio = W / H;

                    let gsx, gsy, gsw, gsh;
                    if (srcRatio > dstRatio) {
                        gsh = imgH; gsw = gsh * dstRatio; gsy = 0; gsx = (imgW - gsw) / 2;
                    } else {
                        gsw = imgW; gsh = gsw / dstRatio; gsx = 0; gsy = (imgH - gsh) / 2;
                    }

                    ctx.drawImage(img, gsx, gsy, gsw, gsh, 0, 0, W, H);
                    ctx.restore();
                }

                // 2. Draw Live Video & Captured Segments
                layout.forEach((slot, idx) => {
                    // Calculate destination in the expanded canvas
                    const dx = slot.x * W;
                    const dy = slot.y * H;
                    const dw = slot.w * W;
                    const dh = slot.h * H;

                    // Decide what to draw
                    if (idx === App.state.activeSegment) {
                        // DRAW LIVE VIDEO
                        if (video.readyState === 4) {
                            ctx.save(); // Save state before possible mirroring

                            const vidW = video.videoWidth;
                            const vidH = video.videoHeight;
                            const srcRatio = vidW / vidH;
                            const dstRatio = dw / dh;

                            let sx, sy, sw, sh;
                            if (srcRatio > dstRatio) {
                                sh = vidH; sw = sh * dstRatio; sy = 0; sx = (vidW - sw) / 2;
                            } else {
                                sw = vidW; sh = sw / dstRatio; sx = 0; sy = (vidH - sh) / 2;
                            }

                            // Mirror Logic
                            if (App.state.mirrorVideo && App.state.facingMode === 'user') {
                                ctx.translate(dx + dw, dy); // Translate to slot origin + width
                                ctx.scale(-1, 1); // Flip horizontal
                                ctx.drawImage(video, sx, sy, sw, sh, 0, 0, dw, dh);
                            } else {
                                ctx.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh);
                            }
                            ctx.restore(); // Restore state
                        }
                    } else if (App.state.segments[idx]) {
                        // DRAW CAPTURED SEGMENT
                        ctx.drawImage(App.state.segments[idx], 0, 0, App.state.segments[idx].width, App.state.segments[idx].height, dx, dy, dw, dh);
                    } else {
                        // DRAW BLACK (Future segment) - Mask it out
                        ctx.fillStyle = "#111";
                        ctx.fillRect(dx, dy, dw, dh);
                    }

                    // Draw thin border between segments
                    ctx.strokeStyle = "rgba(255,255,255,0.1)";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(dx, dy, dw, dh);
                });

                requestAnimationFrame(App.drawLoop);
            },

            flipCamera: () => {
                App.state.facingMode = App.state.facingMode === 'user' ? 'environment' : 'user';
                App.initCamera();
            },

            toggleMirror: () => {
                App.state.mirrorVideo = !App.state.mirrorVideo;
                // Update UI state if needed (e.g. highlight button)
                const btn = document.getElementById('mirrorToggleBtn');
                if (App.state.mirrorVideo) {
                    btn.classList.add('bg-white/40');
                    btn.classList.remove('bg-black/40');
                } else {
                    btn.classList.remove('bg-white/40');
                    btn.classList.add('bg-black/40');
                }
            },

            toggleGhost: () => {
                const ghost = document.getElementById('ghostOverlay');
                const btn = document.getElementById('ghostToggleBtn');
                const slider = document.getElementById('ghostSliderContainer');

                if (App.state.ghostMode) {
                    // Ghost IS active.
                    // If slider is hidden, just show slider.
                    if (slider.classList.contains('hidden')) {
                        slider.classList.remove('hidden');
                    } else {
                        // If slider is visible, turn OFF ghost mode.
                        App.state.ghostMode = false;
                        ghost.classList.add('opacity-0');
                        btn.classList.add('opacity-50');
                        slider.classList.add('hidden');
                    }
                } else {
                    // Ghost is OFF. Turn ON.
                    App.state.ghostMode = true;
                    ghost.classList.remove('opacity-0');
                    ghost.style.opacity = App.state.ghostOpacity;
                    btn.classList.remove('opacity-50');
                    slider.classList.remove('hidden');
                }
            },

            setGhostOpacity: (val) => {
                const newVal = parseFloat(val);
                App.state.ghostOpacity = newVal;

                const ghost = document.getElementById('ghostOverlay');
                if (App.state.ghostMode) ghost.style.opacity = newVal;

                // Save to storage
                const s = Storage.getSettings();
                s.ghostOpacity = newVal;
                Storage.setSettings(s);
            },

            handleTagInput: (e) => {
                const val = e.target.value.trim().toLowerCase();
                const suggestions = document.getElementById('tagSuggestions');
                const diary = App.state.diaries.find(d => d.id === App.state.activeDiaryId);
                const allTags = diary ? diary.tags : [];

                const matches = val
                    ? allTags.filter(t => t.toLowerCase().includes(val) && !App.state.currentTags.includes(t))
                    : allTags.filter(t => !App.state.currentTags.includes(t));

                if (matches.length > 0) {
                    suggestions.classList.remove('hidden');
                    suggestions.innerHTML = matches.map(t =>
                        `<div class="p-2 hover:bg-oatmeal cursor-pointer text-sm" onclick="App.addTag('${t}')">${t}</div>`
                    ).join('');
                } else {
                    suggestions.classList.add('hidden');
                }

                if (e.key === 'Enter' && val) {
                    App.addTag(e.target.value.trim());
                }
            },

            addTag: (t) => {
                if (!App.state.currentTags.includes(t)) {
                    App.state.currentTags.push(t);
                    App.renderTags();
                    document.getElementById('tagInput').value = '';
                    document.getElementById('tagSuggestions').classList.add('hidden');
                }
            },

            renderTags: () => {
                const container = document.getElementById('activeTags');
                container.innerHTML = App.state.currentTags.map(t => `
                    <span class="bg-oatmeal border border-oatmeal-dark text-dull-purple px-2 py-1 rounded text-xs flex items-center gap-1">
                        ${t}
                        <button onclick="App.removeTag('${t}')" class="hover:text-red-500"><i data-lucide="x" class="w-3 h-3"></i></button>
                    </span>
                `).join('');
                lucide.createIcons();
            },

            removeTag: (t) => {
                App.state.currentTags = App.state.currentTags.filter(x => x !== t);
                App.renderTags();
            },

            confirmDelete: (diaryId, entryId) => {
                App.state.pendingDelete = { diaryId, entryId };
                App.openModal('deleteModal');
            },

            executeDelete: async () => {
                const { diaryId, entryId } = App.state.pendingDelete;
                if (!diaryId || !entryId) return;

                App.closeModal('deleteModal');

                // Get notion ID before local deletion
                const diary = Storage.getData().find(d => d.id === diaryId);
                const entry = diary?.entries.find(e => e.id === entryId);
                const notionId = entry?.notionId;

                // 1. Local Delete
                Storage.deleteEntry(diaryId, entryId);
                App.state.diaries = Storage.getData();
                App.renderDiaryView();
                App.renderSidebar();
                App.showToast("Deleted locally", "success");

                // 2. Notion Delete (Archive)
                if (notionId) {
                    try {
                        // Notion API: Archive Page
                        await API.request('PATCH', `/pages/${notionId}`, { archived: true });
                        App.showToast("Deleted from Notion", "success");
                    } catch (e) {
                        console.error("Notion delete failed", e);
                        App.showToast("Failed to delete from Notion", "error");
                    }
                }
            },

            saveEntry: async () => {
                const notes = document.getElementById('entryNotes').value;
                const titleInput = document.getElementById('entryTitle').value;
                const dateVal = document.getElementById('entryDate').value;
                const date = UTILS.localToUTC(dateVal);

                const title = titleInput.trim() || new Date(dateVal).toLocaleString(undefined, {
                    weekday: 'short', year: 'numeric', month: 'short', day: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });

                if (!App.state.capturedImage) return App.showToast('An image is required.', 'error');

                const newEntry = {
                    id: UTILS.id(),
                    date: date,
                    title: title,
                    notes: notes,
                    tags: App.state.currentTags,
                    photoDataURL: App.state.capturedImage,
                    synced: false,
                    notionId: null
                };

                Storage.saveEntry(App.state.activeDiaryId, newEntry);
                App.state.diaries = Storage.getData();

                App.closeModal('entryModal');
                App.renderDiaryView();
                App.showToast("Saved locally", 'success');
                SyncManager.syncCurrentDiary();
            },

            copyWorkerCode: (btn) => {
                const code = document.getElementById('workerCodeBlock').innerText;
                const textArea = document.createElement('textarea');
                textArea.value = code;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    const originalText = btn.innerText;
                    btn.innerText = "Copied!";
                    setTimeout(() => btn.innerText = originalText, 2000);
                } catch (err) {
                    console.error('Fallback copy failed', err);
                }
                document.body.removeChild(textArea);
            },

            captureSegment: () => {
                const video = document.getElementById('videoSource');
                const canvas = document.createElement('canvas');

                const isPortrait = App.state.orientation === 'portrait';
                const BaseW = isPortrait ? 960 : 1280;
                const BaseH = isPortrait ? 1280 : 960;

                // The segment canvas is always the size of one "Base" frame
                canvas.width = BaseW;
                canvas.height = BaseH;

                const ctx = canvas.getContext('2d');
                const vidW = video.videoWidth;
                const vidH = video.videoHeight;
                const srcRatio = vidW / vidH;
                const dstRatio = BaseW / BaseH;

                let sx, sy, sw, sh;
                if (srcRatio > dstRatio) { sh = vidH; sw = sh * dstRatio; sy = 0; sx = (vidW - sw) / 2; }
                else { sw = vidW; sh = sw / dstRatio; sx = 0; sy = (vidH - sh) / 2; }

                if (App.state.mirrorVideo && App.state.facingMode === 'user') {
                    ctx.save();
                    ctx.translate(BaseW, 0);
                    ctx.scale(-1, 1);
                    ctx.drawImage(video, sx, sy, sw, sh, 0, 0, BaseW, BaseH);
                    ctx.restore();
                } else {
                    ctx.drawImage(video, sx, sy, sw, sh, 0, 0, BaseW, BaseH);
                }
                App.state.segments[App.state.activeSegment] = canvas;

                // Smart flow logic
                const layout = App.collageConfigs[App.state.collageMode];
                const total = layout.length;
                let allFilled = true;
                let nextEmpty = -1;
                for (let i = 0; i < total; i++) {
                    if (!App.state.segments[i]) {
                        allFilled = false;
                        if (nextEmpty === -1) nextEmpty = i;
                    }
                }

                if (allFilled) {
                    App.finalizeCollage();
                } else {
                    App.state.activeSegment = nextEmpty;
                    document.getElementById('segCurrent').innerText = App.state.activeSegment + 1;
                    App.updateGridOverlay();
                }
            },

            finalizeCollage: () => {
                const layout = App.collageConfigs[App.state.collageMode];
                const finalCanvas = document.getElementById('photoCanvas');

                if (!finalCanvas) return;

                const isPortrait = App.state.orientation === 'portrait';
                const mode = App.state.collageMode;
                const BaseW = isPortrait ? 960 : 1280;
                const BaseH = isPortrait ? 1280 : 960;

                // Determine Multipliers
                let multW = 1;
                let multH = 1;
                if (mode === 2) multW = 2;
                else if (mode === 3) multW = 3;
                else if (mode === 4) { multW = 2; multH = 2; }
                else if (mode === 5) { multW = 1; multH = 2; }
                else if (mode === 6) { multW = 1; multH = 3; }
                else if (mode === 7) { multW = 2; multH = 2; }

                const W = BaseW * multW;
                const H = BaseH * multH;

                finalCanvas.width = W; finalCanvas.height = H;
                const ctx = finalCanvas.getContext('2d');

                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, W, H);

                layout.forEach((slot, idx) => {
                    const seg = App.state.segments[idx];
                    if (seg) {
                        // Destination in Final Canvas
                        const dx = slot.x * W;
                        const dy = slot.y * H;
                        const dw = slot.w * W;
                        const dh = slot.h * H;

                        // Draw segment (which is BaseW x BaseH) into destination slot
                        // Note: for 2x/3x, dw approx equals BaseW. For 4x, dw approx equals BaseW.
                        // Slight floating point diffs possible, but drawImage handles scaling.
                        ctx.drawImage(seg, 0, 0, seg.width, seg.height, dx, dy, dw, dh);
                    }
                });

                App.state.capturedImage = finalCanvas.toDataURL('image/jpeg', 0.8);

                document.getElementById('cameraSection').classList.add('hidden');
                document.getElementById('smallPreview').src = App.state.capturedImage;
                document.getElementById('takenPhotoUI').classList.remove('hidden');
                document.getElementById('takenPhotoUI').classList.add('flex');
                document.getElementById('saveEntryBtn').disabled = false;

                if (App.state.stream) App.state.stream.getTracks().forEach(t => t.stop());
            },

            handleCollageClick: (e) => {
                if (App.state.collageMode === 1) return;
                const img = e.target;
                const rect = img.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;

                const layout = App.collageConfigs[App.state.collageMode];
                const clickedIdx = layout.findIndex(slot => x >= slot.x && x <= slot.x + slot.w && y >= slot.y && y <= slot.y + slot.h);

                if (clickedIdx !== -1) {
                    App.state.activeSegment = clickedIdx;
                    App.retakePartial();
                }
            },

            retakePartial: () => {
                document.getElementById('takenPhotoUI').classList.add('hidden');
                document.getElementById('takenPhotoUI').classList.remove('flex');
                document.getElementById('cameraSection').classList.remove('hidden');

                App.initCamera();
                App.updateGridOverlay();
                document.getElementById('segCurrent').innerText = App.state.activeSegment + 1;
            },

            retakeAll: () => {
                App.state.activeSegment = 0;
                App.state.segments = [];
                document.getElementById('takenPhotoUI').classList.add('hidden');
                document.getElementById('takenPhotoUI').classList.remove('flex');
                document.getElementById('cameraSection').classList.remove('hidden');
                document.getElementById('saveEntryBtn').disabled = true;
                App.initCamera();
                App.setCollageMode(App.state.collageMode);
            },

            retakePhoto: () => { App.retakeAll(); },

            handleFileUpload: async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const base64 = await UTILS.toBase64(file);
                    const img = new Image();
                    img.src = base64;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');

                        const isPortrait = App.state.orientation === 'portrait';
                        const BaseW = isPortrait ? 960 : 1280;
                        const BaseH = isPortrait ? 1280 : 960;

                        canvas.width = BaseW;
                        canvas.height = BaseH;
                        const ctx = canvas.getContext('2d');

                        const srcRatio = img.width / img.height;
                        const dstRatio = BaseW / BaseH;
                        let sx, sy, sw, sh;
                        if (srcRatio > dstRatio) { sh = img.height; sw = sh * dstRatio; sy = 0; sx = (img.width - sw) / 2; }
                        else { sw = img.width; sh = sw / dstRatio; sx = 0; sy = (img.height - sh) / 2; }

                        ctx.drawImage(img, sx, sy, sw, sh, 0, 0, BaseW, BaseH);

                        App.state.segments[App.state.activeSegment] = canvas;

                        const total = layout.length;
                        const filledCount = App.state.segments.filter(s => s).length;

                        if (filledCount === total) {
                            App.finalizeCollage();
                        } else {
                            App.state.activeSegment++;
                            document.getElementById('segCurrent').innerText = App.state.activeSegment + 1;
                            App.updateGridOverlay();
                        }
                    }
                }
            },
            renderSettingsStatus: (settings) => {
                const statusEl = document.getElementById('connectionStatus');
                const s = settings || Storage.getSettings();

                if (!s.authToken) {
                    statusEl.innerHTML = `
                        <div class="flex items-start gap-3 text-amber-700 bg-amber-50 p-3 rounded-lg border border-amber-100 text-xs">
                            <div class="bg-white p-1 rounded-full shadow-sm mt-0.5"><i data-lucide="alert-circle" class="w-4 h-4 text-amber-600"></i></div>
                            <div class="flex-1">
                                <strong class="block text-sm mb-0.5">Not Connected</strong>
                                <span class="opacity-80">Connect via OAuth or verify your manual key to start.</span>
                            </div>
                        </div>
                    `;
                } else if (s.authToken.startsWith('secret_')) {
                    statusEl.innerHTML = `
                        <div class="flex items-start gap-3 text-green-700 bg-green-50 p-3 rounded-lg border border-green-100 text-xs">
                            <div class="bg-white p-1 rounded-full shadow-sm mt-0.5"><i data-lucide="key" class="w-4 h-4 text-green-600"></i></div>
                            <div class="flex-1">
                                <strong class="block text-sm mb-0.5">Connected via Secret Key</strong>
                                <span class="opacity-80">Integration verified manually.</span>
                            </div>
                        </div>
                    `;
                } else {
                    statusEl.innerHTML = `
                        <div class="flex items-start gap-3 text-dull-purple bg-dull-purple/10 p-3 rounded-lg border border-dull-purple/20 text-xs">
                            <div class="bg-white p-1 rounded-full shadow-sm mt-0.5"><i data-lucide="zap" class="w-4 h-4 text-dull-purple"></i></div>
                            <div class="flex-1">
                                <strong class="block text-sm mb-0.5">Connected via OAuth</strong>
                                <span class="opacity-80">Access granted via standard Notion authorization.</span>
                            </div>
                        </div>
                    `;
                }
                lucide.createIcons();
            },
            populateSettingsInputs: () => {
                const s = Storage.getSettings();
                // Don't show token if it is OAuth (doesn't start with secret_)
                const isSecret = s.authToken && s.authToken.startsWith('secret_');
                document.getElementById('settingAuthToken').value = isSecret ? s.authToken : '';
                document.getElementById('settingWorkerUrl').value = s.workerUrl || '';
                document.getElementById('settingProxyToken').value = s.proxyToken || '';

                // Unlock state logic
                const hasVerifiedWorker = !!s.workerUrl;
                const authSection = document.getElementById('authSection');

                if (hasVerifiedWorker) {
                    authSection.classList.remove('opacity-50', 'pointer-events-none');
                } else {
                    authSection.classList.add('opacity-50', 'pointer-events-none');
                }

                // Check if we should enable save
                // Save is only enabled if AUTH is also verified (token present)
                const isAuthVerified = !!s.authToken;

                document.getElementById('saveSettingsBtn').disabled = !isAuthVerified;
            },
            onSettingInput: () => {
                const workerUrl = document.getElementById('settingWorkerUrl').value;
                // Enable verify button if text present
                document.getElementById('verifyWorkerBtn').disabled = !workerUrl;
            },
            verifyWorker: async () => {
                const btn = document.getElementById('verifyWorkerBtn');
                const originalText = btn.innerText;
                const workerUrl = document.getElementById('settingWorkerUrl').value.trim();
                const proxyToken = document.getElementById('settingProxyToken').value.trim();

                if (!workerUrl) return App.showToast("Enter a Worker URL first", "error");

                btn.innerText = "Checking...";
                btn.disabled = true;

                // Test proxy by hitting Notion API directly via "General Mode"
                // using the endpoint we ultimately care about.
                // We expect a 401 Unauthorized from Notion (since we send no Notion token here),
                // which proves the proxy is forwarding requests and returning responses correctly.
                const cleanWorkerUrl = workerUrl.replace(/\/$/, '');
                let fetchUrl;
                try {
                    fetchUrl = new URL(cleanWorkerUrl);
                } catch (e) {
                    App.showToast("Invalid Worker URL format", "error");
                    btn.innerText = originalText;
                    btn.disabled = false;
                    return;
                }

                fetchUrl.searchParams.append('url', 'https://api.notion.com/v1/users/me');
                if (proxyToken) fetchUrl.searchParams.append('token', proxyToken);

                try {
                    const res = await fetch(fetchUrl.toString());

                    // Notion returns 401 if we reach it but have no auth. 
                    // This confirms the proxy works.
                    if (res.ok || res.status === 401) {
                        App.showToast("Proxy Verified!", "success");

                        // Save proxy settings immediately
                        const current = Storage.getSettings();
                        Storage.setSettings({ ...current, workerUrl, proxyToken });

                        // Enable Auth Section
                        document.getElementById('authSection').classList.remove('opacity-50', 'pointer-events-none');
                    } else {
                        // If we get 403, it might be the Proxy Token mismatch (if the worker sends CORS on error, which it might not, but we catch network errors below)
                        throw new Error("Proxy returned status " + res.status);
                    }
                } catch (e) {
                    // console.error(e); // User requested removal
                    // If the worker code blocks 403 without CORS, it appears as a Network Error here.
                    App.showToast("Verification failed. Check Worker URL & Proxy Secret.", "error");
                } finally {
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            },
            saveBeforeOAuth: () => {
                const workerUrl = document.getElementById('settingWorkerUrl').value;
                const proxyToken = document.getElementById('settingProxyToken').value;
                // Save partial settings
                const current = Storage.getSettings();
                Storage.setSettings({ ...current, workerUrl, proxyToken });
                // Redirect
                window.location.href = 'https://notion-oauth-handler.mimansa-jaiswal.workers.dev/auth/login?from=/tools/photo-chronicles.html';
            },
            testManualConnection: async (btn) => {
                const workerUrl = document.getElementById('settingWorkerUrl').value;
                const authToken = document.getElementById('settingAuthToken').value;
                const proxyToken = document.getElementById('settingProxyToken').value;

                if (!authToken || !workerUrl) return App.showToast("Token and Worker URL required", "error");

                const originalText = btn.innerText;
                btn.innerText = "Verifying...";
                btn.disabled = true;

                try {
                    const tempSettings = { workerUrl, authToken, proxyToken };
                    const res = await API.request('GET', '/users/me', null, tempSettings);
                    App.showToast(`Verified: ${res.bot?.workspace_name || 'Connected'}`, 'success');

                    // Save fully verified settings
                    Storage.setSettings(tempSettings);

                    App.renderSettingsStatus(tempSettings);
                    document.getElementById('saveSettingsBtn').disabled = false;

                    // Auto-scan DBs on verification
                    App.scanForDatabases(tempSettings);
                } catch (e) {
                    App.showToast(e.message, 'error');
                    document.getElementById('saveSettingsBtn').disabled = true;
                } finally {
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            },
            testConnection: async (btn) => {
                App.testManualConnection(btn);
            },
            saveSettings: () => {
                // Just close modal since we saved incrementally during verification steps
                App.closeModal('settingsModal');
                App.showToast("Settings Closed", "success");
                App.renderWelcomeState();
            },
            openModal: (id) => {
                document.getElementById(id).classList.remove('hidden', 'flex');
                document.getElementById(id).classList.add('flex');
                if (id === 'settingsModal') {
                    App.populateSettingsInputs();
                    App.renderSettingsStatus();
                }
                if (id === 'entryModal' && !App.state.stream) App.initCamera();

                // Re-init icons for newly visible modals
                lucide.createIcons();
            },
            closeModal: (id) => {
                document.getElementById(id).classList.add('hidden');
                document.getElementById(id).classList.remove('flex');
                if (id === 'entryModal' && App.state.stream) App.state.stream.getTracks().forEach(t => t.stop());
            }
        };

        window.onload = App.init;
    </script>
</body>

</html>