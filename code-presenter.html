<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodePresenter</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Marked for Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- Diff Match Patch -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>

    <!-- LZ-String -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

    <!-- Shiki Loader (Main App) -->
    <script type="module">
        import { getHighlighter } from 'https://esm.sh/shiki@1.0.0';

        window.initShiki = async () => {
            try {
                const highlighter = await getHighlighter({
                    themes: ['vitesse-light', 'vitesse-dark', 'solarized-light', 'rose-pine-moon'],
                    langs: ['javascript', 'jsx', 'python', 'css', 'html', 'markdown']
                });
                window.shikiHighlighter = highlighter;
                window.dispatchEvent(new Event('shiki-ready'));
            } catch (e) {
                console.error("Shiki failed to load:", e);
            }
        };
        window.initShiki();
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap');

        :root {
            --bg-light: 253 250 247;
            --text-light: 45 42 39;
            --accent-light: 95 50 140;
            /* Default Font */
            --font-code: 'JetBrains Mono', monospace;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: rgb(var(--bg-light));
            color: rgb(var(--text-light));
            overflow: hidden;
        }

        /* Global Code Font Application */
        .font-mono,
        code,
        pre {
            font-family: var(--font-code) !important;
        }

        .canvas-bg {
            background-color: rgb(var(--bg-light));
            background-image: radial-gradient(#e5e7eb 1px, transparent 1px);
            background-size: 24px 24px;
        }

        .mac-window {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Scrollbars */
        .custom-scroll::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        .custom-scroll::-webkit-scrollbar-track {
            background: transparent;
        }

        .custom-scroll::-webkit-scrollbar-thumb {
            background: rgba(128, 128, 128, 0.2);
            border-radius: 5px;
        }

        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: rgba(128, 128, 128, 0.4);
        }

        .custom-scroll::-webkit-scrollbar-corner {
            background: transparent;
        }

        /* Magic Move Container */
        .shiki-magic-move-container {
            position: relative;
            font-family: var(--font-code) !important;
            /* Fix 2: Apply var */
            font-size: 15px;
            line-height: 1.5;
            white-space: pre;
            tab-size: 4;
            overflow: hidden;
            width: 100%;
            height: 100%;
            text-align: left;
            display: block;
        }

        .shiki-magic-move-item {
            display: inline-block;
            vertical-align: baseline;
            transition: all var(--smm-duration) var(--smm-easing);
            will-change: transform, opacity, color;
        }

        .shiki-magic-move-enter-from,
        .shiki-magic-move-leave-to {
            opacity: 0;
            transform: scale(0.9);
        }

        .shiki-magic-move-leave-active {
            position: absolute;
            pointer-events: none;
        }

        /* Editor Layers */
        .editor-textarea {
            color: transparent;
            background: transparent;
            caret-color: currentColor;
            z-index: 10;
            resize: none;
            outline: none;
            white-space: pre !important;
            font-family: var(--font-code) !important;
            /* Fix 2: Apply var */
        }

        .syntax-layer {
            pointer-events: none;
            z-index: 1;
            display: block;
            font-family: var(--font-code) !important;
            /* Fix 2: Apply var */
        }

        /* Line Numbers */
        .line-numbers {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 40px;
            text-align: right;
            padding-top: 32px;
            padding-right: 8px;
            font-family: var(--font-code) !important;
            /* Fix 2: Apply var */
            font-size: 15px;
            line-height: 1.5;
            user-select: none;
            opacity: 0.4;
            border-right: 1px solid rgba(128, 128, 128, 0.1);
            z-index: 20;
            cursor: pointer;
            overflow: hidden;
        }

        .line-numbers div:hover {
            color: var(--accent-light);
            opacity: 1;
            font-weight: bold;
        }

        .line-numbers div.focused {
            color: var(--accent-light);
            opacity: 1;
            font-weight: bold;
        }

        /* Highlights */
        .dimmed {
            opacity: 0.25;
            filter: blur(0.8px);
            transition: all 0.4s ease;
        }

        /* Markdown */
        .markdown-preview {
            font-family: 'Inter', sans-serif;
            padding: 32px;
            padding-bottom: 4px !important;
            overflow: auto;
            height: 100%;
            color: inherit;
        }

        .markdown-preview h1 {
            font-size: 2em;
            font-weight: 700;
            margin-bottom: 0.5em;
        }

        .markdown-preview p {
            margin-bottom: 1em;
            line-height: 2;
        }

        .markdown-preview ul,
        .markdown-preview ol {
            padding-left: 1.5rem;
            margin: 0 0 1em 0;
        }

        .markdown-preview li {
            margin-bottom: 0.6em;
            line-height: 2;
        }

        .markdown-preview code {
            background: rgba(128, 128, 128, 0.2);
            padding: 2px 4px;
            border-radius: 4px;
            font-family: var(--font-code) !important;
            font-size: 0.9em;
        }

        /* EXACT ALIGNMENT CSS */
        .code-area-shared {
            font-family: var(--font-code) !important;
            /* Fix 2: Apply var */
            font-size: 15px;
            line-height: 1.5;
            padding: 32px;
            padding-bottom: 4px !important;
            white-space: pre !important;
            overflow: auto;
            box-sizing: border-box;
            tab-size: 4;
            border: 0;
            margin: 0;
            display: block !important;
            height: 100%;
            width: 100%;
        }

        /* UI Utils */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            z-index: 100;
            background: linear-gradient(135deg, transparent 50%, rgba(128, 128, 128, 0.3) 50%);
            border-bottom-right-radius: 12px;
        }

        .resize-handle:hover {
            background: linear-gradient(135deg, transparent 50%, rgba(128, 128, 128, 0.6) 50%);
        }

        .title-input {
            background: transparent;
            border: none;
            outline: none;
            color: inherit;
            font-family: inherit;
            font-size: 12px;
            text-align: center;
            opacity: 0.6;
            width: 100%;
        }

        .title-input:focus {
            opacity: 1;
        }

        /* Shiki Styles override */
        .shiki {
            background: transparent !important;
            margin: 0 !important;
            padding: 0 !important;
            font-family: var(--font-code) !important;
        }

        /* Custom Toggle Color */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #7c3aed;
        }

        .toggle-checkbox:checked+.toggle-label {
            background-color: #7c3aed;
        }
    </style>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        cp: {
                            bg: 'rgb(253, 250, 247)',
                            text: 'rgb(45, 42, 39)',
                            accent: '#7c3aed', /* Dull Purple */
                            link: 'rgb(60, 75, 95)',
                        }
                    }
                }
            }
        }
    </script>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useLayoutEffect } = React;

        // --- THEMES (Shiki) ---
        const THEMES = {
            carbon: { name: 'Carbon (Dark)', shikiTheme: 'vitesse-dark', bg: '#121212', text: '#dbd7caee', chrome: '#1e1e1e' },
            dawn: { name: 'Dawn (Light)', shikiTheme: 'vitesse-light', bg: '#ffffff', text: '#393a34', chrome: '#f4f4f5' },
            solarized: { name: 'Solarized (Light)', shikiTheme: 'solarized-light', bg: '#fdf6e3', text: '#657b83', chrome: '#eee8d5' },
            midnight: { name: 'Midnight (Blue)', shikiTheme: 'rose-pine-moon', bg: '#232136', text: '#e0def4', chrome: '#2a273f' }
        };

        // --- ICONS ---
        const Icon = ({ name, size = 18, className }) => {
            const iconData = window.lucide && window.lucide.icons ? window.lucide.icons[name] : null;
            if (!iconData) return null;
            return (
                <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                    {iconData.map(([tag, attrs], index) => React.createElement(tag, { ...attrs, key: index }))}
                </svg>
            );
        };

        const generateId = () => Math.random().toString(36).substr(2, 9);

        // --- MAGIC MOVE RENDERER ---
        const CLASS_PREFIX = 'shiki-magic-move';

        class MagicMoveRenderer {
            constructor(target, options = {}) {
                this.options = { globalScale: 1, duration: 500, delayMove: 0.1, delayLeave: 0.1, delayEnter: 0.2, easing: 'ease-in-out', animateContainer: true, ...options };
                this.mapDom = new Map();
                this.isFirstRender = true;
                if (typeof target === 'string') this.container = document.querySelector(target);
                else this.container = target;
                this.anchor = document.createElement('span');
                Object.assign(this.anchor.style, { position: 'absolute', top: '0', left: '0', height: '1px', width: '1px', visibility: 'hidden' });
                this.container.prepend(this.anchor);
                this.container.classList.add('shiki-magic-move-container');
            }
            applyElement(el, token) {
                if (token.content === '\n') { el.textContent = ''; } else { el.textContent = token.content; el.classList.add(CLASS_PREFIX + '-item'); }
                if (token.htmlClass && token.content !== '\n') { el.className = [CLASS_PREFIX + '-item', token.htmlClass].join(' '); }
                if (token.color) el.style.color = token.color;
            }
            registerTransitionEnd(el, cb) {
                return () => {
                    let resolved = false;
                    const promise = new Promise((resolve) => {
                        const anims = el.getAnimations();
                        Promise.allSettled(anims.map(a => a.finished)).then(() => { if (resolved) return; resolved = true; cb(); resolve(); });
                        setTimeout(() => { if (resolved) return; resolved = true; cb(); resolve(); }, this.options.duration + 100);
                    });
                    return promise;
                }
            }
            setCssVariables() {
                this.container.style.setProperty('--smm-duration', `${this.options.duration}ms`);
                this.container.style.setProperty('--smm-easing', this.options.easing);
            }
            render(step) {
                this.setCssVariables();
                const newDomMap = new Map();
                const move = [], enter = [], leave = [];
                const promises = [];
                const postReflow = [];
                const { globalScale: scale } = this.options;
                const position = new Map();
                let anchorRect = this.anchor.getBoundingClientRect();
                for (const el of this.mapDom.values()) {
                    const rect = el.getBoundingClientRect();
                    position.set(el, { x: rect.x - anchorRect.x, y: rect.y - anchorRect.y });
                }
                const newChildren = step.tokens.map((token) => {
                    if (this.mapDom.has(token.key)) {
                        const el = this.mapDom.get(token.key);
                        this.applyElement(el, token);
                        move.push(el);
                        newDomMap.set(token.key, el);
                        this.mapDom.delete(token.key);
                        return el;
                    } else {
                        const el = document.createElement(token.content === '\n' ? 'br' : 'span');
                        this.applyElement(el, token);
                        enter.push(el);
                        newDomMap.set(token.key, el);
                        return el;
                    }
                });
                for (const [_, el] of this.mapDom) { if (el.tagName !== 'BR') leave.push(el); }
                this.container.replaceChildren(this.anchor, ...newChildren, ...leave);
                this.mapDom = newDomMap;
                leave.forEach((el) => {
                    el.style.position = 'absolute';
                    const pos = position.get(el);
                    if (pos) { el.style.top = `${pos.y / scale}px`; el.style.left = `${pos.x / scale}px`; }
                    el.classList.add(CLASS_PREFIX + '-leave-from', CLASS_PREFIX + '-leave-active');
                    requestAnimationFrame(() => { el.classList.remove(CLASS_PREFIX + '-leave-from'); el.classList.add(CLASS_PREFIX + '-leave-to'); });
                    promises.push(this.registerTransitionEnd(el, () => el.remove()));
                });
                if (!this.isFirstRender) {
                    enter.forEach((el) => {
                        if (el.tagName === 'BR') return;
                        el.classList.add(CLASS_PREFIX + '-enter-from', CLASS_PREFIX + '-enter-active');
                        requestAnimationFrame(() => { el.classList.remove(CLASS_PREFIX + '-enter-from'); el.classList.add(CLASS_PREFIX + '-enter-to'); });
                        promises.push(this.registerTransitionEnd(el, () => { el.classList.remove(CLASS_PREFIX + '-enter-active', CLASS_PREFIX + '-enter-to'); }));
                    });
                }
                anchorRect = this.anchor.getBoundingClientRect();
                move.forEach((el) => {
                    if (el.tagName === 'BR') return;
                    const newRect = el.getBoundingClientRect();
                    const newPos = { x: newRect.x - anchorRect.x, y: newRect.y - anchorRect.y };
                    const oldPos = position.get(el);
                    if (oldPos) {
                        el.style.transitionDuration = '0ms';
                        const dx = (oldPos.x - newPos.x) / scale;
                        const dy = (oldPos.y - newPos.y) / scale;
                        el.style.transform = `translate(${dx}px, ${dy}px)`;
                        requestAnimationFrame(() => {
                            el.classList.add(CLASS_PREFIX + '-move');
                            el.style.transform = '';
                            el.style.transitionDuration = '';
                        });
                        promises.push(this.registerTransitionEnd(el, () => el.classList.remove(CLASS_PREFIX + '-move')));
                    }
                });
                this.isFirstRender = false;
            }
        }

        // --- RENDERER SOURCE FOR EXPORT ---
        const RENDERER_BODY = `
            const CLASS_PREFIX = 'shiki-magic-move';
            const defaultOptions = { globalScale: 1, duration: 500, delayMove: 0.1, delayLeave: 0.1, delayEnter: 0.2, easing: 'ease-in-out', animateContainer: true };
            class MagicMoveRenderer {
                constructor(target, options = {}) {
                    this.options = { ...defaultOptions, ...options };
                    this.mapDom = new Map();
                    this.isFirstRender = true;
                    if (typeof target === 'string') this.container = document.querySelector(target);
                    else this.container = target;
                    this.anchor = document.createElement('span');
                    Object.assign(this.anchor.style, { position: 'absolute', top: '0', left: '0', height: '1px', width: '1px', visibility: 'hidden' });
                    this.container.prepend(this.anchor);
                    this.container.classList.add('shiki-magic-move-container');
                }
                applyElement(el, token) {
                    if (token.content === '\\n') { el.textContent = ''; } else { el.textContent = token.content; el.classList.add(CLASS_PREFIX + '-item'); }
                    if (token.htmlClass && token.content !== '\\n') { el.className = [CLASS_PREFIX + '-item', token.htmlClass].join(' '); }
                    if (token.color) el.style.color = token.color;
                }
                registerTransitionEnd(el, cb) {
                    return () => {
                        let resolved = false;
                        const promise = new Promise((resolve) => {
                            const anims = el.getAnimations();
                            Promise.allSettled(anims.map(a => a.finished)).then(() => { if(resolved) return; resolved = true; cb(); resolve(); });
                            setTimeout(() => { if(resolved) return; resolved = true; cb(); resolve(); }, this.options.duration + 100);
                        });
                        return promise;
                    }
                }
                setCssVariables() {
                    this.container.style.setProperty('--smm-duration', \`\${this.options.duration}ms\`);
                    this.container.style.setProperty('--smm-easing', this.options.easing);
                }
                render(step) {
                    this.setCssVariables();
                    const newDomMap = new Map();
                    const move = [], enter = [], leave = [];
                    const { globalScale: scale } = this.options;
                    const position = new Map();
                    let anchorRect = this.anchor.getBoundingClientRect();
                    for (const el of this.mapDom.values()) {
                        const rect = el.getBoundingClientRect();
                        position.set(el, { x: rect.x - anchorRect.x, y: rect.y - anchorRect.y });
                    }
                    const newChildren = step.tokens.map((token) => {
                        if (this.mapDom.has(token.key)) {
                            const el = this.mapDom.get(token.key);
                            this.applyElement(el, token);
                            move.push(el);
                            newDomMap.set(token.key, el);
                            this.mapDom.delete(token.key);
                            return el;
                        } else {
                            const el = document.createElement(token.content === '\\n' ? 'br' : 'span');
                            this.applyElement(el, token);
                            enter.push(el);
                            newDomMap.set(token.key, el);
                            return el;
                        }
                    });
                    for (const [_, el] of this.mapDom) { if (el.tagName !== 'BR') leave.push(el); }
                    this.container.replaceChildren(this.anchor, ...newChildren, ...leave);
                    this.mapDom = newDomMap;
                    leave.forEach((el) => {
                        el.style.position = 'absolute';
                        const pos = position.get(el);
                        if(pos) { el.style.top = \`\${pos.y / scale}px\`; el.style.left = \`\${pos.x / scale}px\`; }
                        el.classList.add(CLASS_PREFIX + '-leave-from', CLASS_PREFIX + '-leave-active');
                        requestAnimationFrame(() => { el.classList.remove(CLASS_PREFIX + '-leave-from'); el.classList.add(CLASS_PREFIX + '-leave-to'); });
                        this.registerTransitionEnd(el, () => el.remove())();
                    });
                    if (!this.isFirstRender) {
                        enter.forEach((el) => {
                            if(el.tagName === 'BR') return; 
                            el.classList.add(CLASS_PREFIX + '-enter-from', CLASS_PREFIX + '-enter-active');
                            requestAnimationFrame(() => { el.classList.remove(CLASS_PREFIX + '-enter-from'); el.classList.add(CLASS_PREFIX + '-enter-to'); });
                            this.registerTransitionEnd(el, () => { el.classList.remove(CLASS_PREFIX + '-enter-active', CLASS_PREFIX + '-enter-to'); })();
                        });
                    }
                    anchorRect = this.anchor.getBoundingClientRect();
                    move.forEach((el) => {
                        if(el.tagName === 'BR') return;
                        const newRect = el.getBoundingClientRect();
                        const newPos = { x: newRect.x - anchorRect.x, y: newRect.y - anchorRect.y };
                        const oldPos = position.get(el);
                        if (oldPos) {
                            el.style.transitionDuration = '0ms';
                            const dx = (oldPos.x - newPos.x) / scale;
                            const dy = (oldPos.y - newPos.y) / scale;
                            el.style.transform = \`translate(\${dx}px, \${dy}px)\`;
                            requestAnimationFrame(() => { el.classList.add(CLASS_PREFIX + '-move'); el.style.transform = ''; el.style.transitionDuration = ''; });
                            this.registerTransitionEnd(el, () => el.classList.remove(CLASS_PREFIX + '-move'))();
                        }
                    });
                    this.isFirstRender = false;
                }
            }
        `;

        // --- DIFF UTILS ---
        const calculateMatches = (a, b) => {
            if (!window.diff_match_patch) return [];
            const dmp = new diff_match_patch();
            const diffs = dmp.diff_main(a, b);
            dmp.diff_cleanupSemantic(diffs);
            const matches = [];
            let aOffset = 0, bOffset = 0;
            diffs.forEach(([op, text]) => {
                if (op === 0) {
                    matches.push({ from: [aOffset, aOffset + text.length], to: [bOffset, bOffset + text.length], content: text });
                    aOffset += text.length; bOffset += text.length;
                } else if (op === -1) aOffset += text.length;
                else if (op === 1) bOffset += text.length;
            });
            return matches;
        };

        // --- TOKENIZER ---
        const processCodeToTokens = async (code, language, theme, focusedLines = []) => {
            if (!window.shikiHighlighter) return { tokens: [] };
            code = code.replace(/\r\n/g, '\n');

            const { tokens } = window.shikiHighlighter.codeToTokens(code, { lang: language, theme: theme });

            const flattened = [];
            let offset = 0;

            tokens.forEach(line => {
                line.forEach(token => {
                    flattened.push({
                        content: token.content,
                        color: token.color,
                        htmlClass: 'token',
                        offset: offset
                    });
                    offset += token.content.length;
                });
                flattened.push({ content: '\n', htmlClass: 'break', offset: offset });
                offset += 1;
            });

            if (focusedLines && focusedLines.length > 0) {
                let lineIdx = 1;
                flattened.forEach(t => {
                    if (t.content === '\n') lineIdx++;
                    else if (!focusedLines.includes(lineIdx)) {
                        t.htmlClass += ' dimmed';
                    }
                });
            }

            const counts = {};
            return {
                tokens: flattened.map((t, i) => {
                    const keyBase = t.content.trim();
                    const keySuffix = t.content === '\n' ? `break-${i}` : keyBase;
                    counts[keySuffix] = (counts[keySuffix] || 0) + 1;
                    return {
                        ...t,
                        key: t.content === '\n' ? `break-${i}` : `${keyBase}-${counts[keySuffix]}`
                    };
                })
            };
        };

        const syncTokens = (prevTokens, currTokens, prevCode, currCode) => {
            const matches = calculateMatches(prevCode, currCode);
            matches.forEach(match => {
                const tokensFrom = prevTokens.filter(t => t.offset >= match.from[0] && t.offset + t.content.length <= match.from[1]);
                const tokensTo = currTokens.filter(t => t.offset >= match.to[0] && t.offset + t.content.length <= match.to[1]);
                let idxF = 0, idxT = 0;
                while (idxF < tokensFrom.length && idxT < tokensTo.length) {
                    const tF = tokensFrom[idxF], tT = tokensTo[idxT];
                    if (tF.content === tT.content) { tT.key = tF.key; idxF++; idxT++; } else { idxT++; }
                }
            });
            return { tokens: currTokens };
        };

        // --- EDITOR COMPONENTS ---
        // Fix 1: Use useMemo for synchronous rendering of HTML
        const SimpleHighlighter = ({ code, language, theme, focusedLines = [], shikiReady }) => {
            const html = useMemo(() => {
                if (!window.shikiHighlighter) return code.replace(/</g, '&lt;');
                try {
                    const h = window.shikiHighlighter.codeToHtml(code, { lang: language, theme: theme });
                    // Apply dimming logic directly to generated HTML string or DOM nodes
                    // Since Shiki returns a string, we parse it to apply classes
                    if (focusedLines.length > 0) {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(h, 'text/html');
                        const lines = doc.querySelectorAll('.line');
                        lines.forEach((line, idx) => {
                            if (!focusedLines.includes(idx + 1)) line.classList.add('dimmed');
                        });
                        return doc.body.innerHTML;
                    }
                    return h;
                } catch (e) { return code; }
            }, [code, language, theme, focusedLines, shikiReady]);

            return <div className="code-area-shared syntax-layer" dangerouslySetInnerHTML={{ __html: html }} />;
        };

        const MagicMove = ({ code, language, theme, focusedLines, prevCodeRef, prevTokensRef, shikiReady }) => {
            const containerRef = useRef(null);
            const rendererRef = useRef(null);

            useLayoutEffect(() => {
                if (containerRef.current && !rendererRef.current) {
                    rendererRef.current = new MagicMoveRenderer(containerRef.current);
                }
            }, []);

            useEffect(() => {
                if (rendererRef.current && window.shikiHighlighter) {
                    processCodeToTokens(code, language, theme, focusedLines).then(rawStep => {
                        let finalStep = rawStep;
                        if (prevCodeRef.current && prevTokensRef.current) {
                            finalStep = syncTokens(prevTokensRef.current, rawStep.tokens, prevCodeRef.current, code);
                        }
                        rendererRef.current.render(finalStep);
                        prevCodeRef.current = code;
                        prevTokensRef.current = finalStep.tokens;
                    });
                }
            }, [code, language, theme, focusedLines, shikiReady]);

            return <div ref={containerRef} className="code-area-shared syntax-layer overflow-hidden" />;
        };

        const DEFAULT_FONT = 'JetBrains Mono';
        const normalizeFontName = (value = '') => value.replace(/[^0-9a-zA-Z\s-]/g, ' ').replace(/\s+/g, ' ').trim();
        const buildGoogleFontUrl = (fontName) => fontName ? `https://fonts.googleapis.com/css2?family=${fontName.split(/\s+/).join('+')}:wght@400;500;700&display=swap` : '';

        // --- SLIDE DATA ---
        const INITIAL_SLIDES = [
            { id: generateId(), title: 'README.md', language: 'markdown', focusedLines: [], code: `# CodePresenter\n\nTransform your code into **cinematic animations**.\n\n- ðŸª„ Magic Move Transitions\n- ðŸŽ¨ Rich Syntax Highlighting\n- ðŸŽ¥ Video & HTML Export\n- âš¡ Zero Dependencies` },
            { id: generateId(), title: 'transformer.py', language: 'python', focusedLines: [], code: `import torch\nimport torch.nn as nn\n\nclass Transformer(nn.Module):\n    def __init__(self, dim, depth):\n        super().__init__()\n        self.layers = nn.ModuleList([])\n\n    def forward(self, x):\n        return x` },
            { id: generateId(), title: 'transformer.py', language: 'python', focusedLines: [], code: `import torch\nimport torch.nn as nn\n\nclass Transformer(nn.Module):\n    def __init__(self, dim, depth, heads):\n        super().__init__()\n        self.layers = nn.ModuleList([\n            Attention(dim, heads)\n            for _ in range(depth)\n        ])\n\n    def forward(self, x):\n        for attn in self.layers:\n            x = attn(x)\n        return x` },
            { id: generateId(), title: 'transformer.py', language: 'python', focusedLines: [], code: `import torch\nimport torch.nn as nn\n\nclass Transformer(nn.Module):\n    def __init__(self, dim, depth, heads, mlp_dim):\n        super().__init__()\n        self.layers = nn.ModuleList([\n            nn.ModuleList([\n                Attention(dim, heads),\n                FeedForward(dim, mlp_dim)\n            ])\n            for _ in range(depth)\n        ])\n\n    def forward(self, x):\n        for attn, ff in self.layers:\n            x = attn(x) + x\n            x = ff(x) + x\n        return x` },
            { id: generateId(), title: 'transformer.py', language: 'python', focusedLines: [16], code: `import torch\nimport torch.nn as nn\n\nclass Transformer(nn.Module):\n    def __init__(self, dim, depth, heads, mlp_dim):\n        super().__init__()\n        self.layers = nn.ModuleList([\n            nn.ModuleList([\n                Attention(dim, heads),\n                FeedForward(dim, mlp_dim)\n            ])\n            for _ in range(depth)\n        ])\n        self.norm = nn.LayerNorm(dim)\n\n    def forward(self, x):\n        for attn, ff in self.layers:\n            x = attn(x) + x\n            x = ff(x) + x\n        return self.norm(x)` }
        ];

        const Toggle = ({ label, checked, onChange }) => (
            <div className="flex items-center justify-between text-xs text-gray-600 py-1">
                <span>{label}</span>
                <div className="relative inline-block w-8 h-4 align-middle select-none transition duration-200 ease-in">
                    <input type="checkbox" name="toggle" id={label} className="toggle-checkbox absolute block w-4 h-4 rounded-full bg-white border-2 appearance-none cursor-pointer" checked={checked} onChange={(e) => onChange(e.target.checked)} />
                    <label htmlFor={label} className={`toggle-label block overflow-hidden h-4 rounded-full cursor-pointer ${checked ? 'bg-[#7c3aed]' : 'bg-gray-300'}`}></label>
                </div>
            </div>
        );

        // --- MAIN APP ---
        const App = () => {
            const [slides, setSlides] = useState(INITIAL_SLIDES);
            const [currentSlideIndex, setCurrentSlideIndex] = useState(0);
            const [isPlaying, setIsPlaying] = useState(false);
            const [frameSize, setFrameSize] = useState({ width: 800, height: 500 });
            const [currentThemeKey, setCurrentThemeKey] = useState('carbon');
            const [toastMessage, setToastMessage] = useState(null);
            const [exportModalOpen, setExportModalOpen] = useState(false);
            const [settingsOpen, setSettingsOpen] = useState(false);
            const [animatingKey, setAnimatingKey] = useState(null);
            const [shikiReady, setShikiReady] = useState(false);

            // States for UI Settings
            const [settings, setSettings] = useState({ showLineNumbers: true, showCopyButton: true, showFrame: true, fontFamily: DEFAULT_FONT });
            const [appliedFont, setAppliedFont] = useState(DEFAULT_FONT);
            const [fontStatus, setFontStatus] = useState(null);

            const [copyState, setCopyState] = useState('idle');
            const [exportCopyState, setExportCopyState] = useState('idle');

            const textareaRef = useRef(null);
            const lineNumbersRef = useRef(null);
            const frameRef = useRef(null);
            const prevCodeRef = useRef(null);
            const prevTokensRef = useRef(null);

            const isResizing = useRef(false);
            const resizeStartPos = useRef({ x: 0, y: 0 });
            const resizeStartSize = useRef({ width: 0, height: 0 });

            const currentSlide = slides[currentSlideIndex];
            const currentTheme = THEMES[currentThemeKey];

            // Load Font Effect (debounced)
            useEffect(() => {
                let cancelled = false;
                let debounceId = null;

                const setFontState = (font, message = null) => {
                    if (cancelled) return;
                    setAppliedFont(font);
                    setFontStatus(message);
                    document.documentElement.style.setProperty('--font-code', `'${font}', monospace`);
                };

                const removeLink = (id) => {
                    const link = document.getElementById(id);
                    if (link) link.remove();
                };

                const applyFontPreference = () => {
                    if (cancelled) return;
                    setFontStatus(null);
                    const rawInput = settings.fontFamily || '';
                    const normalizedInput = normalizeFontName(rawInput);
                    const hasRawInput = rawInput.trim().length > 0;

                    if (!normalizedInput && hasRawInput) {
                        removeLink('custom-font-link-pending');
                        removeLink('custom-font-link');
                        setFontState(DEFAULT_FONT, 'Only letters, numbers, spaces, and hyphens are allowed. Showing JetBrains Mono.');
                        return;
                    }

                    const desiredFont = normalizedInput || DEFAULT_FONT;

                    if (desiredFont === DEFAULT_FONT) {
                        removeLink('custom-font-link-pending');
                        removeLink('custom-font-link');
                        setFontState(DEFAULT_FONT, null);
                        return;
                    }

                    removeLink('custom-font-link-pending');
                    const pendingLink = document.createElement('link');
                    pendingLink.id = 'custom-font-link-pending';
                    pendingLink.rel = 'stylesheet';
                    pendingLink.href = buildGoogleFontUrl(desiredFont);
                    pendingLink.onload = () => {
                        if (cancelled) return;
                        removeLink('custom-font-link');
                        pendingLink.id = 'custom-font-link';
                        setFontState(desiredFont, null);
                    };
                    pendingLink.onerror = () => {
                        if (cancelled) return;
                        pendingLink.remove();
                        setFontState(DEFAULT_FONT, 'Font not found on Google Fonts. Showing JetBrains Mono.');
                    };
                    document.head.appendChild(pendingLink);
                };

                debounceId = window.setTimeout(applyFontPreference, 400);

                return () => {
                    cancelled = true;
                    if (debounceId) clearTimeout(debounceId);
                };
            }, [settings.fontFamily]);

            // Listen for Shiki
            useEffect(() => {
                const handler = () => setShikiReady(true);
                window.addEventListener('shiki-ready', handler);
                if (window.shikiHighlighter) setShikiReady(true);
                return () => window.removeEventListener('shiki-ready', handler);
            }, []);

            // Load state
            useEffect(() => {
                const hash = window.location.hash.slice(1);
                if (hash) {
                    try {
                        const decompressed = LZString.decompressFromEncodedURIComponent(hash);
                        if (decompressed) {
                            const data = JSON.parse(decompressed);
                            if (data && data.length > 0) setSlides(data);
                        }
                    } catch (e) { }
                } else {
                    const local = localStorage.getItem('cp-state');
                    if (local) setSlides(JSON.parse(local));
                }
            }, []);

            useEffect(() => { localStorage.setItem('cp-state', JSON.stringify(slides)); }, [slides]);

            const handleResizeStart = (e) => {
                e.preventDefault();
                e.stopPropagation();
                isResizing.current = true;
                resizeStartPos.current = { x: e.clientX, y: e.clientY };
                resizeStartSize.current = { ...frameSize };
                document.addEventListener('mousemove', handleResizeMove);
                document.addEventListener('mouseup', handleResizeEnd);
            };
            const handleResizeMove = (e) => {
                if (!isResizing.current) return;
                setFrameSize({ width: Math.max(400, resizeStartSize.current.width + (e.clientX - resizeStartPos.current.x)), height: Math.max(200, resizeStartSize.current.height + (e.clientY - resizeStartPos.current.y)) });
            };
            const handleResizeEnd = () => {
                isResizing.current = false;
                document.removeEventListener('mousemove', handleResizeMove);
                document.removeEventListener('mouseup', handleResizeEnd);
            };

            const changeSlide = (idx, { animate } = {}) => {
                if (idx < 0 || idx >= slides.length) return;
                const shouldAnimate = typeof animate === 'boolean' ? animate : isPlaying;
                if (shouldAnimate) {
                    setAnimatingKey(Date.now());
                    setTimeout(() => setAnimatingKey(null), 600);
                } else {
                    setAnimatingKey(null);
                }
                setCurrentSlideIndex(idx);
            };

            const updateSlide = (key, val) => {
                const n = [...slides];
                n[currentSlideIndex] = { ...n[currentSlideIndex], [key]: val };
                setSlides(n);
            };

            const toggleFocus = (lineNum) => {
                const lines = currentSlide.focusedLines || [];
                updateSlide('focusedLines', lines.includes(lineNum) ? lines.filter(l => l !== lineNum) : [...lines, lineNum]);
            };

            const copyText = (text) => {
                const t = document.createElement("textarea");
                t.value = text; t.style.position = "fixed"; t.style.left = "-9999px";
                document.body.appendChild(t); t.focus(); t.select();
                try {
                    document.execCommand('copy');
                    setCopyState('copied');
                    setTimeout(() => setCopyState('idle'), 2000);
                } catch (e) { }
                document.body.removeChild(t);
            };

            const generateShareLink = () => {
                const url = `${window.location.origin}${window.location.pathname}#${LZString.compressToEncodedURIComponent(JSON.stringify(slides))}`;
                const t = document.createElement("textarea"); t.value = url; t.style.position = "fixed"; t.style.left = "-9999px";
                document.body.appendChild(t); t.focus(); t.select();
                try { document.execCommand('copy'); setToastMessage("Link Copied!"); } catch (e) { }
                document.body.removeChild(t);
            };

            const addSlide = () => {
                const n = [...slides];
                n.splice(currentSlideIndex + 1, 0, { ...currentSlide, id: generateId(), focusedLines: [] });
                setSlides(n);
                changeSlide(currentSlideIndex + 1);
            };

            const duplicateSlide = () => {
                const n = [...slides];
                n.splice(currentSlideIndex + 1, 0, {
                    ...currentSlide,
                    id: generateId(),
                    focusedLines: [...(currentSlide.focusedLines || [])]
                });
                setSlides(n);
                changeSlide(currentSlideIndex + 1);
            };

            const addNewSlide = () => {
                const n = [...slides];
                n.splice(currentSlideIndex + 1, 0, {
                    id: generateId(),
                    title: 'Untitled',
                    language: currentSlide.language,
                    code: '',
                    focusedLines: []
                });
                setSlides(n);
                changeSlide(currentSlideIndex + 1);
            };

            // Keyboard nav
            useEffect(() => {
                const handleKey = (e) => {
                    if (e.key === 'Escape' && isPlaying) setIsPlaying(false);
                    if (isPlaying) {
                        if (e.key === 'ArrowRight') changeSlide(currentSlideIndex + 1);
                        if (e.key === 'ArrowLeft') changeSlide(currentSlideIndex - 1);
                    }
                };
                window.addEventListener('keydown', handleKey);
                return () => window.removeEventListener('keydown', handleKey);
            }, [isPlaying, currentSlideIndex]);

            useEffect(() => {
                if (toastMessage) { const t = setTimeout(() => setToastMessage(null), 3000); return () => clearTimeout(t); }
            }, [toastMessage]);

            const SVG_COPY = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>`;
            const SVG_CHECK = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>`;

            // --- EXPORT COMPONENT GENERATOR ---
            const generateComponent = () => {
                const id = `cp-${generateId()}`;
                const slideData = JSON.stringify(slides);
                const safeFont = normalizeFontName(appliedFont) || DEFAULT_FONT;
                const fontLink = buildGoogleFontUrl(safeFont);

                const styles = `
                    [id="${id}"] { width:${frameSize.width}px;height:${frameSize.height}px;background:${currentTheme.bg};color:${currentTheme.text};${settings.showFrame ? 'border-radius:12px;overflow:hidden;box-shadow:0 20px 50px rgba(0,0,0,0.2);' : ''}display:flex;flex-direction:column;font-family:'${safeFont}',monospace;position:relative; }
                    [id="${id}"] .h { height:40px;background:${currentTheme.chrome};display:${settings.showFrame ? 'flex' : 'none'};align-items:center;padding:0 16px;border-bottom:1px solid rgba(0,0,0,0.1); }
                    [id="${id}"] .b { flex:1;position:relative;overflow:hidden;display:flex; }
                    [id="${id}"] .ln { padding-top:32px;text-align:right;width:40px;opacity:0.4;user-select:none;border-right:1px solid rgba(128,128,128,0.1);display:${settings.showLineNumbers ? 'block' : 'none'};font-size:15px;line-height:1.5;font-family:'${safeFont}',monospace; }
                    [id="${id}"] .c-wrap { flex:1;position:relative; }
                    [id="${id}"] .shiki-magic-move-container { font-size:15px;line-height:1.5;white-space:pre;padding:32px;padding-bottom:32px;width:100%;height:100%;display:block;overflow:auto;font-family:'${safeFont}',monospace; }
                    [id="${id}"] .shiki-magic-move-item { display:inline-block;vertical-align:baseline;transition:all 500ms ease-in-out; }
                    [id="${id}"] .shiki-magic-move-enter-from, [id="${id}"] .shiki-magic-move-leave-to { opacity:0;transform:scale(0.9); }
                    [id="${id}"] .shiki-magic-move-leave-active { position:absolute;pointer-events:none; }
                    [id="${id}"] .dimmed { opacity:0.25;filter:blur(0.5px);transition:all 0.4s; }
                    [id="${id}"] .md-view { padding:32px;height:100%;overflow:auto;color:${currentTheme.text};font-family:'Inter',sans-serif;line-height:1.5; }
                    [id="${id}"] .md-view h1,
                    [id="${id}"] .md-view h2,
                    [id="${id}"] .md-view h3,
                    [id="${id}"] .md-view h4,
                    [id="${id}"] .md-view h5,
                    [id="${id}"] .md-view h6,
                    [id="${id}"] .md-view p,
                    [id="${id}"] .md-view ul,
                    [id="${id}"] .md-view ol,
                    [id="${id}"] .md-view li {
                        margin: 0;
                        line-height: 1.5;
                    }
                    [id="${id}"] .md-view h1 { font-size:2em;font-weight:700; }
                    [id="${id}"] .md-view ul,[id="${id}"] .md-view ol { padding-left:1.5rem; }
                    [id="${id}"] .md-view li { list-style-position:outside; line-height:0; }
                    [id="${id}"] .md-view code { background:rgba(128,128,128,0.2);padding:2px 4px;border-radius:4px;font-family:'${safeFont}',monospace;font-size:0.9em; }
                    [id="${id}"] .copy-btn { margin-left:auto;background:none;border:none;color:${currentTheme.text};opacity:0.5;cursor:pointer;display:${settings.showCopyButton ? 'block' : 'none'}; }
                    [id="${id}"] .copy-btn-float { position:absolute;top:10px;right:10px;z-index:50;background:${currentTheme.chrome};border-radius:4px;padding:4px;opacity:0.6;color:${currentTheme.text};border:1px solid rgba(128,128,128,0.2);cursor:pointer;display:${settings.showCopyButton && !settings.showFrame ? 'block' : 'none'}; }
                    [id="${id}"] .nav { position:absolute;bottom:0;left:0;right:0;display:flex;align-items:center;justify-content:space-between;padding:10px 18px;background:rgba(15,15,15,0.25);backdrop-filter:blur(10px);border-top:1px solid rgba(255,255,255,0.08); }
                    [id="${id}"] .nav button { background:rgba(255,255,255,0.15);border:none;color:${currentTheme.text};cursor:pointer;padding:6px 14px;border-radius:9999px;font-size:11px;font-weight:600;letter-spacing:0.02em;display:flex;align-items:center;gap:6px;transition:background 0.2s, transform 0.2s; }
                    [id="${id}"] .nav button:hover { background:rgba(255,255,255,0.25);transform:translateY(-1px); }
                    [id="${id}"] .nav-count { font-size:11px;font-weight:600;color:${currentTheme.text};text-transform:uppercase;letter-spacing:0.1em;opacity:0.8; }
                `;

                return `<!-- CodePresenter Component -->
<div id="${id}">
    ${fontLink ? `<link href="${fontLink}" rel="stylesheet" />` : ''}
<style>${styles}</style>
<div class="h">
 <div style="display:flex;gap:8px"><div style="width:12px;height:12px;border-radius:50%;background:#ff5f56"></div><div style="width:12px;height:12px;border-radius:50%;background:#ffbd2e"></div><div style="width:12px;height:12px;border-radius:50%;background:#27c93f"></div></div>
 <div id="${id}-t" style="flex:1;text-align:center;font-size:12px;color:${currentTheme.text};opacity:0.6"></div>
 <button class="copy-btn" id="${id}-cp">${SVG_COPY}</button>
</div>
<div class="b">
 <div id="${id}-l" class="ln"></div>
 <div id="${id}-c" class="c-wrap"></div>
 <button class="copy-btn-float" id="${id}-cp-float">${SVG_COPY}</button>
</div>
 <div class="nav"><button id="${id}-p">â† Prev</button><span class="nav-count" id="${id}-count"></span><button id="${id}-n">Next â†’</button></div>
<script type="module">
${RENDERER_BODY}
const slides = ${slideData};
const themeKey = '${currentTheme.shikiTheme}';
const rootId = '${id}';
const svgCopy = '${SVG_COPY}';
const svgCheck = '${SVG_CHECK}';

const ensureLoader = () => {
    if (window.__CP_ASYNC_LOADER__) return window.__CP_ASYNC_LOADER__;
    const store = {
        shikiModulePromise: null,
        highlighterPromises: new Map(),
        diffPromise: null,
        markedPromise: null
    };
    const loader = {
        getHighlighter(theme) {
            if (!store.highlighterPromises.has(theme)) {
                if (!store.shikiModulePromise) {
                    store.shikiModulePromise = import('https://esm.sh/shiki@1.0.0');
                }
                store.highlighterPromises.set(theme, store.shikiModulePromise.then(mod => mod.getHighlighter({
                    themes: [theme],
                    langs: ['javascript', 'python', 'jsx', 'css', 'html', 'markdown']
                })));
            }
            return store.highlighterPromises.get(theme);
        },
        getDiff() {
            if (!store.diffPromise) {
                store.diffPromise = import('https://esm.sh/diff-match-patch@1.0.5').then(mod => {
                    const Ctor = mod.diff_match_patch || mod.default || mod;
                    return new Ctor();
                });
            }
            return store.diffPromise;
        },
        getMarked() {
            if (!store.markedPromise) {
                store.markedPromise = import('https://esm.sh/marked@12?bundle').then(mod => {
                    if (mod.marked) return mod.marked;
                    if (typeof mod.default === 'function' || (mod.default && typeof mod.default.parse === 'function')) return mod.default;
                    return mod;
                });
            }
            return store.markedPromise;
        }
    };
    window.__CP_ASYNC_LOADER__ = loader;
    return loader;
};

const runComponent = async () => {
    const root = document.getElementById(rootId);
    if (!root) return;

    const elements = {
        code: document.getElementById('${id}-c'),
        lines: document.getElementById('${id}-l'),
        title: document.getElementById('${id}-t'),
        count: document.getElementById('${id}-count'),
        copy: document.getElementById('${id}-cp'),
        copyFloat: document.getElementById('${id}-cp-float'),
        prev: document.getElementById('${id}-p'),
        next: document.getElementById('${id}-n')
    };

    if (!elements.code) return;

    const loader = ensureLoader();
    const [highlighter, dmp, markedLib] = await Promise.all([
        loader.getHighlighter(themeKey),
        loader.getDiff(),
        loader.getMarked()
    ]);

    const renderer = new MagicMoveRenderer(elements.code);
    let index = 0;
    let previousCode = '';
    let previousTokens = null;

    const parseMarkdown = (text) => {
        if (!markedLib) return text;
        if (typeof markedLib.parse === 'function') return markedLib.parse(text);
        if (markedLib.marked && typeof markedLib.marked.parse === 'function') return markedLib.marked.parse(text);
        return text;
    };

    const tokenize = (code, language, focus = []) => {
        const source = typeof code === 'string' ? code : '';
        const lang = language || 'javascript';
        const { tokens } = highlighter.codeToTokens(source, { lang, theme: themeKey });
        let flat = [];
        let offset = 0;
        tokens.forEach(line => {
            line.forEach(token => {
                flat.push({ content: token.content, color: token.color, htmlClass: 'token', offset });
                offset += token.content.length;
            });
            flat.push({ content: '\\n', htmlClass: 'break', offset });
            offset += 1;
        });
        if (focus.length) {
            let lineIdx = 1;
            flat.forEach(token => {
                if (token.content === '\\n') lineIdx++;
                else if (!focus.includes(lineIdx)) token.htmlClass += ' dimmed';
            });
        }
        const counts = {};
        return flat.map((token, idx) => {
            const keyBase = token.content.trim();
            const keySuffix = token.content === '\\n' ? 'br-' + idx : keyBase;
            counts[keySuffix] = (counts[keySuffix] || 0) + 1;
            return { ...token, key: token.content === '\\n' ? 'br-' + idx : keyBase + '-' + counts[keySuffix] };
        });
    };

    const syncTokenKeys = (fromTokens, toTokens, oldCode, newCode) => {
        if (!fromTokens || !fromTokens.length) return toTokens;
        const diffs = dmp.diff_main(oldCode, newCode);
        dmp.diff_cleanupSemantic(diffs);
        let fromOffset = 0;
        let toOffset = 0;
        diffs.forEach(([op, text]) => {
            if (op === 0) {
                const fromSegment = fromTokens.filter(t => t.offset >= fromOffset && t.offset + t.content.length <= fromOffset + text.length);
                const toSegment = toTokens.filter(t => t.offset >= toOffset && t.offset + t.content.length <= toOffset + text.length);
                let x = 0, y = 0;
                while (x < fromSegment.length && y < toSegment.length) {
                    if (fromSegment[x].content === toSegment[y].content) {
                        toSegment[y].key = fromSegment[x].key;
                        x++;
                        y++;
                    } else {
                        y++;
                    }
                }
                fromOffset += text.length;
                toOffset += text.length;
            } else if (op === -1) {
                fromOffset += text.length;
            } else if (op === 1) {
                toOffset += text.length;
            }
        });
        return toTokens;
    };

    const updateLineNumbers = (slide) => {
        if (!elements.lines) return;
        const focus = slide.focusedLines || [];
        const text = typeof slide.code === 'string' ? slide.code : '';
        if (slide.language === 'markdown') {
            elements.lines.style.display = 'none';
            elements.lines.innerHTML = '';
            return;
        }
        elements.lines.style.display = 'block';
        elements.lines.innerHTML = text.split('\\n').map((_, idx) => {
            const cls = focus.includes(idx + 1) ? 'focused' : '';
            return '<div class="' + cls + '">' + (idx + 1) + '</div>';
        }).join('');
    };

    const renderMarkdown = (slide) => {
        if (!elements.code) return;
        const html = parseMarkdown(typeof slide.code === 'string' ? slide.code : '');
        elements.code.innerHTML = '<div class="md-view">' + html + '</div>';
        renderer.mapDom.clear();
        renderer.isFirstRender = true;
        previousTokens = null;
        previousCode = '';
    };

    const renderCode = (slide) => {
        if (!elements.code) return;
        const source = typeof slide.code === 'string' ? slide.code : '';
        let tokens = tokenize(source, slide.language, slide.focusedLines || []);
        if (previousTokens && previousCode) {
            tokens = syncTokenKeys(previousTokens, tokens, previousCode, source);
        }
        renderer.render({ tokens });
        previousTokens = tokens;
        previousCode = source;
    };

    const update = () => {
        const slide = slides[index];
        if (!slide) return;
        if (elements.title) elements.title.textContent = slide.title || '';
        if (elements.count) elements.count.textContent = \`Slide \${index + 1} / \${slides.length}\`;
        if (elements.prev) elements.prev.style.visibility = index === 0 ? 'hidden' : 'visible';
        if (elements.next) elements.next.style.visibility = index === slides.length - 1 ? 'hidden' : 'visible';
        updateLineNumbers(slide);
        if (slide.language === 'markdown') renderMarkdown(slide);
        else renderCode(slide);
    };

    const setCopyIcon = (icon) => {
        if (elements.copy) elements.copy.innerHTML = icon;
        if (elements.copyFloat) elements.copyFloat.innerHTML = icon;
    };

    const copyFn = () => {
        const slide = slides[index];
        if (!slide) return;
        const area = document.createElement('textarea');
        area.value = typeof slide.code === 'string' ? slide.code : '';
        area.style.position = 'fixed';
        area.style.left = '-9999px';
        document.body.appendChild(area);
        area.select();
        document.execCommand('copy');
        document.body.removeChild(area);
        setCopyIcon(svgCheck);
        setTimeout(() => setCopyIcon(svgCopy), 2000);
    };

    if (elements.copy) elements.copy.addEventListener('click', copyFn);
    if (elements.copyFloat) elements.copyFloat.addEventListener('click', copyFn);

    if (elements.prev) elements.prev.addEventListener('click', () => {
        if (index > 0) {
            index -= 1;
            update();
        }
    });
    if (elements.next) elements.next.addEventListener('click', () => {
        if (index < slides.length - 1) {
            index += 1;
            update();
        }
    });

    if (elements.code && elements.lines) {
        elements.code.addEventListener('scroll', () => {
            elements.lines.scrollTop = elements.code.scrollTop;
        });
    }

    update();
};

runComponent();
<\/script></div>`;
            };

            // Helpers for render
            const isEditor = !isPlaying;
            const effectiveShowFrame = isEditor ? true : settings.showFrame;
            const effectiveShowLines = isEditor ? (currentSlide.language !== 'markdown') : (settings.showLineNumbers && currentSlide.language !== 'markdown');
            const effectiveShowCopy = isEditor ? true : settings.showCopyButton;
            const floatingCopy = !effectiveShowFrame && effectiveShowCopy;

            const showMagicMove = isPlaying || animatingKey !== null;
            const canGoPrev = currentSlideIndex > 0;
            const canGoNext = currentSlideIndex < slides.length - 1;

            return (
                <div className="flex h-screen w-screen overflow-hidden text-sm" style={{ color: currentTheme.text }}>
                    {toastMessage && <div className="fixed top-4 left-1/2 -translate-x-1/2 z-[300] bg-gray-900 text-white px-4 py-2 rounded-full shadow-lg animate-in fade-in slide-in-from-top-2">{toastMessage}</div>}

                    {exportModalOpen && (
                        <div className="fixed inset-0 z-[200] bg-black/50 flex items-center justify-center p-4">
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl p-6 space-y-4 text-gray-900">
                                <h3 className="font-bold text-lg">Export HTML Component</h3>
                                <textarea className="w-full h-64 bg-gray-100 p-3 font-mono text-xs rounded" readOnly value={generateComponent()} />
                                <div className="flex justify-end gap-2">
                                    <button onClick={() => setExportModalOpen(false)} className="px-4 py-2 rounded hover:bg-gray-100">Close</button>
                                    <button onClick={() => {
                                        const t = document.createElement("textarea");
                                        t.value = generateComponent();
                                        document.body.appendChild(t); t.select();
                                        document.execCommand('copy'); document.body.removeChild(t);
                                        setExportCopyState('copied'); setTimeout(() => setExportCopyState('idle'), 2000);
                                    }} className="px-4 py-2 bg-[#7c3aed] text-white rounded hover:bg-[#6d28d9] flex items-center gap-2">{exportCopyState === 'copied' ? 'Copied!' : 'Copy Code'}</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {isEditor && (
                        <div className="w-64 border-r border-gray-200 flex flex-col z-20 shadow-xl bg-white">
                            <div className="p-4 border-b border-gray-100 font-bold flex items-center gap-2 text-gray-800 justify-between">
                                <div className="flex items-center gap-2"><Icon name="Code2" /> CodePresenter</div>
                                <button onClick={() => setSettingsOpen(!settingsOpen)} className="p-1 hover:bg-gray-100 rounded"><Icon name="Settings" size={16} /></button>
                            </div>
                            {settingsOpen && (
                                <div className="p-4 bg-gray-50 border-b border-gray-200 space-y-2">
                                    <Toggle label="Show Line Numbers" checked={settings.showLineNumbers} onChange={(v) => setSettings({ ...settings, showLineNumbers: v })} />
                                    <Toggle label="Show Copy Button" checked={settings.showCopyButton} onChange={(v) => setSettings({ ...settings, showCopyButton: v })} />
                                    <Toggle label="Show Window Frame" checked={settings.showFrame} onChange={(v) => setSettings({ ...settings, showFrame: v })} />
                                    <div className="flex flex-col gap-1 py-2">
                                        <label className="text-xs text-gray-500 font-medium">Font Family (Google Fonts)</label>
                                        <input className="w-full bg-white border border-gray-200 rounded px-2 py-1 text-xs font-mono text-gray-900" value={settings.fontFamily} onChange={(e) => setSettings({ ...settings, fontFamily: e.target.value })} placeholder="e.g. Fira Code" />
                                        {fontStatus && <p className="text-[10px] text-red-500 mt-1">{fontStatus}</p>}
                                    </div>
                                </div>
                            )}
                            <div className="p-2 grid grid-cols-2 gap-2 border-b border-gray-100 bg-gray-50/50">
                                <button onClick={addNewSlide} className="flex items-center justify-center gap-1.5 px-2 py-1.5 bg-white border border-gray-200 rounded-md text-xs font-medium text-gray-600 hover:border-[#7c3aed] hover:text-[#7c3aed] transition-colors shadow-sm"><Icon name="Plus" size={14} /> New</button>
                                <button onClick={duplicateSlide} className="flex items-center justify-center gap-1.5 px-2 py-1.5 bg-white border border-gray-200 rounded-md text-xs font-medium text-gray-600 hover:border-[#7c3aed] hover:text-[#7c3aed] transition-colors shadow-sm"><Icon name="Copy" size={14} /> Duplicate</button>
                            </div>
                            <div className="flex-1 overflow-y-auto p-2 space-y-2">
                                {slides.map((s, i) => (
                                    <div key={s.id} onClick={() => changeSlide(i)} className={`p-3 rounded-lg cursor-pointer border transition-all group ${i === currentSlideIndex ? 'bg-white border-[#7c3aed]/30 shadow-md ring-1 ring-[#7c3aed]/10' : 'bg-transparent border-transparent hover:bg-gray-100'}`}>
                                        <div className="flex justify-between items-center mb-1.5">
                                            <span className={`text-[10px] font-bold ${i === currentSlideIndex ? 'text-[#7c3aed]' : 'text-gray-400'}`}>SLIDE {i + 1}</span>
                                            <button onClick={(e) => { e.stopPropagation(); if (slides.length <= 1) return; const n = slides.filter((_, x) => x !== i); setSlides(n); if (i <= currentSlideIndex && currentSlideIndex > 0) setCurrentSlideIndex(currentSlideIndex - 1); }} className="text-gray-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-opacity"><Icon name="Trash2" size={12} /></button>
                                        </div>
                                        <div className="font-medium text-xs truncate text-gray-700 mb-2 flex items-center gap-1"><Icon name="FileCode" size={10} className="opacity-50" />{s.title || 'Untitled'}</div>
                                        <div className="h-16 bg-gray-50 border border-gray-200 rounded overflow-hidden relative"><div className="absolute inset-0 p-1.5 text-[6px] leading-relaxed text-gray-600 font-mono whitespace-pre select-none pointer-events-none">{s.code ? s.code.substring(0, 300) : <span className="italic opacity-50">Empty slide</span>}</div><div className="absolute bottom-0 left-0 right-0 h-4 bg-gradient-to-t from-gray-50 to-transparent"></div></div>
                                    </div>
                                ))}
                            </div>
                            <div className="p-4 border-t border-gray-100 bg-gray-50 space-y-2">
                                <button onClick={() => setIsPlaying(true)} className="w-full py-2 bg-[#7c3aed] text-white rounded shadow hover:bg-[#6d28d9] flex justify-center gap-2"><Icon name="Play" size={16} /> Present</button>
                                <div className="grid grid-cols-1 gap-2">
                                    <button onClick={() => setExportModalOpen(true)} className="py-2 bg-white border rounded text-gray-600 hover:bg-gray-50 text-xs flex items-center justify-center gap-1"><Icon name="Code" size={12} /> Component</button>
                                </div>
                                <button onClick={generateShareLink} className="w-full py-2 bg-gray-100 border rounded text-gray-600 hover:bg-gray-200 text-xs flex items-center justify-center gap-1"><Icon name="Share2" size={12} /> Share</button>
                            </div>
                        </div>
                    )}

                    <div className="flex-1 relative flex items-center justify-center overflow-hidden bg-gray-100">
                        <div className="canvas-bg absolute inset-0"></div>
                        {isEditor && (
                            <div className="absolute top-4 z-30 bg-white/90 backdrop-blur p-2 rounded-lg shadow-sm border flex items-center gap-2">
                                <select value={currentThemeKey} onChange={(e) => setCurrentThemeKey(e.target.value)} className="bg-transparent text-xs font-medium outline-none text-gray-700 cursor-pointer">
                                    {Object.entries(THEMES).map(([k, v]) => <option key={k} value={k}>{v.name}</option>)}
                                </select>
                                <div className="w-px h-4 bg-gray-300"></div>
                                <select value={currentSlide.language} onChange={(e) => updateSlide('language', e.target.value)} className="bg-transparent text-xs outline-none text-gray-500 cursor-pointer">
                                    <option value="javascript">JS</option><option value="jsx">JSX</option><option value="python">Python</option><option value="markdown">MD</option>
                                </select>
                            </div>
                        )}

                        <div ref={frameRef} className={`mac-window relative z-10 shrink-0 ${settings.showFrame || isEditor ? 'framed' : 'frameless'}`} style={{ width: frameSize.width, height: frameSize.height, background: currentTheme.bg, color: currentTheme.text, transform: isPlaying ? 'scale(1.1)' : 'scale(1)', transition: 'transform 0.5s' }}>
                            {effectiveShowFrame && (
                                <div style={{ background: currentTheme.chrome, borderColor: 'rgba(0,0,0,0.1)' }} className="h-10 flex items-center px-4 border-b shrink-0 select-none">
                                    <div className="flex gap-2"><div className="w-3 h-3 rounded-full bg-red-400"></div><div className="w-3 h-3 rounded-full bg-yellow-400"></div><div className="w-3 h-3 rounded-full bg-green-400"></div></div>
                                    <input className="title-input flex-1" value={currentSlide.title} onChange={(e) => updateSlide('title', e.target.value)} />
                                    {effectiveShowCopy && (
                                        <button onClick={() => copyText(currentSlide.code)} className="opacity-50 hover:opacity-100" title="Copy">
                                            {copyState === 'copied' ? <Icon name="Check" size={14} className="text-green-500" /> : <Icon name="Copy" size={14} />}
                                        </button>
                                    )}
                                </div>
                            )}

                            <div className="flex-1 relative overflow-hidden" onClick={() => isEditor && textareaRef.current?.focus()}>
                                {floatingCopy && (
                                    <button onClick={() => copyText(currentSlide.code)} className="copy-btn-floating" title="Copy">
                                        {copyState === 'copied' ? <Icon name="Check" size={14} className="text-green-500" /> : <Icon name="Copy" size={14} />}
                                    </button>
                                )}

                                {effectiveShowLines && (
                                    <div ref={lineNumbersRef} className="line-numbers custom-scroll" style={{ background: currentTheme.bg }} onClick={(e) => e.stopPropagation()}>
                                        {currentSlide.code.split('\n').map((_, i) => (
                                            <div key={i} onClick={(e) => { e.stopPropagation(); toggleFocus(i + 1); }} className={(currentSlide.focusedLines || []).includes(i + 1) ? 'focused' : ''}>{i + 1}</div>
                                        ))}
                                    </div>
                                )}
                                <div className="absolute inset-0" style={{ left: effectiveShowLines ? 40 : 0 }}>
                                    {currentSlide.language === 'markdown' && showMagicMove ? (
                                        <div className="markdown-preview" dangerouslySetInnerHTML={{ __html: window.marked ? marked.parse(currentSlide.code) : currentSlide.code }} />
                                    ) : (
                                        <>
                                            <div className="absolute inset-0 z-0 pointer-events-none">
                                                {showMagicMove ?
                                                    <MagicMove code={currentSlide.code} language={currentSlide.language} theme={currentTheme.shikiTheme} focusedLines={currentSlide.focusedLines || []} prevCodeRef={prevCodeRef} prevTokensRef={prevTokensRef} shikiReady={shikiReady} />
                                                    : <SimpleHighlighter code={currentSlide.code} language={currentSlide.language} theme={currentTheme.shikiTheme} focusedLines={currentSlide.focusedLines || []} shikiReady={shikiReady} />
                                                }
                                            </div>
                                            {isEditor && (
                                                <textarea
                                                    ref={textareaRef}
                                                    className="editor-textarea code-area-shared absolute inset-0 w-full h-full custom-scroll"
                                                    style={{ caretColor: currentTheme.text }}
                                                    value={currentSlide.code}
                                                    onChange={(e) => updateSlide('code', e.target.value)}
                                                    onScroll={(e) => {
                                                        const v = e.target.previousSibling.firstChild || e.target.previousSibling;
                                                        if (v) { v.scrollTop = e.target.scrollTop; v.scrollLeft = e.target.scrollLeft; }
                                                        if (lineNumbersRef.current) lineNumbersRef.current.scrollTop = e.target.scrollTop;
                                                    }}
                                                    spellCheck="false"
                                                />
                                            )}
                                        </>
                                    )}
                                </div>
                            </div>

                            {isEditor && <div className="resize-handle" onMouseDown={handleResizeStart} title="Drag to resize"></div>}
                        </div>

                        {isPlaying && (
                            <div className="fixed bottom-10 z-50 bg-black/80 text-white px-6 py-3 rounded-full flex items-center gap-4 backdrop-blur">
                                <button
                                    onClick={() => canGoPrev && changeSlide(currentSlideIndex - 1)}
                                    className={!canGoPrev ? 'opacity-30 cursor-not-allowed' : ''}
                                    disabled={!canGoPrev}
                                >
                                    <Icon name="ArrowLeft" />
                                </button>
                                <span className="text-xs font-mono opacity-50">{currentSlideIndex + 1} / {slides.length}</span>
                                <button
                                    onClick={() => canGoNext && changeSlide(currentSlideIndex + 1)}
                                    className={!canGoNext ? 'opacity-30 cursor-not-allowed' : ''}
                                    disabled={!canGoNext}
                                >
                                    <Icon name="ArrowRight" />
                                </button>
                                <button onClick={() => setIsPlaying(false)} className="text-red-400 ml-4"><Icon name="X" /></button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>